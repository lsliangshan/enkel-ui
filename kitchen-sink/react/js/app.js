(function (factory) {
	typeof define === 'function' && define.amd ? define(factory) :
	factory();
}(function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var arguments$1 = arguments;

		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments$1[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	var ReactPropTypesSecret_1 = ReactPropTypesSecret;

	var printWarning = function() {};

	{
	  var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
	  var loggedTypeFailures = {};
	  var has = Function.call.bind(Object.prototype.hasOwnProperty);

	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  {
	    for (var typeSpecName in typeSpecs) {
	      if (has(typeSpecs, typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof typeSpecs[typeSpecName] !== 'function') {
	            var err = Error(
	              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
	              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
	            );
	            err.name = 'Invariant Violation';
	            throw err;
	          }
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error && !(error instanceof Error)) {
	          printWarning(
	            (componentName || 'React class') + ': type specification of ' +
	            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
	            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
	            'You may have forgotten to pass an argument to the type checker ' +
	            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
	            'shape all require an argument).'
	          );
	        }
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;

	          var stack = getStack ? getStack() : '';

	          printWarning(
	            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
	          );
	        }
	      }
	    }
	  }
	}

	/**
	 * Resets warning cache when testing.
	 *
	 * @private
	 */
	checkPropTypes.resetWarningCache = function() {
	  {
	    loggedTypeFailures = {};
	  }
	};

	var checkPropTypes_1 = checkPropTypes;

	var react_development = createCommonjsModule(function (module) {



	{
	  (function() {

	var _assign = objectAssign;
	var checkPropTypes = checkPropTypes_1;

	// TODO: this is special because it gets imported during build.

	var ReactVersion = '16.8.6';

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;

	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;

	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;

	var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator';

	function getIteratorFn(maybeIterable) {
	  if (maybeIterable === null || typeof maybeIterable !== 'object') {
	    return null;
	  }
	  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
	  if (typeof maybeIterator === 'function') {
	    return maybeIterator;
	  }
	  return null;
	}

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var validateFormat = function () {};

	{
	  validateFormat = function (format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}

	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);

	  if (!condition) {
	    var error = void 0;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	// Relying on the `invariant()` implementation lets us
	// preserve the format and params in the www builds.

	/**
	 * Forked from fbjs/warning:
	 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
	 *
	 * Only change is we use console.warn instead of console.error,
	 * and do nothing when 'console' is not supported.
	 * This really simplifies the code.
	 * ---
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var lowPriorityWarning = function () {};

	{
	  var printWarning = function (format) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    var argIndex = 0;
	    var message = 'Warning: ' + format.replace(/%s/g, function () {
	      return args[argIndex++];
	    });
	    if (typeof console !== 'undefined') {
	      console.warn(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };

	  lowPriorityWarning = function (condition, format) {
	    if (format === undefined) {
	      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	    if (!condition) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	        args[_key2 - 2] = arguments[_key2];
	      }

	      printWarning.apply(undefined, [format].concat(args));
	    }
	  };
	}

	var lowPriorityWarning$1 = lowPriorityWarning;

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warningWithoutStack = function () {};

	{
	  warningWithoutStack = function (condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }

	    if (format === undefined) {
	      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	    if (args.length > 8) {
	      // Check before the condition to catch violations early.
	      throw new Error('warningWithoutStack() currently supports at most 8 arguments.');
	    }
	    if (condition) {
	      return;
	    }
	    if (typeof console !== 'undefined') {
	      var argsWithFormat = args.map(function (item) {
	        return '' + item;
	      });
	      argsWithFormat.unshift('Warning: ' + format);

	      // We intentionally don't use spread (or .apply) directly because it
	      // breaks IE9: https://github.com/facebook/react/issues/13610
	      Function.prototype.apply.call(console.error, console, argsWithFormat);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	var warningWithoutStack$1 = warningWithoutStack;

	var didWarnStateUpdateForUnmountedComponent = {};

	function warnNoop(publicInstance, callerName) {
	  {
	    var _constructor = publicInstance.constructor;
	    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
	    var warningKey = componentName + '.' + callerName;
	    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
	      return;
	    }
	    warningWithoutStack$1(false, "Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
	    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
	  }
	}

	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {?function} callback Called after component is updated.
	   * @param {?string} callerName name of the calling function in the public API.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance, callback, callerName) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @param {?function} callback Called after component is updated.
	   * @param {?string} callerName name of the calling function in the public API.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
	    warnNoop(publicInstance, 'replaceState');
	  },

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @param {?function} callback Called after component is updated.
	   * @param {?string} Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
	    warnNoop(publicInstance, 'setState');
	  }
	};

	var emptyObject = {};
	{
	  Object.freeze(emptyObject);
	}

	/**
	 * Base class helpers for the updating state of a component.
	 */
	function Component(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  // If a component has string refs, we will assign a different object later.
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}

	Component.prototype.isReactComponent = {};

	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	Component.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
	  this.updater.enqueueSetState(this, partialState, callback, 'setState');
	};

	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	Component.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
	};

	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	{
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    Object.defineProperty(Component.prototype, methodName, {
	      get: function () {
	        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
	        return undefined;
	      }
	    });
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}

	function ComponentDummy() {}
	ComponentDummy.prototype = Component.prototype;

	/**
	 * Convenience component with default shallow equality check for sCU.
	 */
	function PureComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  // If a component has string refs, we will assign a different object later.
	  this.refs = emptyObject;
	  this.updater = updater || ReactNoopUpdateQueue;
	}

	var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
	pureComponentPrototype.constructor = PureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(pureComponentPrototype, Component.prototype);
	pureComponentPrototype.isPureReactComponent = true;

	// an immutable object with a single mutable value
	function createRef() {
	  var refObject = {
	    current: null
	  };
	  {
	    Object.seal(refObject);
	  }
	  return refObject;
	}

	/**
	 * Keeps track of the current dispatcher.
	 */
	var ReactCurrentDispatcher = {
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	};

	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	var ReactCurrentOwner = {
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	};

	var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

	var describeComponentFrame = function (name, source, ownerName) {
	  var sourceInfo = '';
	  if (source) {
	    var path = source.fileName;
	    var fileName = path.replace(BEFORE_SLASH_RE, '');
	    {
	      // In DEV, include code for a common special case:
	      // prefer "folder/index.js" instead of just "index.js".
	      if (/^index\./.test(fileName)) {
	        var match = path.match(BEFORE_SLASH_RE);
	        if (match) {
	          var pathBeforeSlash = match[1];
	          if (pathBeforeSlash) {
	            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
	            fileName = folderName + '/' + fileName;
	          }
	        }
	      }
	    }
	    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
	  } else if (ownerName) {
	    sourceInfo = ' (created by ' + ownerName + ')';
	  }
	  return '\n    in ' + (name || 'Unknown') + sourceInfo;
	};

	var Resolved = 1;


	function refineResolvedLazyComponent(lazyComponent) {
	  return lazyComponent._status === Resolved ? lazyComponent._result : null;
	}

	function getWrappedName(outerType, innerType, wrapperName) {
	  var functionName = innerType.displayName || innerType.name || '';
	  return outerType.displayName || (functionName !== '' ? wrapperName + '(' + functionName + ')' : wrapperName);
	}

	function getComponentName(type) {
	  if (type == null) {
	    // Host root, text node or just invalid type.
	    return null;
	  }
	  {
	    if (typeof type.tag === 'number') {
	      warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
	    }
	  }
	  if (typeof type === 'function') {
	    return type.displayName || type.name || null;
	  }
	  if (typeof type === 'string') {
	    return type;
	  }
	  switch (type) {
	    case REACT_CONCURRENT_MODE_TYPE:
	      return 'ConcurrentMode';
	    case REACT_FRAGMENT_TYPE:
	      return 'Fragment';
	    case REACT_PORTAL_TYPE:
	      return 'Portal';
	    case REACT_PROFILER_TYPE:
	      return 'Profiler';
	    case REACT_STRICT_MODE_TYPE:
	      return 'StrictMode';
	    case REACT_SUSPENSE_TYPE:
	      return 'Suspense';
	  }
	  if (typeof type === 'object') {
	    switch (type.$$typeof) {
	      case REACT_CONTEXT_TYPE:
	        return 'Context.Consumer';
	      case REACT_PROVIDER_TYPE:
	        return 'Context.Provider';
	      case REACT_FORWARD_REF_TYPE:
	        return getWrappedName(type, type.render, 'ForwardRef');
	      case REACT_MEMO_TYPE:
	        return getComponentName(type.type);
	      case REACT_LAZY_TYPE:
	        {
	          var thenable = type;
	          var resolvedThenable = refineResolvedLazyComponent(thenable);
	          if (resolvedThenable) {
	            return getComponentName(resolvedThenable);
	          }
	        }
	    }
	  }
	  return null;
	}

	var ReactDebugCurrentFrame = {};

	var currentlyValidatingElement = null;

	function setCurrentlyValidatingElement(element) {
	  {
	    currentlyValidatingElement = element;
	  }
	}

	{
	  // Stack implementation injected by the current renderer.
	  ReactDebugCurrentFrame.getCurrentStack = null;

	  ReactDebugCurrentFrame.getStackAddendum = function () {
	    var stack = '';

	    // Add an extra top frame while an element is being validated
	    if (currentlyValidatingElement) {
	      var name = getComponentName(currentlyValidatingElement.type);
	      var owner = currentlyValidatingElement._owner;
	      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
	    }

	    // Delegate to the injected renderer-specific implementation
	    var impl = ReactDebugCurrentFrame.getCurrentStack;
	    if (impl) {
	      stack += impl() || '';
	    }

	    return stack;
	  };
	}

	var ReactSharedInternals = {
	  ReactCurrentDispatcher: ReactCurrentDispatcher,
	  ReactCurrentOwner: ReactCurrentOwner,
	  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
	  assign: _assign
	};

	{
	  _assign(ReactSharedInternals, {
	    // These should not be included in production.
	    ReactDebugCurrentFrame: ReactDebugCurrentFrame,
	    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
	    // TODO: remove in React 17.0.
	    ReactComponentTreeHook: {}
	  });
	}

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = warningWithoutStack$1;

	{
	  warning = function (condition, format) {
	    if (condition) {
	      return;
	    }
	    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
	    var stack = ReactDebugCurrentFrame.getStackAddendum();
	    // eslint-disable-next-line react-internal/warning-and-invariant-args

	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }

	    warningWithoutStack$1.apply(undefined, [false, format + '%s'].concat(args, [stack]));
	  };
	}

	var warning$1 = warning;

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};

	var specialPropKeyWarningShown = void 0;
	var specialPropRefWarningShown = void 0;

	function hasValidRef(config) {
	  {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}

	function hasValidKey(config) {
	  {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}

	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function () {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      warningWithoutStack$1(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}

	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function () {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      warningWithoutStack$1(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}

	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allows us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,

	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,

	    // Record the component responsible for creating this element.
	    _owner: owner
	  };

	  {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};

	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    Object.defineProperty(element._store, 'validated', {
	      configurable: false,
	      enumerable: false,
	      writable: true,
	      value: false
	    });
	    // self and source are DEV only properties.
	    Object.defineProperty(element, '_self', {
	      configurable: false,
	      enumerable: false,
	      writable: false,
	      value: self
	    });
	    // Two elements created in two different places should be considered
	    // equal for testing purposes and therefore we hide it from enumeration.
	    Object.defineProperty(element, '_source', {
	      configurable: false,
	      enumerable: false,
	      writable: false,
	      value: source
	    });
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }

	  return element;
	};

	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://reactjs.org/docs/react-api.html#createelement
	 */
	function createElement(type, config, children) {
	  var propName = void 0;

	  // Reserved names are extracted
	  var props = {};

	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;

	  if (config != null) {
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }

	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }

	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    {
	      if (Object.freeze) {
	        Object.freeze(childArray);
	      }
	    }
	    props.children = childArray;
	  }

	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  {
	    if (key || ref) {
	      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	      if (key) {
	        defineKeyPropWarningGetter(props, displayName);
	      }
	      if (ref) {
	        defineRefPropWarningGetter(props, displayName);
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	}

	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://reactjs.org/docs/react-api.html#createfactory
	 */


	function cloneAndReplaceKey(oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

	  return newElement;
	}

	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://reactjs.org/docs/react-api.html#cloneelement
	 */
	function cloneElement(element, config, children) {
	  !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;

	  var propName = void 0;

	  // Original props are copied
	  var props = _assign({}, element.props);

	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;

	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;

	  if (config != null) {
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }

	    // Remaining properties override existing props
	    var defaultProps = void 0;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }

	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }

	  return ReactElement(element.type, key, ref, self, source, owner, props);
	}

	/**
	 * Verifies the object is a ReactElement.
	 * See https://reactjs.org/docs/react-api.html#isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a ReactElement.
	 * @final
	 */
	function isValidElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}

	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';

	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });

	  return '$' + escapedString;
	}

	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */

	var didWarnAboutMaps = false;

	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}

	var POOL_SIZE = 10;
	var traverseContextPool = [];
	function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
	  if (traverseContextPool.length) {
	    var traverseContext = traverseContextPool.pop();
	    traverseContext.result = mapResult;
	    traverseContext.keyPrefix = keyPrefix;
	    traverseContext.func = mapFunction;
	    traverseContext.context = mapContext;
	    traverseContext.count = 0;
	    return traverseContext;
	  } else {
	    return {
	      result: mapResult,
	      keyPrefix: keyPrefix,
	      func: mapFunction,
	      context: mapContext,
	      count: 0
	    };
	  }
	}

	function releaseTraverseContext(traverseContext) {
	  traverseContext.result = null;
	  traverseContext.keyPrefix = null;
	  traverseContext.func = null;
	  traverseContext.context = null;
	  traverseContext.count = 0;
	  if (traverseContextPool.length < POOL_SIZE) {
	    traverseContextPool.push(traverseContext);
	  }
	}

	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;

	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }

	  var invokeCallback = false;

	  if (children === null) {
	    invokeCallback = true;
	  } else {
	    switch (type) {
	      case 'string':
	      case 'number':
	        invokeCallback = true;
	        break;
	      case 'object':
	        switch (children.$$typeof) {
	          case REACT_ELEMENT_TYPE:
	          case REACT_PORTAL_TYPE:
	            invokeCallback = true;
	        }
	    }
	  }

	  if (invokeCallback) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }

	  var child = void 0;
	  var nextName = void 0;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (typeof iteratorFn === 'function') {
	      {
	        // Warn about using Maps as children
	        if (iteratorFn === children.entries) {
	          !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;
	          didWarnAboutMaps = true;
	        }
	      }

	      var iterator = iteratorFn.call(children);
	      var step = void 0;
	      var ii = 0;
	      while (!(step = iterator.next()).done) {
	        child = step.value;
	        nextName = nextNamePrefix + getComponentKey(child, ii++);
	        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
	      }
	      var childrenString = '' + children;
	      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
	    }
	  }

	  return subtreeCount;
	}

	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }

	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}

	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (typeof component === 'object' && component !== null && component.key != null) {
	    // Explicit key
	    return escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}

	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func,
	      context = bookKeeping.context;

	  func.call(context, child, bookKeeping.count++);
	}

	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  releaseTraverseContext(traverseContext);
	}

	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result,
	      keyPrefix = bookKeeping.keyPrefix,
	      func = bookKeeping.func,
	      context = bookKeeping.context;


	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {
	      return c;
	    });
	  } else if (mappedChild != null) {
	    if (isValidElement(mappedChild)) {
	      mappedChild = cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}

	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  releaseTraverseContext(traverseContext);
	}

	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}

	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://reactjs.org/docs/react-api.html#reactchildrencount
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children) {
	  return traverseAllChildren(children, function () {
	    return null;
	  }, null);
	}

	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, function (child) {
	    return child;
	  });
	  return result;
	}

	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
	  return children;
	}

	function createContext(defaultValue, calculateChangedBits) {
	  if (calculateChangedBits === undefined) {
	    calculateChangedBits = null;
	  } else {
	    {
	      !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warningWithoutStack$1(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;
	    }
	  }

	  var context = {
	    $$typeof: REACT_CONTEXT_TYPE,
	    _calculateChangedBits: calculateChangedBits,
	    // As a workaround to support multiple concurrent renderers, we categorize
	    // some renderers as primary and others as secondary. We only expect
	    // there to be two concurrent renderers at most: React Native (primary) and
	    // Fabric (secondary); React DOM (primary) and React ART (secondary).
	    // Secondary renderers store their context values on separate fields.
	    _currentValue: defaultValue,
	    _currentValue2: defaultValue,
	    // Used to track how many concurrent renderers this context currently
	    // supports within in a single renderer. Such as parallel server rendering.
	    _threadCount: 0,
	    // These are circular
	    Provider: null,
	    Consumer: null
	  };

	  context.Provider = {
	    $$typeof: REACT_PROVIDER_TYPE,
	    _context: context
	  };

	  var hasWarnedAboutUsingNestedContextConsumers = false;
	  var hasWarnedAboutUsingConsumerProvider = false;

	  {
	    // A separate object, but proxies back to the original context object for
	    // backwards compatibility. It has a different $$typeof, so we can properly
	    // warn for the incorrect usage of Context as a Consumer.
	    var Consumer = {
	      $$typeof: REACT_CONTEXT_TYPE,
	      _context: context,
	      _calculateChangedBits: context._calculateChangedBits
	    };
	    // $FlowFixMe: Flow complains about not setting a value, which is intentional here
	    Object.defineProperties(Consumer, {
	      Provider: {
	        get: function () {
	          if (!hasWarnedAboutUsingConsumerProvider) {
	            hasWarnedAboutUsingConsumerProvider = true;
	            warning$1(false, 'Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
	          }
	          return context.Provider;
	        },
	        set: function (_Provider) {
	          context.Provider = _Provider;
	        }
	      },
	      _currentValue: {
	        get: function () {
	          return context._currentValue;
	        },
	        set: function (_currentValue) {
	          context._currentValue = _currentValue;
	        }
	      },
	      _currentValue2: {
	        get: function () {
	          return context._currentValue2;
	        },
	        set: function (_currentValue2) {
	          context._currentValue2 = _currentValue2;
	        }
	      },
	      _threadCount: {
	        get: function () {
	          return context._threadCount;
	        },
	        set: function (_threadCount) {
	          context._threadCount = _threadCount;
	        }
	      },
	      Consumer: {
	        get: function () {
	          if (!hasWarnedAboutUsingNestedContextConsumers) {
	            hasWarnedAboutUsingNestedContextConsumers = true;
	            warning$1(false, 'Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
	          }
	          return context.Consumer;
	        }
	      }
	    });
	    // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty
	    context.Consumer = Consumer;
	  }

	  {
	    context._currentRenderer = null;
	    context._currentRenderer2 = null;
	  }

	  return context;
	}

	function lazy(ctor) {
	  var lazyType = {
	    $$typeof: REACT_LAZY_TYPE,
	    _ctor: ctor,
	    // React uses these fields to store the result.
	    _status: -1,
	    _result: null
	  };

	  {
	    // In production, this would just set it on the object.
	    var defaultProps = void 0;
	    var propTypes = void 0;
	    Object.defineProperties(lazyType, {
	      defaultProps: {
	        configurable: true,
	        get: function () {
	          return defaultProps;
	        },
	        set: function (newDefaultProps) {
	          warning$1(false, 'React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
	          defaultProps = newDefaultProps;
	          // Match production behavior more closely:
	          Object.defineProperty(lazyType, 'defaultProps', {
	            enumerable: true
	          });
	        }
	      },
	      propTypes: {
	        configurable: true,
	        get: function () {
	          return propTypes;
	        },
	        set: function (newPropTypes) {
	          warning$1(false, 'React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
	          propTypes = newPropTypes;
	          // Match production behavior more closely:
	          Object.defineProperty(lazyType, 'propTypes', {
	            enumerable: true
	          });
	        }
	      }
	    });
	  }

	  return lazyType;
	}

	function forwardRef(render) {
	  {
	    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
	      warningWithoutStack$1(false, 'forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
	    } else if (typeof render !== 'function') {
	      warningWithoutStack$1(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
	    } else {
	      !(
	      // Do not warn for 0 arguments because it could be due to usage of the 'arguments' object
	      render.length === 0 || render.length === 2) ? warningWithoutStack$1(false, 'forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.') : void 0;
	    }

	    if (render != null) {
	      !(render.defaultProps == null && render.propTypes == null) ? warningWithoutStack$1(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;
	    }
	  }

	  return {
	    $$typeof: REACT_FORWARD_REF_TYPE,
	    render: render
	  };
	}

	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' ||
	  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
	}

	function memo(type, compare) {
	  {
	    if (!isValidElementType(type)) {
	      warningWithoutStack$1(false, 'memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
	    }
	  }
	  return {
	    $$typeof: REACT_MEMO_TYPE,
	    type: type,
	    compare: compare === undefined ? null : compare
	  };
	}

	function resolveDispatcher() {
	  var dispatcher = ReactCurrentDispatcher.current;
	  !(dispatcher !== null) ? invariant(false, 'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.') : void 0;
	  return dispatcher;
	}

	function useContext(Context, unstable_observedBits) {
	  var dispatcher = resolveDispatcher();
	  {
	    !(unstable_observedBits === undefined) ? warning$1(false, 'useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://fb.me/rules-of-hooks' : '') : void 0;

	    // TODO: add a more generic warning for invalid values.
	    if (Context._context !== undefined) {
	      var realContext = Context._context;
	      // Don't deduplicate because this legitimately causes bugs
	      // and nobody should be using this in existing code.
	      if (realContext.Consumer === Context) {
	        warning$1(false, 'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
	      } else if (realContext.Provider === Context) {
	        warning$1(false, 'Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
	      }
	    }
	  }
	  return dispatcher.useContext(Context, unstable_observedBits);
	}

	function useState(initialState) {
	  var dispatcher = resolveDispatcher();
	  return dispatcher.useState(initialState);
	}

	function useReducer(reducer, initialArg, init) {
	  var dispatcher = resolveDispatcher();
	  return dispatcher.useReducer(reducer, initialArg, init);
	}

	function useRef(initialValue) {
	  var dispatcher = resolveDispatcher();
	  return dispatcher.useRef(initialValue);
	}

	function useEffect(create, inputs) {
	  var dispatcher = resolveDispatcher();
	  return dispatcher.useEffect(create, inputs);
	}

	function useLayoutEffect(create, inputs) {
	  var dispatcher = resolveDispatcher();
	  return dispatcher.useLayoutEffect(create, inputs);
	}

	function useCallback(callback, inputs) {
	  var dispatcher = resolveDispatcher();
	  return dispatcher.useCallback(callback, inputs);
	}

	function useMemo(create, inputs) {
	  var dispatcher = resolveDispatcher();
	  return dispatcher.useMemo(create, inputs);
	}

	function useImperativeHandle(ref, create, inputs) {
	  var dispatcher = resolveDispatcher();
	  return dispatcher.useImperativeHandle(ref, create, inputs);
	}

	function useDebugValue(value, formatterFn) {
	  {
	    var dispatcher = resolveDispatcher();
	    return dispatcher.useDebugValue(value, formatterFn);
	  }
	}

	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */

	var propTypesMisspellWarningShown = void 0;

	{
	  propTypesMisspellWarningShown = false;
	}

	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = getComponentName(ReactCurrentOwner.current.type);
	    if (name) {
	      return '\n\nCheck the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	function getSourceInfoErrorAddendum(elementProps) {
	  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
	    var source = elementProps.__source;
	    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
	    var lineNumber = source.lineNumber;
	    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
	  }
	  return '';
	}

	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};

	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();

	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = '\n\nCheck the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}

	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;

	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
	    return;
	  }
	  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + getComponentName(element._owner.type) + '.';
	  }

	  setCurrentlyValidatingElement(element);
	  {
	    warning$1(false, 'Each child in a list should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
	  }
	  setCurrentlyValidatingElement(null);
	}

	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    if (typeof iteratorFn === 'function') {
	      // Entry iterators used to provide implicit keys,
	      // but now we print a separate warning for them later.
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step = void 0;
	        while (!(step = iterator.next()).done) {
	          if (isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}

	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var type = element.type;
	  if (type === null || type === undefined || typeof type === 'string') {
	    return;
	  }
	  var name = getComponentName(type);
	  var propTypes = void 0;
	  if (typeof type === 'function') {
	    propTypes = type.propTypes;
	  } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||
	  // Note: Memo only checks outer props here.
	  // Inner props are checked in the reconciler.
	  type.$$typeof === REACT_MEMO_TYPE)) {
	    propTypes = type.propTypes;
	  } else {
	    return;
	  }
	  if (propTypes) {
	    setCurrentlyValidatingElement(element);
	    checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);
	    setCurrentlyValidatingElement(null);
	  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
	    propTypesMisspellWarningShown = true;
	    warningWithoutStack$1(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
	  }
	  if (typeof type.getDefaultProps === 'function') {
	    !type.getDefaultProps.isReactClassApproved ? warningWithoutStack$1(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}

	/**
	 * Given a fragment, validate that it can only be provided with fragment props
	 * @param {ReactElement} fragment
	 */
	function validateFragmentProps(fragment) {
	  setCurrentlyValidatingElement(fragment);

	  var keys = Object.keys(fragment.props);
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (key !== 'children' && key !== 'key') {
	      warning$1(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
	      break;
	    }
	  }

	  if (fragment.ref !== null) {
	    warning$1(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');
	  }

	  setCurrentlyValidatingElement(null);
	}

	function createElementWithValidation(type, props, children) {
	  var validType = isValidElementType(type);

	  // We warn in this case but don't throw. We expect the element creation to
	  // succeed and there will likely be errors in render.
	  if (!validType) {
	    var info = '';
	    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
	      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
	    }

	    var sourceInfo = getSourceInfoErrorAddendum(props);
	    if (sourceInfo) {
	      info += sourceInfo;
	    } else {
	      info += getDeclarationErrorAddendum();
	    }

	    var typeString = void 0;
	    if (type === null) {
	      typeString = 'null';
	    } else if (Array.isArray(type)) {
	      typeString = 'array';
	    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
	      typeString = '<' + (getComponentName(type.type) || 'Unknown') + ' />';
	      info = ' Did you accidentally export a JSX literal instead of a component?';
	    } else {
	      typeString = typeof type;
	    }

	    warning$1(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
	  }

	  var element = createElement.apply(this, arguments);

	  // The result can be nullish if a mock or a custom function is used.
	  // TODO: Drop this when these are no longer allowed as the type argument.
	  if (element == null) {
	    return element;
	  }

	  // Skip key warning if the type isn't valid since our key validation logic
	  // doesn't expect a non-string/function type and can throw confusing errors.
	  // We don't want exception behavior to differ between dev and prod.
	  // (Rendering will throw with a helpful message and as soon as the type is
	  // fixed, the key warnings will appear.)
	  if (validType) {
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], type);
	    }
	  }

	  if (type === REACT_FRAGMENT_TYPE) {
	    validateFragmentProps(element);
	  } else {
	    validatePropTypes(element);
	  }

	  return element;
	}

	function createFactoryWithValidation(type) {
	  var validatedFactory = createElementWithValidation.bind(null, type);
	  validatedFactory.type = type;
	  // Legacy hook: remove it
	  {
	    Object.defineProperty(validatedFactory, 'type', {
	      enumerable: false,
	      get: function () {
	        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
	        Object.defineProperty(this, 'type', {
	          value: type
	        });
	        return type;
	      }
	    });
	  }

	  return validatedFactory;
	}

	function cloneElementWithValidation(element, props, children) {
	  var newElement = cloneElement.apply(this, arguments);
	  for (var i = 2; i < arguments.length; i++) {
	    validateChildKeys(arguments[i], newElement.type);
	  }
	  validatePropTypes(newElement);
	  return newElement;
	}

	var React = {
	  Children: {
	    map: mapChildren,
	    forEach: forEachChildren,
	    count: countChildren,
	    toArray: toArray,
	    only: onlyChild
	  },

	  createRef: createRef,
	  Component: Component,
	  PureComponent: PureComponent,

	  createContext: createContext,
	  forwardRef: forwardRef,
	  lazy: lazy,
	  memo: memo,

	  useCallback: useCallback,
	  useContext: useContext,
	  useEffect: useEffect,
	  useImperativeHandle: useImperativeHandle,
	  useDebugValue: useDebugValue,
	  useLayoutEffect: useLayoutEffect,
	  useMemo: useMemo,
	  useReducer: useReducer,
	  useRef: useRef,
	  useState: useState,

	  Fragment: REACT_FRAGMENT_TYPE,
	  StrictMode: REACT_STRICT_MODE_TYPE,
	  Suspense: REACT_SUSPENSE_TYPE,

	  createElement: createElementWithValidation,
	  cloneElement: cloneElementWithValidation,
	  createFactory: createFactoryWithValidation,
	  isValidElement: isValidElement,

	  version: ReactVersion,

	  unstable_ConcurrentMode: REACT_CONCURRENT_MODE_TYPE,
	  unstable_Profiler: REACT_PROFILER_TYPE,

	  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals
	};



	var React$2 = Object.freeze({
		default: React
	});

	var React$3 = ( React$2 && React ) || React$2;

	// TODO: decide on the top-level export form.
	// This is hacky but makes it work with both Rollup and Jest.
	var react = React$3.default || React$3;

	module.exports = react;
	  })();
	}
	});

	var react = createCommonjsModule(function (module) {

	{
	  module.exports = react_development;
	}
	});

	var scheduler_development = createCommonjsModule(function (module, exports) {



	{
	  (function() {

	Object.defineProperty(exports, '__esModule', { value: true });

	var enableSchedulerDebugging = false;

	/* eslint-disable no-var */

	// TODO: Use symbols?
	var ImmediatePriority = 1;
	var UserBlockingPriority = 2;
	var NormalPriority = 3;
	var LowPriority = 4;
	var IdlePriority = 5;

	// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
	// Math.pow(2, 30) - 1
	// 0b111111111111111111111111111111
	var maxSigned31BitInt = 1073741823;

	// Times out immediately
	var IMMEDIATE_PRIORITY_TIMEOUT = -1;
	// Eventually times out
	var USER_BLOCKING_PRIORITY = 250;
	var NORMAL_PRIORITY_TIMEOUT = 5000;
	var LOW_PRIORITY_TIMEOUT = 10000;
	// Never times out
	var IDLE_PRIORITY = maxSigned31BitInt;

	// Callbacks are stored as a circular, doubly linked list.
	var firstCallbackNode = null;

	var currentDidTimeout = false;

	var currentPriorityLevel = NormalPriority;
	var currentEventStartTime = -1;
	var currentExpirationTime = -1;

	// This is set when a callback is being executed, to prevent re-entrancy.
	var isExecutingCallback = false;

	var isHostCallbackScheduled = false;

	var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

	function ensureHostCallbackIsScheduled() {
	  if (isExecutingCallback) {
	    // Don't schedule work yet; wait until the next time we yield.
	    return;
	  }
	  // Schedule the host callback using the earliest expiration in the list.
	  var expirationTime = firstCallbackNode.expirationTime;
	  if (!isHostCallbackScheduled) {
	    isHostCallbackScheduled = true;
	  } else {
	    // Cancel the existing host callback.
	    cancelHostCallback();
	  }
	  requestHostCallback(flushWork, expirationTime);
	}

	function flushFirstCallback() {
	  var flushedNode = firstCallbackNode;

	  // Remove the node from the list before calling the callback. That way the
	  // list is in a consistent state even if the callback throws.
	  var next = firstCallbackNode.next;
	  if (firstCallbackNode === next) {
	    // This is the last callback in the list.
	    firstCallbackNode = null;
	    next = null;
	  } else {
	    var lastCallbackNode = firstCallbackNode.previous;
	    firstCallbackNode = lastCallbackNode.next = next;
	    next.previous = lastCallbackNode;
	  }

	  flushedNode.next = flushedNode.previous = null;

	  // Now it's safe to call the callback.
	  var callback = flushedNode.callback;
	  var expirationTime = flushedNode.expirationTime;
	  var priorityLevel = flushedNode.priorityLevel;
	  var previousPriorityLevel = currentPriorityLevel;
	  var previousExpirationTime = currentExpirationTime;
	  currentPriorityLevel = priorityLevel;
	  currentExpirationTime = expirationTime;
	  var continuationCallback;
	  try {
	    continuationCallback = callback();
	  } finally {
	    currentPriorityLevel = previousPriorityLevel;
	    currentExpirationTime = previousExpirationTime;
	  }

	  // A callback may return a continuation. The continuation should be scheduled
	  // with the same priority and expiration as the just-finished callback.
	  if (typeof continuationCallback === 'function') {
	    var continuationNode = {
	      callback: continuationCallback,
	      priorityLevel: priorityLevel,
	      expirationTime: expirationTime,
	      next: null,
	      previous: null
	    };

	    // Insert the new callback into the list, sorted by its expiration. This is
	    // almost the same as the code in `scheduleCallback`, except the callback
	    // is inserted into the list *before* callbacks of equal expiration instead
	    // of after.
	    if (firstCallbackNode === null) {
	      // This is the first callback in the list.
	      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;
	    } else {
	      var nextAfterContinuation = null;
	      var node = firstCallbackNode;
	      do {
	        if (node.expirationTime >= expirationTime) {
	          // This callback expires at or after the continuation. We will insert
	          // the continuation *before* this callback.
	          nextAfterContinuation = node;
	          break;
	        }
	        node = node.next;
	      } while (node !== firstCallbackNode);

	      if (nextAfterContinuation === null) {
	        // No equal or lower priority callback was found, which means the new
	        // callback is the lowest priority callback in the list.
	        nextAfterContinuation = firstCallbackNode;
	      } else if (nextAfterContinuation === firstCallbackNode) {
	        // The new callback is the highest priority callback in the list.
	        firstCallbackNode = continuationNode;
	        ensureHostCallbackIsScheduled();
	      }

	      var previous = nextAfterContinuation.previous;
	      previous.next = nextAfterContinuation.previous = continuationNode;
	      continuationNode.next = nextAfterContinuation;
	      continuationNode.previous = previous;
	    }
	  }
	}

	function flushImmediateWork() {
	  if (
	  // Confirm we've exited the outer most event handler
	  currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {
	    isExecutingCallback = true;
	    try {
	      do {
	        flushFirstCallback();
	      } while (
	      // Keep flushing until there are no more immediate callbacks
	      firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);
	    } finally {
	      isExecutingCallback = false;
	      if (firstCallbackNode !== null) {
	        // There's still work remaining. Request another callback.
	        ensureHostCallbackIsScheduled();
	      } else {
	        isHostCallbackScheduled = false;
	      }
	    }
	  }
	}

	function flushWork(didTimeout) {

	  isExecutingCallback = true;
	  var previousDidTimeout = currentDidTimeout;
	  currentDidTimeout = didTimeout;
	  try {
	    if (didTimeout) {
	      // Flush all the expired callbacks without yielding.
	      while (firstCallbackNode !== null && !(enableSchedulerDebugging)) {
	        // TODO Wrap in feature flag
	        // Read the current time. Flush all the callbacks that expire at or
	        // earlier than that time. Then read the current time again and repeat.
	        // This optimizes for as few performance.now calls as possible.
	        var currentTime = exports.unstable_now();
	        if (firstCallbackNode.expirationTime <= currentTime) {
	          do {
	            flushFirstCallback();
	          } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime && !(enableSchedulerDebugging));
	          continue;
	        }
	        break;
	      }
	    } else {
	      // Keep flushing callbacks until we run out of time in the frame.
	      if (firstCallbackNode !== null) {
	        do {
	          flushFirstCallback();
	        } while (firstCallbackNode !== null && !shouldYieldToHost());
	      }
	    }
	  } finally {
	    isExecutingCallback = false;
	    currentDidTimeout = previousDidTimeout;
	    if (firstCallbackNode !== null) {
	      // There's still work remaining. Request another callback.
	      ensureHostCallbackIsScheduled();
	    } else {
	      isHostCallbackScheduled = false;
	    }
	    // Before exiting, flush all the immediate work that was scheduled.
	    flushImmediateWork();
	  }
	}

	function unstable_runWithPriority(priorityLevel, eventHandler) {
	  switch (priorityLevel) {
	    case ImmediatePriority:
	    case UserBlockingPriority:
	    case NormalPriority:
	    case LowPriority:
	    case IdlePriority:
	      break;
	    default:
	      priorityLevel = NormalPriority;
	  }

	  var previousPriorityLevel = currentPriorityLevel;
	  var previousEventStartTime = currentEventStartTime;
	  currentPriorityLevel = priorityLevel;
	  currentEventStartTime = exports.unstable_now();

	  try {
	    return eventHandler();
	  } finally {
	    currentPriorityLevel = previousPriorityLevel;
	    currentEventStartTime = previousEventStartTime;

	    // Before exiting, flush all the immediate work that was scheduled.
	    flushImmediateWork();
	  }
	}

	function unstable_next(eventHandler) {
	  var priorityLevel = void 0;
	  switch (currentPriorityLevel) {
	    case ImmediatePriority:
	    case UserBlockingPriority:
	    case NormalPriority:
	      // Shift down to normal priority
	      priorityLevel = NormalPriority;
	      break;
	    default:
	      // Anything lower than normal priority should remain at the current level.
	      priorityLevel = currentPriorityLevel;
	      break;
	  }

	  var previousPriorityLevel = currentPriorityLevel;
	  var previousEventStartTime = currentEventStartTime;
	  currentPriorityLevel = priorityLevel;
	  currentEventStartTime = exports.unstable_now();

	  try {
	    return eventHandler();
	  } finally {
	    currentPriorityLevel = previousPriorityLevel;
	    currentEventStartTime = previousEventStartTime;

	    // Before exiting, flush all the immediate work that was scheduled.
	    flushImmediateWork();
	  }
	}

	function unstable_wrapCallback(callback) {
	  var parentPriorityLevel = currentPriorityLevel;
	  return function () {
	    // This is a fork of runWithPriority, inlined for performance.
	    var previousPriorityLevel = currentPriorityLevel;
	    var previousEventStartTime = currentEventStartTime;
	    currentPriorityLevel = parentPriorityLevel;
	    currentEventStartTime = exports.unstable_now();

	    try {
	      return callback.apply(this, arguments);
	    } finally {
	      currentPriorityLevel = previousPriorityLevel;
	      currentEventStartTime = previousEventStartTime;
	      flushImmediateWork();
	    }
	  };
	}

	function unstable_scheduleCallback(callback, deprecated_options) {
	  var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();

	  var expirationTime;
	  if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {
	    // FIXME: Remove this branch once we lift expiration times out of React.
	    expirationTime = startTime + deprecated_options.timeout;
	  } else {
	    switch (currentPriorityLevel) {
	      case ImmediatePriority:
	        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;
	        break;
	      case UserBlockingPriority:
	        expirationTime = startTime + USER_BLOCKING_PRIORITY;
	        break;
	      case IdlePriority:
	        expirationTime = startTime + IDLE_PRIORITY;
	        break;
	      case LowPriority:
	        expirationTime = startTime + LOW_PRIORITY_TIMEOUT;
	        break;
	      case NormalPriority:
	      default:
	        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;
	    }
	  }

	  var newNode = {
	    callback: callback,
	    priorityLevel: currentPriorityLevel,
	    expirationTime: expirationTime,
	    next: null,
	    previous: null
	  };

	  // Insert the new callback into the list, ordered first by expiration, then
	  // by insertion. So the new callback is inserted any other callback with
	  // equal expiration.
	  if (firstCallbackNode === null) {
	    // This is the first callback in the list.
	    firstCallbackNode = newNode.next = newNode.previous = newNode;
	    ensureHostCallbackIsScheduled();
	  } else {
	    var next = null;
	    var node = firstCallbackNode;
	    do {
	      if (node.expirationTime > expirationTime) {
	        // The new callback expires before this one.
	        next = node;
	        break;
	      }
	      node = node.next;
	    } while (node !== firstCallbackNode);

	    if (next === null) {
	      // No callback with a later expiration was found, which means the new
	      // callback has the latest expiration in the list.
	      next = firstCallbackNode;
	    } else if (next === firstCallbackNode) {
	      // The new callback has the earliest expiration in the entire list.
	      firstCallbackNode = newNode;
	      ensureHostCallbackIsScheduled();
	    }

	    var previous = next.previous;
	    previous.next = next.previous = newNode;
	    newNode.next = next;
	    newNode.previous = previous;
	  }

	  return newNode;
	}

	function unstable_pauseExecution() {
	}

	function unstable_continueExecution() {
	  if (firstCallbackNode !== null) {
	    ensureHostCallbackIsScheduled();
	  }
	}

	function unstable_getFirstCallbackNode() {
	  return firstCallbackNode;
	}

	function unstable_cancelCallback(callbackNode) {
	  var next = callbackNode.next;
	  if (next === null) {
	    // Already cancelled.
	    return;
	  }

	  if (next === callbackNode) {
	    // This is the only scheduled callback. Clear the list.
	    firstCallbackNode = null;
	  } else {
	    // Remove the callback from its position in the list.
	    if (callbackNode === firstCallbackNode) {
	      firstCallbackNode = next;
	    }
	    var previous = callbackNode.previous;
	    previous.next = next;
	    next.previous = previous;
	  }

	  callbackNode.next = callbackNode.previous = null;
	}

	function unstable_getCurrentPriorityLevel() {
	  return currentPriorityLevel;
	}

	function unstable_shouldYield() {
	  return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());
	}

	// The remaining code is essentially a polyfill for requestIdleCallback. It
	// works by scheduling a requestAnimationFrame, storing the time for the start
	// of the frame, then scheduling a postMessage which gets scheduled after paint.
	// Within the postMessage handler do as much work as possible until time + frame
	// rate. By separating the idle call into a separate event tick we ensure that
	// layout, paint and other browser work is counted against the available time.
	// The frame rate is dynamically adjusted.

	// We capture a local reference to any global, in case it gets polyfilled after
	// this module is initially evaluated. We want to be using a
	// consistent implementation.
	var localDate = Date;

	// This initialization code may run even on server environments if a component
	// just imports ReactDOM (e.g. for findDOMNode). Some environments might not
	// have setTimeout or clearTimeout. However, we always expect them to be defined
	// on the client. https://github.com/facebook/react/pull/13088
	var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
	var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;

	// We don't expect either of these to necessarily be defined, but we will error
	// later if they are missing on the client.
	var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;
	var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;

	// requestAnimationFrame does not run when the tab is in the background. If
	// we're backgrounded we prefer for that work to happen so that the page
	// continues to load in the background. So we also schedule a 'setTimeout' as
	// a fallback.
	// TODO: Need a better heuristic for backgrounded work.
	var ANIMATION_FRAME_TIMEOUT = 100;
	var rAFID;
	var rAFTimeoutID;
	var requestAnimationFrameWithTimeout = function (callback) {
	  // schedule rAF and also a setTimeout
	  rAFID = localRequestAnimationFrame(function (timestamp) {
	    // cancel the setTimeout
	    localClearTimeout(rAFTimeoutID);
	    callback(timestamp);
	  });
	  rAFTimeoutID = localSetTimeout(function () {
	    // cancel the requestAnimationFrame
	    localCancelAnimationFrame(rAFID);
	    callback(exports.unstable_now());
	  }, ANIMATION_FRAME_TIMEOUT);
	};

	if (hasNativePerformanceNow) {
	  var Performance = performance;
	  exports.unstable_now = function () {
	    return Performance.now();
	  };
	} else {
	  exports.unstable_now = function () {
	    return localDate.now();
	  };
	}

	var requestHostCallback;
	var cancelHostCallback;
	var shouldYieldToHost;

	var globalValue = null;
	if (typeof window !== 'undefined') {
	  globalValue = window;
	} else if (typeof commonjsGlobal !== 'undefined') {
	  globalValue = commonjsGlobal;
	}

	if (globalValue && globalValue._schedMock) {
	  // Dynamic injection, only for testing purposes.
	  var globalImpl = globalValue._schedMock;
	  requestHostCallback = globalImpl[0];
	  cancelHostCallback = globalImpl[1];
	  shouldYieldToHost = globalImpl[2];
	  exports.unstable_now = globalImpl[3];
	} else if (
	// If Scheduler runs in a non-DOM environment, it falls back to a naive
	// implementation using setTimeout.
	typeof window === 'undefined' ||
	// Check if MessageChannel is supported, too.
	typeof MessageChannel !== 'function') {
	  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,
	  // fallback to a naive implementation.
	  var _callback = null;
	  var _flushCallback = function (didTimeout) {
	    if (_callback !== null) {
	      try {
	        _callback(didTimeout);
	      } finally {
	        _callback = null;
	      }
	    }
	  };
	  requestHostCallback = function (cb, ms) {
	    if (_callback !== null) {
	      // Protect against re-entrancy.
	      setTimeout(requestHostCallback, 0, cb);
	    } else {
	      _callback = cb;
	      setTimeout(_flushCallback, 0, false);
	    }
	  };
	  cancelHostCallback = function () {
	    _callback = null;
	  };
	  shouldYieldToHost = function () {
	    return false;
	  };
	} else {
	  if (typeof console !== 'undefined') {
	    // TODO: Remove fb.me link
	    if (typeof localRequestAnimationFrame !== 'function') {
	      console.error("This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
	    }
	    if (typeof localCancelAnimationFrame !== 'function') {
	      console.error("This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
	    }
	  }

	  var scheduledHostCallback = null;
	  var isMessageEventScheduled = false;
	  var timeoutTime = -1;

	  var isAnimationFrameScheduled = false;

	  var isFlushingHostCallback = false;

	  var frameDeadline = 0;
	  // We start out assuming that we run at 30fps but then the heuristic tracking
	  // will adjust this value to a faster fps if we get more frequent animation
	  // frames.
	  var previousFrameTime = 33;
	  var activeFrameTime = 33;

	  shouldYieldToHost = function () {
	    return frameDeadline <= exports.unstable_now();
	  };

	  // We use the postMessage trick to defer idle work until after the repaint.
	  var channel = new MessageChannel();
	  var port = channel.port2;
	  channel.port1.onmessage = function (event) {
	    isMessageEventScheduled = false;

	    var prevScheduledCallback = scheduledHostCallback;
	    var prevTimeoutTime = timeoutTime;
	    scheduledHostCallback = null;
	    timeoutTime = -1;

	    var currentTime = exports.unstable_now();

	    var didTimeout = false;
	    if (frameDeadline - currentTime <= 0) {
	      // There's no time left in this idle period. Check if the callback has
	      // a timeout and whether it's been exceeded.
	      if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {
	        // Exceeded the timeout. Invoke the callback even though there's no
	        // time left.
	        didTimeout = true;
	      } else {
	        // No timeout.
	        if (!isAnimationFrameScheduled) {
	          // Schedule another animation callback so we retry later.
	          isAnimationFrameScheduled = true;
	          requestAnimationFrameWithTimeout(animationTick);
	        }
	        // Exit without invoking the callback.
	        scheduledHostCallback = prevScheduledCallback;
	        timeoutTime = prevTimeoutTime;
	        return;
	      }
	    }

	    if (prevScheduledCallback !== null) {
	      isFlushingHostCallback = true;
	      try {
	        prevScheduledCallback(didTimeout);
	      } finally {
	        isFlushingHostCallback = false;
	      }
	    }
	  };

	  var animationTick = function (rafTime) {
	    if (scheduledHostCallback !== null) {
	      // Eagerly schedule the next animation callback at the beginning of the
	      // frame. If the scheduler queue is not empty at the end of the frame, it
	      // will continue flushing inside that callback. If the queue *is* empty,
	      // then it will exit immediately. Posting the callback at the start of the
	      // frame ensures it's fired within the earliest possible frame. If we
	      // waited until the end of the frame to post the callback, we risk the
	      // browser skipping a frame and not firing the callback until the frame
	      // after that.
	      requestAnimationFrameWithTimeout(animationTick);
	    } else {
	      // No pending work. Exit.
	      isAnimationFrameScheduled = false;
	      return;
	    }

	    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
	    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
	      if (nextFrameTime < 8) {
	        // Defensive coding. We don't support higher frame rates than 120hz.
	        // If the calculated frame time gets lower than 8, it is probably a bug.
	        nextFrameTime = 8;
	      }
	      // If one frame goes long, then the next one can be short to catch up.
	      // If two frames are short in a row, then that's an indication that we
	      // actually have a higher frame rate than what we're currently optimizing.
	      // We adjust our heuristic dynamically accordingly. For example, if we're
	      // running on 120hz display or 90hz VR display.
	      // Take the max of the two in case one of them was an anomaly due to
	      // missed frame deadlines.
	      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
	    } else {
	      previousFrameTime = nextFrameTime;
	    }
	    frameDeadline = rafTime + activeFrameTime;
	    if (!isMessageEventScheduled) {
	      isMessageEventScheduled = true;
	      port.postMessage(undefined);
	    }
	  };

	  requestHostCallback = function (callback, absoluteTimeout) {
	    scheduledHostCallback = callback;
	    timeoutTime = absoluteTimeout;
	    if (isFlushingHostCallback || absoluteTimeout < 0) {
	      // Don't wait for the next frame. Continue working ASAP, in a new event.
	      port.postMessage(undefined);
	    } else if (!isAnimationFrameScheduled) {
	      // If rAF didn't already schedule one, we need to schedule a frame.
	      // TODO: If this rAF doesn't materialize because the browser throttles, we
	      // might want to still have setTimeout trigger rIC as a backup to ensure
	      // that we keep performing work.
	      isAnimationFrameScheduled = true;
	      requestAnimationFrameWithTimeout(animationTick);
	    }
	  };

	  cancelHostCallback = function () {
	    scheduledHostCallback = null;
	    isMessageEventScheduled = false;
	    timeoutTime = -1;
	  };
	}

	exports.unstable_ImmediatePriority = ImmediatePriority;
	exports.unstable_UserBlockingPriority = UserBlockingPriority;
	exports.unstable_NormalPriority = NormalPriority;
	exports.unstable_IdlePriority = IdlePriority;
	exports.unstable_LowPriority = LowPriority;
	exports.unstable_runWithPriority = unstable_runWithPriority;
	exports.unstable_next = unstable_next;
	exports.unstable_scheduleCallback = unstable_scheduleCallback;
	exports.unstable_cancelCallback = unstable_cancelCallback;
	exports.unstable_wrapCallback = unstable_wrapCallback;
	exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
	exports.unstable_shouldYield = unstable_shouldYield;
	exports.unstable_continueExecution = unstable_continueExecution;
	exports.unstable_pauseExecution = unstable_pauseExecution;
	exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
	  })();
	}
	});

	unwrapExports(scheduler_development);
	var scheduler_development_1 = scheduler_development.unstable_now;
	var scheduler_development_2 = scheduler_development.unstable_ImmediatePriority;
	var scheduler_development_3 = scheduler_development.unstable_UserBlockingPriority;
	var scheduler_development_4 = scheduler_development.unstable_NormalPriority;
	var scheduler_development_5 = scheduler_development.unstable_IdlePriority;
	var scheduler_development_6 = scheduler_development.unstable_LowPriority;
	var scheduler_development_7 = scheduler_development.unstable_runWithPriority;
	var scheduler_development_8 = scheduler_development.unstable_next;
	var scheduler_development_9 = scheduler_development.unstable_scheduleCallback;
	var scheduler_development_10 = scheduler_development.unstable_cancelCallback;
	var scheduler_development_11 = scheduler_development.unstable_wrapCallback;
	var scheduler_development_12 = scheduler_development.unstable_getCurrentPriorityLevel;
	var scheduler_development_13 = scheduler_development.unstable_shouldYield;
	var scheduler_development_14 = scheduler_development.unstable_continueExecution;
	var scheduler_development_15 = scheduler_development.unstable_pauseExecution;
	var scheduler_development_16 = scheduler_development.unstable_getFirstCallbackNode;

	var scheduler = createCommonjsModule(function (module) {

	{
	  module.exports = scheduler_development;
	}
	});

	var schedulerTracing_development = createCommonjsModule(function (module, exports) {



	{
	  (function() {

	Object.defineProperty(exports, '__esModule', { value: true });

	// Only used in www builds.
	 // TODO: true? Here it might just be false.

	// Only used in www builds.


	// Only used in www builds.


	// React Fire: prevent the value and checked attributes from syncing
	// with their related DOM properties


	// These APIs will no longer be "unstable" in the upcoming 16.7 release,
	// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.

	var DEFAULT_THREAD_ID = 0;

	// Counters used to generate unique IDs.
	var interactionIDCounter = 0;
	var threadIDCounter = 0;

	// Set of currently traced interactions.
	// Interactions "stack"–
	// Meaning that newly traced interactions are appended to the previously active set.
	// When an interaction goes out of scope, the previous set (if any) is restored.
	exports.__interactionsRef = null;

	// Listener(s) to notify when interactions begin and end.
	exports.__subscriberRef = null;

	{
	  exports.__interactionsRef = {
	    current: new Set()
	  };
	  exports.__subscriberRef = {
	    current: null
	  };
	}

	function unstable_clear(callback) {

	  var prevInteractions = exports.__interactionsRef.current;
	  exports.__interactionsRef.current = new Set();

	  try {
	    return callback();
	  } finally {
	    exports.__interactionsRef.current = prevInteractions;
	  }
	}

	function unstable_getCurrent() {
	  {
	    return exports.__interactionsRef.current;
	  }
	}

	function unstable_getThreadID() {
	  return ++threadIDCounter;
	}

	function unstable_trace(name, timestamp, callback) {
	  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;

	  var interaction = {
	    __count: 1,
	    id: interactionIDCounter++,
	    name: name,
	    timestamp: timestamp
	  };

	  var prevInteractions = exports.__interactionsRef.current;

	  // Traced interactions should stack/accumulate.
	  // To do that, clone the current interactions.
	  // The previous set will be restored upon completion.
	  var interactions = new Set(prevInteractions);
	  interactions.add(interaction);
	  exports.__interactionsRef.current = interactions;

	  var subscriber = exports.__subscriberRef.current;
	  var returnValue = void 0;

	  try {
	    if (subscriber !== null) {
	      subscriber.onInteractionTraced(interaction);
	    }
	  } finally {
	    try {
	      if (subscriber !== null) {
	        subscriber.onWorkStarted(interactions, threadID);
	      }
	    } finally {
	      try {
	        returnValue = callback();
	      } finally {
	        exports.__interactionsRef.current = prevInteractions;

	        try {
	          if (subscriber !== null) {
	            subscriber.onWorkStopped(interactions, threadID);
	          }
	        } finally {
	          interaction.__count--;

	          // If no async work was scheduled for this interaction,
	          // Notify subscribers that it's completed.
	          if (subscriber !== null && interaction.__count === 0) {
	            subscriber.onInteractionScheduledWorkCompleted(interaction);
	          }
	        }
	      }
	    }
	  }

	  return returnValue;
	}

	function unstable_wrap(callback) {
	  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;

	  var wrappedInteractions = exports.__interactionsRef.current;

	  var subscriber = exports.__subscriberRef.current;
	  if (subscriber !== null) {
	    subscriber.onWorkScheduled(wrappedInteractions, threadID);
	  }

	  // Update the pending async work count for the current interactions.
	  // Update after calling subscribers in case of error.
	  wrappedInteractions.forEach(function (interaction) {
	    interaction.__count++;
	  });

	  var hasRun = false;

	  function wrapped() {
	    var prevInteractions = exports.__interactionsRef.current;
	    exports.__interactionsRef.current = wrappedInteractions;

	    subscriber = exports.__subscriberRef.current;

	    try {
	      var returnValue = void 0;

	      try {
	        if (subscriber !== null) {
	          subscriber.onWorkStarted(wrappedInteractions, threadID);
	        }
	      } finally {
	        try {
	          returnValue = callback.apply(undefined, arguments);
	        } finally {
	          exports.__interactionsRef.current = prevInteractions;

	          if (subscriber !== null) {
	            subscriber.onWorkStopped(wrappedInteractions, threadID);
	          }
	        }
	      }

	      return returnValue;
	    } finally {
	      if (!hasRun) {
	        // We only expect a wrapped function to be executed once,
	        // But in the event that it's executed more than once–
	        // Only decrement the outstanding interaction counts once.
	        hasRun = true;

	        // Update pending async counts for all wrapped interactions.
	        // If this was the last scheduled async work for any of them,
	        // Mark them as completed.
	        wrappedInteractions.forEach(function (interaction) {
	          interaction.__count--;

	          if (subscriber !== null && interaction.__count === 0) {
	            subscriber.onInteractionScheduledWorkCompleted(interaction);
	          }
	        });
	      }
	    }
	  }

	  wrapped.cancel = function cancel() {
	    subscriber = exports.__subscriberRef.current;

	    try {
	      if (subscriber !== null) {
	        subscriber.onWorkCanceled(wrappedInteractions, threadID);
	      }
	    } finally {
	      // Update pending async counts for all wrapped interactions.
	      // If this was the last scheduled async work for any of them,
	      // Mark them as completed.
	      wrappedInteractions.forEach(function (interaction) {
	        interaction.__count--;

	        if (subscriber && interaction.__count === 0) {
	          subscriber.onInteractionScheduledWorkCompleted(interaction);
	        }
	      });
	    }
	  };

	  return wrapped;
	}

	var subscribers = null;
	{
	  subscribers = new Set();
	}

	function unstable_subscribe(subscriber) {
	  {
	    subscribers.add(subscriber);

	    if (subscribers.size === 1) {
	      exports.__subscriberRef.current = {
	        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
	        onInteractionTraced: onInteractionTraced,
	        onWorkCanceled: onWorkCanceled,
	        onWorkScheduled: onWorkScheduled,
	        onWorkStarted: onWorkStarted,
	        onWorkStopped: onWorkStopped
	      };
	    }
	  }
	}

	function unstable_unsubscribe(subscriber) {
	  {
	    subscribers.delete(subscriber);

	    if (subscribers.size === 0) {
	      exports.__subscriberRef.current = null;
	    }
	  }
	}

	function onInteractionTraced(interaction) {
	  var didCatchError = false;
	  var caughtError = null;

	  subscribers.forEach(function (subscriber) {
	    try {
	      subscriber.onInteractionTraced(interaction);
	    } catch (error) {
	      if (!didCatchError) {
	        didCatchError = true;
	        caughtError = error;
	      }
	    }
	  });

	  if (didCatchError) {
	    throw caughtError;
	  }
	}

	function onInteractionScheduledWorkCompleted(interaction) {
	  var didCatchError = false;
	  var caughtError = null;

	  subscribers.forEach(function (subscriber) {
	    try {
	      subscriber.onInteractionScheduledWorkCompleted(interaction);
	    } catch (error) {
	      if (!didCatchError) {
	        didCatchError = true;
	        caughtError = error;
	      }
	    }
	  });

	  if (didCatchError) {
	    throw caughtError;
	  }
	}

	function onWorkScheduled(interactions, threadID) {
	  var didCatchError = false;
	  var caughtError = null;

	  subscribers.forEach(function (subscriber) {
	    try {
	      subscriber.onWorkScheduled(interactions, threadID);
	    } catch (error) {
	      if (!didCatchError) {
	        didCatchError = true;
	        caughtError = error;
	      }
	    }
	  });

	  if (didCatchError) {
	    throw caughtError;
	  }
	}

	function onWorkStarted(interactions, threadID) {
	  var didCatchError = false;
	  var caughtError = null;

	  subscribers.forEach(function (subscriber) {
	    try {
	      subscriber.onWorkStarted(interactions, threadID);
	    } catch (error) {
	      if (!didCatchError) {
	        didCatchError = true;
	        caughtError = error;
	      }
	    }
	  });

	  if (didCatchError) {
	    throw caughtError;
	  }
	}

	function onWorkStopped(interactions, threadID) {
	  var didCatchError = false;
	  var caughtError = null;

	  subscribers.forEach(function (subscriber) {
	    try {
	      subscriber.onWorkStopped(interactions, threadID);
	    } catch (error) {
	      if (!didCatchError) {
	        didCatchError = true;
	        caughtError = error;
	      }
	    }
	  });

	  if (didCatchError) {
	    throw caughtError;
	  }
	}

	function onWorkCanceled(interactions, threadID) {
	  var didCatchError = false;
	  var caughtError = null;

	  subscribers.forEach(function (subscriber) {
	    try {
	      subscriber.onWorkCanceled(interactions, threadID);
	    } catch (error) {
	      if (!didCatchError) {
	        didCatchError = true;
	        caughtError = error;
	      }
	    }
	  });

	  if (didCatchError) {
	    throw caughtError;
	  }
	}

	exports.unstable_clear = unstable_clear;
	exports.unstable_getCurrent = unstable_getCurrent;
	exports.unstable_getThreadID = unstable_getThreadID;
	exports.unstable_trace = unstable_trace;
	exports.unstable_wrap = unstable_wrap;
	exports.unstable_subscribe = unstable_subscribe;
	exports.unstable_unsubscribe = unstable_unsubscribe;
	  })();
	}
	});

	unwrapExports(schedulerTracing_development);
	var schedulerTracing_development_1 = schedulerTracing_development.__interactionsRef;
	var schedulerTracing_development_2 = schedulerTracing_development.__subscriberRef;
	var schedulerTracing_development_3 = schedulerTracing_development.unstable_clear;
	var schedulerTracing_development_4 = schedulerTracing_development.unstable_getCurrent;
	var schedulerTracing_development_5 = schedulerTracing_development.unstable_getThreadID;
	var schedulerTracing_development_6 = schedulerTracing_development.unstable_trace;
	var schedulerTracing_development_7 = schedulerTracing_development.unstable_wrap;
	var schedulerTracing_development_8 = schedulerTracing_development.unstable_subscribe;
	var schedulerTracing_development_9 = schedulerTracing_development.unstable_unsubscribe;

	var tracing = createCommonjsModule(function (module) {

	{
	  module.exports = schedulerTracing_development;
	}
	});

	var reactDom_development = createCommonjsModule(function (module) {



	{
	  (function() {

	var React = react;
	var _assign = objectAssign;
	var checkPropTypes = checkPropTypes_1;
	var scheduler$1 = scheduler;
	var tracing$1 = tracing;

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var validateFormat = function () {};

	{
	  validateFormat = function (format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}

	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);

	  if (!condition) {
	    var error = void 0;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	// Relying on the `invariant()` implementation lets us
	// preserve the format and params in the www builds.

	!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;

	var invokeGuardedCallbackImpl = function (name, func, context, a, b, c, d, e, f) {
	  var funcArgs = Array.prototype.slice.call(arguments, 3);
	  try {
	    func.apply(context, funcArgs);
	  } catch (error) {
	    this.onError(error);
	  }
	};

	{
	  // In DEV mode, we swap out invokeGuardedCallback for a special version
	  // that plays more nicely with the browser's DevTools. The idea is to preserve
	  // "Pause on exceptions" behavior. Because React wraps all user-provided
	  // functions in invokeGuardedCallback, and the production version of
	  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
	  // like caught exceptions, and the DevTools won't pause unless the developer
	  // takes the extra step of enabling pause on caught exceptions. This is
	  // unintuitive, though, because even though React has caught the error, from
	  // the developer's perspective, the error is uncaught.
	  //
	  // To preserve the expected "Pause on exceptions" behavior, we don't use a
	  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
	  // DOM node, and call the user-provided callback from inside an event handler
	  // for that fake event. If the callback throws, the error is "captured" using
	  // a global event handler. But because the error happens in a different
	  // event loop context, it does not interrupt the normal program flow.
	  // Effectively, this gives us try-catch behavior without actually using
	  // try-catch. Neat!

	  // Check that the browser supports the APIs we need to implement our special
	  // DEV version of invokeGuardedCallback
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');

	    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {
	      // If document doesn't exist we know for sure we will crash in this method
	      // when we call document.createEvent(). However this can cause confusing
	      // errors: https://github.com/facebookincubator/create-react-app/issues/3482
	      // So we preemptively throw with a better message instead.
	      !(typeof document !== 'undefined') ? invariant(false, 'The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.') : void 0;
	      var evt = document.createEvent('Event');

	      // Keeps track of whether the user-provided callback threw an error. We
	      // set this to true at the beginning, then set it to false right after
	      // calling the function. If the function errors, `didError` will never be
	      // set to false. This strategy works even if the browser is flaky and
	      // fails to call our global error handler, because it doesn't rely on
	      // the error event at all.
	      var didError = true;

	      // Keeps track of the value of window.event so that we can reset it
	      // during the callback to let user code access window.event in the
	      // browsers that support it.
	      var windowEvent = window.event;

	      // Keeps track of the descriptor of window.event to restore it after event
	      // dispatching: https://github.com/facebook/react/issues/13688
	      var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');

	      // Create an event handler for our fake event. We will synchronously
	      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
	      // call the user-provided callback.
	      var funcArgs = Array.prototype.slice.call(arguments, 3);
	      function callCallback() {
	        // We immediately remove the callback from event listeners so that
	        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
	        // nested call would trigger the fake event handlers of any call higher
	        // in the stack.
	        fakeNode.removeEventListener(evtType, callCallback, false);

	        // We check for window.hasOwnProperty('event') to prevent the
	        // window.event assignment in both IE <= 10 as they throw an error
	        // "Member not found" in strict mode, and in Firefox which does not
	        // support window.event.
	        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {
	          window.event = windowEvent;
	        }

	        func.apply(context, funcArgs);
	        didError = false;
	      }

	      // Create a global error event handler. We use this to capture the value
	      // that was thrown. It's possible that this error handler will fire more
	      // than once; for example, if non-React code also calls `dispatchEvent`
	      // and a handler for that event throws. We should be resilient to most of
	      // those cases. Even if our error event handler fires more than once, the
	      // last error event is always used. If the callback actually does error,
	      // we know that the last error event is the correct one, because it's not
	      // possible for anything else to have happened in between our callback
	      // erroring and the code that follows the `dispatchEvent` call below. If
	      // the callback doesn't error, but the error event was fired, we know to
	      // ignore it because `didError` will be false, as described above.
	      var error = void 0;
	      // Use this to track whether the error event is ever called.
	      var didSetError = false;
	      var isCrossOriginError = false;

	      function handleWindowError(event) {
	        error = event.error;
	        didSetError = true;
	        if (error === null && event.colno === 0 && event.lineno === 0) {
	          isCrossOriginError = true;
	        }
	        if (event.defaultPrevented) {
	          // Some other error handler has prevented default.
	          // Browsers silence the error report if this happens.
	          // We'll remember this to later decide whether to log it or not.
	          if (error != null && typeof error === 'object') {
	            try {
	              error._suppressLogging = true;
	            } catch (inner) {
	              // Ignore.
	            }
	          }
	        }
	      }

	      // Create a fake event type.
	      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');

	      // Attach our event handlers
	      window.addEventListener('error', handleWindowError);
	      fakeNode.addEventListener(evtType, callCallback, false);

	      // Synchronously dispatch our fake event. If the user-provided function
	      // errors, it will trigger our global error handler.
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);

	      if (windowEventDescriptor) {
	        Object.defineProperty(window, 'event', windowEventDescriptor);
	      }

	      if (didError) {
	        if (!didSetError) {
	          // The callback errored, but the error event never fired.
	          error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
	        } else if (isCrossOriginError) {
	          error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');
	        }
	        this.onError(error);
	      }

	      // Remove our event listeners
	      window.removeEventListener('error', handleWindowError);
	    };

	    invokeGuardedCallbackImpl = invokeGuardedCallbackDev;
	  }
	}

	var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;

	// Used by Fiber to simulate a try-catch.
	var hasError = false;
	var caughtError = null;

	// Used by event system to capture/rethrow the first error.
	var hasRethrowError = false;
	var rethrowError = null;

	var reporter = {
	  onError: function (error) {
	    hasError = true;
	    caughtError = error;
	  }
	};

	/**
	 * Call a function while guarding against errors that happens within it.
	 * Returns an error if it throws, otherwise null.
	 *
	 * In production, this is implemented using a try-catch. The reason we don't
	 * use a try-catch directly is so that we can swap out a different
	 * implementation in DEV mode.
	 *
	 * @param {String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} context The context to use when calling the function
	 * @param {...*} args Arguments for function
	 */
	function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
	  hasError = false;
	  caughtError = null;
	  invokeGuardedCallbackImpl$1.apply(reporter, arguments);
	}

	/**
	 * Same as invokeGuardedCallback, but instead of returning an error, it stores
	 * it in a global so it can be rethrown by `rethrowCaughtError` later.
	 * TODO: See if caughtError and rethrowError can be unified.
	 *
	 * @param {String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} context The context to use when calling the function
	 * @param {...*} args Arguments for function
	 */
	function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
	  invokeGuardedCallback.apply(this, arguments);
	  if (hasError) {
	    var error = clearCaughtError();
	    if (!hasRethrowError) {
	      hasRethrowError = true;
	      rethrowError = error;
	    }
	  }
	}

	/**
	 * During execution of guarded functions we will capture the first error which
	 * we will rethrow to be handled by the top level error handler.
	 */
	function rethrowCaughtError() {
	  if (hasRethrowError) {
	    var error = rethrowError;
	    hasRethrowError = false;
	    rethrowError = null;
	    throw error;
	  }
	}

	function hasCaughtError() {
	  return hasError;
	}

	function clearCaughtError() {
	  if (hasError) {
	    var error = caughtError;
	    hasError = false;
	    caughtError = null;
	    return error;
	  } else {
	    invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');
	  }
	}

	/**
	 * Injectable ordering of event plugins.
	 */
	var eventPluginOrder = null;

	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};

	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!eventPluginOrder) {
	    // Wait until an `eventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var pluginModule = namesToPlugins[pluginName];
	    var pluginIndex = eventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;
	    if (plugins[pluginIndex]) {
	      continue;
	    }
	    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;
	    plugins[pluginIndex] = pluginModule;
	    var publishedEvents = pluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;
	    }
	  }
	}

	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
	  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;
	  eventNameDispatchConfigs[eventName] = dispatchConfig;

	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
	    return true;
	  }
	  return false;
	}

	/**
	 * Publishes a registration name that is used to identify dispatched events.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, pluginModule, eventName) {
	  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;
	  registrationNameModules[registrationName] = pluginModule;
	  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

	  {
	    var lowerCasedName = registrationName.toLowerCase();
	    possibleRegistrationNames[lowerCasedName] = registrationName;

	    if (registrationName === 'onDoubleClick') {
	      possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}

	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */

	/**
	 * Ordered list of injected plugins.
	 */
	var plugins = [];

	/**
	 * Mapping from event name to dispatch config
	 */
	var eventNameDispatchConfigs = {};

	/**
	 * Mapping from registration name to plugin module
	 */
	var registrationNameModules = {};

	/**
	 * Mapping from registration name to event name
	 */
	var registrationNameDependencies = {};

	/**
	 * Mapping from lowercase registration names to the properly cased version,
	 * used to warn in the case of missing event handlers. Available
	 * only in true.
	 * @type {Object}
	 */
	var possibleRegistrationNames = {};
	// Trust the developer to only use possibleRegistrationNames in true

	/**
	 * Injects an ordering of plugins (by plugin name). This allows the ordering
	 * to be decoupled from injection of the actual plugins so that ordering is
	 * always deterministic regardless of packaging, on-the-fly injection, etc.
	 *
	 * @param {array} InjectedEventPluginOrder
	 * @internal
	 * @see {EventPluginHub.injection.injectEventPluginOrder}
	 */
	function injectEventPluginOrder(injectedEventPluginOrder) {
	  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;
	  // Clone the ordering so it cannot be dynamically mutated.
	  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
	  recomputePluginOrdering();
	}

	/**
	 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	 * in the ordering injected by `injectEventPluginOrder`.
	 *
	 * Plugins can be injected as part of page initialization or on-the-fly.
	 *
	 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	 * @internal
	 * @see {EventPluginHub.injection.injectEventPluginsByName}
	 */
	function injectEventPluginsByName(injectedNamesToPlugins) {
	  var isOrderingDirty = false;
	  for (var pluginName in injectedNamesToPlugins) {
	    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	      continue;
	    }
	    var pluginModule = injectedNamesToPlugins[pluginName];
	    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
	      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;
	      namesToPlugins[pluginName] = pluginModule;
	      isOrderingDirty = true;
	    }
	  }
	  if (isOrderingDirty) {
	    recomputePluginOrdering();
	  }
	}

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warningWithoutStack = function () {};

	{
	  warningWithoutStack = function (condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }

	    if (format === undefined) {
	      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	    if (args.length > 8) {
	      // Check before the condition to catch violations early.
	      throw new Error('warningWithoutStack() currently supports at most 8 arguments.');
	    }
	    if (condition) {
	      return;
	    }
	    if (typeof console !== 'undefined') {
	      var argsWithFormat = args.map(function (item) {
	        return '' + item;
	      });
	      argsWithFormat.unshift('Warning: ' + format);

	      // We intentionally don't use spread (or .apply) directly because it
	      // breaks IE9: https://github.com/facebook/react/issues/13610
	      Function.prototype.apply.call(console.error, console, argsWithFormat);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	var warningWithoutStack$1 = warningWithoutStack;

	var getFiberCurrentPropsFromNode = null;
	var getInstanceFromNode = null;
	var getNodeFromInstance = null;

	function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {
	  getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;
	  getInstanceFromNode = getInstanceFromNodeImpl;
	  getNodeFromInstance = getNodeFromInstanceImpl;
	  {
	    !(getNodeFromInstance && getInstanceFromNode) ? warningWithoutStack$1(false, 'EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	  }
	}

	var validateEventDispatches = void 0;
	{
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;

	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

	    !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}

	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = getNodeFromInstance(inst);
	  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
	  event.currentTarget = null;
	}

	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}

	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */


	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */


	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */

	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */

	function accumulateInto(current, next) {
	  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;

	  if (current == null) {
	    return next;
	  }

	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }

	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }

	  return [current, next];
	}

	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 * @param {function} cb Callback invoked with each element or a collection.
	 * @param {?} [scope] Scope used as `this` in a callback.
	 */
	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}

	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;

	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @private
	 */
	var executeDispatchesAndRelease = function (event) {
	  if (event) {
	    executeDispatchesInOrder(event);

	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e);
	};

	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}

	function shouldPreventMouseEvent(name, type, props) {
	  switch (name) {
	    case 'onClick':
	    case 'onClickCapture':
	    case 'onDoubleClick':
	    case 'onDoubleClickCapture':
	    case 'onMouseDown':
	    case 'onMouseDownCapture':
	    case 'onMouseMove':
	    case 'onMouseMoveCapture':
	    case 'onMouseUp':
	    case 'onMouseUpCapture':
	      return !!(props.disabled && isInteractive(type));
	    default:
	      return false;
	  }
	}

	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */

	/**
	 * Methods for injecting dependencies.
	 */
	var injection = {
	  /**
	   * @param {array} InjectedEventPluginOrder
	   * @public
	   */
	  injectEventPluginOrder: injectEventPluginOrder,

	  /**
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   */
	  injectEventPluginsByName: injectEventPluginsByName
	};

	/**
	 * @param {object} inst The instance, which is the source of events.
	 * @param {string} registrationName Name of listener (e.g. `onClick`).
	 * @return {?function} The stored callback.
	 */
	function getListener(inst, registrationName) {
	  var listener = void 0;

	  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
	  // live here; needs to be moved to a better place soon
	  var stateNode = inst.stateNode;
	  if (!stateNode) {
	    // Work in progress (ex: onload events in incremental mode).
	    return null;
	  }
	  var props = getFiberCurrentPropsFromNode(stateNode);
	  if (!props) {
	    // Work in progress.
	    return null;
	  }
	  listener = props[registrationName];
	  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
	    return null;
	  }
	  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;
	  return listener;
	}

	/**
	 * Allows registered plugins an opportunity to extract events from top-level
	 * native browser events.
	 *
	 * @return {*} An accumulation of synthetic events.
	 * @internal
	 */
	function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var events = null;
	  for (var i = 0; i < plugins.length; i++) {
	    // Not every plugin in the ordering may be loaded at runtime.
	    var possiblePlugin = plugins[i];
	    if (possiblePlugin) {
	      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	      if (extractedEvents) {
	        events = accumulateInto(events, extractedEvents);
	      }
	    }
	  }
	  return events;
	}

	function runEventsInBatch(events) {
	  if (events !== null) {
	    eventQueue = accumulateInto(eventQueue, events);
	  }

	  // Set `eventQueue` to null before processing it so that we can tell if more
	  // events get enqueued while processing.
	  var processingEventQueue = eventQueue;
	  eventQueue = null;

	  if (!processingEventQueue) {
	    return;
	  }

	  forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;
	  // This would be a good time to rethrow if any of the event handlers threw.
	  rethrowCaughtError();
	}

	function runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	  runEventsInBatch(events);
	}

	var FunctionComponent = 0;
	var ClassComponent = 1;
	var IndeterminateComponent = 2; // Before we know whether it is function or class
	var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
	var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
	var HostComponent = 5;
	var HostText = 6;
	var Fragment = 7;
	var Mode = 8;
	var ContextConsumer = 9;
	var ContextProvider = 10;
	var ForwardRef = 11;
	var Profiler = 12;
	var SuspenseComponent = 13;
	var MemoComponent = 14;
	var SimpleMemoComponent = 15;
	var LazyComponent = 16;
	var IncompleteClassComponent = 17;
	var DehydratedSuspenseComponent = 18;

	var randomKey = Math.random().toString(36).slice(2);
	var internalInstanceKey = '__reactInternalInstance$' + randomKey;
	var internalEventHandlersKey = '__reactEventHandlers$' + randomKey;

	function precacheFiberNode(hostInst, node) {
	  node[internalInstanceKey] = hostInst;
	}

	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }

	  while (!node[internalInstanceKey]) {
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }

	  var inst = node[internalInstanceKey];
	  if (inst.tag === HostComponent || inst.tag === HostText) {
	    // In Fiber, this will always be the deepest root.
	    return inst;
	  }

	  return null;
	}

	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode$1(node) {
	  var inst = node[internalInstanceKey];
	  if (inst) {
	    if (inst.tag === HostComponent || inst.tag === HostText) {
	      return inst;
	    } else {
	      return null;
	    }
	  }
	  return null;
	}

	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance$1(inst) {
	  if (inst.tag === HostComponent || inst.tag === HostText) {
	    // In Fiber this, is just the state node right now. We assume it will be
	    // a host component or host text.
	    return inst.stateNode;
	  }

	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  invariant(false, 'getNodeFromInstance: Invalid argument.');
	}

	function getFiberCurrentPropsFromNode$1(node) {
	  return node[internalEventHandlersKey] || null;
	}

	function updateFiberProps(node, props) {
	  node[internalEventHandlersKey] = props;
	}

	function getParent(inst) {
	  do {
	    inst = inst.return;
	    // TODO: If this is a HostRoot we might want to bail out.
	    // That is depending on if we want nested subtrees (layers) to bubble
	    // events to their parent. We could also go through parentNode on the
	    // host node but that wouldn't work for React Native and doesn't let us
	    // do the portal feature.
	  } while (inst && inst.tag !== HostComponent);
	  if (inst) {
	    return inst;
	  }
	  return null;
	}

	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = getParent(tempA)) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = getParent(tempB)) {
	    depthB++;
	  }

	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = getParent(instA);
	    depthA--;
	  }

	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = getParent(instB);
	    depthB--;
	  }

	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB || instA === instB.alternate) {
	      return instA;
	    }
	    instA = getParent(instA);
	    instB = getParent(instB);
	  }
	  return null;
	}

	/**
	 * Return if A is an ancestor of B.
	 */


	/**
	 * Return the parent instance of the passed-in instance.
	 */


	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = getParent(inst);
	  }
	  var i = void 0;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], 'captured', arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], 'bubbled', arg);
	  }
	}

	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (true) {
	    if (!from) {
	      break;
	    }
	    if (from === common) {
	      break;
	    }
	    var alternate = from.alternate;
	    if (alternate !== null && alternate === common) {
	      break;
	    }
	    pathFrom.push(from);
	    from = getParent(from);
	  }
	  var pathTo = [];
	  while (true) {
	    if (!to) {
	      break;
	    }
	    if (to === common) {
	      break;
	    }
	    var _alternate = to.alternate;
	    if (_alternate !== null && _alternate === common) {
	      break;
	    }
	    pathTo.push(to);
	    to = getParent(to);
	  }
	  for (var i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], 'bubbled', argFrom);
	  }
	  for (var _i = pathTo.length; _i-- > 0;) {
	    fn(pathTo[_i], 'captured', argTo);
	  }
	}

	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}

	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing even a
	 * single one.
	 */

	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, phase, event) {
	  {
	    !inst ? warningWithoutStack$1(false, 'Dispatching inst must not be null') : void 0;
	  }
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}

	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}

	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (inst && event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}

	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}

	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}



	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}

	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}

	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

	// Do not uses the below two methods directly!
	// Instead use constants exported from DOMTopLevelEventTypes in ReactDOM.
	// (It is the only module that is allowed to access these methods.)

	function unsafeCastStringToDOMTopLevelType(topLevelType) {
	  return topLevelType;
	}

	function unsafeCastDOMTopLevelTypeToString(topLevelType) {
	  return topLevelType;
	}

	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};

	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;

	  return prefixes;
	}

	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};

	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};

	/**
	 * Element to check for prefixes on.
	 */
	var style = {};

	/**
	 * Bootstrap if a DOM exists.
	 */
	if (canUseDOM) {
	  style = document.createElement('div').style;

	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }

	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}

	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }

	  var prefixMap = vendorPrefixes[eventName];

	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }

	  return eventName;
	}

	/**
	 * To identify top level events in ReactDOM, we use constants defined by this
	 * module. This is the only module that uses the unsafe* methods to express
	 * that the constants actually correspond to the browser event names. This lets
	 * us save some bundle size by avoiding a top level type -> event name map.
	 * The rest of ReactDOM code should import top level types from this file.
	 */
	var TOP_ABORT = unsafeCastStringToDOMTopLevelType('abort');
	var TOP_ANIMATION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationend'));
	var TOP_ANIMATION_ITERATION = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationiteration'));
	var TOP_ANIMATION_START = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationstart'));
	var TOP_BLUR = unsafeCastStringToDOMTopLevelType('blur');
	var TOP_CAN_PLAY = unsafeCastStringToDOMTopLevelType('canplay');
	var TOP_CAN_PLAY_THROUGH = unsafeCastStringToDOMTopLevelType('canplaythrough');
	var TOP_CANCEL = unsafeCastStringToDOMTopLevelType('cancel');
	var TOP_CHANGE = unsafeCastStringToDOMTopLevelType('change');
	var TOP_CLICK = unsafeCastStringToDOMTopLevelType('click');
	var TOP_CLOSE = unsafeCastStringToDOMTopLevelType('close');
	var TOP_COMPOSITION_END = unsafeCastStringToDOMTopLevelType('compositionend');
	var TOP_COMPOSITION_START = unsafeCastStringToDOMTopLevelType('compositionstart');
	var TOP_COMPOSITION_UPDATE = unsafeCastStringToDOMTopLevelType('compositionupdate');
	var TOP_CONTEXT_MENU = unsafeCastStringToDOMTopLevelType('contextmenu');
	var TOP_COPY = unsafeCastStringToDOMTopLevelType('copy');
	var TOP_CUT = unsafeCastStringToDOMTopLevelType('cut');
	var TOP_DOUBLE_CLICK = unsafeCastStringToDOMTopLevelType('dblclick');
	var TOP_AUX_CLICK = unsafeCastStringToDOMTopLevelType('auxclick');
	var TOP_DRAG = unsafeCastStringToDOMTopLevelType('drag');
	var TOP_DRAG_END = unsafeCastStringToDOMTopLevelType('dragend');
	var TOP_DRAG_ENTER = unsafeCastStringToDOMTopLevelType('dragenter');
	var TOP_DRAG_EXIT = unsafeCastStringToDOMTopLevelType('dragexit');
	var TOP_DRAG_LEAVE = unsafeCastStringToDOMTopLevelType('dragleave');
	var TOP_DRAG_OVER = unsafeCastStringToDOMTopLevelType('dragover');
	var TOP_DRAG_START = unsafeCastStringToDOMTopLevelType('dragstart');
	var TOP_DROP = unsafeCastStringToDOMTopLevelType('drop');
	var TOP_DURATION_CHANGE = unsafeCastStringToDOMTopLevelType('durationchange');
	var TOP_EMPTIED = unsafeCastStringToDOMTopLevelType('emptied');
	var TOP_ENCRYPTED = unsafeCastStringToDOMTopLevelType('encrypted');
	var TOP_ENDED = unsafeCastStringToDOMTopLevelType('ended');
	var TOP_ERROR = unsafeCastStringToDOMTopLevelType('error');
	var TOP_FOCUS = unsafeCastStringToDOMTopLevelType('focus');
	var TOP_GOT_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType('gotpointercapture');
	var TOP_INPUT = unsafeCastStringToDOMTopLevelType('input');
	var TOP_INVALID = unsafeCastStringToDOMTopLevelType('invalid');
	var TOP_KEY_DOWN = unsafeCastStringToDOMTopLevelType('keydown');
	var TOP_KEY_PRESS = unsafeCastStringToDOMTopLevelType('keypress');
	var TOP_KEY_UP = unsafeCastStringToDOMTopLevelType('keyup');
	var TOP_LOAD = unsafeCastStringToDOMTopLevelType('load');
	var TOP_LOAD_START = unsafeCastStringToDOMTopLevelType('loadstart');
	var TOP_LOADED_DATA = unsafeCastStringToDOMTopLevelType('loadeddata');
	var TOP_LOADED_METADATA = unsafeCastStringToDOMTopLevelType('loadedmetadata');
	var TOP_LOST_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType('lostpointercapture');
	var TOP_MOUSE_DOWN = unsafeCastStringToDOMTopLevelType('mousedown');
	var TOP_MOUSE_MOVE = unsafeCastStringToDOMTopLevelType('mousemove');
	var TOP_MOUSE_OUT = unsafeCastStringToDOMTopLevelType('mouseout');
	var TOP_MOUSE_OVER = unsafeCastStringToDOMTopLevelType('mouseover');
	var TOP_MOUSE_UP = unsafeCastStringToDOMTopLevelType('mouseup');
	var TOP_PASTE = unsafeCastStringToDOMTopLevelType('paste');
	var TOP_PAUSE = unsafeCastStringToDOMTopLevelType('pause');
	var TOP_PLAY = unsafeCastStringToDOMTopLevelType('play');
	var TOP_PLAYING = unsafeCastStringToDOMTopLevelType('playing');
	var TOP_POINTER_CANCEL = unsafeCastStringToDOMTopLevelType('pointercancel');
	var TOP_POINTER_DOWN = unsafeCastStringToDOMTopLevelType('pointerdown');


	var TOP_POINTER_MOVE = unsafeCastStringToDOMTopLevelType('pointermove');
	var TOP_POINTER_OUT = unsafeCastStringToDOMTopLevelType('pointerout');
	var TOP_POINTER_OVER = unsafeCastStringToDOMTopLevelType('pointerover');
	var TOP_POINTER_UP = unsafeCastStringToDOMTopLevelType('pointerup');
	var TOP_PROGRESS = unsafeCastStringToDOMTopLevelType('progress');
	var TOP_RATE_CHANGE = unsafeCastStringToDOMTopLevelType('ratechange');
	var TOP_RESET = unsafeCastStringToDOMTopLevelType('reset');
	var TOP_SCROLL = unsafeCastStringToDOMTopLevelType('scroll');
	var TOP_SEEKED = unsafeCastStringToDOMTopLevelType('seeked');
	var TOP_SEEKING = unsafeCastStringToDOMTopLevelType('seeking');
	var TOP_SELECTION_CHANGE = unsafeCastStringToDOMTopLevelType('selectionchange');
	var TOP_STALLED = unsafeCastStringToDOMTopLevelType('stalled');
	var TOP_SUBMIT = unsafeCastStringToDOMTopLevelType('submit');
	var TOP_SUSPEND = unsafeCastStringToDOMTopLevelType('suspend');
	var TOP_TEXT_INPUT = unsafeCastStringToDOMTopLevelType('textInput');
	var TOP_TIME_UPDATE = unsafeCastStringToDOMTopLevelType('timeupdate');
	var TOP_TOGGLE = unsafeCastStringToDOMTopLevelType('toggle');
	var TOP_TOUCH_CANCEL = unsafeCastStringToDOMTopLevelType('touchcancel');
	var TOP_TOUCH_END = unsafeCastStringToDOMTopLevelType('touchend');
	var TOP_TOUCH_MOVE = unsafeCastStringToDOMTopLevelType('touchmove');
	var TOP_TOUCH_START = unsafeCastStringToDOMTopLevelType('touchstart');
	var TOP_TRANSITION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('transitionend'));
	var TOP_VOLUME_CHANGE = unsafeCastStringToDOMTopLevelType('volumechange');
	var TOP_WAITING = unsafeCastStringToDOMTopLevelType('waiting');
	var TOP_WHEEL = unsafeCastStringToDOMTopLevelType('wheel');

	// List of events that need to be individually attached to media elements.
	// Note that events in this list will *not* be listened to at the top level
	// unless they're explicitly whitelisted in `ReactBrowserEventEmitter.listenTo`.
	var mediaEventTypes = [TOP_ABORT, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_VOLUME_CHANGE, TOP_WAITING];

	function getRawEventName(topLevelType) {
	  return unsafeCastDOMTopLevelTypeToString(topLevelType);
	}

	/**
	 * These variables store information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 *
	 */

	var root = null;
	var startText = null;
	var fallbackText = null;

	function initialize(nativeEventTarget) {
	  root = nativeEventTarget;
	  startText = getText();
	  return true;
	}

	function reset() {
	  root = null;
	  startText = null;
	  fallbackText = null;
	}

	function getData() {
	  if (fallbackText) {
	    return fallbackText;
	  }

	  var start = void 0;
	  var startValue = startText;
	  var startLength = startValue.length;
	  var end = void 0;
	  var endValue = getText();
	  var endLength = endValue.length;

	  for (start = 0; start < startLength; start++) {
	    if (startValue[start] !== endValue[start]) {
	      break;
	    }
	  }

	  var minEnd = startLength - start;
	  for (end = 1; end <= minEnd; end++) {
	    if (startValue[startLength - end] !== endValue[endLength - end]) {
	      break;
	    }
	  }

	  var sliceTail = end > 1 ? 1 - end : undefined;
	  fallbackText = endValue.slice(start, sliceTail);
	  return fallbackText;
	}

	function getText() {
	  if ('value' in root) {
	    return root.value;
	  }
	  return root.textContent;
	}

	/* eslint valid-typeof: 0 */

	var EVENT_POOL_SIZE = 10;

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: function () {
	    return null;
	  },
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};

	function functionThatReturnsTrue() {
	  return true;
	}

	function functionThatReturnsFalse() {
	  return false;
	}

	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	    delete this.isDefaultPrevented;
	    delete this.isPropagationStopped;
	  }

	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;

	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }

	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = functionThatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = functionThatReturnsFalse;
	  }
	  this.isPropagationStopped = functionThatReturnsFalse;
	  return this;
	}

	_assign(SyntheticEvent.prototype, {
	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }

	    if (event.preventDefault) {
	      event.preventDefault();
	    } else if (typeof event.returnValue !== 'unknown') {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = functionThatReturnsTrue;
	  },

	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }

	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }

	    this.isPropagationStopped = functionThatReturnsTrue;
	  },

	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = functionThatReturnsTrue;
	  },

	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: functionThatReturnsFalse,

	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      }
	    }
	    this.dispatchConfig = null;
	    this._targetInst = null;
	    this.nativeEvent = null;
	    this.isDefaultPrevented = functionThatReturnsFalse;
	    this.isPropagationStopped = functionThatReturnsFalse;
	    this._dispatchListeners = null;
	    this._dispatchInstances = null;
	    {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));
	      Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));
	    }
	  }
	});

	SyntheticEvent.Interface = EventInterface;

	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 */
	SyntheticEvent.extend = function (Interface) {
	  var Super = this;

	  var E = function () {};
	  E.prototype = Super.prototype;
	  var prototype = new E();

	  function Class() {
	    return Super.apply(this, arguments);
	  }
	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;

	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.extend = Super.extend;
	  addEventPoolingTo(Class);

	  return Class;
	};

	addEventPoolingTo(SyntheticEvent);

	/**
	 * Helper to nullify syntheticEvent instance properties when destructing
	 *
	 * @param {String} propName
	 * @param {?object} getVal
	 * @return {object} defineProperty object
	 */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };

	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }

	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }

	  function warn(action, result) {
	    warningWithoutStack$1(false, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);
	  }
	}

	function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
	  var EventConstructor = this;
	  if (EventConstructor.eventPool.length) {
	    var instance = EventConstructor.eventPool.pop();
	    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
	    return instance;
	  }
	  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
	}

	function releasePooledEvent(event) {
	  var EventConstructor = this;
	  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance into a pool of a different type.') : void 0;
	  event.destructor();
	  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
	    EventConstructor.eventPool.push(event);
	  }
	}

	function addEventPoolingTo(EventConstructor) {
	  EventConstructor.eventPool = [];
	  EventConstructor.getPooled = getPooledEvent;
	  EventConstructor.release = releasePooledEvent;
	}

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var SyntheticCompositionEvent = SyntheticEvent.extend({
	  data: null
	});

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var SyntheticInputEvent = SyntheticEvent.extend({
	  data: null
	});

	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;

	var canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;

	var documentMode = null;
	if (canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}

	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode;

	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: 'onBeforeInput',
	      captured: 'onBeforeInputCapture'
	    },
	    dependencies: [TOP_COMPOSITION_END, TOP_KEY_PRESS, TOP_TEXT_INPUT, TOP_PASTE]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionEnd',
	      captured: 'onCompositionEndCapture'
	    },
	    dependencies: [TOP_BLUR, TOP_COMPOSITION_END, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionStart',
	      captured: 'onCompositionStartCapture'
	    },
	    dependencies: [TOP_BLUR, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionUpdate',
	      captured: 'onCompositionUpdateCapture'
	    },
	    dependencies: [TOP_BLUR, TOP_COMPOSITION_UPDATE, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]
	  }
	};

	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;

	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}

	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case TOP_COMPOSITION_START:
	      return eventTypes.compositionStart;
	    case TOP_COMPOSITION_END:
	      return eventTypes.compositionEnd;
	    case TOP_COMPOSITION_UPDATE:
	      return eventTypes.compositionUpdate;
	  }
	}

	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === TOP_KEY_DOWN && nativeEvent.keyCode === START_KEYCODE;
	}

	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case TOP_KEY_UP:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case TOP_KEY_DOWN:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case TOP_KEY_PRESS:
	    case TOP_MOUSE_DOWN:
	    case TOP_BLUR:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}

	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}

	/**
	 * Check if a composition event was triggered by Korean IME.
	 * Our fallback mode does not work well with IE's Korean IME,
	 * so just use native composition events when Korean IME is used.
	 * Although CompositionEvent.locale property is deprecated,
	 * it is available in IE, where our fallback mode is enabled.
	 *
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isUsingKoreanIME(nativeEvent) {
	  return nativeEvent.locale === 'ko';
	}

	// Track the current IME composition status, if any.
	var isComposing = false;

	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType = void 0;
	  var fallbackData = void 0;

	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!isComposing) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }

	  if (!eventType) {
	    return null;
	  }

	  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!isComposing && eventType === eventTypes.compositionStart) {
	      isComposing = initialize(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (isComposing) {
	        fallbackData = getData();
	      }
	    }
	  }

	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }

	  accumulateTwoPhaseDispatches(event);
	  return event;
	}

	/**
	 * @param {TopLevelType} topLevelType Number from `TopLevelType`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case TOP_COMPOSITION_END:
	      return getDataFromCustomEvent(nativeEvent);
	    case TOP_KEY_PRESS:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }

	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;

	    case TOP_TEXT_INPUT:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;

	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to ignore it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }

	      return chars;

	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}

	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {number} topLevelType Number from `TopLevelEventTypes`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  // If composition event is available, we extract a string only at
	  // compositionevent, otherwise extract it at fallback events.
	  if (isComposing) {
	    if (topLevelType === TOP_COMPOSITION_END || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = getData();
	      reset();
	      isComposing = false;
	      return chars;
	    }
	    return null;
	  }

	  switch (topLevelType) {
	    case TOP_PASTE:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case TOP_KEY_PRESS:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (!isKeypressCommand(nativeEvent)) {
	        // IE fires the `keypress` event when a user types an emoji via
	        // Touch keyboard of Windows.  In such a case, the `char` property
	        // holds an emoji character like `\uD83D\uDE0A`.  Because its length
	        // is 2, the property `which` does not represent an emoji correctly.
	        // In such a case, we directly return the `char` property instead of
	        // using `which`.
	        if (nativeEvent.char && nativeEvent.char.length > 1) {
	          return nativeEvent.char;
	        } else if (nativeEvent.which) {
	          return String.fromCharCode(nativeEvent.which);
	        }
	      }
	      return null;
	    case TOP_COMPOSITION_END:
	      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}

	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars = void 0;

	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }

	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }

	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

	  event.data = chars;
	  accumulateTwoPhaseDispatches(event);
	  return event;
	}

	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	  eventTypes: eventTypes,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var composition = extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);

	    var beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);

	    if (composition === null) {
	      return beforeInput;
	    }

	    if (beforeInput === null) {
	      return composition;
	    }

	    return [composition, beforeInput];
	  }
	};

	// Use to restore controlled state after a change event has fired.

	var restoreImpl = null;
	var restoreTarget = null;
	var restoreQueue = null;

	function restoreStateOfTarget(target) {
	  // We perform this translation at the end of the event loop so that we
	  // always receive the correct fiber here
	  var internalInstance = getInstanceFromNode(target);
	  if (!internalInstance) {
	    // Unmounted
	    return;
	  }
	  !(typeof restoreImpl === 'function') ? invariant(false, 'setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
	  restoreImpl(internalInstance.stateNode, internalInstance.type, props);
	}

	function setRestoreImplementation(impl) {
	  restoreImpl = impl;
	}

	function enqueueStateRestore(target) {
	  if (restoreTarget) {
	    if (restoreQueue) {
	      restoreQueue.push(target);
	    } else {
	      restoreQueue = [target];
	    }
	  } else {
	    restoreTarget = target;
	  }
	}

	function needsStateRestore() {
	  return restoreTarget !== null || restoreQueue !== null;
	}

	function restoreStateIfNeeded() {
	  if (!restoreTarget) {
	    return;
	  }
	  var target = restoreTarget;
	  var queuedTargets = restoreQueue;
	  restoreTarget = null;
	  restoreQueue = null;

	  restoreStateOfTarget(target);
	  if (queuedTargets) {
	    for (var i = 0; i < queuedTargets.length; i++) {
	      restoreStateOfTarget(queuedTargets[i]);
	    }
	  }
	}

	// Used as a way to call batchedUpdates when we don't have a reference to
	// the renderer. Such as when we're dispatching events or if third party
	// libraries need to call batchedUpdates. Eventually, this API will go away when
	// everything is batched by default. We'll then have a similar API to opt-out of
	// scheduled work and instead do synchronous work.

	// Defaults
	var _batchedUpdatesImpl = function (fn, bookkeeping) {
	  return fn(bookkeeping);
	};
	var _interactiveUpdatesImpl = function (fn, a, b) {
	  return fn(a, b);
	};
	var _flushInteractiveUpdatesImpl = function () {};

	var isBatching = false;
	function batchedUpdates(fn, bookkeeping) {
	  if (isBatching) {
	    // If we are currently inside another batch, we need to wait until it
	    // fully completes before restoring state.
	    return fn(bookkeeping);
	  }
	  isBatching = true;
	  try {
	    return _batchedUpdatesImpl(fn, bookkeeping);
	  } finally {
	    // Here we wait until all updates have propagated, which is important
	    // when using controlled components within layers:
	    // https://github.com/facebook/react/issues/1698
	    // Then we restore state of any controlled component.
	    isBatching = false;
	    var controlledComponentsHavePendingUpdates = needsStateRestore();
	    if (controlledComponentsHavePendingUpdates) {
	      // If a controlled event was fired, we may need to restore the state of
	      // the DOM node back to the controlled value. This is necessary when React
	      // bails out of the update without touching the DOM.
	      _flushInteractiveUpdatesImpl();
	      restoreStateIfNeeded();
	    }
	  }
	}

	function interactiveUpdates(fn, a, b) {
	  return _interactiveUpdatesImpl(fn, a, b);
	}



	function setBatchingImplementation(batchedUpdatesImpl, interactiveUpdatesImpl, flushInteractiveUpdatesImpl) {
	  _batchedUpdatesImpl = batchedUpdatesImpl;
	  _interactiveUpdatesImpl = interactiveUpdatesImpl;
	  _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;
	}

	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	var supportedInputTypes = {
	  color: true,
	  date: true,
	  datetime: true,
	  'datetime-local': true,
	  email: true,
	  month: true,
	  number: true,
	  password: true,
	  range: true,
	  search: true,
	  tel: true,
	  text: true,
	  time: true,
	  url: true,
	  week: true
	};

	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }

	  if (nodeName === 'textarea') {
	    return true;
	  }

	  return false;
	}

	/**
	 * HTML nodeType values that represent the type of the node
	 */

	var ELEMENT_NODE = 1;
	var TEXT_NODE = 3;
	var COMMENT_NODE = 8;
	var DOCUMENT_NODE = 9;
	var DOCUMENT_FRAGMENT_NODE = 11;

	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	function getEventTarget(nativeEvent) {
	  // Fallback to nativeEvent.srcElement for IE9
	  // https://github.com/facebook/react/issues/12506
	  var target = nativeEvent.target || nativeEvent.srcElement || window;

	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }

	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === TEXT_NODE ? target.parentNode : target;
	}

	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix) {
	  if (!canUseDOM) {
	    return false;
	  }

	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;

	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }

	  return isSupported;
	}

	function isCheckable(elem) {
	  var type = elem.type;
	  var nodeName = elem.nodeName;
	  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
	}

	function getTracker(node) {
	  return node._valueTracker;
	}

	function detachTracker(node) {
	  node._valueTracker = null;
	}

	function getValueFromNode(node) {
	  var value = '';
	  if (!node) {
	    return value;
	  }

	  if (isCheckable(node)) {
	    value = node.checked ? 'true' : 'false';
	  } else {
	    value = node.value;
	  }

	  return value;
	}

	function trackValueOnNode(node) {
	  var valueField = isCheckable(node) ? 'checked' : 'value';
	  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

	  var currentValue = '' + node[valueField];

	  // if someone has already defined a value or Safari, then bail
	  // and don't track value will cause over reporting of changes,
	  // but it's better then a hard failure
	  // (needed for certain tests that spyOn input values and Safari)
	  if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
	    return;
	  }
	  var get = descriptor.get,
	      set = descriptor.set;

	  Object.defineProperty(node, valueField, {
	    configurable: true,
	    get: function () {
	      return get.call(this);
	    },
	    set: function (value) {
	      currentValue = '' + value;
	      set.call(this, value);
	    }
	  });
	  // We could've passed this the first time
	  // but it triggers a bug in IE11 and Edge 14/15.
	  // Calling defineProperty() again should be equivalent.
	  // https://github.com/facebook/react/issues/11768
	  Object.defineProperty(node, valueField, {
	    enumerable: descriptor.enumerable
	  });

	  var tracker = {
	    getValue: function () {
	      return currentValue;
	    },
	    setValue: function (value) {
	      currentValue = '' + value;
	    },
	    stopTracking: function () {
	      detachTracker(node);
	      delete node[valueField];
	    }
	  };
	  return tracker;
	}

	function track(node) {
	  if (getTracker(node)) {
	    return;
	  }

	  // TODO: Once it's just Fiber we can move this to node._wrapperState
	  node._valueTracker = trackValueOnNode(node);
	}

	function updateValueIfChanged(node) {
	  if (!node) {
	    return false;
	  }

	  var tracker = getTracker(node);
	  // if there is no tracker at this point it's unlikely
	  // that trying again will succeed
	  if (!tracker) {
	    return true;
	  }

	  var lastValue = tracker.getValue();
	  var nextValue = getValueFromNode(node);
	  if (nextValue !== lastValue) {
	    tracker.setValue(nextValue);
	    return true;
	  }
	  return false;
	}

	var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

	// Prevent newer renderers from RTE when used with older react package versions.
	// Current owner and dispatcher used to share the same ref,
	// but PR #14548 split them out to better support the react-debug-tools package.
	if (!ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher')) {
	  ReactSharedInternals.ReactCurrentDispatcher = {
	    current: null
	  };
	}

	var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

	var describeComponentFrame = function (name, source, ownerName) {
	  var sourceInfo = '';
	  if (source) {
	    var path = source.fileName;
	    var fileName = path.replace(BEFORE_SLASH_RE, '');
	    {
	      // In DEV, include code for a common special case:
	      // prefer "folder/index.js" instead of just "index.js".
	      if (/^index\./.test(fileName)) {
	        var match = path.match(BEFORE_SLASH_RE);
	        if (match) {
	          var pathBeforeSlash = match[1];
	          if (pathBeforeSlash) {
	            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
	            fileName = folderName + '/' + fileName;
	          }
	        }
	      }
	    }
	    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
	  } else if (ownerName) {
	    sourceInfo = ' (created by ' + ownerName + ')';
	  }
	  return '\n    in ' + (name || 'Unknown') + sourceInfo;
	};

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;

	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;

	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;

	var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator';

	function getIteratorFn(maybeIterable) {
	  if (maybeIterable === null || typeof maybeIterable !== 'object') {
	    return null;
	  }
	  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
	  if (typeof maybeIterator === 'function') {
	    return maybeIterator;
	  }
	  return null;
	}

	var Pending = 0;
	var Resolved = 1;
	var Rejected = 2;

	function refineResolvedLazyComponent(lazyComponent) {
	  return lazyComponent._status === Resolved ? lazyComponent._result : null;
	}

	function getWrappedName(outerType, innerType, wrapperName) {
	  var functionName = innerType.displayName || innerType.name || '';
	  return outerType.displayName || (functionName !== '' ? wrapperName + '(' + functionName + ')' : wrapperName);
	}

	function getComponentName(type) {
	  if (type == null) {
	    // Host root, text node or just invalid type.
	    return null;
	  }
	  {
	    if (typeof type.tag === 'number') {
	      warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
	    }
	  }
	  if (typeof type === 'function') {
	    return type.displayName || type.name || null;
	  }
	  if (typeof type === 'string') {
	    return type;
	  }
	  switch (type) {
	    case REACT_CONCURRENT_MODE_TYPE:
	      return 'ConcurrentMode';
	    case REACT_FRAGMENT_TYPE:
	      return 'Fragment';
	    case REACT_PORTAL_TYPE:
	      return 'Portal';
	    case REACT_PROFILER_TYPE:
	      return 'Profiler';
	    case REACT_STRICT_MODE_TYPE:
	      return 'StrictMode';
	    case REACT_SUSPENSE_TYPE:
	      return 'Suspense';
	  }
	  if (typeof type === 'object') {
	    switch (type.$$typeof) {
	      case REACT_CONTEXT_TYPE:
	        return 'Context.Consumer';
	      case REACT_PROVIDER_TYPE:
	        return 'Context.Provider';
	      case REACT_FORWARD_REF_TYPE:
	        return getWrappedName(type, type.render, 'ForwardRef');
	      case REACT_MEMO_TYPE:
	        return getComponentName(type.type);
	      case REACT_LAZY_TYPE:
	        {
	          var thenable = type;
	          var resolvedThenable = refineResolvedLazyComponent(thenable);
	          if (resolvedThenable) {
	            return getComponentName(resolvedThenable);
	          }
	        }
	    }
	  }
	  return null;
	}

	var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

	function describeFiber(fiber) {
	  switch (fiber.tag) {
	    case HostRoot:
	    case HostPortal:
	    case HostText:
	    case Fragment:
	    case ContextProvider:
	    case ContextConsumer:
	      return '';
	    default:
	      var owner = fiber._debugOwner;
	      var source = fiber._debugSource;
	      var name = getComponentName(fiber.type);
	      var ownerName = null;
	      if (owner) {
	        ownerName = getComponentName(owner.type);
	      }
	      return describeComponentFrame(name, source, ownerName);
	  }
	}

	function getStackByFiberInDevAndProd(workInProgress) {
	  var info = '';
	  var node = workInProgress;
	  do {
	    info += describeFiber(node);
	    node = node.return;
	  } while (node);
	  return info;
	}

	var current = null;
	var phase = null;

	function getCurrentFiberOwnerNameInDevOrNull() {
	  {
	    if (current === null) {
	      return null;
	    }
	    var owner = current._debugOwner;
	    if (owner !== null && typeof owner !== 'undefined') {
	      return getComponentName(owner.type);
	    }
	  }
	  return null;
	}

	function getCurrentFiberStackInDev() {
	  {
	    if (current === null) {
	      return '';
	    }
	    // Safe because if current fiber exists, we are reconciling,
	    // and it is guaranteed to be the work-in-progress version.
	    return getStackByFiberInDevAndProd(current);
	  }
	  return '';
	}

	function resetCurrentFiber() {
	  {
	    ReactDebugCurrentFrame.getCurrentStack = null;
	    current = null;
	    phase = null;
	  }
	}

	function setCurrentFiber(fiber) {
	  {
	    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
	    current = fiber;
	    phase = null;
	  }
	}

	function setCurrentPhase(lifeCyclePhase) {
	  {
	    phase = lifeCyclePhase;
	  }
	}

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = warningWithoutStack$1;

	{
	  warning = function (condition, format) {
	    if (condition) {
	      return;
	    }
	    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
	    var stack = ReactDebugCurrentFrame.getStackAddendum();
	    // eslint-disable-next-line react-internal/warning-and-invariant-args

	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }

	    warningWithoutStack$1.apply(undefined, [false, format + '%s'].concat(args, [stack]));
	  };
	}

	var warning$1 = warning;

	// A reserved attribute.
	// It is handled by React separately and shouldn't be written to the DOM.
	var RESERVED = 0;

	// A simple string attribute.
	// Attributes that aren't in the whitelist are presumed to have this type.
	var STRING = 1;

	// A string attribute that accepts booleans in React. In HTML, these are called
	// "enumerated" attributes with "true" and "false" as possible values.
	// When true, it should be set to a "true" string.
	// When false, it should be set to a "false" string.
	var BOOLEANISH_STRING = 2;

	// A real boolean attribute.
	// When true, it should be present (set either to an empty string or its name).
	// When false, it should be omitted.
	var BOOLEAN = 3;

	// An attribute that can be used as a flag as well as with a value.
	// When true, it should be present (set either to an empty string or its name).
	// When false, it should be omitted.
	// For any other value, should be present with that value.
	var OVERLOADED_BOOLEAN = 4;

	// An attribute that must be numeric or parse as a numeric.
	// When falsy, it should be removed.
	var NUMERIC = 5;

	// An attribute that must be positive numeric or parse as a positive numeric.
	// When falsy, it should be removed.
	var POSITIVE_NUMERIC = 6;

	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */
	var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';


	var ROOT_ATTRIBUTE_NAME = 'data-reactroot';
	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};

	function isAttributeNameSafe(attributeName) {
	  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
	    return true;
	  }
	  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  {
	    warning$1(false, 'Invalid attribute name: `%s`', attributeName);
	  }
	  return false;
	}

	function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
	  if (propertyInfo !== null) {
	    return propertyInfo.type === RESERVED;
	  }
	  if (isCustomComponentTag) {
	    return false;
	  }
	  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
	    return true;
	  }
	  return false;
	}

	function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
	  if (propertyInfo !== null && propertyInfo.type === RESERVED) {
	    return false;
	  }
	  switch (typeof value) {
	    case 'function':
	    // $FlowIssue symbol is perfectly valid here
	    case 'symbol':
	      // eslint-disable-line
	      return true;
	    case 'boolean':
	      {
	        if (isCustomComponentTag) {
	          return false;
	        }
	        if (propertyInfo !== null) {
	          return !propertyInfo.acceptsBooleans;
	        } else {
	          var prefix = name.toLowerCase().slice(0, 5);
	          return prefix !== 'data-' && prefix !== 'aria-';
	        }
	      }
	    default:
	      return false;
	  }
	}

	function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
	  if (value === null || typeof value === 'undefined') {
	    return true;
	  }
	  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
	    return true;
	  }
	  if (isCustomComponentTag) {
	    return false;
	  }
	  if (propertyInfo !== null) {
	    switch (propertyInfo.type) {
	      case BOOLEAN:
	        return !value;
	      case OVERLOADED_BOOLEAN:
	        return value === false;
	      case NUMERIC:
	        return isNaN(value);
	      case POSITIVE_NUMERIC:
	        return isNaN(value) || value < 1;
	    }
	  }
	  return false;
	}

	function getPropertyInfo(name) {
	  return properties.hasOwnProperty(name) ? properties[name] : null;
	}

	function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace) {
	  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
	  this.attributeName = attributeName;
	  this.attributeNamespace = attributeNamespace;
	  this.mustUseProperty = mustUseProperty;
	  this.propertyName = name;
	  this.type = type;
	}

	// When adding attributes to this list, be sure to also add them to
	// the `possibleStandardNames` module to ensure casing and incorrect
	// name warnings.
	var properties = {};

	// These props are reserved by React. They shouldn't be written to the DOM.
	['children', 'dangerouslySetInnerHTML',
	// TODO: This prevents the assignment of defaultValue to regular
	// elements (not just inputs). Now that ReactDOMInput assigns to the
	// defaultValue property -- do we need this?
	'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'].forEach(function (name) {
	  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
	  name, // attributeName
	  null);
	} // attributeNamespace
	);

	// A few React string attributes have a different name.
	// This is a mapping from React prop names to the attribute names.
	[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
	  var name = _ref[0],
	      attributeName = _ref[1];

	  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
	  attributeName, // attributeName
	  null);
	} // attributeNamespace
	);

	// These are "enumerated" HTML attributes that accept "true" and "false".
	// In React, we let users pass `true` and `false` even though technically
	// these aren't boolean attributes (they are coerced to strings).
	['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
	  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
	  name.toLowerCase(), // attributeName
	  null);
	} // attributeNamespace
	);

	// These are "enumerated" SVG attributes that accept "true" and "false".
	// In React, we let users pass `true` and `false` even though technically
	// these aren't boolean attributes (they are coerced to strings).
	// Since these are SVG attributes, their attribute names are case-sensitive.
	['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
	  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
	  name, // attributeName
	  null);
	} // attributeNamespace
	);

	// These are HTML boolean attributes.
	['allowFullScreen', 'async',
	// Note: there is a special case that prevents it from being written to the DOM
	// on the client side because the browsers are inconsistent. Instead we call focus().
	'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless',
	// Microdata
	'itemScope'].forEach(function (name) {
	  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
	  name.toLowerCase(), // attributeName
	  null);
	} // attributeNamespace
	);

	// These are the few React props that we set as DOM properties
	// rather than attributes. These are all booleans.
	['checked',
	// Note: `option.selected` is not updated if `select.multiple` is
	// disabled with `removeAttribute`. We have special logic for handling this.
	'multiple', 'muted', 'selected'].forEach(function (name) {
	  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
	  name, // attributeName
	  null);
	} // attributeNamespace
	);

	// These are HTML attributes that are "overloaded booleans": they behave like
	// booleans, but can also accept a string value.
	['capture', 'download'].forEach(function (name) {
	  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
	  name, // attributeName
	  null);
	} // attributeNamespace
	);

	// These are HTML attributes that must be positive numbers.
	['cols', 'rows', 'size', 'span'].forEach(function (name) {
	  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
	  name, // attributeName
	  null);
	} // attributeNamespace
	);

	// These are HTML attributes that must be numbers.
	['rowSpan', 'start'].forEach(function (name) {
	  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
	  name.toLowerCase(), // attributeName
	  null);
	} // attributeNamespace
	);

	var CAMELIZE = /[\-\:]([a-z])/g;
	var capitalize = function (token) {
	  return token[1].toUpperCase();
	};

	// This is a list of all SVG attributes that need special casing, namespacing,
	// or boolean value assignment. Regular attributes that just accept strings
	// and have the same names are omitted, just like in the HTML whitelist.
	// Some of these attributes can be hard to find. This list was created by
	// scrapping the MDN documentation.
	['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height'].forEach(function (attributeName) {
	  var name = attributeName.replace(CAMELIZE, capitalize);
	  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
	  attributeName, null);
	} // attributeNamespace
	);

	// String SVG attributes with the xlink namespace.
	['xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type'].forEach(function (attributeName) {
	  var name = attributeName.replace(CAMELIZE, capitalize);
	  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
	  attributeName, 'http://www.w3.org/1999/xlink');
	});

	// String SVG attributes with the xml namespace.
	['xml:base', 'xml:lang', 'xml:space'].forEach(function (attributeName) {
	  var name = attributeName.replace(CAMELIZE, capitalize);
	  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
	  attributeName, 'http://www.w3.org/XML/1998/namespace');
	});

	// These attribute exists both in HTML and SVG.
	// The attribute name is case-sensitive in SVG so we can't just use
	// the React name like we do for attributes that exist only in HTML.
	['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
	  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
	  attributeName.toLowerCase(), // attributeName
	  null);
	} // attributeNamespace
	);

	/**
	 * Get the value for a property on a node. Only used in DEV for SSR validation.
	 * The "expected" argument is used as a hint of what the expected value is.
	 * Some properties have multiple equivalent values.
	 */
	function getValueForProperty(node, name, expected, propertyInfo) {
	  {
	    if (propertyInfo.mustUseProperty) {
	      var propertyName = propertyInfo.propertyName;

	      return node[propertyName];
	    } else {
	      var attributeName = propertyInfo.attributeName;

	      var stringValue = null;

	      if (propertyInfo.type === OVERLOADED_BOOLEAN) {
	        if (node.hasAttribute(attributeName)) {
	          var value = node.getAttribute(attributeName);
	          if (value === '') {
	            return true;
	          }
	          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
	            return value;
	          }
	          if (value === '' + expected) {
	            return expected;
	          }
	          return value;
	        }
	      } else if (node.hasAttribute(attributeName)) {
	        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
	          // We had an attribute but shouldn't have had one, so read it
	          // for the error message.
	          return node.getAttribute(attributeName);
	        }
	        if (propertyInfo.type === BOOLEAN) {
	          // If this was a boolean, it doesn't matter what the value is
	          // the fact that we have it is the same as the expected.
	          return expected;
	        }
	        // Even if this property uses a namespace we use getAttribute
	        // because we assume its namespaced name is the same as our config.
	        // To use getAttributeNS we need the local name which we don't have
	        // in our config atm.
	        stringValue = node.getAttribute(attributeName);
	      }

	      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
	        return stringValue === null ? expected : stringValue;
	      } else if (stringValue === '' + expected) {
	        return expected;
	      } else {
	        return stringValue;
	      }
	    }
	  }
	}

	/**
	 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
	 * The third argument is used as a hint of what the expected value is. Some
	 * attributes have multiple equivalent values.
	 */
	function getValueForAttribute(node, name, expected) {
	  {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (!node.hasAttribute(name)) {
	      return expected === undefined ? undefined : null;
	    }
	    var value = node.getAttribute(name);
	    if (value === '' + expected) {
	      return expected;
	    }
	    return value;
	  }
	}

	/**
	 * Sets the value for a property on a node.
	 *
	 * @param {DOMElement} node
	 * @param {string} name
	 * @param {*} value
	 */
	function setValueForProperty(node, name, value, isCustomComponentTag) {
	  var propertyInfo = getPropertyInfo(name);
	  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
	    return;
	  }
	  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
	    value = null;
	  }
	  // If the prop isn't in the special list, treat it as a simple attribute.
	  if (isCustomComponentTag || propertyInfo === null) {
	    if (isAttributeNameSafe(name)) {
	      var _attributeName = name;
	      if (value === null) {
	        node.removeAttribute(_attributeName);
	      } else {
	        node.setAttribute(_attributeName, '' + value);
	      }
	    }
	    return;
	  }
	  var mustUseProperty = propertyInfo.mustUseProperty;

	  if (mustUseProperty) {
	    var propertyName = propertyInfo.propertyName;

	    if (value === null) {
	      var type = propertyInfo.type;

	      node[propertyName] = type === BOOLEAN ? false : '';
	    } else {
	      // Contrary to `setAttribute`, object properties are properly
	      // `toString`ed by IE8/9.
	      node[propertyName] = value;
	    }
	    return;
	  }
	  // The rest are treated as attributes with special cases.
	  var attributeName = propertyInfo.attributeName,
	      attributeNamespace = propertyInfo.attributeNamespace;

	  if (value === null) {
	    node.removeAttribute(attributeName);
	  } else {
	    var _type = propertyInfo.type;

	    var attributeValue = void 0;
	    if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
	      attributeValue = '';
	    } else {
	      // `setAttribute` with objects becomes only `[object]` in IE8/9,
	      // ('' + value) makes it output the correct toString()-value.
	      attributeValue = '' + value;
	    }
	    if (attributeNamespace) {
	      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
	    } else {
	      node.setAttribute(attributeName, attributeValue);
	    }
	  }
	}

	// Flow does not allow string concatenation of most non-string types. To work
	// around this limitation, we use an opaque type that can only be obtained by
	// passing the value through getToStringValue first.
	function toString(value) {
	  return '' + value;
	}

	function getToStringValue(value) {
	  switch (typeof value) {
	    case 'boolean':
	    case 'number':
	    case 'object':
	    case 'string':
	    case 'undefined':
	      return value;
	    default:
	      // function, symbol are assigned as empty strings
	      return '';
	  }
	}

	var ReactDebugCurrentFrame$1 = null;

	var ReactControlledValuePropTypes = {
	  checkPropTypes: null
	};

	{
	  ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

	  var hasReadOnlyValue = {
	    button: true,
	    checkbox: true,
	    image: true,
	    hidden: true,
	    radio: true,
	    reset: true,
	    submit: true
	  };

	  var propTypes = {
	    value: function (props, propName, componentName) {
	      if (hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled || props[propName] == null) {
	        return null;
	      }
	      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	    },
	    checked: function (props, propName, componentName) {
	      if (props.onChange || props.readOnly || props.disabled || props[propName] == null) {
	        return null;
	      }
	      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	    }
	  };

	  /**
	   * Provide a linked `value` attribute for controlled forms. You should not use
	   * this outside of the ReactDOM controlled form components.
	   */
	  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props) {
	    checkPropTypes(propTypes, props, 'prop', tagName, ReactDebugCurrentFrame$1.getStackAddendum);
	  };
	}

	// Only used in www builds.
	var enableSuspenseServerRenderer = false; // TODO: true? Here it might just be false.

	// TODO: direct imports like some-package/src/* are bad. Fix me.
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;

	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked != null : props.value != null;
	}

	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */

	function getHostProps(element, props) {
	  var node = element;
	  var checked = props.checked;

	  var hostProps = _assign({}, props, {
	    defaultChecked: undefined,
	    defaultValue: undefined,
	    value: undefined,
	    checked: checked != null ? checked : node._wrapperState.initialChecked
	  });

	  return hostProps;
	}

	function initWrapperState(element, props) {
	  {
	    ReactControlledValuePropTypes.checkPropTypes('input', props);

	    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	      warning$1(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);
	      didWarnCheckedDefaultChecked = true;
	    }
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	      warning$1(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);
	      didWarnValueDefaultValue = true;
	    }
	  }

	  var node = element;
	  var defaultValue = props.defaultValue == null ? '' : props.defaultValue;

	  node._wrapperState = {
	    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	    initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
	    controlled: isControlled(props)
	  };
	}

	function updateChecked(element, props) {
	  var node = element;
	  var checked = props.checked;
	  if (checked != null) {
	    setValueForProperty(node, 'checked', checked, false);
	  }
	}

	function updateWrapper(element, props) {
	  var node = element;
	  {
	    var _controlled = isControlled(props);

	    if (!node._wrapperState.controlled && _controlled && !didWarnUncontrolledToControlled) {
	      warning$1(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', props.type);
	      didWarnUncontrolledToControlled = true;
	    }
	    if (node._wrapperState.controlled && !_controlled && !didWarnControlledToUncontrolled) {
	      warning$1(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', props.type);
	      didWarnControlledToUncontrolled = true;
	    }
	  }

	  updateChecked(element, props);

	  var value = getToStringValue(props.value);
	  var type = props.type;

	  if (value != null) {
	    if (type === 'number') {
	      if (value === 0 && node.value === '' ||
	      // We explicitly want to coerce to number here if possible.
	      // eslint-disable-next-line
	      node.value != value) {
	        node.value = toString(value);
	      }
	    } else if (node.value !== toString(value)) {
	      node.value = toString(value);
	    }
	  } else if (type === 'submit' || type === 'reset') {
	    // Submit/reset inputs need the attribute removed completely to avoid
	    // blank-text buttons.
	    node.removeAttribute('value');
	    return;
	  }

	  {
	    // When syncing the value attribute, the value comes from a cascade of
	    // properties:
	    //  1. The value React property
	    //  2. The defaultValue React property
	    //  3. Otherwise there should be no change
	    if (props.hasOwnProperty('value')) {
	      setDefaultValue(node, props.type, value);
	    } else if (props.hasOwnProperty('defaultValue')) {
	      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
	    }
	  }

	  {
	    // When syncing the checked attribute, it only changes when it needs
	    // to be removed, such as transitioning from a checkbox into a text input
	    if (props.checked == null && props.defaultChecked != null) {
	      node.defaultChecked = !!props.defaultChecked;
	    }
	  }
	}

	function postMountWrapper(element, props, isHydrating) {
	  var node = element;

	  // Do not assign value if it is already set. This prevents user text input
	  // from being lost during SSR hydration.
	  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {
	    var type = props.type;
	    var isButton = type === 'submit' || type === 'reset';

	    // Avoid setting value attribute on submit/reset inputs as it overrides the
	    // default value provided by the browser. See: #12872
	    if (isButton && (props.value === undefined || props.value === null)) {
	      return;
	    }

	    var _initialValue = toString(node._wrapperState.initialValue);

	    // Do not assign value if it is already set. This prevents user text input
	    // from being lost during SSR hydration.
	    if (!isHydrating) {
	      {
	        // When syncing the value attribute, the value property should use
	        // the wrapperState._initialValue property. This uses:
	        //
	        //   1. The value React property when present
	        //   2. The defaultValue React property when present
	        //   3. An empty string
	        if (_initialValue !== node.value) {
	          node.value = _initialValue;
	        }
	      }
	    }

	    {
	      // Otherwise, the value attribute is synchronized to the property,
	      // so we assign defaultValue to the same thing as the value property
	      // assignment step above.
	      node.defaultValue = _initialValue;
	    }
	  }

	  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	  // this is needed to work around a chrome bug where setting defaultChecked
	  // will sometimes influence the value of checked (even after detachment).
	  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	  // We need to temporarily unset name to avoid disrupting radio button groups.
	  var name = node.name;
	  if (name !== '') {
	    node.name = '';
	  }

	  {
	    // When syncing the checked attribute, both the checked property and
	    // attribute are assigned at the same time using defaultChecked. This uses:
	    //
	    //   1. The checked React property when present
	    //   2. The defaultChecked React property when present
	    //   3. Otherwise, false
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !!node._wrapperState.initialChecked;
	  }

	  if (name !== '') {
	    node.name = name;
	  }
	}

	function restoreControlledState(element, props) {
	  var node = element;
	  updateWrapper(node, props);
	  updateNamedCousins(node, props);
	}

	function updateNamedCousins(rootNode, props) {
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var queryRoot = rootNode;

	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }

	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form. It might not even be in the
	    // document. Let's just use the local `querySelectorAll` to ensure we don't
	    // miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
	      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;

	      // We need update the tracked value on the named cousin since the value
	      // was changed but the input saw no event or value set
	      updateValueIfChanged(otherNode);

	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      updateWrapper(otherNode, otherProps);
	    }
	  }
	}

	// In Chrome, assigning defaultValue to certain input types triggers input validation.
	// For number inputs, the display value loses trailing decimal points. For email inputs,
	// Chrome raises "The specified value <x> is not a valid email address".
	//
	// Here we check to see if the defaultValue has actually changed, avoiding these problems
	// when the user is inputting text
	//
	// https://github.com/facebook/react/issues/7253
	function setDefaultValue(node, type, value) {
	  if (
	  // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
	  type !== 'number' || node.ownerDocument.activeElement !== node) {
	    if (value == null) {
	      node.defaultValue = toString(node._wrapperState.initialValue);
	    } else if (node.defaultValue !== toString(value)) {
	      node.defaultValue = toString(value);
	    }
	  }
	}

	var eventTypes$1 = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: 'onChange',
	      captured: 'onChangeCapture'
	    },
	    dependencies: [TOP_BLUR, TOP_CHANGE, TOP_CLICK, TOP_FOCUS, TOP_INPUT, TOP_KEY_DOWN, TOP_KEY_UP, TOP_SELECTION_CHANGE]
	  }
	};

	function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
	  var event = SyntheticEvent.getPooled(eventTypes$1.change, inst, nativeEvent, target);
	  event.type = 'change';
	  // Flag this event loop as needing state restore.
	  enqueueStateRestore(target);
	  accumulateTwoPhaseDispatches(event);
	  return event;
	}
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;

	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}

	function manualDispatchChangeEvent(nativeEvent) {
	  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  batchedUpdates(runEventInBatch, event);
	}

	function runEventInBatch(event) {
	  runEventsInBatch(event);
	}

	function getInstIfValueChanged(targetInst) {
	  var targetNode = getNodeFromInstance$1(targetInst);
	  if (updateValueIfChanged(targetNode)) {
	    return targetInst;
	  }
	}

	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === TOP_CHANGE) {
	    return targetInst;
	  }
	}

	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.
	  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
	}

	/**
	 * (For IE <=9) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}

	/**
	 * (For IE <=9) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);
	  activeElement = null;
	  activeElementInst = null;
	}

	/**
	 * (For IE <=9) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  if (getInstIfValueChanged(activeElementInst)) {
	    manualDispatchChangeEvent(nativeEvent);
	  }
	}

	function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
	  if (topLevelType === TOP_FOCUS) {
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === TOP_BLUR) {
	    stopWatchingForValueChange();
	  }
	}

	// For IE8 and IE9.
	function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
	  if (topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    return getInstIfValueChanged(activeElementInst);
	  }
	}

	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  var nodeName = elem.nodeName;
	  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}

	function getTargetInstForClickEvent(topLevelType, targetInst) {
	  if (topLevelType === TOP_CLICK) {
	    return getInstIfValueChanged(targetInst);
	  }
	}

	function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === TOP_INPUT || topLevelType === TOP_CHANGE) {
	    return getInstIfValueChanged(targetInst);
	  }
	}

	function handleControlledInputBlur(node) {
	  var state = node._wrapperState;

	  if (!state || !state.controlled || node.type !== 'number') {
	    return;
	  }

	  {
	    // If controlled, assign the value attribute to the current value on blur
	    setDefaultValue(node, 'number', node.value);
	  }
	}

	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	  eventTypes: eventTypes$1,

	  _isInputEventSupported: isInputEventSupported,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

	    var getTargetInstFunc = void 0,
	        handleEventFunc = void 0;
	    if (shouldUseChangeEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForChangeEvent;
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventPolyfill;
	        handleEventFunc = handleEventsForInputEventPolyfill;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }

	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst);
	      if (inst) {
	        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
	        return event;
	      }
	    }

	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }

	    // When blurring, set the value attribute for number inputs
	    if (topLevelType === TOP_BLUR) {
	      handleControlledInputBlur(targetNode);
	    }
	  }
	};

	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

	var SyntheticUIEvent = SyntheticEvent.extend({
	  view: null,
	  detail: null
	});

	var modifierKeyToProp = {
	  Alt: 'altKey',
	  Control: 'ctrlKey',
	  Meta: 'metaKey',
	  Shift: 'shiftKey'
	};

	// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
	// getModifierState. If getModifierState is not supported, we map it to a set of
	// modifier keys exposed by the event. In this case, Lock-keys are not supported.
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */

	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}

	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}

	var previousScreenX = 0;
	var previousScreenY = 0;
	// Use flags to signal movementX/Y has already been set
	var isMovementXSet = false;
	var isMovementYSet = false;

	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var SyntheticMouseEvent = SyntheticUIEvent.extend({
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  pageX: null,
	  pageY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: null,
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  movementX: function (event) {
	    if ('movementX' in event) {
	      return event.movementX;
	    }

	    var screenX = previousScreenX;
	    previousScreenX = event.screenX;

	    if (!isMovementXSet) {
	      isMovementXSet = true;
	      return 0;
	    }

	    return event.type === 'mousemove' ? event.screenX - screenX : 0;
	  },
	  movementY: function (event) {
	    if ('movementY' in event) {
	      return event.movementY;
	    }

	    var screenY = previousScreenY;
	    previousScreenY = event.screenY;

	    if (!isMovementYSet) {
	      isMovementYSet = true;
	      return 0;
	    }

	    return event.type === 'mousemove' ? event.screenY - screenY : 0;
	  }
	});

	/**
	 * @interface PointerEvent
	 * @see http://www.w3.org/TR/pointerevents/
	 */
	var SyntheticPointerEvent = SyntheticMouseEvent.extend({
	  pointerId: null,
	  width: null,
	  height: null,
	  pressure: null,
	  tangentialPressure: null,
	  tiltX: null,
	  tiltY: null,
	  twist: null,
	  pointerType: null,
	  isPrimary: null
	});

	var eventTypes$2 = {
	  mouseEnter: {
	    registrationName: 'onMouseEnter',
	    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]
	  },
	  mouseLeave: {
	    registrationName: 'onMouseLeave',
	    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]
	  },
	  pointerEnter: {
	    registrationName: 'onPointerEnter',
	    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]
	  },
	  pointerLeave: {
	    registrationName: 'onPointerLeave',
	    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]
	  }
	};

	var EnterLeaveEventPlugin = {
	  eventTypes: eventTypes$2,

	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var isOverEvent = topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER;
	    var isOutEvent = topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT;

	    if (isOverEvent && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }

	    if (!isOutEvent && !isOverEvent) {
	      // Must not be a mouse or pointer in or out - ignoring.
	      return null;
	    }

	    var win = void 0;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }

	    var from = void 0;
	    var to = void 0;
	    if (isOutEvent) {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }

	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }

	    var eventInterface = void 0,
	        leaveEventType = void 0,
	        enterEventType = void 0,
	        eventTypePrefix = void 0;

	    if (topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_MOUSE_OVER) {
	      eventInterface = SyntheticMouseEvent;
	      leaveEventType = eventTypes$2.mouseLeave;
	      enterEventType = eventTypes$2.mouseEnter;
	      eventTypePrefix = 'mouse';
	    } else if (topLevelType === TOP_POINTER_OUT || topLevelType === TOP_POINTER_OVER) {
	      eventInterface = SyntheticPointerEvent;
	      leaveEventType = eventTypes$2.pointerLeave;
	      enterEventType = eventTypes$2.pointerEnter;
	      eventTypePrefix = 'pointer';
	    }

	    var fromNode = from == null ? win : getNodeFromInstance$1(from);
	    var toNode = to == null ? win : getNodeFromInstance$1(to);

	    var leave = eventInterface.getPooled(leaveEventType, from, nativeEvent, nativeEventTarget);
	    leave.type = eventTypePrefix + 'leave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;

	    var enter = eventInterface.getPooled(enterEventType, to, nativeEvent, nativeEventTarget);
	    enter.type = eventTypePrefix + 'enter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;

	    accumulateEnterLeaveDispatches(leave, enter, from, to);

	    return [leave, enter];
	  }
	};

	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
	  ;
	}

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }

	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }

	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);

	  if (keysA.length !== keysB.length) {
	    return false;
	  }

	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty$1.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 *
	 * Note that this module is currently shared and assumed to be stateless.
	 * If this becomes an actual Map, that will break.
	 */

	/**
	 * This API should be called `delete` but we'd have to make sure to always
	 * transform these to strings for IE support. When this transform is fully
	 * supported we can rename it.
	 */


	function get(key) {
	  return key._reactInternalFiber;
	}

	function has(key) {
	  return key._reactInternalFiber !== undefined;
	}

	function set(key, value) {
	  key._reactInternalFiber = value;
	}

	// Don't change these two values. They're used by React Dev Tools.
	var NoEffect = /*              */0;
	var PerformedWork = /*         */1;

	// You can change the rest (and add more).
	var Placement = /*             */2;
	var Update = /*                */4;
	var PlacementAndUpdate = /*    */6;
	var Deletion = /*              */8;
	var ContentReset = /*          */16;
	var Callback = /*              */32;
	var DidCapture = /*            */64;
	var Ref = /*                   */128;
	var Snapshot = /*              */256;
	var Passive = /*               */512;

	// Passive & Update & Callback & Ref & Snapshot
	var LifecycleEffectMask = /*   */932;

	// Union of all host effects
	var HostEffectMask = /*        */1023;

	var Incomplete = /*            */1024;
	var ShouldCapture = /*         */2048;

	var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;

	var MOUNTING = 1;
	var MOUNTED = 2;
	var UNMOUNTED = 3;

	function isFiberMountedImpl(fiber) {
	  var node = fiber;
	  if (!fiber.alternate) {
	    // If there is no alternate, this might be a new tree that isn't inserted
	    // yet. If it is, then it will have a pending insertion effect on it.
	    if ((node.effectTag & Placement) !== NoEffect) {
	      return MOUNTING;
	    }
	    while (node.return) {
	      node = node.return;
	      if ((node.effectTag & Placement) !== NoEffect) {
	        return MOUNTING;
	      }
	    }
	  } else {
	    while (node.return) {
	      node = node.return;
	    }
	  }
	  if (node.tag === HostRoot) {
	    // TODO: Check if this was a nested HostRoot when used with
	    // renderContainerIntoSubtree.
	    return MOUNTED;
	  }
	  // If we didn't hit the root, that means that we're in an disconnected tree
	  // that has been unmounted.
	  return UNMOUNTED;
	}

	function isFiberMounted(fiber) {
	  return isFiberMountedImpl(fiber) === MOUNTED;
	}

	function isMounted(component) {
	  {
	    var owner = ReactCurrentOwner$1.current;
	    if (owner !== null && owner.tag === ClassComponent) {
	      var ownerFiber = owner;
	      var instance = ownerFiber.stateNode;
	      !instance._warnedAboutRefsInRender ? warningWithoutStack$1(false, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber.type) || 'A component') : void 0;
	      instance._warnedAboutRefsInRender = true;
	    }
	  }

	  var fiber = get(component);
	  if (!fiber) {
	    return false;
	  }
	  return isFiberMountedImpl(fiber) === MOUNTED;
	}

	function assertIsMounted(fiber) {
	  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
	}

	function findCurrentFiberUsingSlowPath(fiber) {
	  var alternate = fiber.alternate;
	  if (!alternate) {
	    // If there is no alternate, then we only need to check if it is mounted.
	    var state = isFiberMountedImpl(fiber);
	    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
	    if (state === MOUNTING) {
	      return null;
	    }
	    return fiber;
	  }
	  // If we have two possible branches, we'll walk backwards up to the root
	  // to see what path the root points to. On the way we may hit one of the
	  // special cases and we'll deal with them.
	  var a = fiber;
	  var b = alternate;
	  while (true) {
	    var parentA = a.return;
	    var parentB = parentA ? parentA.alternate : null;
	    if (!parentA || !parentB) {
	      // We're at the root.
	      break;
	    }

	    // If both copies of the parent fiber point to the same child, we can
	    // assume that the child is current. This happens when we bailout on low
	    // priority: the bailed out fiber's child reuses the current child.
	    if (parentA.child === parentB.child) {
	      var child = parentA.child;
	      while (child) {
	        if (child === a) {
	          // We've determined that A is the current branch.
	          assertIsMounted(parentA);
	          return fiber;
	        }
	        if (child === b) {
	          // We've determined that B is the current branch.
	          assertIsMounted(parentA);
	          return alternate;
	        }
	        child = child.sibling;
	      }
	      // We should never have an alternate for any mounting node. So the only
	      // way this could possibly happen is if this was unmounted, if at all.
	      invariant(false, 'Unable to find node on an unmounted component.');
	    }

	    if (a.return !== b.return) {
	      // The return pointer of A and the return pointer of B point to different
	      // fibers. We assume that return pointers never criss-cross, so A must
	      // belong to the child set of A.return, and B must belong to the child
	      // set of B.return.
	      a = parentA;
	      b = parentB;
	    } else {
	      // The return pointers point to the same fiber. We'll have to use the
	      // default, slow path: scan the child sets of each parent alternate to see
	      // which child belongs to which set.
	      //
	      // Search parent A's child set
	      var didFindChild = false;
	      var _child = parentA.child;
	      while (_child) {
	        if (_child === a) {
	          didFindChild = true;
	          a = parentA;
	          b = parentB;
	          break;
	        }
	        if (_child === b) {
	          didFindChild = true;
	          b = parentA;
	          a = parentB;
	          break;
	        }
	        _child = _child.sibling;
	      }
	      if (!didFindChild) {
	        // Search parent B's child set
	        _child = parentB.child;
	        while (_child) {
	          if (_child === a) {
	            didFindChild = true;
	            a = parentB;
	            b = parentA;
	            break;
	          }
	          if (_child === b) {
	            didFindChild = true;
	            b = parentB;
	            a = parentA;
	            break;
	          }
	          _child = _child.sibling;
	        }
	        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;
	      }
	    }

	    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	  }
	  // If the root is not a host container, we're in a disconnected tree. I.e.
	  // unmounted.
	  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
	  if (a.stateNode.current === a) {
	    // We've determined that A is the current branch.
	    return fiber;
	  }
	  // Otherwise B has to be current branch.
	  return alternate;
	}

	function findCurrentHostFiber(parent) {
	  var currentParent = findCurrentFiberUsingSlowPath(parent);
	  if (!currentParent) {
	    return null;
	  }

	  // Next we'll drill down this component to find the first HostComponent/Text.
	  var node = currentParent;
	  while (true) {
	    if (node.tag === HostComponent || node.tag === HostText) {
	      return node;
	    } else if (node.child) {
	      node.child.return = node;
	      node = node.child;
	      continue;
	    }
	    if (node === currentParent) {
	      return null;
	    }
	    while (!node.sibling) {
	      if (!node.return || node.return === currentParent) {
	        return null;
	      }
	      node = node.return;
	    }
	    node.sibling.return = node.return;
	    node = node.sibling;
	  }
	  // Flow needs the return null here, but ESLint complains about it.
	  // eslint-disable-next-line no-unreachable
	  return null;
	}

	function findCurrentHostFiberWithNoPortals(parent) {
	  var currentParent = findCurrentFiberUsingSlowPath(parent);
	  if (!currentParent) {
	    return null;
	  }

	  // Next we'll drill down this component to find the first HostComponent/Text.
	  var node = currentParent;
	  while (true) {
	    if (node.tag === HostComponent || node.tag === HostText) {
	      return node;
	    } else if (node.child && node.tag !== HostPortal) {
	      node.child.return = node;
	      node = node.child;
	      continue;
	    }
	    if (node === currentParent) {
	      return null;
	    }
	    while (!node.sibling) {
	      if (!node.return || node.return === currentParent) {
	        return null;
	      }
	      node = node.return;
	    }
	    node.sibling.return = node.return;
	    node = node.sibling;
	  }
	  // Flow needs the return null here, but ESLint complains about it.
	  // eslint-disable-next-line no-unreachable
	  return null;
	}

	function addEventBubbleListener(element, eventType, listener) {
	  element.addEventListener(eventType, listener, false);
	}

	function addEventCaptureListener(element, eventType, listener) {
	  element.addEventListener(eventType, listener, true);
	}

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var SyntheticAnimationEvent = SyntheticEvent.extend({
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	});

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var SyntheticClipboardEvent = SyntheticEvent.extend({
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	});

	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var SyntheticFocusEvent = SyntheticUIEvent.extend({
	  relatedTarget: null
	});

	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	function getEventCharCode(nativeEvent) {
	  var charCode = void 0;
	  var keyCode = nativeEvent.keyCode;

	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;

	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }

	  // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
	  // report Enter as charCode 10 when ctrl is pressed.
	  if (charCode === 10) {
	    charCode = 13;
	  }

	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }

	  return 0;
	}

	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  Esc: 'Escape',
	  Spacebar: ' ',
	  Left: 'ArrowLeft',
	  Up: 'ArrowUp',
	  Right: 'ArrowRight',
	  Down: 'ArrowDown',
	  Del: 'Delete',
	  Win: 'OS',
	  Menu: 'ContextMenu',
	  Apps: 'ContextMenu',
	  Scroll: 'ScrollLock',
	  MozPrintableKey: 'Unidentified'
	};

	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  '8': 'Backspace',
	  '9': 'Tab',
	  '12': 'Clear',
	  '13': 'Enter',
	  '16': 'Shift',
	  '17': 'Control',
	  '18': 'Alt',
	  '19': 'Pause',
	  '20': 'CapsLock',
	  '27': 'Escape',
	  '32': ' ',
	  '33': 'PageUp',
	  '34': 'PageDown',
	  '35': 'End',
	  '36': 'Home',
	  '37': 'ArrowLeft',
	  '38': 'ArrowUp',
	  '39': 'ArrowRight',
	  '40': 'ArrowDown',
	  '45': 'Insert',
	  '46': 'Delete',
	  '112': 'F1',
	  '113': 'F2',
	  '114': 'F3',
	  '115': 'F4',
	  '116': 'F5',
	  '117': 'F6',
	  '118': 'F7',
	  '119': 'F8',
	  '120': 'F9',
	  '121': 'F10',
	  '122': 'F11',
	  '123': 'F12',
	  '144': 'NumLock',
	  '145': 'ScrollLock',
	  '224': 'Meta'
	};

	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.

	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }

	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);

	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}

	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var SyntheticKeyboardEvent = SyntheticUIEvent.extend({
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.

	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.

	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	});

	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var SyntheticDragEvent = SyntheticMouseEvent.extend({
	  dataTransfer: null
	});

	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var SyntheticTouchEvent = SyntheticUIEvent.extend({
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	});

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var SyntheticTransitionEvent = SyntheticEvent.extend({
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	});

	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var SyntheticWheelEvent = SyntheticMouseEvent.extend({
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },

	  deltaZ: null,

	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	});

	/**
	 * Turns
	 * ['abort', ...]
	 * into
	 * eventTypes = {
	 *   'abort': {
	 *     phasedRegistrationNames: {
	 *       bubbled: 'onAbort',
	 *       captured: 'onAbortCapture',
	 *     },
	 *     dependencies: [TOP_ABORT],
	 *   },
	 *   ...
	 * };
	 * topLevelEventsToDispatchConfig = new Map([
	 *   [TOP_ABORT, { sameConfig }],
	 * ]);
	 */

	var interactiveEventTypeNames = [[TOP_BLUR, 'blur'], [TOP_CANCEL, 'cancel'], [TOP_CLICK, 'click'], [TOP_CLOSE, 'close'], [TOP_CONTEXT_MENU, 'contextMenu'], [TOP_COPY, 'copy'], [TOP_CUT, 'cut'], [TOP_AUX_CLICK, 'auxClick'], [TOP_DOUBLE_CLICK, 'doubleClick'], [TOP_DRAG_END, 'dragEnd'], [TOP_DRAG_START, 'dragStart'], [TOP_DROP, 'drop'], [TOP_FOCUS, 'focus'], [TOP_INPUT, 'input'], [TOP_INVALID, 'invalid'], [TOP_KEY_DOWN, 'keyDown'], [TOP_KEY_PRESS, 'keyPress'], [TOP_KEY_UP, 'keyUp'], [TOP_MOUSE_DOWN, 'mouseDown'], [TOP_MOUSE_UP, 'mouseUp'], [TOP_PASTE, 'paste'], [TOP_PAUSE, 'pause'], [TOP_PLAY, 'play'], [TOP_POINTER_CANCEL, 'pointerCancel'], [TOP_POINTER_DOWN, 'pointerDown'], [TOP_POINTER_UP, 'pointerUp'], [TOP_RATE_CHANGE, 'rateChange'], [TOP_RESET, 'reset'], [TOP_SEEKED, 'seeked'], [TOP_SUBMIT, 'submit'], [TOP_TOUCH_CANCEL, 'touchCancel'], [TOP_TOUCH_END, 'touchEnd'], [TOP_TOUCH_START, 'touchStart'], [TOP_VOLUME_CHANGE, 'volumeChange']];
	var nonInteractiveEventTypeNames = [[TOP_ABORT, 'abort'], [TOP_ANIMATION_END, 'animationEnd'], [TOP_ANIMATION_ITERATION, 'animationIteration'], [TOP_ANIMATION_START, 'animationStart'], [TOP_CAN_PLAY, 'canPlay'], [TOP_CAN_PLAY_THROUGH, 'canPlayThrough'], [TOP_DRAG, 'drag'], [TOP_DRAG_ENTER, 'dragEnter'], [TOP_DRAG_EXIT, 'dragExit'], [TOP_DRAG_LEAVE, 'dragLeave'], [TOP_DRAG_OVER, 'dragOver'], [TOP_DURATION_CHANGE, 'durationChange'], [TOP_EMPTIED, 'emptied'], [TOP_ENCRYPTED, 'encrypted'], [TOP_ENDED, 'ended'], [TOP_ERROR, 'error'], [TOP_GOT_POINTER_CAPTURE, 'gotPointerCapture'], [TOP_LOAD, 'load'], [TOP_LOADED_DATA, 'loadedData'], [TOP_LOADED_METADATA, 'loadedMetadata'], [TOP_LOAD_START, 'loadStart'], [TOP_LOST_POINTER_CAPTURE, 'lostPointerCapture'], [TOP_MOUSE_MOVE, 'mouseMove'], [TOP_MOUSE_OUT, 'mouseOut'], [TOP_MOUSE_OVER, 'mouseOver'], [TOP_PLAYING, 'playing'], [TOP_POINTER_MOVE, 'pointerMove'], [TOP_POINTER_OUT, 'pointerOut'], [TOP_POINTER_OVER, 'pointerOver'], [TOP_PROGRESS, 'progress'], [TOP_SCROLL, 'scroll'], [TOP_SEEKING, 'seeking'], [TOP_STALLED, 'stalled'], [TOP_SUSPEND, 'suspend'], [TOP_TIME_UPDATE, 'timeUpdate'], [TOP_TOGGLE, 'toggle'], [TOP_TOUCH_MOVE, 'touchMove'], [TOP_TRANSITION_END, 'transitionEnd'], [TOP_WAITING, 'waiting'], [TOP_WHEEL, 'wheel']];

	var eventTypes$4 = {};
	var topLevelEventsToDispatchConfig = {};

	function addEventTypeNameToConfig(_ref, isInteractive) {
	  var topEvent = _ref[0],
	      event = _ref[1];

	  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
	  var onEvent = 'on' + capitalizedEvent;

	  var type = {
	    phasedRegistrationNames: {
	      bubbled: onEvent,
	      captured: onEvent + 'Capture'
	    },
	    dependencies: [topEvent],
	    isInteractive: isInteractive
	  };
	  eventTypes$4[event] = type;
	  topLevelEventsToDispatchConfig[topEvent] = type;
	}

	interactiveEventTypeNames.forEach(function (eventTuple) {
	  addEventTypeNameToConfig(eventTuple, true);
	});
	nonInteractiveEventTypeNames.forEach(function (eventTuple) {
	  addEventTypeNameToConfig(eventTuple, false);
	});

	// Only used in DEV for exhaustiveness validation.
	var knownHTMLTopLevelTypes = [TOP_ABORT, TOP_CANCEL, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_CLOSE, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_INPUT, TOP_INVALID, TOP_LOAD, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_RESET, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUBMIT, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_TOGGLE, TOP_VOLUME_CHANGE, TOP_WAITING];

	var SimpleEventPlugin = {
	  eventTypes: eventTypes$4,

	  isInteractiveTopLevelEventType: function (topLevelType) {
	    var config = topLevelEventsToDispatchConfig[topLevelType];
	    return config !== undefined && config.isInteractive === true;
	  },


	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor = void 0;
	    switch (topLevelType) {
	      case TOP_KEY_PRESS:
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case TOP_KEY_DOWN:
	      case TOP_KEY_UP:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case TOP_BLUR:
	      case TOP_FOCUS:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case TOP_CLICK:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case TOP_AUX_CLICK:
	      case TOP_DOUBLE_CLICK:
	      case TOP_MOUSE_DOWN:
	      case TOP_MOUSE_MOVE:
	      case TOP_MOUSE_UP:
	      // TODO: Disabled elements should not respond to mouse events
	      /* falls through */
	      case TOP_MOUSE_OUT:
	      case TOP_MOUSE_OVER:
	      case TOP_CONTEXT_MENU:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case TOP_DRAG:
	      case TOP_DRAG_END:
	      case TOP_DRAG_ENTER:
	      case TOP_DRAG_EXIT:
	      case TOP_DRAG_LEAVE:
	      case TOP_DRAG_OVER:
	      case TOP_DRAG_START:
	      case TOP_DROP:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case TOP_TOUCH_CANCEL:
	      case TOP_TOUCH_END:
	      case TOP_TOUCH_MOVE:
	      case TOP_TOUCH_START:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case TOP_ANIMATION_END:
	      case TOP_ANIMATION_ITERATION:
	      case TOP_ANIMATION_START:
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case TOP_TRANSITION_END:
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case TOP_SCROLL:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case TOP_WHEEL:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case TOP_COPY:
	      case TOP_CUT:
	      case TOP_PASTE:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	      case TOP_GOT_POINTER_CAPTURE:
	      case TOP_LOST_POINTER_CAPTURE:
	      case TOP_POINTER_CANCEL:
	      case TOP_POINTER_DOWN:
	      case TOP_POINTER_MOVE:
	      case TOP_POINTER_OUT:
	      case TOP_POINTER_OVER:
	      case TOP_POINTER_UP:
	        EventConstructor = SyntheticPointerEvent;
	        break;
	      default:
	        {
	          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {
	            warningWithoutStack$1(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);
	          }
	        }
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	    }
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    accumulateTwoPhaseDispatches(event);
	    return event;
	  }
	};

	var isInteractiveTopLevelEventType = SimpleEventPlugin.isInteractiveTopLevelEventType;


	var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;
	var callbackBookkeepingPool = [];

	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findRootContainerNode(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst.return) {
	    inst = inst.return;
	  }
	  if (inst.tag !== HostRoot) {
	    // This can happen if we're in a detached tree.
	    return null;
	  }
	  return inst.stateNode.containerInfo;
	}

	// Used to store ancestor hierarchy in top level callback
	function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {
	  if (callbackBookkeepingPool.length) {
	    var instance = callbackBookkeepingPool.pop();
	    instance.topLevelType = topLevelType;
	    instance.nativeEvent = nativeEvent;
	    instance.targetInst = targetInst;
	    return instance;
	  }
	  return {
	    topLevelType: topLevelType,
	    nativeEvent: nativeEvent,
	    targetInst: targetInst,
	    ancestors: []
	  };
	}

	function releaseTopLevelCallbackBookKeeping(instance) {
	  instance.topLevelType = null;
	  instance.nativeEvent = null;
	  instance.targetInst = null;
	  instance.ancestors.length = 0;
	  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {
	    callbackBookkeepingPool.push(instance);
	  }
	}

	function handleTopLevel(bookKeeping) {
	  var targetInst = bookKeeping.targetInst;

	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    if (!ancestor) {
	      bookKeeping.ancestors.push(ancestor);
	      break;
	    }
	    var root = findRootContainerNode(ancestor);
	    if (!root) {
	      break;
	    }
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = getClosestInstanceFromNode(root);
	  } while (ancestor);

	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    runExtractedEventsInBatch(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}

	// TODO: can we stop exporting these?
	var _enabled = true;

	function setEnabled(enabled) {
	  _enabled = !!enabled;
	}

	function isEnabled() {
	  return _enabled;
	}

	/**
	 * Traps top-level events by using event bubbling.
	 *
	 * @param {number} topLevelType Number from `TopLevelEventTypes`.
	 * @param {object} element Element on which to attach listener.
	 * @return {?object} An object with a remove function which will forcefully
	 *                  remove the listener.
	 * @internal
	 */
	function trapBubbledEvent(topLevelType, element) {
	  if (!element) {
	    return null;
	  }
	  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;

	  addEventBubbleListener(element, getRawEventName(topLevelType),
	  // Check if interactive and wrap in interactiveUpdates
	  dispatch.bind(null, topLevelType));
	}

	/**
	 * Traps a top-level event by using event capturing.
	 *
	 * @param {number} topLevelType Number from `TopLevelEventTypes`.
	 * @param {object} element Element on which to attach listener.
	 * @return {?object} An object with a remove function which will forcefully
	 *                  remove the listener.
	 * @internal
	 */
	function trapCapturedEvent(topLevelType, element) {
	  if (!element) {
	    return null;
	  }
	  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;

	  addEventCaptureListener(element, getRawEventName(topLevelType),
	  // Check if interactive and wrap in interactiveUpdates
	  dispatch.bind(null, topLevelType));
	}

	function dispatchInteractiveEvent(topLevelType, nativeEvent) {
	  interactiveUpdates(dispatchEvent, topLevelType, nativeEvent);
	}

	function dispatchEvent(topLevelType, nativeEvent) {
	  if (!_enabled) {
	    return;
	  }

	  var nativeEventTarget = getEventTarget(nativeEvent);
	  var targetInst = getClosestInstanceFromNode(nativeEventTarget);
	  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {
	    // If we get an event (ex: img onload) before committing that
	    // component's mount, ignore it for now (that is, treat it as if it was an
	    // event on a non-React tree). We might also consider queueing events and
	    // dispatching them after the mount.
	    targetInst = null;
	  }

	  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);

	  try {
	    // Event queue being processed in the same cycle allows
	    // `preventDefault`.
	    batchedUpdates(handleTopLevel, bookKeeping);
	  } finally {
	    releaseTopLevelCallbackBookKeeping(bookKeeping);
	  }
	}

	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactDOMEventListener, which is injected and can therefore support
	 *    pluggable event sources. This is the only work that occurs in the main
	 *    thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */

	var alreadyListeningTo = {};
	var reactTopListenersCounter = 0;

	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);

	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}

	/**
	 * We listen for bubbled touch events on the document object.
	 *
	 * Firefox v8.01 (and possibly others) exhibited strange behavior when
	 * mounting `onmousemove` events at some node that was not the document
	 * element. The symptoms were that if your mouse is not moving over something
	 * contained within that mount point (for example on the background) the
	 * top-level listeners for `onmousemove` won't be called. However, if you
	 * register the `mousemove` on the document object, then it will of course
	 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	 * top-level listeners to the document object only, at least for these
	 * movement types of events and possibly all events.
	 *
	 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	 *
	 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	 * they bubble to document.
	 *
	 * @param {string} registrationName Name of listener (e.g. `onClick`).
	 * @param {object} mountAt Container where to mount the listener
	 */
	function listenTo(registrationName, mountAt) {
	  var isListening = getListeningForDocument(mountAt);
	  var dependencies = registrationNameDependencies[registrationName];

	  for (var i = 0; i < dependencies.length; i++) {
	    var dependency = dependencies[i];
	    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	      switch (dependency) {
	        case TOP_SCROLL:
	          trapCapturedEvent(TOP_SCROLL, mountAt);
	          break;
	        case TOP_FOCUS:
	        case TOP_BLUR:
	          trapCapturedEvent(TOP_FOCUS, mountAt);
	          trapCapturedEvent(TOP_BLUR, mountAt);
	          // We set the flag for a single dependency later in this function,
	          // but this ensures we mark both as attached rather than just one.
	          isListening[TOP_BLUR] = true;
	          isListening[TOP_FOCUS] = true;
	          break;
	        case TOP_CANCEL:
	        case TOP_CLOSE:
	          if (isEventSupported(getRawEventName(dependency))) {
	            trapCapturedEvent(dependency, mountAt);
	          }
	          break;
	        case TOP_INVALID:
	        case TOP_SUBMIT:
	        case TOP_RESET:
	          // We listen to them on the target DOM elements.
	          // Some of them bubble so we don't want them to fire twice.
	          break;
	        default:
	          // By default, listen on the top level to all non-media events.
	          // Media events don't bubble so adding the listener wouldn't do anything.
	          var isMediaEvent = mediaEventTypes.indexOf(dependency) !== -1;
	          if (!isMediaEvent) {
	            trapBubbledEvent(dependency, mountAt);
	          }
	          break;
	      }
	      isListening[dependency] = true;
	    }
	  }
	}

	function isListeningToAllDependencies(registrationName, mountAt) {
	  var isListening = getListeningForDocument(mountAt);
	  var dependencies = registrationNameDependencies[registrationName];
	  for (var i = 0; i < dependencies.length; i++) {
	    var dependency = dependencies[i];
	    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	      return false;
	    }
	  }
	  return true;
	}

	function getActiveElement(doc) {
	  doc = doc || (typeof document !== 'undefined' ? document : undefined);
	  if (typeof doc === 'undefined') {
	    return null;
	  }
	  try {
	    return doc.activeElement || doc.body;
	  } catch (e) {
	    return doc.body;
	  }
	}

	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}

	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}

	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;

	  while (node) {
	    if (node.nodeType === TEXT_NODE) {
	      nodeEnd = nodeStart + node.textContent.length;

	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }

	      nodeStart = nodeEnd;
	    }

	    node = getLeafNode(getSiblingNode(node));
	  }
	}

	/**
	 * @param {DOMElement} outerNode
	 * @return {?object}
	 */
	function getOffsets(outerNode) {
	  var ownerDocument = outerNode.ownerDocument;

	  var win = ownerDocument && ownerDocument.defaultView || window;
	  var selection = win.getSelection && win.getSelection();

	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }

	  var anchorNode = selection.anchorNode,
	      anchorOffset = selection.anchorOffset,
	      focusNode = selection.focusNode,
	      focusOffset = selection.focusOffset;

	  // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
	  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
	  // expose properties, triggering a "Permission denied error" if any of its
	  // properties are accessed. The only seemingly possible way to avoid erroring
	  // is to access a property that typically works for non-anonymous divs and
	  // catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427

	  try {
	    /* eslint-disable no-unused-expressions */
	    anchorNode.nodeType;
	    focusNode.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }

	  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
	}

	/**
	 * Returns {start, end} where `start` is the character/codepoint index of
	 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
	 * `end` is the index of (focusNode, focusOffset).
	 *
	 * Returns null if you pass in garbage input but we should probably just crash.
	 *
	 * Exported only for testing.
	 */
	function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
	  var length = 0;
	  var start = -1;
	  var end = -1;
	  var indexWithinAnchor = 0;
	  var indexWithinFocus = 0;
	  var node = outerNode;
	  var parentNode = null;

	  outer: while (true) {
	    var next = null;

	    while (true) {
	      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
	        start = length + anchorOffset;
	      }
	      if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
	        end = length + focusOffset;
	      }

	      if (node.nodeType === TEXT_NODE) {
	        length += node.nodeValue.length;
	      }

	      if ((next = node.firstChild) === null) {
	        break;
	      }
	      // Moving from `node` to its first child `next`.
	      parentNode = node;
	      node = next;
	    }

	    while (true) {
	      if (node === outerNode) {
	        // If `outerNode` has children, this is always the second time visiting
	        // it. If it has no children, this is still the first loop, and the only
	        // valid selection is anchorNode and focusNode both equal to this node
	        // and both offsets 0, in which case we will have handled above.
	        break outer;
	      }
	      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
	        start = length;
	      }
	      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
	        end = length;
	      }
	      if ((next = node.nextSibling) !== null) {
	        break;
	      }
	      node = parentNode;
	      parentNode = node.parentNode;
	    }

	    // Moving from `node` to its next sibling `next`.
	    node = next;
	  }

	  if (start === -1 || end === -1) {
	    // This should never happen. (Would happen if the anchor/focus nodes aren't
	    // actually inside the passed-in node.)
	    return null;
	  }

	  return {
	    start: start,
	    end: end
	  };
	}

	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setOffsets(node, offsets) {
	  var doc = node.ownerDocument || document;
	  var win = doc && doc.defaultView || window;

	  // Edge fails with "Object expected" in some scenarios.
	  // (For instance: TinyMCE editor used in a list component that supports pasting to add more,
	  // fails when pasting 100+ items)
	  if (!win.getSelection) {
	    return;
	  }

	  var selection = win.getSelection();
	  var length = node.textContent.length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }

	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);

	  if (startMarker && endMarker) {
	    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
	      return;
	    }
	    var range = doc.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();

	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}

	function isTextNode(node) {
	  return node && node.nodeType === TEXT_NODE;
	}

	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}

	function isInDocument(node) {
	  return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
	}

	function isSameOriginFrame(iframe) {
	  try {
	    // Accessing the contentDocument of a HTMLIframeElement can cause the browser
	    // to throw, e.g. if it has a cross-origin src attribute.
	    // Safari will show an error in the console when the access results in "Blocked a frame with origin". e.g:
	    // iframe.contentDocument.defaultView;
	    // A safety way is to access one of the cross origin properties: Window or Location
	    // Which might result in "SecurityError" DOM Exception and it is compatible to Safari.
	    // https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl

	    return typeof iframe.contentWindow.location.href === 'string';
	  } catch (err) {
	    return false;
	  }
	}

	function getActiveElementDeep() {
	  var win = window;
	  var element = getActiveElement();
	  while (element instanceof win.HTMLIFrameElement) {
	    if (isSameOriginFrame(element)) {
	      win = element.contentWindow;
	    } else {
	      return element;
	    }
	    element = getActiveElement(win.document);
	  }
	  return element;
	}

	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */

	/**
	 * @hasSelectionCapabilities: we get the element types that support selection
	 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
	 * and `selectionEnd` rows.
	 */
	function hasSelectionCapabilities(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');
	}

	function getSelectionInformation() {
	  var focusedElem = getActiveElementDeep();
	  return {
	    focusedElem: focusedElem,
	    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null
	  };
	}

	/**
	 * @restoreSelection: If any selection information was potentially lost,
	 * restore it. This is useful when performing operations that could remove dom
	 * nodes and place them back in, resulting in focus being lost.
	 */
	function restoreSelection(priorSelectionInformation) {
	  var curFocusedElem = getActiveElementDeep();
	  var priorFocusedElem = priorSelectionInformation.focusedElem;
	  var priorSelectionRange = priorSelectionInformation.selectionRange;
	  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	    if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
	      setSelection(priorFocusedElem, priorSelectionRange);
	    }

	    // Focusing a node can change the scroll position, which is undesirable
	    var ancestors = [];
	    var ancestor = priorFocusedElem;
	    while (ancestor = ancestor.parentNode) {
	      if (ancestor.nodeType === ELEMENT_NODE) {
	        ancestors.push({
	          element: ancestor,
	          left: ancestor.scrollLeft,
	          top: ancestor.scrollTop
	        });
	      }
	    }

	    if (typeof priorFocusedElem.focus === 'function') {
	      priorFocusedElem.focus();
	    }

	    for (var i = 0; i < ancestors.length; i++) {
	      var info = ancestors[i];
	      info.element.scrollLeft = info.left;
	      info.element.scrollTop = info.top;
	    }
	  }
	}

	/**
	 * @getSelection: Gets the selection bounds of a focused textarea, input or
	 * contentEditable node.
	 * -@input: Look up selection bounds of this input
	 * -@return {start: selectionStart, end: selectionEnd}
	 */
	function getSelection$1(input) {
	  var selection = void 0;

	  if ('selectionStart' in input) {
	    // Modern browser with input or textarea.
	    selection = {
	      start: input.selectionStart,
	      end: input.selectionEnd
	    };
	  } else {
	    // Content editable or old IE textarea.
	    selection = getOffsets(input);
	  }

	  return selection || { start: 0, end: 0 };
	}

	/**
	 * @setSelection: Sets the selection bounds of a textarea or input and focuses
	 * the input.
	 * -@input     Set selection bounds of this input or textarea
	 * -@offsets   Object of same form that is returned from get*
	 */
	function setSelection(input, offsets) {
	  var start = offsets.start,
	      end = offsets.end;

	  if (end === undefined) {
	    end = start;
	  }

	  if ('selectionStart' in input) {
	    input.selectionStart = start;
	    input.selectionEnd = Math.min(end, input.value.length);
	  } else {
	    setOffsets(input, offsets);
	  }
	}

	var skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;

	var eventTypes$3 = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: 'onSelect',
	      captured: 'onSelectCapture'
	    },
	    dependencies: [TOP_BLUR, TOP_CONTEXT_MENU, TOP_DRAG_END, TOP_FOCUS, TOP_KEY_DOWN, TOP_KEY_UP, TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_SELECTION_CHANGE]
	  }
	};

	var activeElement$1 = null;
	var activeElementInst$1 = null;
	var lastSelection = null;
	var mouseDown = false;

	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else {
	    var win = node.ownerDocument && node.ownerDocument.defaultView || window;
	    var selection = win.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  }
	}

	/**
	 * Get document associated with the event target.
	 *
	 * @param {object} nativeEventTarget
	 * @return {Document}
	 */
	function getEventTargetDocument(eventTarget) {
	  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
	}

	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @param {object} nativeEventTarget
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  var doc = getEventTargetDocument(nativeEventTarget);

	  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
	    return null;
	  }

	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement$1);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;

	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);

	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement$1;

	    accumulateTwoPhaseDispatches(syntheticEvent);

	    return syntheticEvent;
	  }

	  return null;
	}

	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	  eventTypes: eventTypes$3,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var doc = getEventTargetDocument(nativeEventTarget);
	    // Track whether all listeners exists for this plugin. If none exist, we do
	    // not extract events. See #3639.
	    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {
	      return null;
	    }

	    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case TOP_FOCUS:
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement$1 = targetNode;
	          activeElementInst$1 = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case TOP_BLUR:
	        activeElement$1 = null;
	        activeElementInst$1 = null;
	        lastSelection = null;
	        break;
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case TOP_MOUSE_DOWN:
	        mouseDown = true;
	        break;
	      case TOP_CONTEXT_MENU:
	      case TOP_MOUSE_UP:
	      case TOP_DRAG_END:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case TOP_SELECTION_CHANGE:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case TOP_KEY_DOWN:
	      case TOP_KEY_UP:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }

	    return null;
	  }
	};

	/**
	 * Inject modules for resolving DOM hierarchy and plugin ordering.
	 */
	injection.injectEventPluginOrder(DOMEventPluginOrder);
	setComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromNode$1, getNodeFromInstance$1);

	/**
	 * Some important event plugins included by default (without having to require
	 * them).
	 */
	injection.injectEventPluginsByName({
	  SimpleEventPlugin: SimpleEventPlugin,
	  EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	  ChangeEventPlugin: ChangeEventPlugin,
	  SelectEventPlugin: SelectEventPlugin,
	  BeforeInputEventPlugin: BeforeInputEventPlugin
	});

	var didWarnSelectedSetOnOption = false;
	var didWarnInvalidChild = false;

	function flattenChildren(children) {
	  var content = '';

	  // Flatten children. We'll warn if they are invalid
	  // during validateProps() which runs for hydration too.
	  // Note that this would throw on non-element objects.
	  // Elements are stringified (which is normally irrelevant
	  // but matters for <fbt>).
	  React.Children.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    content += child;
	    // Note: we don't warn about invalid children here.
	    // Instead, this is done separately below so that
	    // it happens during the hydration codepath too.
	  });

	  return content;
	}

	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */

	function validateProps(element, props) {
	  {
	    // This mirrors the codepath above, but runs for hydration too.
	    // Warn about invalid children here so that client and hydration are consistent.
	    // TODO: this seems like it could cause a DEV-only throw for hydration
	    // if children contains a non-element object. We should try to avoid that.
	    if (typeof props.children === 'object' && props.children !== null) {
	      React.Children.forEach(props.children, function (child) {
	        if (child == null) {
	          return;
	        }
	        if (typeof child === 'string' || typeof child === 'number') {
	          return;
	        }
	        if (typeof child.type !== 'string') {
	          return;
	        }
	        if (!didWarnInvalidChild) {
	          didWarnInvalidChild = true;
	          warning$1(false, 'Only strings and numbers are supported as <option> children.');
	        }
	      });
	    }

	    // TODO: Remove support for `selected` in <option>.
	    if (props.selected != null && !didWarnSelectedSetOnOption) {
	      warning$1(false, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');
	      didWarnSelectedSetOnOption = true;
	    }
	  }
	}

	function postMountWrapper$1(element, props) {
	  // value="" should make a value attribute (#6219)
	  if (props.value != null) {
	    element.setAttribute('value', toString(getToStringValue(props.value)));
	  }
	}

	function getHostProps$1(element, props) {
	  var hostProps = _assign({ children: undefined }, props);
	  var content = flattenChildren(props.children);

	  if (content) {
	    hostProps.children = content;
	  }

	  return hostProps;
	}

	// TODO: direct imports like some-package/src/* are bad. Fix me.
	var didWarnValueDefaultValue$1 = void 0;

	{
	  didWarnValueDefaultValue$1 = false;
	}

	function getDeclarationErrorAddendum() {
	  var ownerName = getCurrentFiberOwnerNameInDevOrNull();
	  if (ownerName) {
	    return '\n\nCheck the render method of `' + ownerName + '`.';
	  }
	  return '';
	}

	var valuePropNames = ['value', 'defaultValue'];

	/**
	 * Validation function for `value` and `defaultValue`.
	 */
	function checkSelectPropTypes(props) {
	  ReactControlledValuePropTypes.checkPropTypes('select', props);

	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	      warning$1(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
	    } else if (!props.multiple && isArray) {
	      warning$1(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
	    }
	  }
	}

	function updateOptions(node, multiple, propValue, setDefaultSelected) {
	  var options = node.options;

	  if (multiple) {
	    var selectedValues = propValue;
	    var selectedValue = {};
	    for (var i = 0; i < selectedValues.length; i++) {
	      // Prefix to avoid chaos with special keys.
	      selectedValue['$' + selectedValues[i]] = true;
	    }
	    for (var _i = 0; _i < options.length; _i++) {
	      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
	      if (options[_i].selected !== selected) {
	        options[_i].selected = selected;
	      }
	      if (selected && setDefaultSelected) {
	        options[_i].defaultSelected = true;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    var _selectedValue = toString(getToStringValue(propValue));
	    var defaultSelected = null;
	    for (var _i2 = 0; _i2 < options.length; _i2++) {
	      if (options[_i2].value === _selectedValue) {
	        options[_i2].selected = true;
	        if (setDefaultSelected) {
	          options[_i2].defaultSelected = true;
	        }
	        return;
	      }
	      if (defaultSelected === null && !options[_i2].disabled) {
	        defaultSelected = options[_i2];
	      }
	    }
	    if (defaultSelected !== null) {
	      defaultSelected.selected = true;
	    }
	  }
	}

	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */

	function getHostProps$2(element, props) {
	  return _assign({}, props, {
	    value: undefined
	  });
	}

	function initWrapperState$1(element, props) {
	  var node = element;
	  {
	    checkSelectPropTypes(props);
	  }

	  node._wrapperState = {
	    wasMultiple: !!props.multiple
	  };

	  {
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
	      warning$1(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
	      didWarnValueDefaultValue$1 = true;
	    }
	  }
	}

	function postMountWrapper$2(element, props) {
	  var node = element;
	  node.multiple = !!props.multiple;
	  var value = props.value;
	  if (value != null) {
	    updateOptions(node, !!props.multiple, value, false);
	  } else if (props.defaultValue != null) {
	    updateOptions(node, !!props.multiple, props.defaultValue, true);
	  }
	}

	function postUpdateWrapper(element, props) {
	  var node = element;
	  var wasMultiple = node._wrapperState.wasMultiple;
	  node._wrapperState.wasMultiple = !!props.multiple;

	  var value = props.value;
	  if (value != null) {
	    updateOptions(node, !!props.multiple, value, false);
	  } else if (wasMultiple !== !!props.multiple) {
	    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	    if (props.defaultValue != null) {
	      updateOptions(node, !!props.multiple, props.defaultValue, true);
	    } else {
	      // Revert the select back to its default unselected state.
	      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
	    }
	  }
	}

	function restoreControlledState$2(element, props) {
	  var node = element;
	  var value = props.value;

	  if (value != null) {
	    updateOptions(node, !!props.multiple, value, false);
	  }
	}

	var didWarnValDefaultVal = false;

	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */

	function getHostProps$3(element, props) {
	  var node = element;
	  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;

	  // Always set children to the same thing. In IE9, the selection range will
	  // get reset if `textContent` is mutated.  We could add a check in setTextContent
	  // to only set the value if/when the value differs from the node value (which would
	  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
	  // solution. The value can be a boolean or object so that's why it's forced
	  // to be a string.
	  var hostProps = _assign({}, props, {
	    value: undefined,
	    defaultValue: undefined,
	    children: toString(node._wrapperState.initialValue)
	  });

	  return hostProps;
	}

	function initWrapperState$2(element, props) {
	  var node = element;
	  {
	    ReactControlledValuePropTypes.checkPropTypes('textarea', props);
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	      warning$1(false, '%s contains a textarea with both value and defaultValue props. ' + 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component');
	      didWarnValDefaultVal = true;
	    }
	  }

	  var initialValue = props.value;

	  // Only bother fetching default value if we're going to use it
	  if (initialValue == null) {
	    var defaultValue = props.defaultValue;
	    // TODO (yungsters): Remove support for children content in <textarea>.
	    var children = props.children;
	    if (children != null) {
	      {
	        warning$1(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
	      }
	      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;
	      if (Array.isArray(children)) {
	        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;
	        children = children[0];
	      }

	      defaultValue = children;
	    }
	    if (defaultValue == null) {
	      defaultValue = '';
	    }
	    initialValue = defaultValue;
	  }

	  node._wrapperState = {
	    initialValue: getToStringValue(initialValue)
	  };
	}

	function updateWrapper$1(element, props) {
	  var node = element;
	  var value = getToStringValue(props.value);
	  var defaultValue = getToStringValue(props.defaultValue);
	  if (value != null) {
	    // Cast `value` to a string to ensure the value is set correctly. While
	    // browsers typically do this as necessary, jsdom doesn't.
	    var newValue = toString(value);
	    // To avoid side effects (such as losing text selection), only set value if changed
	    if (newValue !== node.value) {
	      node.value = newValue;
	    }
	    if (props.defaultValue == null && node.defaultValue !== newValue) {
	      node.defaultValue = newValue;
	    }
	  }
	  if (defaultValue != null) {
	    node.defaultValue = toString(defaultValue);
	  }
	}

	function postMountWrapper$3(element, props) {
	  var node = element;
	  // This is in postMount because we need access to the DOM node, which is not
	  // available until after the component has mounted.
	  var textContent = node.textContent;

	  // Only set node.value if textContent is equal to the expected
	  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
	  // will populate textContent as well.
	  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
	  if (textContent === node._wrapperState.initialValue) {
	    node.value = textContent;
	  }
	}

	function restoreControlledState$3(element, props) {
	  // DOM component is still mounted; update
	  updateWrapper$1(element, props);
	}

	var HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';
	var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
	var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

	var Namespaces = {
	  html: HTML_NAMESPACE$1,
	  mathml: MATH_NAMESPACE,
	  svg: SVG_NAMESPACE
	};

	// Assumes there is no parent namespace.
	function getIntrinsicNamespace(type) {
	  switch (type) {
	    case 'svg':
	      return SVG_NAMESPACE;
	    case 'math':
	      return MATH_NAMESPACE;
	    default:
	      return HTML_NAMESPACE$1;
	  }
	}

	function getChildNamespace(parentNamespace, type) {
	  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {
	    // No (or default) parent namespace: potential entry point.
	    return getIntrinsicNamespace(type);
	  }
	  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
	    // We're leaving SVG.
	    return HTML_NAMESPACE$1;
	  }
	  // By default, pass namespace below.
	  return parentNamespace;
	}

	/* globals MSApp */

	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */
	var createMicrosoftUnsafeLocalFunction = function (func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};

	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer = void 0;

	/**
	 * Set the innerHTML property of a node
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node

	  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var svgNode = reusableSVGContainer.firstChild;
	    while (node.firstChild) {
	      node.removeChild(node.firstChild);
	    }
	    while (svgNode.firstChild) {
	      node.appendChild(svgNode.firstChild);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});

	/**
	 * Set the textContent property of a node. For text updates, it's faster
	 * to set the `nodeValue` of the Text node directly instead of using
	 * `.textContent` which will remove the existing node and create a new one.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  if (text) {
	    var firstChild = node.firstChild;

	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};

	// List derived from Gecko source code:
	// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js
	var shorthandToLonghand = {
	  animation: ['animationDelay', 'animationDirection', 'animationDuration', 'animationFillMode', 'animationIterationCount', 'animationName', 'animationPlayState', 'animationTimingFunction'],
	  background: ['backgroundAttachment', 'backgroundClip', 'backgroundColor', 'backgroundImage', 'backgroundOrigin', 'backgroundPositionX', 'backgroundPositionY', 'backgroundRepeat', 'backgroundSize'],
	  backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
	  border: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth', 'borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth', 'borderLeftColor', 'borderLeftStyle', 'borderLeftWidth', 'borderRightColor', 'borderRightStyle', 'borderRightWidth', 'borderTopColor', 'borderTopStyle', 'borderTopWidth'],
	  borderBlockEnd: ['borderBlockEndColor', 'borderBlockEndStyle', 'borderBlockEndWidth'],
	  borderBlockStart: ['borderBlockStartColor', 'borderBlockStartStyle', 'borderBlockStartWidth'],
	  borderBottom: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth'],
	  borderColor: ['borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor'],
	  borderImage: ['borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth'],
	  borderInlineEnd: ['borderInlineEndColor', 'borderInlineEndStyle', 'borderInlineEndWidth'],
	  borderInlineStart: ['borderInlineStartColor', 'borderInlineStartStyle', 'borderInlineStartWidth'],
	  borderLeft: ['borderLeftColor', 'borderLeftStyle', 'borderLeftWidth'],
	  borderRadius: ['borderBottomLeftRadius', 'borderBottomRightRadius', 'borderTopLeftRadius', 'borderTopRightRadius'],
	  borderRight: ['borderRightColor', 'borderRightStyle', 'borderRightWidth'],
	  borderStyle: ['borderBottomStyle', 'borderLeftStyle', 'borderRightStyle', 'borderTopStyle'],
	  borderTop: ['borderTopColor', 'borderTopStyle', 'borderTopWidth'],
	  borderWidth: ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth'],
	  columnRule: ['columnRuleColor', 'columnRuleStyle', 'columnRuleWidth'],
	  columns: ['columnCount', 'columnWidth'],
	  flex: ['flexBasis', 'flexGrow', 'flexShrink'],
	  flexFlow: ['flexDirection', 'flexWrap'],
	  font: ['fontFamily', 'fontFeatureSettings', 'fontKerning', 'fontLanguageOverride', 'fontSize', 'fontSizeAdjust', 'fontStretch', 'fontStyle', 'fontVariant', 'fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition', 'fontWeight', 'lineHeight'],
	  fontVariant: ['fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition'],
	  gap: ['columnGap', 'rowGap'],
	  grid: ['gridAutoColumns', 'gridAutoFlow', 'gridAutoRows', 'gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
	  gridArea: ['gridColumnEnd', 'gridColumnStart', 'gridRowEnd', 'gridRowStart'],
	  gridColumn: ['gridColumnEnd', 'gridColumnStart'],
	  gridColumnGap: ['columnGap'],
	  gridGap: ['columnGap', 'rowGap'],
	  gridRow: ['gridRowEnd', 'gridRowStart'],
	  gridRowGap: ['rowGap'],
	  gridTemplate: ['gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
	  listStyle: ['listStyleImage', 'listStylePosition', 'listStyleType'],
	  margin: ['marginBottom', 'marginLeft', 'marginRight', 'marginTop'],
	  marker: ['markerEnd', 'markerMid', 'markerStart'],
	  mask: ['maskClip', 'maskComposite', 'maskImage', 'maskMode', 'maskOrigin', 'maskPositionX', 'maskPositionY', 'maskRepeat', 'maskSize'],
	  maskPosition: ['maskPositionX', 'maskPositionY'],
	  outline: ['outlineColor', 'outlineStyle', 'outlineWidth'],
	  overflow: ['overflowX', 'overflowY'],
	  padding: ['paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop'],
	  placeContent: ['alignContent', 'justifyContent'],
	  placeItems: ['alignItems', 'justifyItems'],
	  placeSelf: ['alignSelf', 'justifySelf'],
	  textDecoration: ['textDecorationColor', 'textDecorationLine', 'textDecorationStyle'],
	  textEmphasis: ['textEmphasisColor', 'textEmphasisStyle'],
	  transition: ['transitionDelay', 'transitionDuration', 'transitionProperty', 'transitionTimingFunction'],
	  wordWrap: ['overflowWrap']
	};

	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  columns: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridArea: true,
	  gridRow: true,
	  gridRowEnd: true,
	  gridRowSpan: true,
	  gridRowStart: true,
	  gridColumn: true,
	  gridColumnEnd: true,
	  gridColumnSpan: true,
	  gridColumnStart: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,

	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};

	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}

	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});

	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, isCustomProperty) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901

	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }

	  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
	    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
	  }

	  return ('' + value).trim();
	}

	var uppercasePattern = /([A-Z])/g;
	var msPattern = /^ms-/;

	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 */
	function hyphenateStyleName(name) {
	  return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
	}

	var warnValidStyle = function () {};

	{
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	  var msPattern$1 = /^-ms-/;
	  var hyphenPattern = /-(.)/g;

	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;

	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;
	  var warnedForInfinityValue = false;

	  var camelize = function (string) {
	    return string.replace(hyphenPattern, function (_, character) {
	      return character.toUpperCase();
	    });
	  };

	  var warnHyphenatedStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }

	    warnedStyleNames[name] = true;
	    warning$1(false, 'Unsupported style property %s. Did you mean %s?', name,
	    // As Andi Smith suggests
	    // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	    // is converted to lowercase `ms`.
	    camelize(name.replace(msPattern$1, 'ms-')));
	  };

	  var warnBadVendoredStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }

	    warnedStyleNames[name] = true;
	    warning$1(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
	  };

	  var warnStyleValueWithSemicolon = function (name, value) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }

	    warnedStyleValues[value] = true;
	    warning$1(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
	  };

	  var warnStyleValueIsNaN = function (name, value) {
	    if (warnedForNaNValue) {
	      return;
	    }

	    warnedForNaNValue = true;
	    warning$1(false, '`NaN` is an invalid value for the `%s` css style property.', name);
	  };

	  var warnStyleValueIsInfinity = function (name, value) {
	    if (warnedForInfinityValue) {
	      return;
	    }

	    warnedForInfinityValue = true;
	    warning$1(false, '`Infinity` is an invalid value for the `%s` css style property.', name);
	  };

	  warnValidStyle = function (name, value) {
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value);
	    }

	    if (typeof value === 'number') {
	      if (isNaN(value)) {
	        warnStyleValueIsNaN(name, value);
	      } else if (!isFinite(value)) {
	        warnStyleValueIsInfinity(name, value);
	      }
	    }
	  };
	}

	var warnValidStyle$1 = warnValidStyle;

	/**
	 * Operations for dealing with CSS properties.
	 */

	/**
	 * This creates a string that is expected to be equivalent to the style
	 * attribute generated by server-side rendering. It by-passes warnings and
	 * security checks so it's not safe to use this value for anything other than
	 * comparison. It is only used in DEV for SSR validation.
	 */
	function createDangerousStringForStyles(styles) {
	  {
	    var serialized = '';
	    var delimiter = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (styleValue != null) {
	        var isCustomProperty = styleName.indexOf('--') === 0;
	        serialized += delimiter + hyphenateStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);

	        delimiter = ';';
	      }
	    }
	    return serialized || null;
	  }
	}

	/**
	 * Sets the value for multiple styles on a node.  If a value is specified as
	 * '' (empty string), the corresponding style property will be unset.
	 *
	 * @param {DOMElement} node
	 * @param {object} styles
	 */
	function setValueForStyles(node, styles) {
	  var style = node.style;
	  for (var styleName in styles) {
	    if (!styles.hasOwnProperty(styleName)) {
	      continue;
	    }
	    var isCustomProperty = styleName.indexOf('--') === 0;
	    {
	      if (!isCustomProperty) {
	        warnValidStyle$1(styleName, styles[styleName]);
	      }
	    }
	    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
	    if (styleName === 'float') {
	      styleName = 'cssFloat';
	    }
	    if (isCustomProperty) {
	      style.setProperty(styleName, styleValue);
	    } else {
	      style[styleName] = styleValue;
	    }
	  }
	}

	function isValueEmpty(value) {
	  return value == null || typeof value === 'boolean' || value === '';
	}

	/**
	 * Given {color: 'red', overflow: 'hidden'} returns {
	 *   color: 'color',
	 *   overflowX: 'overflow',
	 *   overflowY: 'overflow',
	 * }. This can be read as "the overflowY property was set by the overflow
	 * shorthand". That is, the values are the property that each was derived from.
	 */
	function expandShorthandMap(styles) {
	  var expanded = {};
	  for (var key in styles) {
	    var longhands = shorthandToLonghand[key] || [key];
	    for (var i = 0; i < longhands.length; i++) {
	      expanded[longhands[i]] = key;
	    }
	  }
	  return expanded;
	}

	/**
	 * When mixing shorthand and longhand property names, we warn during updates if
	 * we expect an incorrect result to occur. In particular, we warn for:
	 *
	 * Updating a shorthand property (longhand gets overwritten):
	 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
	 *   becomes .style.font = 'baz'
	 * Removing a shorthand property (longhand gets lost too):
	 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
	 *   becomes .style.font = ''
	 * Removing a longhand property (should revert to shorthand; doesn't):
	 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
	 *   becomes .style.fontVariant = ''
	 */
	function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
	  {
	    return;
	  }

	  if (!nextStyles) {
	    return;
	  }

	  var expandedUpdates = expandShorthandMap(styleUpdates);
	  var expandedStyles = expandShorthandMap(nextStyles);
	  var warnedAbout = {};
	  for (var key in expandedUpdates) {
	    var originalKey = expandedUpdates[key];
	    var correctOriginalKey = expandedStyles[key];
	    if (correctOriginalKey && originalKey !== correctOriginalKey) {
	      var warningKey = originalKey + ',' + correctOriginalKey;
	      if (warnedAbout[warningKey]) {
	        continue;
	      }
	      warnedAbout[warningKey] = true;
	      warning$1(false, '%s a style property during rerender (%s) when a ' + 'conflicting property is set (%s) can lead to styling bugs. To ' + "avoid this, don't mix shorthand and non-shorthand properties " + 'for the same value; instead, replace the shorthand with ' + 'separate values.', isValueEmpty(styleUpdates[originalKey]) ? 'Removing' : 'Updating', originalKey, correctOriginalKey);
	    }
	  }
	}

	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.

	var omittedCloseTags = {
	  area: true,
	  base: true,
	  br: true,
	  col: true,
	  embed: true,
	  hr: true,
	  img: true,
	  input: true,
	  keygen: true,
	  link: true,
	  meta: true,
	  param: true,
	  source: true,
	  track: true,
	  wbr: true
	  // NOTE: menuitem's close tag should be omitted, but that causes problems.
	};

	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.

	var voidElementTags = _assign({
	  menuitem: true
	}, omittedCloseTags);

	// TODO: We can remove this if we add invariantWithStack()
	// or add stack by default to invariants where possible.
	var HTML$1 = '__html';

	var ReactDebugCurrentFrame$2 = null;
	{
	  ReactDebugCurrentFrame$2 = ReactSharedInternals.ReactDebugCurrentFrame;
	}

	function assertValidProps(tag, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, ReactDebugCurrentFrame$2.getStackAddendum()) : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;
	  }
	  {
	    !(props.suppressContentEditableWarning || !props.contentEditable || props.children == null) ? warning$1(false, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	  }
	  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', ReactDebugCurrentFrame$2.getStackAddendum()) : void 0;
	}

	function isCustomComponent(tagName, props) {
	  if (tagName.indexOf('-') === -1) {
	    return typeof props.is === 'string';
	  }
	  switch (tagName) {
	    // These are reserved SVG and MathML elements.
	    // We don't mind this whitelist too much because we expect it to never grow.
	    // The alternative is to track the namespace in a few places which is convoluted.
	    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
	    case 'annotation-xml':
	    case 'color-profile':
	    case 'font-face':
	    case 'font-face-src':
	    case 'font-face-uri':
	    case 'font-face-format':
	    case 'font-face-name':
	    case 'missing-glyph':
	      return false;
	    default:
	      return true;
	  }
	}

	// When adding attributes to the HTML or SVG whitelist, be sure to
	// also add them to this module to ensure casing and incorrect name
	// warnings.
	var possibleStandardNames = {
	  // HTML
	  accept: 'accept',
	  acceptcharset: 'acceptCharset',
	  'accept-charset': 'acceptCharset',
	  accesskey: 'accessKey',
	  action: 'action',
	  allowfullscreen: 'allowFullScreen',
	  alt: 'alt',
	  as: 'as',
	  async: 'async',
	  autocapitalize: 'autoCapitalize',
	  autocomplete: 'autoComplete',
	  autocorrect: 'autoCorrect',
	  autofocus: 'autoFocus',
	  autoplay: 'autoPlay',
	  autosave: 'autoSave',
	  capture: 'capture',
	  cellpadding: 'cellPadding',
	  cellspacing: 'cellSpacing',
	  challenge: 'challenge',
	  charset: 'charSet',
	  checked: 'checked',
	  children: 'children',
	  cite: 'cite',
	  class: 'className',
	  classid: 'classID',
	  classname: 'className',
	  cols: 'cols',
	  colspan: 'colSpan',
	  content: 'content',
	  contenteditable: 'contentEditable',
	  contextmenu: 'contextMenu',
	  controls: 'controls',
	  controlslist: 'controlsList',
	  coords: 'coords',
	  crossorigin: 'crossOrigin',
	  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
	  data: 'data',
	  datetime: 'dateTime',
	  default: 'default',
	  defaultchecked: 'defaultChecked',
	  defaultvalue: 'defaultValue',
	  defer: 'defer',
	  dir: 'dir',
	  disabled: 'disabled',
	  download: 'download',
	  draggable: 'draggable',
	  enctype: 'encType',
	  for: 'htmlFor',
	  form: 'form',
	  formmethod: 'formMethod',
	  formaction: 'formAction',
	  formenctype: 'formEncType',
	  formnovalidate: 'formNoValidate',
	  formtarget: 'formTarget',
	  frameborder: 'frameBorder',
	  headers: 'headers',
	  height: 'height',
	  hidden: 'hidden',
	  high: 'high',
	  href: 'href',
	  hreflang: 'hrefLang',
	  htmlfor: 'htmlFor',
	  httpequiv: 'httpEquiv',
	  'http-equiv': 'httpEquiv',
	  icon: 'icon',
	  id: 'id',
	  innerhtml: 'innerHTML',
	  inputmode: 'inputMode',
	  integrity: 'integrity',
	  is: 'is',
	  itemid: 'itemID',
	  itemprop: 'itemProp',
	  itemref: 'itemRef',
	  itemscope: 'itemScope',
	  itemtype: 'itemType',
	  keyparams: 'keyParams',
	  keytype: 'keyType',
	  kind: 'kind',
	  label: 'label',
	  lang: 'lang',
	  list: 'list',
	  loop: 'loop',
	  low: 'low',
	  manifest: 'manifest',
	  marginwidth: 'marginWidth',
	  marginheight: 'marginHeight',
	  max: 'max',
	  maxlength: 'maxLength',
	  media: 'media',
	  mediagroup: 'mediaGroup',
	  method: 'method',
	  min: 'min',
	  minlength: 'minLength',
	  multiple: 'multiple',
	  muted: 'muted',
	  name: 'name',
	  nomodule: 'noModule',
	  nonce: 'nonce',
	  novalidate: 'noValidate',
	  open: 'open',
	  optimum: 'optimum',
	  pattern: 'pattern',
	  placeholder: 'placeholder',
	  playsinline: 'playsInline',
	  poster: 'poster',
	  preload: 'preload',
	  profile: 'profile',
	  radiogroup: 'radioGroup',
	  readonly: 'readOnly',
	  referrerpolicy: 'referrerPolicy',
	  rel: 'rel',
	  required: 'required',
	  reversed: 'reversed',
	  role: 'role',
	  rows: 'rows',
	  rowspan: 'rowSpan',
	  sandbox: 'sandbox',
	  scope: 'scope',
	  scoped: 'scoped',
	  scrolling: 'scrolling',
	  seamless: 'seamless',
	  selected: 'selected',
	  shape: 'shape',
	  size: 'size',
	  sizes: 'sizes',
	  span: 'span',
	  spellcheck: 'spellCheck',
	  src: 'src',
	  srcdoc: 'srcDoc',
	  srclang: 'srcLang',
	  srcset: 'srcSet',
	  start: 'start',
	  step: 'step',
	  style: 'style',
	  summary: 'summary',
	  tabindex: 'tabIndex',
	  target: 'target',
	  title: 'title',
	  type: 'type',
	  usemap: 'useMap',
	  value: 'value',
	  width: 'width',
	  wmode: 'wmode',
	  wrap: 'wrap',

	  // SVG
	  about: 'about',
	  accentheight: 'accentHeight',
	  'accent-height': 'accentHeight',
	  accumulate: 'accumulate',
	  additive: 'additive',
	  alignmentbaseline: 'alignmentBaseline',
	  'alignment-baseline': 'alignmentBaseline',
	  allowreorder: 'allowReorder',
	  alphabetic: 'alphabetic',
	  amplitude: 'amplitude',
	  arabicform: 'arabicForm',
	  'arabic-form': 'arabicForm',
	  ascent: 'ascent',
	  attributename: 'attributeName',
	  attributetype: 'attributeType',
	  autoreverse: 'autoReverse',
	  azimuth: 'azimuth',
	  basefrequency: 'baseFrequency',
	  baselineshift: 'baselineShift',
	  'baseline-shift': 'baselineShift',
	  baseprofile: 'baseProfile',
	  bbox: 'bbox',
	  begin: 'begin',
	  bias: 'bias',
	  by: 'by',
	  calcmode: 'calcMode',
	  capheight: 'capHeight',
	  'cap-height': 'capHeight',
	  clip: 'clip',
	  clippath: 'clipPath',
	  'clip-path': 'clipPath',
	  clippathunits: 'clipPathUnits',
	  cliprule: 'clipRule',
	  'clip-rule': 'clipRule',
	  color: 'color',
	  colorinterpolation: 'colorInterpolation',
	  'color-interpolation': 'colorInterpolation',
	  colorinterpolationfilters: 'colorInterpolationFilters',
	  'color-interpolation-filters': 'colorInterpolationFilters',
	  colorprofile: 'colorProfile',
	  'color-profile': 'colorProfile',
	  colorrendering: 'colorRendering',
	  'color-rendering': 'colorRendering',
	  contentscripttype: 'contentScriptType',
	  contentstyletype: 'contentStyleType',
	  cursor: 'cursor',
	  cx: 'cx',
	  cy: 'cy',
	  d: 'd',
	  datatype: 'datatype',
	  decelerate: 'decelerate',
	  descent: 'descent',
	  diffuseconstant: 'diffuseConstant',
	  direction: 'direction',
	  display: 'display',
	  divisor: 'divisor',
	  dominantbaseline: 'dominantBaseline',
	  'dominant-baseline': 'dominantBaseline',
	  dur: 'dur',
	  dx: 'dx',
	  dy: 'dy',
	  edgemode: 'edgeMode',
	  elevation: 'elevation',
	  enablebackground: 'enableBackground',
	  'enable-background': 'enableBackground',
	  end: 'end',
	  exponent: 'exponent',
	  externalresourcesrequired: 'externalResourcesRequired',
	  fill: 'fill',
	  fillopacity: 'fillOpacity',
	  'fill-opacity': 'fillOpacity',
	  fillrule: 'fillRule',
	  'fill-rule': 'fillRule',
	  filter: 'filter',
	  filterres: 'filterRes',
	  filterunits: 'filterUnits',
	  floodopacity: 'floodOpacity',
	  'flood-opacity': 'floodOpacity',
	  floodcolor: 'floodColor',
	  'flood-color': 'floodColor',
	  focusable: 'focusable',
	  fontfamily: 'fontFamily',
	  'font-family': 'fontFamily',
	  fontsize: 'fontSize',
	  'font-size': 'fontSize',
	  fontsizeadjust: 'fontSizeAdjust',
	  'font-size-adjust': 'fontSizeAdjust',
	  fontstretch: 'fontStretch',
	  'font-stretch': 'fontStretch',
	  fontstyle: 'fontStyle',
	  'font-style': 'fontStyle',
	  fontvariant: 'fontVariant',
	  'font-variant': 'fontVariant',
	  fontweight: 'fontWeight',
	  'font-weight': 'fontWeight',
	  format: 'format',
	  from: 'from',
	  fx: 'fx',
	  fy: 'fy',
	  g1: 'g1',
	  g2: 'g2',
	  glyphname: 'glyphName',
	  'glyph-name': 'glyphName',
	  glyphorientationhorizontal: 'glyphOrientationHorizontal',
	  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
	  glyphorientationvertical: 'glyphOrientationVertical',
	  'glyph-orientation-vertical': 'glyphOrientationVertical',
	  glyphref: 'glyphRef',
	  gradienttransform: 'gradientTransform',
	  gradientunits: 'gradientUnits',
	  hanging: 'hanging',
	  horizadvx: 'horizAdvX',
	  'horiz-adv-x': 'horizAdvX',
	  horizoriginx: 'horizOriginX',
	  'horiz-origin-x': 'horizOriginX',
	  ideographic: 'ideographic',
	  imagerendering: 'imageRendering',
	  'image-rendering': 'imageRendering',
	  in2: 'in2',
	  in: 'in',
	  inlist: 'inlist',
	  intercept: 'intercept',
	  k1: 'k1',
	  k2: 'k2',
	  k3: 'k3',
	  k4: 'k4',
	  k: 'k',
	  kernelmatrix: 'kernelMatrix',
	  kernelunitlength: 'kernelUnitLength',
	  kerning: 'kerning',
	  keypoints: 'keyPoints',
	  keysplines: 'keySplines',
	  keytimes: 'keyTimes',
	  lengthadjust: 'lengthAdjust',
	  letterspacing: 'letterSpacing',
	  'letter-spacing': 'letterSpacing',
	  lightingcolor: 'lightingColor',
	  'lighting-color': 'lightingColor',
	  limitingconeangle: 'limitingConeAngle',
	  local: 'local',
	  markerend: 'markerEnd',
	  'marker-end': 'markerEnd',
	  markerheight: 'markerHeight',
	  markermid: 'markerMid',
	  'marker-mid': 'markerMid',
	  markerstart: 'markerStart',
	  'marker-start': 'markerStart',
	  markerunits: 'markerUnits',
	  markerwidth: 'markerWidth',
	  mask: 'mask',
	  maskcontentunits: 'maskContentUnits',
	  maskunits: 'maskUnits',
	  mathematical: 'mathematical',
	  mode: 'mode',
	  numoctaves: 'numOctaves',
	  offset: 'offset',
	  opacity: 'opacity',
	  operator: 'operator',
	  order: 'order',
	  orient: 'orient',
	  orientation: 'orientation',
	  origin: 'origin',
	  overflow: 'overflow',
	  overlineposition: 'overlinePosition',
	  'overline-position': 'overlinePosition',
	  overlinethickness: 'overlineThickness',
	  'overline-thickness': 'overlineThickness',
	  paintorder: 'paintOrder',
	  'paint-order': 'paintOrder',
	  panose1: 'panose1',
	  'panose-1': 'panose1',
	  pathlength: 'pathLength',
	  patterncontentunits: 'patternContentUnits',
	  patterntransform: 'patternTransform',
	  patternunits: 'patternUnits',
	  pointerevents: 'pointerEvents',
	  'pointer-events': 'pointerEvents',
	  points: 'points',
	  pointsatx: 'pointsAtX',
	  pointsaty: 'pointsAtY',
	  pointsatz: 'pointsAtZ',
	  prefix: 'prefix',
	  preservealpha: 'preserveAlpha',
	  preserveaspectratio: 'preserveAspectRatio',
	  primitiveunits: 'primitiveUnits',
	  property: 'property',
	  r: 'r',
	  radius: 'radius',
	  refx: 'refX',
	  refy: 'refY',
	  renderingintent: 'renderingIntent',
	  'rendering-intent': 'renderingIntent',
	  repeatcount: 'repeatCount',
	  repeatdur: 'repeatDur',
	  requiredextensions: 'requiredExtensions',
	  requiredfeatures: 'requiredFeatures',
	  resource: 'resource',
	  restart: 'restart',
	  result: 'result',
	  results: 'results',
	  rotate: 'rotate',
	  rx: 'rx',
	  ry: 'ry',
	  scale: 'scale',
	  security: 'security',
	  seed: 'seed',
	  shaperendering: 'shapeRendering',
	  'shape-rendering': 'shapeRendering',
	  slope: 'slope',
	  spacing: 'spacing',
	  specularconstant: 'specularConstant',
	  specularexponent: 'specularExponent',
	  speed: 'speed',
	  spreadmethod: 'spreadMethod',
	  startoffset: 'startOffset',
	  stddeviation: 'stdDeviation',
	  stemh: 'stemh',
	  stemv: 'stemv',
	  stitchtiles: 'stitchTiles',
	  stopcolor: 'stopColor',
	  'stop-color': 'stopColor',
	  stopopacity: 'stopOpacity',
	  'stop-opacity': 'stopOpacity',
	  strikethroughposition: 'strikethroughPosition',
	  'strikethrough-position': 'strikethroughPosition',
	  strikethroughthickness: 'strikethroughThickness',
	  'strikethrough-thickness': 'strikethroughThickness',
	  string: 'string',
	  stroke: 'stroke',
	  strokedasharray: 'strokeDasharray',
	  'stroke-dasharray': 'strokeDasharray',
	  strokedashoffset: 'strokeDashoffset',
	  'stroke-dashoffset': 'strokeDashoffset',
	  strokelinecap: 'strokeLinecap',
	  'stroke-linecap': 'strokeLinecap',
	  strokelinejoin: 'strokeLinejoin',
	  'stroke-linejoin': 'strokeLinejoin',
	  strokemiterlimit: 'strokeMiterlimit',
	  'stroke-miterlimit': 'strokeMiterlimit',
	  strokewidth: 'strokeWidth',
	  'stroke-width': 'strokeWidth',
	  strokeopacity: 'strokeOpacity',
	  'stroke-opacity': 'strokeOpacity',
	  suppresscontenteditablewarning: 'suppressContentEditableWarning',
	  suppresshydrationwarning: 'suppressHydrationWarning',
	  surfacescale: 'surfaceScale',
	  systemlanguage: 'systemLanguage',
	  tablevalues: 'tableValues',
	  targetx: 'targetX',
	  targety: 'targetY',
	  textanchor: 'textAnchor',
	  'text-anchor': 'textAnchor',
	  textdecoration: 'textDecoration',
	  'text-decoration': 'textDecoration',
	  textlength: 'textLength',
	  textrendering: 'textRendering',
	  'text-rendering': 'textRendering',
	  to: 'to',
	  transform: 'transform',
	  typeof: 'typeof',
	  u1: 'u1',
	  u2: 'u2',
	  underlineposition: 'underlinePosition',
	  'underline-position': 'underlinePosition',
	  underlinethickness: 'underlineThickness',
	  'underline-thickness': 'underlineThickness',
	  unicode: 'unicode',
	  unicodebidi: 'unicodeBidi',
	  'unicode-bidi': 'unicodeBidi',
	  unicoderange: 'unicodeRange',
	  'unicode-range': 'unicodeRange',
	  unitsperem: 'unitsPerEm',
	  'units-per-em': 'unitsPerEm',
	  unselectable: 'unselectable',
	  valphabetic: 'vAlphabetic',
	  'v-alphabetic': 'vAlphabetic',
	  values: 'values',
	  vectoreffect: 'vectorEffect',
	  'vector-effect': 'vectorEffect',
	  version: 'version',
	  vertadvy: 'vertAdvY',
	  'vert-adv-y': 'vertAdvY',
	  vertoriginx: 'vertOriginX',
	  'vert-origin-x': 'vertOriginX',
	  vertoriginy: 'vertOriginY',
	  'vert-origin-y': 'vertOriginY',
	  vhanging: 'vHanging',
	  'v-hanging': 'vHanging',
	  videographic: 'vIdeographic',
	  'v-ideographic': 'vIdeographic',
	  viewbox: 'viewBox',
	  viewtarget: 'viewTarget',
	  visibility: 'visibility',
	  vmathematical: 'vMathematical',
	  'v-mathematical': 'vMathematical',
	  vocab: 'vocab',
	  widths: 'widths',
	  wordspacing: 'wordSpacing',
	  'word-spacing': 'wordSpacing',
	  writingmode: 'writingMode',
	  'writing-mode': 'writingMode',
	  x1: 'x1',
	  x2: 'x2',
	  x: 'x',
	  xchannelselector: 'xChannelSelector',
	  xheight: 'xHeight',
	  'x-height': 'xHeight',
	  xlinkactuate: 'xlinkActuate',
	  'xlink:actuate': 'xlinkActuate',
	  xlinkarcrole: 'xlinkArcrole',
	  'xlink:arcrole': 'xlinkArcrole',
	  xlinkhref: 'xlinkHref',
	  'xlink:href': 'xlinkHref',
	  xlinkrole: 'xlinkRole',
	  'xlink:role': 'xlinkRole',
	  xlinkshow: 'xlinkShow',
	  'xlink:show': 'xlinkShow',
	  xlinktitle: 'xlinkTitle',
	  'xlink:title': 'xlinkTitle',
	  xlinktype: 'xlinkType',
	  'xlink:type': 'xlinkType',
	  xmlbase: 'xmlBase',
	  'xml:base': 'xmlBase',
	  xmllang: 'xmlLang',
	  'xml:lang': 'xmlLang',
	  xmlns: 'xmlns',
	  'xml:space': 'xmlSpace',
	  xmlnsxlink: 'xmlnsXlink',
	  'xmlns:xlink': 'xmlnsXlink',
	  xmlspace: 'xmlSpace',
	  y1: 'y1',
	  y2: 'y2',
	  y: 'y',
	  ychannelselector: 'yChannelSelector',
	  z: 'z',
	  zoomandpan: 'zoomAndPan'
	};

	var ariaProperties = {
	  'aria-current': 0, // state
	  'aria-details': 0,
	  'aria-disabled': 0, // state
	  'aria-hidden': 0, // state
	  'aria-invalid': 0, // state
	  'aria-keyshortcuts': 0,
	  'aria-label': 0,
	  'aria-roledescription': 0,
	  // Widget Attributes
	  'aria-autocomplete': 0,
	  'aria-checked': 0,
	  'aria-expanded': 0,
	  'aria-haspopup': 0,
	  'aria-level': 0,
	  'aria-modal': 0,
	  'aria-multiline': 0,
	  'aria-multiselectable': 0,
	  'aria-orientation': 0,
	  'aria-placeholder': 0,
	  'aria-pressed': 0,
	  'aria-readonly': 0,
	  'aria-required': 0,
	  'aria-selected': 0,
	  'aria-sort': 0,
	  'aria-valuemax': 0,
	  'aria-valuemin': 0,
	  'aria-valuenow': 0,
	  'aria-valuetext': 0,
	  // Live Region Attributes
	  'aria-atomic': 0,
	  'aria-busy': 0,
	  'aria-live': 0,
	  'aria-relevant': 0,
	  // Drag-and-Drop Attributes
	  'aria-dropeffect': 0,
	  'aria-grabbed': 0,
	  // Relationship Attributes
	  'aria-activedescendant': 0,
	  'aria-colcount': 0,
	  'aria-colindex': 0,
	  'aria-colspan': 0,
	  'aria-controls': 0,
	  'aria-describedby': 0,
	  'aria-errormessage': 0,
	  'aria-flowto': 0,
	  'aria-labelledby': 0,
	  'aria-owns': 0,
	  'aria-posinset': 0,
	  'aria-rowcount': 0,
	  'aria-rowindex': 0,
	  'aria-rowspan': 0,
	  'aria-setsize': 0
	};

	var warnedProperties = {};
	var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
	var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function validateProperty(tagName, name) {
	  if (hasOwnProperty$2.call(warnedProperties, name) && warnedProperties[name]) {
	    return true;
	  }

	  if (rARIACamel.test(name)) {
	    var ariaName = 'aria-' + name.slice(4).toLowerCase();
	    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;

	    // If this is an aria-* attribute, but is not listed in the known DOM
	    // DOM properties, then it is an invalid aria-* attribute.
	    if (correctName == null) {
	      warning$1(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);
	      warnedProperties[name] = true;
	      return true;
	    }
	    // aria-* attributes should be lowercase; suggest the lowercase version.
	    if (name !== correctName) {
	      warning$1(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);
	      warnedProperties[name] = true;
	      return true;
	    }
	  }

	  if (rARIA.test(name)) {
	    var lowerCasedName = name.toLowerCase();
	    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;

	    // If this is an aria-* attribute, but is not listed in the known DOM
	    // DOM properties, then it is an invalid aria-* attribute.
	    if (standardName == null) {
	      warnedProperties[name] = true;
	      return false;
	    }
	    // aria-* attributes should be lowercase; suggest the lowercase version.
	    if (name !== standardName) {
	      warning$1(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);
	      warnedProperties[name] = true;
	      return true;
	    }
	  }

	  return true;
	}

	function warnInvalidARIAProps(type, props) {
	  var invalidProps = [];

	  for (var key in props) {
	    var isValid = validateProperty(type, key);
	    if (!isValid) {
	      invalidProps.push(key);
	    }
	  }

	  var unknownPropString = invalidProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');

	  if (invalidProps.length === 1) {
	    warning$1(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop', unknownPropString, type);
	  } else if (invalidProps.length > 1) {
	    warning$1(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop', unknownPropString, type);
	  }
	}

	function validateProperties(type, props) {
	  if (isCustomComponent(type, props)) {
	    return;
	  }
	  warnInvalidARIAProps(type, props);
	}

	var didWarnValueNull = false;

	function validateProperties$1(type, props) {
	  if (type !== 'input' && type !== 'textarea' && type !== 'select') {
	    return;
	  }

	  if (props != null && props.value === null && !didWarnValueNull) {
	    didWarnValueNull = true;
	    if (type === 'select' && props.multiple) {
	      warning$1(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);
	    } else {
	      warning$1(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);
	    }
	  }
	}

	var validateProperty$1 = function () {};

	{
	  var warnedProperties$1 = {};
	  var _hasOwnProperty = Object.prototype.hasOwnProperty;
	  var EVENT_NAME_REGEX = /^on./;
	  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
	  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
	  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

	  validateProperty$1 = function (tagName, name, value, canUseEventSystem) {
	    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
	      return true;
	    }

	    var lowerCasedName = name.toLowerCase();
	    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
	      warning$1(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
	      warnedProperties$1[name] = true;
	      return true;
	    }

	    // We can't rely on the event system being injected on the server.
	    if (canUseEventSystem) {
	      if (registrationNameModules.hasOwnProperty(name)) {
	        return true;
	      }
	      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
	      if (registrationName != null) {
	        warning$1(false, 'Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);
	        warnedProperties$1[name] = true;
	        return true;
	      }
	      if (EVENT_NAME_REGEX.test(name)) {
	        warning$1(false, 'Unknown event handler property `%s`. It will be ignored.', name);
	        warnedProperties$1[name] = true;
	        return true;
	      }
	    } else if (EVENT_NAME_REGEX.test(name)) {
	      // If no event plugins have been injected, we are in a server environment.
	      // So we can't tell if the event name is correct for sure, but we can filter
	      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
	      if (INVALID_EVENT_NAME_REGEX.test(name)) {
	        warning$1(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);
	      }
	      warnedProperties$1[name] = true;
	      return true;
	    }

	    // Let the ARIA attribute hook validate ARIA attributes
	    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
	      return true;
	    }

	    if (lowerCasedName === 'innerhtml') {
	      warning$1(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
	      warnedProperties$1[name] = true;
	      return true;
	    }

	    if (lowerCasedName === 'aria') {
	      warning$1(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
	      warnedProperties$1[name] = true;
	      return true;
	    }

	    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
	      warning$1(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);
	      warnedProperties$1[name] = true;
	      return true;
	    }

	    if (typeof value === 'number' && isNaN(value)) {
	      warning$1(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);
	      warnedProperties$1[name] = true;
	      return true;
	    }

	    var propertyInfo = getPropertyInfo(name);
	    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;

	    // Known attributes should match the casing specified in the property config.
	    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
	      var standardName = possibleStandardNames[lowerCasedName];
	      if (standardName !== name) {
	        warning$1(false, 'Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);
	        warnedProperties$1[name] = true;
	        return true;
	      }
	    } else if (!isReserved && name !== lowerCasedName) {
	      // Unknown attributes should have lowercase casing since that's how they
	      // will be cased anyway with server rendering.
	      warning$1(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);
	      warnedProperties$1[name] = true;
	      return true;
	    }

	    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
	      if (value) {
	        warning$1(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.', value, name, name, value, name);
	      } else {
	        warning$1(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
	      }
	      warnedProperties$1[name] = true;
	      return true;
	    }

	    // Now that we've validated casing, do not validate
	    // data types for reserved props
	    if (isReserved) {
	      return true;
	    }

	    // Warn when a known attribute is a bad type
	    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
	      warnedProperties$1[name] = true;
	      return false;
	    }

	    // Warn when passing the strings 'false' or 'true' into a boolean prop
	    if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
	      warning$1(false, 'Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
	      warnedProperties$1[name] = true;
	      return true;
	    }

	    return true;
	  };
	}

	var warnUnknownProperties = function (type, props, canUseEventSystem) {
	  var unknownProps = [];
	  for (var key in props) {
	    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }

	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	  if (unknownProps.length === 1) {
	    warning$1(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior', unknownPropString, type);
	  } else if (unknownProps.length > 1) {
	    warning$1(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior', unknownPropString, type);
	  }
	};

	function validateProperties$2(type, props, canUseEventSystem) {
	  if (isCustomComponent(type, props)) {
	    return;
	  }
	  warnUnknownProperties(type, props, canUseEventSystem);
	}

	// TODO: direct imports like some-package/src/* are bad. Fix me.
	var didWarnInvalidHydration = false;
	var didWarnShadyDOM = false;

	var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
	var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
	var SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
	var AUTOFOCUS = 'autoFocus';
	var CHILDREN = 'children';
	var STYLE$1 = 'style';
	var HTML = '__html';

	var HTML_NAMESPACE = Namespaces.html;


	var warnedUnknownTags = void 0;
	var suppressHydrationWarning = void 0;

	var validatePropertiesInDevelopment = void 0;
	var warnForTextDifference = void 0;
	var warnForPropDifference = void 0;
	var warnForExtraAttributes = void 0;
	var warnForInvalidEventListener = void 0;
	var canDiffStyleForHydrationWarning = void 0;

	var normalizeMarkupForTextOrAttribute = void 0;
	var normalizeHTML = void 0;

	{
	  warnedUnknownTags = {
	    // Chrome is the only major browser not shipping <time>. But as of July
	    // 2017 it intends to ship it due to widespread usage. We intentionally
	    // *don't* warn for <time> even if it's unrecognized by Chrome because
	    // it soon will be, and many apps have been using it anyway.
	    time: true,
	    // There are working polyfills for <dialog>. Let people use it.
	    dialog: true,
	    // Electron ships a custom <webview> tag to display external web content in
	    // an isolated frame and process.
	    // This tag is not present in non Electron environments such as JSDom which
	    // is often used for testing purposes.
	    // @see https://electronjs.org/docs/api/webview-tag
	    webview: true
	  };

	  validatePropertiesInDevelopment = function (type, props) {
	    validateProperties(type, props);
	    validateProperties$1(type, props);
	    validateProperties$2(type, props, /* canUseEventSystem */true);
	  };

	  // IE 11 parses & normalizes the style attribute as opposed to other
	  // browsers. It adds spaces and sorts the properties in some
	  // non-alphabetical order. Handling that would require sorting CSS
	  // properties in the client & server versions or applying
	  // `expectedStyle` to a temporary DOM node to read its `style` attribute
	  // normalized. Since it only affects IE, we're skipping style warnings
	  // in that browser completely in favor of doing all that work.
	  // See https://github.com/facebook/react/issues/11807
	  canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;

	  // HTML parsing normalizes CR and CRLF to LF.
	  // It also can turn \u0000 into \uFFFD inside attributes.
	  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
	  // If we have a mismatch, it might be caused by that.
	  // We will still patch up in this case but not fire the warning.
	  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
	  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

	  normalizeMarkupForTextOrAttribute = function (markup) {
	    var markupString = typeof markup === 'string' ? markup : '' + markup;
	    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
	  };

	  warnForTextDifference = function (serverText, clientText) {
	    if (didWarnInvalidHydration) {
	      return;
	    }
	    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
	    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
	    if (normalizedServerText === normalizedClientText) {
	      return;
	    }
	    didWarnInvalidHydration = true;
	    warningWithoutStack$1(false, 'Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
	  };

	  warnForPropDifference = function (propName, serverValue, clientValue) {
	    if (didWarnInvalidHydration) {
	      return;
	    }
	    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
	    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
	    if (normalizedServerValue === normalizedClientValue) {
	      return;
	    }
	    didWarnInvalidHydration = true;
	    warningWithoutStack$1(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
	  };

	  warnForExtraAttributes = function (attributeNames) {
	    if (didWarnInvalidHydration) {
	      return;
	    }
	    didWarnInvalidHydration = true;
	    var names = [];
	    attributeNames.forEach(function (name) {
	      names.push(name);
	    });
	    warningWithoutStack$1(false, 'Extra attributes from the server: %s', names);
	  };

	  warnForInvalidEventListener = function (registrationName, listener) {
	    if (listener === false) {
	      warning$1(false, 'Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', registrationName, registrationName, registrationName);
	    } else {
	      warning$1(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener);
	    }
	  };

	  // Parse the HTML and read it back to normalize the HTML string so that it
	  // can be used for comparison.
	  normalizeHTML = function (parent, html) {
	    // We could have created a separate document here to avoid
	    // re-initializing custom elements if they exist. But this breaks
	    // how <noscript> is being handled. So we use the same document.
	    // See the discussion in https://github.com/facebook/react/pull/11157.
	    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
	    testElement.innerHTML = html;
	    return testElement.innerHTML;
	  };
	}

	function ensureListeningTo(rootContainerElement, registrationName) {
	  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
	  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
	  listenTo(registrationName, doc);
	}

	function getOwnerDocumentFromRootContainer(rootContainerElement) {
	  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
	}

	function noop() {}

	function trapClickOnNonInteractiveElement(node) {
	  // Mobile Safari does not fire properly bubble click events on
	  // non-interactive elements, which means delegated click listeners do not
	  // fire. The workaround for this bug involves attaching an empty click
	  // listener on the target node.
	  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	  // Just set it using the onclick property so that we don't have to manage any
	  // bookkeeping for it. Not sure if we need to clear it when the listener is
	  // removed.
	  // TODO: Only do this for the relevant Safaris maybe?
	  node.onclick = noop;
	}

	function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
	  for (var propKey in nextProps) {
	    if (!nextProps.hasOwnProperty(propKey)) {
	      continue;
	    }
	    var nextProp = nextProps[propKey];
	    if (propKey === STYLE$1) {
	      {
	        if (nextProp) {
	          // Freeze the next style object so that we can assume it won't be
	          // mutated. We have already warned for this in the past.
	          Object.freeze(nextProp);
	        }
	      }
	      // Relies on `updateStylesByID` not mutating `styleUpdates`.
	      setValueForStyles(domElement, nextProp);
	    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
	      var nextHtml = nextProp ? nextProp[HTML] : undefined;
	      if (nextHtml != null) {
	        setInnerHTML(domElement, nextHtml);
	      }
	    } else if (propKey === CHILDREN) {
	      if (typeof nextProp === 'string') {
	        // Avoid setting initial textContent when the text is empty. In IE11 setting
	        // textContent on a <textarea> will cause the placeholder to not
	        // show within the <textarea> until it has been focused and blurred again.
	        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
	        var canSetTextContent = tag !== 'textarea' || nextProp !== '';
	        if (canSetTextContent) {
	          setTextContent(domElement, nextProp);
	        }
	      } else if (typeof nextProp === 'number') {
	        setTextContent(domElement, '' + nextProp);
	      }
	    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) ; else if (propKey === AUTOFOCUS) ; else if (registrationNameModules.hasOwnProperty(propKey)) {
	      if (nextProp != null) {
	        if (typeof nextProp !== 'function') {
	          warnForInvalidEventListener(propKey, nextProp);
	        }
	        ensureListeningTo(rootContainerElement, propKey);
	      }
	    } else if (nextProp != null) {
	      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
	    }
	  }
	}

	function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
	  // TODO: Handle wasCustomComponentTag
	  for (var i = 0; i < updatePayload.length; i += 2) {
	    var propKey = updatePayload[i];
	    var propValue = updatePayload[i + 1];
	    if (propKey === STYLE$1) {
	      setValueForStyles(domElement, propValue);
	    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
	      setInnerHTML(domElement, propValue);
	    } else if (propKey === CHILDREN) {
	      setTextContent(domElement, propValue);
	    } else {
	      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
	    }
	  }
	}

	function createElement(type, props, rootContainerElement, parentNamespace) {
	  var isCustomComponentTag = void 0;

	  // We create tags in the namespace of their parent container, except HTML
	  // tags get no namespace.
	  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
	  var domElement = void 0;
	  var namespaceURI = parentNamespace;
	  if (namespaceURI === HTML_NAMESPACE) {
	    namespaceURI = getIntrinsicNamespace(type);
	  }
	  if (namespaceURI === HTML_NAMESPACE) {
	    {
	      isCustomComponentTag = isCustomComponent(type, props);
	      // Should this check be gated by parent namespace? Not sure we want to
	      // allow <SVG> or <mATH>.
	      !(isCustomComponentTag || type === type.toLowerCase()) ? warning$1(false, '<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', type) : void 0;
	    }

	    if (type === 'script') {
	      // Create the script via .innerHTML so its "parser-inserted" flag is
	      // set to true and it does not execute
	      var div = ownerDocument.createElement('div');
	      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
	      // This is guaranteed to yield a script element.
	      var firstChild = div.firstChild;
	      domElement = div.removeChild(firstChild);
	    } else if (typeof props.is === 'string') {
	      // $FlowIssue `createElement` should be updated for Web Components
	      domElement = ownerDocument.createElement(type, { is: props.is });
	    } else {
	      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
	      // See discussion in https://github.com/facebook/react/pull/6896
	      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	      domElement = ownerDocument.createElement(type);
	      // Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`
	      // attributes on `select`s needs to be added before `option`s are inserted.
	      // This prevents:
	      // - a bug where the `select` does not scroll to the correct option because singular
	      //  `select` elements automatically pick the first item #13222
	      // - a bug where the `select` set the first item as selected despite the `size` attribute #14239
	      // See https://github.com/facebook/react/issues/13222
	      // and https://github.com/facebook/react/issues/14239
	      if (type === 'select') {
	        var node = domElement;
	        if (props.multiple) {
	          node.multiple = true;
	        } else if (props.size) {
	          // Setting a size greater than 1 causes a select to behave like `multiple=true`, where
	          // it is possible that no option is selected.
	          //
	          // This is only necessary when a select in "single selection mode".
	          node.size = props.size;
	        }
	      }
	    }
	  } else {
	    domElement = ownerDocument.createElementNS(namespaceURI, type);
	  }

	  {
	    if (namespaceURI === HTML_NAMESPACE) {
	      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
	        warnedUnknownTags[type] = true;
	        warning$1(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
	      }
	    }
	  }

	  return domElement;
	}

	function createTextNode(text, rootContainerElement) {
	  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
	}

	function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
	  var isCustomComponentTag = isCustomComponent(tag, rawProps);
	  {
	    validatePropertiesInDevelopment(tag, rawProps);
	    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
	      warning$1(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerNameInDevOrNull() || 'A component');
	      didWarnShadyDOM = true;
	    }
	  }

	  // TODO: Make sure that we check isMounted before firing any of these events.
	  var props = void 0;
	  switch (tag) {
	    case 'iframe':
	    case 'object':
	      trapBubbledEvent(TOP_LOAD, domElement);
	      props = rawProps;
	      break;
	    case 'video':
	    case 'audio':
	      // Create listener for each media event
	      for (var i = 0; i < mediaEventTypes.length; i++) {
	        trapBubbledEvent(mediaEventTypes[i], domElement);
	      }
	      props = rawProps;
	      break;
	    case 'source':
	      trapBubbledEvent(TOP_ERROR, domElement);
	      props = rawProps;
	      break;
	    case 'img':
	    case 'image':
	    case 'link':
	      trapBubbledEvent(TOP_ERROR, domElement);
	      trapBubbledEvent(TOP_LOAD, domElement);
	      props = rawProps;
	      break;
	    case 'form':
	      trapBubbledEvent(TOP_RESET, domElement);
	      trapBubbledEvent(TOP_SUBMIT, domElement);
	      props = rawProps;
	      break;
	    case 'details':
	      trapBubbledEvent(TOP_TOGGLE, domElement);
	      props = rawProps;
	      break;
	    case 'input':
	      initWrapperState(domElement, rawProps);
	      props = getHostProps(domElement, rawProps);
	      trapBubbledEvent(TOP_INVALID, domElement);
	      // For controlled components we always need to ensure we're listening
	      // to onChange. Even if there is no listener.
	      ensureListeningTo(rootContainerElement, 'onChange');
	      break;
	    case 'option':
	      validateProps(domElement, rawProps);
	      props = getHostProps$1(domElement, rawProps);
	      break;
	    case 'select':
	      initWrapperState$1(domElement, rawProps);
	      props = getHostProps$2(domElement, rawProps);
	      trapBubbledEvent(TOP_INVALID, domElement);
	      // For controlled components we always need to ensure we're listening
	      // to onChange. Even if there is no listener.
	      ensureListeningTo(rootContainerElement, 'onChange');
	      break;
	    case 'textarea':
	      initWrapperState$2(domElement, rawProps);
	      props = getHostProps$3(domElement, rawProps);
	      trapBubbledEvent(TOP_INVALID, domElement);
	      // For controlled components we always need to ensure we're listening
	      // to onChange. Even if there is no listener.
	      ensureListeningTo(rootContainerElement, 'onChange');
	      break;
	    default:
	      props = rawProps;
	  }

	  assertValidProps(tag, props);

	  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

	  switch (tag) {
	    case 'input':
	      // TODO: Make sure we check if this is still unmounted or do any clean
	      // up necessary since we never stop tracking anymore.
	      track(domElement);
	      postMountWrapper(domElement, rawProps, false);
	      break;
	    case 'textarea':
	      // TODO: Make sure we check if this is still unmounted or do any clean
	      // up necessary since we never stop tracking anymore.
	      track(domElement);
	      postMountWrapper$3(domElement, rawProps);
	      break;
	    case 'option':
	      postMountWrapper$1(domElement, rawProps);
	      break;
	    case 'select':
	      postMountWrapper$2(domElement, rawProps);
	      break;
	    default:
	      if (typeof props.onClick === 'function') {
	        // TODO: This cast may not be sound for SVG, MathML or custom elements.
	        trapClickOnNonInteractiveElement(domElement);
	      }
	      break;
	  }
	}

	// Calculate the diff between the two objects.
	function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
	  {
	    validatePropertiesInDevelopment(tag, nextRawProps);
	  }

	  var updatePayload = null;

	  var lastProps = void 0;
	  var nextProps = void 0;
	  switch (tag) {
	    case 'input':
	      lastProps = getHostProps(domElement, lastRawProps);
	      nextProps = getHostProps(domElement, nextRawProps);
	      updatePayload = [];
	      break;
	    case 'option':
	      lastProps = getHostProps$1(domElement, lastRawProps);
	      nextProps = getHostProps$1(domElement, nextRawProps);
	      updatePayload = [];
	      break;
	    case 'select':
	      lastProps = getHostProps$2(domElement, lastRawProps);
	      nextProps = getHostProps$2(domElement, nextRawProps);
	      updatePayload = [];
	      break;
	    case 'textarea':
	      lastProps = getHostProps$3(domElement, lastRawProps);
	      nextProps = getHostProps$3(domElement, nextRawProps);
	      updatePayload = [];
	      break;
	    default:
	      lastProps = lastRawProps;
	      nextProps = nextRawProps;
	      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
	        // TODO: This cast may not be sound for SVG, MathML or custom elements.
	        trapClickOnNonInteractiveElement(domElement);
	      }
	      break;
	  }

	  assertValidProps(tag, nextProps);

	  var propKey = void 0;
	  var styleName = void 0;
	  var styleUpdates = null;
	  for (propKey in lastProps) {
	    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	      continue;
	    }
	    if (propKey === STYLE$1) {
	      var lastStyle = lastProps[propKey];
	      for (styleName in lastStyle) {
	        if (lastStyle.hasOwnProperty(styleName)) {
	          if (!styleUpdates) {
	            styleUpdates = {};
	          }
	          styleUpdates[styleName] = '';
	        }
	      }
	    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ; else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) ; else if (propKey === AUTOFOCUS) ; else if (registrationNameModules.hasOwnProperty(propKey)) {
	      // This is a special case. If any listener updates we need to ensure
	      // that the "current" fiber pointer gets updated so we need a commit
	      // to update this element.
	      if (!updatePayload) {
	        updatePayload = [];
	      }
	    } else {
	      // For all other deleted properties we add it to the queue. We use
	      // the whitelist in the commit phase instead.
	      (updatePayload = updatePayload || []).push(propKey, null);
	    }
	  }
	  for (propKey in nextProps) {
	    var nextProp = nextProps[propKey];
	    var lastProp = lastProps != null ? lastProps[propKey] : undefined;
	    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	      continue;
	    }
	    if (propKey === STYLE$1) {
	      {
	        if (nextProp) {
	          // Freeze the next style object so that we can assume it won't be
	          // mutated. We have already warned for this in the past.
	          Object.freeze(nextProp);
	        }
	      }
	      if (lastProp) {
	        // Unset styles on `lastProp` but not on `nextProp`.
	        for (styleName in lastProp) {
	          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	            if (!styleUpdates) {
	              styleUpdates = {};
	            }
	            styleUpdates[styleName] = '';
	          }
	        }
	        // Update styles that changed since `lastProp`.
	        for (styleName in nextProp) {
	          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	            if (!styleUpdates) {
	              styleUpdates = {};
	            }
	            styleUpdates[styleName] = nextProp[styleName];
	          }
	        }
	      } else {
	        // Relies on `updateStylesByID` not mutating `styleUpdates`.
	        if (!styleUpdates) {
	          if (!updatePayload) {
	            updatePayload = [];
	          }
	          updatePayload.push(propKey, styleUpdates);
	        }
	        styleUpdates = nextProp;
	      }
	    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
	      var nextHtml = nextProp ? nextProp[HTML] : undefined;
	      var lastHtml = lastProp ? lastProp[HTML] : undefined;
	      if (nextHtml != null) {
	        if (lastHtml !== nextHtml) {
	          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);
	        }
	      }
	    } else if (propKey === CHILDREN) {
	      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {
	        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
	      }
	    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) ; else if (registrationNameModules.hasOwnProperty(propKey)) {
	      if (nextProp != null) {
	        // We eagerly listen to this even though we haven't committed yet.
	        if (typeof nextProp !== 'function') {
	          warnForInvalidEventListener(propKey, nextProp);
	        }
	        ensureListeningTo(rootContainerElement, propKey);
	      }
	      if (!updatePayload && lastProp !== nextProp) {
	        // This is a special case. If any listener updates we need to ensure
	        // that the "current" props pointer gets updated so we need a commit
	        // to update this element.
	        updatePayload = [];
	      }
	    } else {
	      // For any other property we always add it to the queue and then we
	      // filter it out using the whitelist during the commit.
	      (updatePayload = updatePayload || []).push(propKey, nextProp);
	    }
	  }
	  if (styleUpdates) {
	    {
	      validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE$1]);
	    }
	    (updatePayload = updatePayload || []).push(STYLE$1, styleUpdates);
	  }
	  return updatePayload;
	}

	// Apply the diff.
	function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
	  // Update checked *before* name.
	  // In the middle of an update, it is possible to have multiple checked.
	  // When a checked radio tries to change name, browser makes another radio's checked false.
	  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
	    updateChecked(domElement, nextRawProps);
	  }

	  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
	  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
	  // Apply the diff.
	  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);

	  // TODO: Ensure that an update gets scheduled if any of the special props
	  // changed.
	  switch (tag) {
	    case 'input':
	      // Update the wrapper around inputs *after* updating props. This has to
	      // happen after `updateDOMProperties`. Otherwise HTML5 input validations
	      // raise warnings and prevent the new value from being assigned.
	      updateWrapper(domElement, nextRawProps);
	      break;
	    case 'textarea':
	      updateWrapper$1(domElement, nextRawProps);
	      break;
	    case 'select':
	      // <select> value update needs to occur after <option> children
	      // reconciliation
	      postUpdateWrapper(domElement, nextRawProps);
	      break;
	  }
	}

	function getPossibleStandardName(propName) {
	  {
	    var lowerCasedName = propName.toLowerCase();
	    if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
	      return null;
	    }
	    return possibleStandardNames[lowerCasedName] || null;
	  }
	  return null;
	}

	function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
	  var isCustomComponentTag = void 0;
	  var extraAttributeNames = void 0;

	  {
	    suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;
	    isCustomComponentTag = isCustomComponent(tag, rawProps);
	    validatePropertiesInDevelopment(tag, rawProps);
	    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
	      warning$1(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerNameInDevOrNull() || 'A component');
	      didWarnShadyDOM = true;
	    }
	  }

	  // TODO: Make sure that we check isMounted before firing any of these events.
	  switch (tag) {
	    case 'iframe':
	    case 'object':
	      trapBubbledEvent(TOP_LOAD, domElement);
	      break;
	    case 'video':
	    case 'audio':
	      // Create listener for each media event
	      for (var i = 0; i < mediaEventTypes.length; i++) {
	        trapBubbledEvent(mediaEventTypes[i], domElement);
	      }
	      break;
	    case 'source':
	      trapBubbledEvent(TOP_ERROR, domElement);
	      break;
	    case 'img':
	    case 'image':
	    case 'link':
	      trapBubbledEvent(TOP_ERROR, domElement);
	      trapBubbledEvent(TOP_LOAD, domElement);
	      break;
	    case 'form':
	      trapBubbledEvent(TOP_RESET, domElement);
	      trapBubbledEvent(TOP_SUBMIT, domElement);
	      break;
	    case 'details':
	      trapBubbledEvent(TOP_TOGGLE, domElement);
	      break;
	    case 'input':
	      initWrapperState(domElement, rawProps);
	      trapBubbledEvent(TOP_INVALID, domElement);
	      // For controlled components we always need to ensure we're listening
	      // to onChange. Even if there is no listener.
	      ensureListeningTo(rootContainerElement, 'onChange');
	      break;
	    case 'option':
	      validateProps(domElement, rawProps);
	      break;
	    case 'select':
	      initWrapperState$1(domElement, rawProps);
	      trapBubbledEvent(TOP_INVALID, domElement);
	      // For controlled components we always need to ensure we're listening
	      // to onChange. Even if there is no listener.
	      ensureListeningTo(rootContainerElement, 'onChange');
	      break;
	    case 'textarea':
	      initWrapperState$2(domElement, rawProps);
	      trapBubbledEvent(TOP_INVALID, domElement);
	      // For controlled components we always need to ensure we're listening
	      // to onChange. Even if there is no listener.
	      ensureListeningTo(rootContainerElement, 'onChange');
	      break;
	  }

	  assertValidProps(tag, rawProps);

	  {
	    extraAttributeNames = new Set();
	    var attributes = domElement.attributes;
	    for (var _i = 0; _i < attributes.length; _i++) {
	      var name = attributes[_i].name.toLowerCase();
	      switch (name) {
	        // Built-in SSR attribute is whitelisted
	        case 'data-reactroot':
	          break;
	        // Controlled attributes are not validated
	        // TODO: Only ignore them on controlled tags.
	        case 'value':
	          break;
	        case 'checked':
	          break;
	        case 'selected':
	          break;
	        default:
	          // Intentionally use the original name.
	          // See discussion in https://github.com/facebook/react/pull/10676.
	          extraAttributeNames.add(attributes[_i].name);
	      }
	    }
	  }

	  var updatePayload = null;
	  for (var propKey in rawProps) {
	    if (!rawProps.hasOwnProperty(propKey)) {
	      continue;
	    }
	    var nextProp = rawProps[propKey];
	    if (propKey === CHILDREN) {
	      // For text content children we compare against textContent. This
	      // might match additional HTML that is hidden when we read it using
	      // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
	      // satisfies our requirement. Our requirement is not to produce perfect
	      // HTML and attributes. Ideally we should preserve structure but it's
	      // ok not to if the visible content is still enough to indicate what
	      // even listeners these nodes might be wired up to.
	      // TODO: Warn if there is more than a single textNode as a child.
	      // TODO: Should we use domElement.firstChild.nodeValue to compare?
	      if (typeof nextProp === 'string') {
	        if (domElement.textContent !== nextProp) {
	          if (!suppressHydrationWarning) {
	            warnForTextDifference(domElement.textContent, nextProp);
	          }
	          updatePayload = [CHILDREN, nextProp];
	        }
	      } else if (typeof nextProp === 'number') {
	        if (domElement.textContent !== '' + nextProp) {
	          if (!suppressHydrationWarning) {
	            warnForTextDifference(domElement.textContent, nextProp);
	          }
	          updatePayload = [CHILDREN, '' + nextProp];
	        }
	      }
	    } else if (registrationNameModules.hasOwnProperty(propKey)) {
	      if (nextProp != null) {
	        if (typeof nextProp !== 'function') {
	          warnForInvalidEventListener(propKey, nextProp);
	        }
	        ensureListeningTo(rootContainerElement, propKey);
	      }
	    } else if (typeof isCustomComponentTag === 'boolean') {
	      // Validate that the properties correspond to their expected values.
	      var serverValue = void 0;
	      var propertyInfo = getPropertyInfo(propKey);
	      if (suppressHydrationWarning) ; else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||
	      // Controlled attributes are not validated
	      // TODO: Only ignore them on controlled tags.
	      propKey === 'value' || propKey === 'checked' || propKey === 'selected') ; else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
	        var serverHTML = domElement.innerHTML;
	        var nextHtml = nextProp ? nextProp[HTML] : undefined;
	        var expectedHTML = normalizeHTML(domElement, nextHtml != null ? nextHtml : '');
	        if (expectedHTML !== serverHTML) {
	          warnForPropDifference(propKey, serverHTML, expectedHTML);
	        }
	      } else if (propKey === STYLE$1) {
	        // $FlowFixMe - Should be inferred as not undefined.
	        extraAttributeNames.delete(propKey);

	        if (canDiffStyleForHydrationWarning) {
	          var expectedStyle = createDangerousStringForStyles(nextProp);
	          serverValue = domElement.getAttribute('style');
	          if (expectedStyle !== serverValue) {
	            warnForPropDifference(propKey, serverValue, expectedStyle);
	          }
	        }
	      } else if (isCustomComponentTag) {
	        // $FlowFixMe - Should be inferred as not undefined.
	        extraAttributeNames.delete(propKey.toLowerCase());
	        serverValue = getValueForAttribute(domElement, propKey, nextProp);

	        if (nextProp !== serverValue) {
	          warnForPropDifference(propKey, serverValue, nextProp);
	        }
	      } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
	        var isMismatchDueToBadCasing = false;
	        if (propertyInfo !== null) {
	          // $FlowFixMe - Should be inferred as not undefined.
	          extraAttributeNames.delete(propertyInfo.attributeName);
	          serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
	        } else {
	          var ownNamespace = parentNamespace;
	          if (ownNamespace === HTML_NAMESPACE) {
	            ownNamespace = getIntrinsicNamespace(tag);
	          }
	          if (ownNamespace === HTML_NAMESPACE) {
	            // $FlowFixMe - Should be inferred as not undefined.
	            extraAttributeNames.delete(propKey.toLowerCase());
	          } else {
	            var standardName = getPossibleStandardName(propKey);
	            if (standardName !== null && standardName !== propKey) {
	              // If an SVG prop is supplied with bad casing, it will
	              // be successfully parsed from HTML, but will produce a mismatch
	              // (and would be incorrectly rendered on the client).
	              // However, we already warn about bad casing elsewhere.
	              // So we'll skip the misleading extra mismatch warning in this case.
	              isMismatchDueToBadCasing = true;
	              // $FlowFixMe - Should be inferred as not undefined.
	              extraAttributeNames.delete(standardName);
	            }
	            // $FlowFixMe - Should be inferred as not undefined.
	            extraAttributeNames.delete(propKey);
	          }
	          serverValue = getValueForAttribute(domElement, propKey, nextProp);
	        }

	        if (nextProp !== serverValue && !isMismatchDueToBadCasing) {
	          warnForPropDifference(propKey, serverValue, nextProp);
	        }
	      }
	    }
	  }

	  {
	    // $FlowFixMe - Should be inferred as not undefined.
	    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
	      // $FlowFixMe - Should be inferred as not undefined.
	      warnForExtraAttributes(extraAttributeNames);
	    }
	  }

	  switch (tag) {
	    case 'input':
	      // TODO: Make sure we check if this is still unmounted or do any clean
	      // up necessary since we never stop tracking anymore.
	      track(domElement);
	      postMountWrapper(domElement, rawProps, true);
	      break;
	    case 'textarea':
	      // TODO: Make sure we check if this is still unmounted or do any clean
	      // up necessary since we never stop tracking anymore.
	      track(domElement);
	      postMountWrapper$3(domElement, rawProps);
	      break;
	    case 'select':
	    case 'option':
	      // For input and textarea we current always set the value property at
	      // post mount to force it to diverge from attributes. However, for
	      // option and select we don't quite do the same thing and select
	      // is not resilient to the DOM state changing so we don't do that here.
	      // TODO: Consider not doing this for input and textarea.
	      break;
	    default:
	      if (typeof rawProps.onClick === 'function') {
	        // TODO: This cast may not be sound for SVG, MathML or custom elements.
	        trapClickOnNonInteractiveElement(domElement);
	      }
	      break;
	  }

	  return updatePayload;
	}

	function diffHydratedText(textNode, text) {
	  var isDifferent = textNode.nodeValue !== text;
	  return isDifferent;
	}

	function warnForUnmatchedText(textNode, text) {
	  {
	    warnForTextDifference(textNode.nodeValue, text);
	  }
	}

	function warnForDeletedHydratableElement(parentNode, child) {
	  {
	    if (didWarnInvalidHydration) {
	      return;
	    }
	    didWarnInvalidHydration = true;
	    warningWithoutStack$1(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
	  }
	}

	function warnForDeletedHydratableText(parentNode, child) {
	  {
	    if (didWarnInvalidHydration) {
	      return;
	    }
	    didWarnInvalidHydration = true;
	    warningWithoutStack$1(false, 'Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
	  }
	}

	function warnForInsertedHydratedElement(parentNode, tag, props) {
	  {
	    if (didWarnInvalidHydration) {
	      return;
	    }
	    didWarnInvalidHydration = true;
	    warningWithoutStack$1(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
	  }
	}

	function warnForInsertedHydratedText(parentNode, text) {
	  {
	    if (text === '') {
	      // We expect to insert empty text nodes since they're not represented in
	      // the HTML.
	      // TODO: Remove this special case if we can just avoid inserting empty
	      // text nodes.
	      return;
	    }
	    if (didWarnInvalidHydration) {
	      return;
	    }
	    didWarnInvalidHydration = true;
	    warningWithoutStack$1(false, 'Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
	  }
	}

	function restoreControlledState$1(domElement, tag, props) {
	  switch (tag) {
	    case 'input':
	      restoreControlledState(domElement, props);
	      return;
	    case 'textarea':
	      restoreControlledState$3(domElement, props);
	      return;
	    case 'select':
	      restoreControlledState$2(domElement, props);
	      return;
	  }
	}

	// TODO: direct imports like some-package/src/* are bad. Fix me.
	var validateDOMNesting = function () {};
	var updatedAncestorInfo = function () {};

	{
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.

	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];

	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);

	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

	  var emptyAncestorInfo = {
	    current: null,

	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,

	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };

	  updatedAncestorInfo = function (oldInfo, tag) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag };

	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }

	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }

	    ancestorInfo.current = info;

	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }

	    return ancestorInfo;
	  };

	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }

	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;

	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }

	    return true;
	  };

	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	      case 'pre':
	      case 'listing':
	      case 'table':
	      case 'hr':
	      case 'xmp':
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;

	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;

	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;

	      case 'button':
	        return ancestorInfo.buttonTagInScope;

	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;

	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }

	    return null;
	  };

	  var didWarn = {};

	  validateDOMNesting = function (childTag, childText, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;

	    if (childText != null) {
	      !(childTag == null) ? warningWithoutStack$1(false, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
	      childTag = '#text';
	    }

	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var invalidParentOrAncestor = invalidParent || invalidAncestor;
	    if (!invalidParentOrAncestor) {
	      return;
	    }

	    var ancestorTag = invalidParentOrAncestor.tag;
	    var addendum = getCurrentFiberStackInDev();

	    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;
	    if (didWarn[warnKey]) {
	      return;
	    }
	    didWarn[warnKey] = true;

	    var tagDisplayName = childTag;
	    var whitespaceInfo = '';
	    if (childTag === '#text') {
	      if (/\S/.test(childText)) {
	        tagDisplayName = 'Text nodes';
	      } else {
	        tagDisplayName = 'Whitespace text nodes';
	        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
	      }
	    } else {
	      tagDisplayName = '<' + childTag + '>';
	    }

	    if (invalidParent) {
	      var info = '';
	      if (ancestorTag === 'table' && childTag === 'tr') {
	        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	      }
	      warningWithoutStack$1(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);
	    } else {
	      warningWithoutStack$1(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);
	    }
	  };
	}

	var SUPPRESS_HYDRATION_WARNING = void 0;
	{
	  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
	}

	var SUSPENSE_START_DATA = '$';

	var STYLE = 'style';

	var eventsEnabled = null;
	var selectionInformation = null;

	function shouldAutoFocusHostComponent(type, props) {
	  switch (type) {
	    case 'button':
	    case 'input':
	    case 'select':
	    case 'textarea':
	      return !!props.autoFocus;
	  }
	  return false;
	}

	function getRootHostContext(rootContainerInstance) {
	  var type = void 0;
	  var namespace = void 0;
	  var nodeType = rootContainerInstance.nodeType;
	  switch (nodeType) {
	    case DOCUMENT_NODE:
	    case DOCUMENT_FRAGMENT_NODE:
	      {
	        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
	        var root = rootContainerInstance.documentElement;
	        namespace = root ? root.namespaceURI : getChildNamespace(null, '');
	        break;
	      }
	    default:
	      {
	        var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
	        var ownNamespace = container.namespaceURI || null;
	        type = container.tagName;
	        namespace = getChildNamespace(ownNamespace, type);
	        break;
	      }
	  }
	  {
	    var validatedTag = type.toLowerCase();
	    var _ancestorInfo = updatedAncestorInfo(null, validatedTag);
	    return { namespace: namespace, ancestorInfo: _ancestorInfo };
	  }
	  return namespace;
	}

	function getChildHostContext(parentHostContext, type, rootContainerInstance) {
	  {
	    var parentHostContextDev = parentHostContext;
	    var _namespace = getChildNamespace(parentHostContextDev.namespace, type);
	    var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
	    return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };
	  }
	  var parentNamespace = parentHostContext;
	  return getChildNamespace(parentNamespace, type);
	}

	function getPublicInstance(instance) {
	  return instance;
	}

	function prepareForCommit(containerInfo) {
	  eventsEnabled = isEnabled();
	  selectionInformation = getSelectionInformation();
	  setEnabled(false);
	}

	function resetAfterCommit(containerInfo) {
	  restoreSelection(selectionInformation);
	  selectionInformation = null;
	  setEnabled(eventsEnabled);
	  eventsEnabled = null;
	}

	function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
	  var parentNamespace = void 0;
	  {
	    // TODO: take namespace into account when validating.
	    var hostContextDev = hostContext;
	    validateDOMNesting(type, null, hostContextDev.ancestorInfo);
	    if (typeof props.children === 'string' || typeof props.children === 'number') {
	      var string = '' + props.children;
	      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
	      validateDOMNesting(null, string, ownAncestorInfo);
	    }
	    parentNamespace = hostContextDev.namespace;
	  }
	  var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
	  precacheFiberNode(internalInstanceHandle, domElement);
	  updateFiberProps(domElement, props);
	  return domElement;
	}

	function appendInitialChild(parentInstance, child) {
	  parentInstance.appendChild(child);
	}

	function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
	  setInitialProperties(domElement, type, props, rootContainerInstance);
	  return shouldAutoFocusHostComponent(type, props);
	}

	function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
	  {
	    var hostContextDev = hostContext;
	    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
	      var string = '' + newProps.children;
	      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
	      validateDOMNesting(null, string, ownAncestorInfo);
	    }
	  }
	  return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);
	}

	function shouldSetTextContent(type, props) {
	  return type === 'textarea' || type === 'option' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
	}

	function shouldDeprioritizeSubtree(type, props) {
	  return !!props.hidden;
	}

	function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
	  {
	    var hostContextDev = hostContext;
	    validateDOMNesting(null, text, hostContextDev.ancestorInfo);
	  }
	  var textNode = createTextNode(text, rootContainerInstance);
	  precacheFiberNode(internalInstanceHandle, textNode);
	  return textNode;
	}
	// This initialization code may run even on server environments
	// if a component just imports ReactDOM (e.g. for findDOMNode).
	// Some environments might not have setTimeout or clearTimeout.
	var scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
	var cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;
	var noTimeout = -1;
	var schedulePassiveEffects = scheduler$1.unstable_scheduleCallback;
	var cancelPassiveEffects = scheduler$1.unstable_cancelCallback;

	function commitMount(domElement, type, newProps, internalInstanceHandle) {
	  // Despite the naming that might imply otherwise, this method only
	  // fires if there is an `Update` effect scheduled during mounting.
	  // This happens if `finalizeInitialChildren` returns `true` (which it
	  // does to implement the `autoFocus` attribute on the client). But
	  // there are also other cases when this might happen (such as patching
	  // up text content during hydration mismatch). So we'll check this again.
	  if (shouldAutoFocusHostComponent(type, newProps)) {
	    domElement.focus();
	  }
	}

	function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
	  // Update the props handle so that we know which props are the ones with
	  // with current event handlers.
	  updateFiberProps(domElement, newProps);
	  // Apply the diff to the DOM node.
	  updateProperties(domElement, updatePayload, type, oldProps, newProps);
	}

	function resetTextContent(domElement) {
	  setTextContent(domElement, '');
	}

	function commitTextUpdate(textInstance, oldText, newText) {
	  textInstance.nodeValue = newText;
	}

	function appendChild(parentInstance, child) {
	  parentInstance.appendChild(child);
	}

	function appendChildToContainer(container, child) {
	  var parentNode = void 0;
	  if (container.nodeType === COMMENT_NODE) {
	    parentNode = container.parentNode;
	    parentNode.insertBefore(child, container);
	  } else {
	    parentNode = container;
	    parentNode.appendChild(child);
	  }
	  // This container might be used for a portal.
	  // If something inside a portal is clicked, that click should bubble
	  // through the React tree. However, on Mobile Safari the click would
	  // never bubble through the *DOM* tree unless an ancestor with onclick
	  // event exists. So we wouldn't see it and dispatch it.
	  // This is why we ensure that non React root containers have inline onclick
	  // defined.
	  // https://github.com/facebook/react/issues/11918
	  var reactRootContainer = container._reactRootContainer;
	  if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {
	    // TODO: This cast may not be sound for SVG, MathML or custom elements.
	    trapClickOnNonInteractiveElement(parentNode);
	  }
	}

	function insertBefore(parentInstance, child, beforeChild) {
	  parentInstance.insertBefore(child, beforeChild);
	}

	function insertInContainerBefore(container, child, beforeChild) {
	  if (container.nodeType === COMMENT_NODE) {
	    container.parentNode.insertBefore(child, beforeChild);
	  } else {
	    container.insertBefore(child, beforeChild);
	  }
	}

	function removeChild(parentInstance, child) {
	  parentInstance.removeChild(child);
	}

	function removeChildFromContainer(container, child) {
	  if (container.nodeType === COMMENT_NODE) {
	    container.parentNode.removeChild(child);
	  } else {
	    container.removeChild(child);
	  }
	}

	function hideInstance(instance) {
	  // TODO: Does this work for all element types? What about MathML? Should we
	  // pass host context to this method?
	  instance = instance;
	  instance.style.display = 'none';
	}

	function hideTextInstance(textInstance) {
	  textInstance.nodeValue = '';
	}

	function unhideInstance(instance, props) {
	  instance = instance;
	  var styleProp = props[STYLE];
	  var display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;
	  instance.style.display = dangerousStyleValue('display', display);
	}

	function unhideTextInstance(textInstance, text) {
	  textInstance.nodeValue = text;
	}

	function canHydrateInstance(instance, type, props) {
	  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
	    return null;
	  }
	  // This has now been refined to an element node.
	  return instance;
	}

	function canHydrateTextInstance(instance, text) {
	  if (text === '' || instance.nodeType !== TEXT_NODE) {
	    // Empty strings are not parsed by HTML so there won't be a correct match here.
	    return null;
	  }
	  // This has now been refined to a text node.
	  return instance;
	}

	function getNextHydratableSibling(instance) {
	  var node = instance.nextSibling;
	  // Skip non-hydratable nodes.
	  while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE && (!enableSuspenseServerRenderer || node.nodeType !== COMMENT_NODE || node.data !== SUSPENSE_START_DATA)) {
	    node = node.nextSibling;
	  }
	  return node;
	}

	function getFirstHydratableChild(parentInstance) {
	  var next = parentInstance.firstChild;
	  // Skip non-hydratable nodes.
	  while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE && (!enableSuspenseServerRenderer || next.nodeType !== COMMENT_NODE || next.data !== SUSPENSE_START_DATA)) {
	    next = next.nextSibling;
	  }
	  return next;
	}

	function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
	  precacheFiberNode(internalInstanceHandle, instance);
	  // TODO: Possibly defer this until the commit phase where all the events
	  // get attached.
	  updateFiberProps(instance, props);
	  var parentNamespace = void 0;
	  {
	    var hostContextDev = hostContext;
	    parentNamespace = hostContextDev.namespace;
	  }
	  return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);
	}

	function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
	  precacheFiberNode(internalInstanceHandle, textInstance);
	  return diffHydratedText(textInstance, text);
	}

	function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {
	  {
	    warnForUnmatchedText(textInstance, text);
	  }
	}

	function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {
	  if (parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
	    warnForUnmatchedText(textInstance, text);
	  }
	}

	function didNotHydrateContainerInstance(parentContainer, instance) {
	  {
	    if (instance.nodeType === ELEMENT_NODE) {
	      warnForDeletedHydratableElement(parentContainer, instance);
	    } else if (instance.nodeType === COMMENT_NODE) ; else {
	      warnForDeletedHydratableText(parentContainer, instance);
	    }
	  }
	}

	function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
	  if (parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
	    if (instance.nodeType === ELEMENT_NODE) {
	      warnForDeletedHydratableElement(parentInstance, instance);
	    } else if (instance.nodeType === COMMENT_NODE) ; else {
	      warnForDeletedHydratableText(parentInstance, instance);
	    }
	  }
	}

	function didNotFindHydratableContainerInstance(parentContainer, type, props) {
	  {
	    warnForInsertedHydratedElement(parentContainer, type, props);
	  }
	}

	function didNotFindHydratableContainerTextInstance(parentContainer, text) {
	  {
	    warnForInsertedHydratedText(parentContainer, text);
	  }
	}



	function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
	  if (parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
	    warnForInsertedHydratedElement(parentInstance, type, props);
	  }
	}

	function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {
	  if (parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
	    warnForInsertedHydratedText(parentInstance, text);
	  }
	}

	function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {
	  if (parentProps[SUPPRESS_HYDRATION_WARNING] !== true) ;
	}

	// Prefix measurements so that it's possible to filter them.
	// Longer prefixes are hard to read in DevTools.
	var reactEmoji = '\u269B';
	var warningEmoji = '\u26D4';
	var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

	// Keep track of current fiber so that we know the path to unwind on pause.
	// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
	var currentFiber = null;
	// If we're in the middle of user code, which fiber and method is it?
	// Reusing `currentFiber` would be confusing for this because user code fiber
	// can change during commit phase too, but we don't need to unwind it (since
	// lifecycles in the commit phase don't resemble a tree).
	var currentPhase = null;
	var currentPhaseFiber = null;
	// Did lifecycle hook schedule an update? This is often a performance problem,
	// so we will keep track of it, and include it in the report.
	// Track commits caused by cascading updates.
	var isCommitting = false;
	var hasScheduledUpdateInCurrentCommit = false;
	var hasScheduledUpdateInCurrentPhase = false;
	var commitCountInCurrentWorkLoop = 0;
	var effectCountInCurrentCommit = 0;
	var isWaitingForCallback = false;
	// During commits, we only show a measurement once per method name
	// to avoid stretch the commit phase with measurement overhead.
	var labelsInCurrentCommit = new Set();

	var formatMarkName = function (markName) {
	  return reactEmoji + ' ' + markName;
	};

	var formatLabel = function (label, warning) {
	  var prefix = warning ? warningEmoji + ' ' : reactEmoji + ' ';
	  var suffix = warning ? ' Warning: ' + warning : '';
	  return '' + prefix + label + suffix;
	};

	var beginMark = function (markName) {
	  performance.mark(formatMarkName(markName));
	};

	var clearMark = function (markName) {
	  performance.clearMarks(formatMarkName(markName));
	};

	var endMark = function (label, markName, warning) {
	  var formattedMarkName = formatMarkName(markName);
	  var formattedLabel = formatLabel(label, warning);
	  try {
	    performance.measure(formattedLabel, formattedMarkName);
	  } catch (err) {}
	  // If previous mark was missing for some reason, this will throw.
	  // This could only happen if React crashed in an unexpected place earlier.
	  // Don't pile on with more errors.

	  // Clear marks immediately to avoid growing buffer.
	  performance.clearMarks(formattedMarkName);
	  performance.clearMeasures(formattedLabel);
	};

	var getFiberMarkName = function (label, debugID) {
	  return label + ' (#' + debugID + ')';
	};

	var getFiberLabel = function (componentName, isMounted, phase) {
	  if (phase === null) {
	    // These are composite component total time measurements.
	    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';
	  } else {
	    // Composite component methods.
	    return componentName + '.' + phase;
	  }
	};

	var beginFiberMark = function (fiber, phase) {
	  var componentName = getComponentName(fiber.type) || 'Unknown';
	  var debugID = fiber._debugID;
	  var isMounted = fiber.alternate !== null;
	  var label = getFiberLabel(componentName, isMounted, phase);

	  if (isCommitting && labelsInCurrentCommit.has(label)) {
	    // During the commit phase, we don't show duplicate labels because
	    // there is a fixed overhead for every measurement, and we don't
	    // want to stretch the commit phase beyond necessary.
	    return false;
	  }
	  labelsInCurrentCommit.add(label);

	  var markName = getFiberMarkName(label, debugID);
	  beginMark(markName);
	  return true;
	};

	var clearFiberMark = function (fiber, phase) {
	  var componentName = getComponentName(fiber.type) || 'Unknown';
	  var debugID = fiber._debugID;
	  var isMounted = fiber.alternate !== null;
	  var label = getFiberLabel(componentName, isMounted, phase);
	  var markName = getFiberMarkName(label, debugID);
	  clearMark(markName);
	};

	var endFiberMark = function (fiber, phase, warning) {
	  var componentName = getComponentName(fiber.type) || 'Unknown';
	  var debugID = fiber._debugID;
	  var isMounted = fiber.alternate !== null;
	  var label = getFiberLabel(componentName, isMounted, phase);
	  var markName = getFiberMarkName(label, debugID);
	  endMark(label, markName, warning);
	};

	var shouldIgnoreFiber = function (fiber) {
	  // Host components should be skipped in the timeline.
	  // We could check typeof fiber.type, but does this work with RN?
	  switch (fiber.tag) {
	    case HostRoot:
	    case HostComponent:
	    case HostText:
	    case HostPortal:
	    case Fragment:
	    case ContextProvider:
	    case ContextConsumer:
	    case Mode:
	      return true;
	    default:
	      return false;
	  }
	};

	var clearPendingPhaseMeasurement = function () {
	  if (currentPhase !== null && currentPhaseFiber !== null) {
	    clearFiberMark(currentPhaseFiber, currentPhase);
	  }
	  currentPhaseFiber = null;
	  currentPhase = null;
	  hasScheduledUpdateInCurrentPhase = false;
	};

	var pauseTimers = function () {
	  // Stops all currently active measurements so that they can be resumed
	  // if we continue in a later deferred loop from the same unit of work.
	  var fiber = currentFiber;
	  while (fiber) {
	    if (fiber._debugIsCurrentlyTiming) {
	      endFiberMark(fiber, null, null);
	    }
	    fiber = fiber.return;
	  }
	};

	var resumeTimersRecursively = function (fiber) {
	  if (fiber.return !== null) {
	    resumeTimersRecursively(fiber.return);
	  }
	  if (fiber._debugIsCurrentlyTiming) {
	    beginFiberMark(fiber, null);
	  }
	};

	var resumeTimers = function () {
	  // Resumes all measurements that were active during the last deferred loop.
	  if (currentFiber !== null) {
	    resumeTimersRecursively(currentFiber);
	  }
	};

	function recordEffect() {
	  {
	    effectCountInCurrentCommit++;
	  }
	}

	function recordScheduleUpdate() {
	  {
	    if (isCommitting) {
	      hasScheduledUpdateInCurrentCommit = true;
	    }
	    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {
	      hasScheduledUpdateInCurrentPhase = true;
	    }
	  }
	}

	function startRequestCallbackTimer() {
	  {
	    if (supportsUserTiming && !isWaitingForCallback) {
	      isWaitingForCallback = true;
	      beginMark('(Waiting for async callback...)');
	    }
	  }
	}

	function stopRequestCallbackTimer(didExpire, expirationTime) {
	  {
	    if (supportsUserTiming) {
	      isWaitingForCallback = false;
	      var warning = didExpire ? 'React was blocked by main thread' : null;
	      endMark('(Waiting for async callback... will force flush in ' + expirationTime + ' ms)', '(Waiting for async callback...)', warning);
	    }
	  }
	}

	function startWorkTimer(fiber) {
	  {
	    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
	      return;
	    }
	    // If we pause, this is the fiber to unwind from.
	    currentFiber = fiber;
	    if (!beginFiberMark(fiber, null)) {
	      return;
	    }
	    fiber._debugIsCurrentlyTiming = true;
	  }
	}

	function cancelWorkTimer(fiber) {
	  {
	    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
	      return;
	    }
	    // Remember we shouldn't complete measurement for this fiber.
	    // Otherwise flamechart will be deep even for small updates.
	    fiber._debugIsCurrentlyTiming = false;
	    clearFiberMark(fiber, null);
	  }
	}

	function stopWorkTimer(fiber) {
	  {
	    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
	      return;
	    }
	    // If we pause, its parent is the fiber to unwind from.
	    currentFiber = fiber.return;
	    if (!fiber._debugIsCurrentlyTiming) {
	      return;
	    }
	    fiber._debugIsCurrentlyTiming = false;
	    endFiberMark(fiber, null, null);
	  }
	}

	function stopFailedWorkTimer(fiber) {
	  {
	    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
	      return;
	    }
	    // If we pause, its parent is the fiber to unwind from.
	    currentFiber = fiber.return;
	    if (!fiber._debugIsCurrentlyTiming) {
	      return;
	    }
	    fiber._debugIsCurrentlyTiming = false;
	    var warning = fiber.tag === SuspenseComponent || fiber.tag === DehydratedSuspenseComponent ? 'Rendering was suspended' : 'An error was thrown inside this error boundary';
	    endFiberMark(fiber, null, warning);
	  }
	}

	function startPhaseTimer(fiber, phase) {
	  {
	    if (!supportsUserTiming) {
	      return;
	    }
	    clearPendingPhaseMeasurement();
	    if (!beginFiberMark(fiber, phase)) {
	      return;
	    }
	    currentPhaseFiber = fiber;
	    currentPhase = phase;
	  }
	}

	function stopPhaseTimer() {
	  {
	    if (!supportsUserTiming) {
	      return;
	    }
	    if (currentPhase !== null && currentPhaseFiber !== null) {
	      var warning = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;
	      endFiberMark(currentPhaseFiber, currentPhase, warning);
	    }
	    currentPhase = null;
	    currentPhaseFiber = null;
	  }
	}

	function startWorkLoopTimer(nextUnitOfWork) {
	  {
	    currentFiber = nextUnitOfWork;
	    if (!supportsUserTiming) {
	      return;
	    }
	    commitCountInCurrentWorkLoop = 0;
	    // This is top level call.
	    // Any other measurements are performed within.
	    beginMark('(React Tree Reconciliation)');
	    // Resume any measurements that were in progress during the last loop.
	    resumeTimers();
	  }
	}

	function stopWorkLoopTimer(interruptedBy, didCompleteRoot) {
	  {
	    if (!supportsUserTiming) {
	      return;
	    }
	    var warning = null;
	    if (interruptedBy !== null) {
	      if (interruptedBy.tag === HostRoot) {
	        warning = 'A top-level update interrupted the previous render';
	      } else {
	        var componentName = getComponentName(interruptedBy.type) || 'Unknown';
	        warning = 'An update to ' + componentName + ' interrupted the previous render';
	      }
	    } else if (commitCountInCurrentWorkLoop > 1) {
	      warning = 'There were cascading updates';
	    }
	    commitCountInCurrentWorkLoop = 0;
	    var label = didCompleteRoot ? '(React Tree Reconciliation: Completed Root)' : '(React Tree Reconciliation: Yielded)';
	    // Pause any measurements until the next loop.
	    pauseTimers();
	    endMark(label, '(React Tree Reconciliation)', warning);
	  }
	}

	function startCommitTimer() {
	  {
	    if (!supportsUserTiming) {
	      return;
	    }
	    isCommitting = true;
	    hasScheduledUpdateInCurrentCommit = false;
	    labelsInCurrentCommit.clear();
	    beginMark('(Committing Changes)');
	  }
	}

	function stopCommitTimer() {
	  {
	    if (!supportsUserTiming) {
	      return;
	    }

	    var warning = null;
	    if (hasScheduledUpdateInCurrentCommit) {
	      warning = 'Lifecycle hook scheduled a cascading update';
	    } else if (commitCountInCurrentWorkLoop > 0) {
	      warning = 'Caused by a cascading update in earlier commit';
	    }
	    hasScheduledUpdateInCurrentCommit = false;
	    commitCountInCurrentWorkLoop++;
	    isCommitting = false;
	    labelsInCurrentCommit.clear();

	    endMark('(Committing Changes)', '(Committing Changes)', warning);
	  }
	}

	function startCommitSnapshotEffectsTimer() {
	  {
	    if (!supportsUserTiming) {
	      return;
	    }
	    effectCountInCurrentCommit = 0;
	    beginMark('(Committing Snapshot Effects)');
	  }
	}

	function stopCommitSnapshotEffectsTimer() {
	  {
	    if (!supportsUserTiming) {
	      return;
	    }
	    var count = effectCountInCurrentCommit;
	    effectCountInCurrentCommit = 0;
	    endMark('(Committing Snapshot Effects: ' + count + ' Total)', '(Committing Snapshot Effects)', null);
	  }
	}

	function startCommitHostEffectsTimer() {
	  {
	    if (!supportsUserTiming) {
	      return;
	    }
	    effectCountInCurrentCommit = 0;
	    beginMark('(Committing Host Effects)');
	  }
	}

	function stopCommitHostEffectsTimer() {
	  {
	    if (!supportsUserTiming) {
	      return;
	    }
	    var count = effectCountInCurrentCommit;
	    effectCountInCurrentCommit = 0;
	    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);
	  }
	}

	function startCommitLifeCyclesTimer() {
	  {
	    if (!supportsUserTiming) {
	      return;
	    }
	    effectCountInCurrentCommit = 0;
	    beginMark('(Calling Lifecycle Methods)');
	  }
	}

	function stopCommitLifeCyclesTimer() {
	  {
	    if (!supportsUserTiming) {
	      return;
	    }
	    var count = effectCountInCurrentCommit;
	    effectCountInCurrentCommit = 0;
	    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);
	  }
	}

	var valueStack = [];

	var fiberStack = void 0;

	{
	  fiberStack = [];
	}

	var index = -1;

	function createCursor(defaultValue) {
	  return {
	    current: defaultValue
	  };
	}

	function pop(cursor, fiber) {
	  if (index < 0) {
	    {
	      warningWithoutStack$1(false, 'Unexpected pop.');
	    }
	    return;
	  }

	  {
	    if (fiber !== fiberStack[index]) {
	      warningWithoutStack$1(false, 'Unexpected Fiber popped.');
	    }
	  }

	  cursor.current = valueStack[index];

	  valueStack[index] = null;

	  {
	    fiberStack[index] = null;
	  }

	  index--;
	}

	function push(cursor, value, fiber) {
	  index++;

	  valueStack[index] = cursor.current;

	  {
	    fiberStack[index] = fiber;
	  }

	  cursor.current = value;
	}

	function checkThatStackIsEmpty() {
	  {
	    if (index !== -1) {
	      warningWithoutStack$1(false, 'Expected an empty stack. Something was not reset properly.');
	    }
	  }
	}

	function resetStackAfterFatalErrorInDev() {
	  {
	    index = -1;
	    valueStack.length = 0;
	    fiberStack.length = 0;
	  }
	}

	var warnedAboutMissingGetChildContext = void 0;

	{
	  warnedAboutMissingGetChildContext = {};
	}

	var emptyContextObject = {};
	{
	  Object.freeze(emptyContextObject);
	}

	// A cursor to the current merged context object on the stack.
	var contextStackCursor = createCursor(emptyContextObject);
	// A cursor to a boolean indicating whether the context has changed.
	var didPerformWorkStackCursor = createCursor(false);
	// Keep track of the previous context object that was on the stack.
	// We use this to get access to the parent context after we have already
	// pushed the next context provider, and now need to merge their contexts.
	var previousContext = emptyContextObject;

	function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
	  if (didPushOwnContextIfProvider && isContextProvider(Component)) {
	    // If the fiber is a context provider itself, when we read its context
	    // we may have already pushed its own child context on the stack. A context
	    // provider should not "see" its own child context. Therefore we read the
	    // previous (parent) context instead for a context provider.
	    return previousContext;
	  }
	  return contextStackCursor.current;
	}

	function cacheContext(workInProgress, unmaskedContext, maskedContext) {
	  var instance = workInProgress.stateNode;
	  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
	  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
	}

	function getMaskedContext(workInProgress, unmaskedContext) {
	  var type = workInProgress.type;
	  var contextTypes = type.contextTypes;
	  if (!contextTypes) {
	    return emptyContextObject;
	  }

	  // Avoid recreating masked context unless unmasked context has changed.
	  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
	  // This may trigger infinite loops if componentWillReceiveProps calls setState.
	  var instance = workInProgress.stateNode;
	  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
	    return instance.__reactInternalMemoizedMaskedChildContext;
	  }

	  var context = {};
	  for (var key in contextTypes) {
	    context[key] = unmaskedContext[key];
	  }

	  {
	    var name = getComponentName(type) || 'Unknown';
	    checkPropTypes(contextTypes, context, 'context', name, getCurrentFiberStackInDev);
	  }

	  // Cache unmasked context so we can avoid recreating masked context unless necessary.
	  // Context is created before the class component is instantiated so check for instance.
	  if (instance) {
	    cacheContext(workInProgress, unmaskedContext, context);
	  }

	  return context;
	}

	function hasContextChanged() {
	  return didPerformWorkStackCursor.current;
	}

	function isContextProvider(type) {
	  var childContextTypes = type.childContextTypes;
	  return childContextTypes !== null && childContextTypes !== undefined;
	}

	function popContext(fiber) {
	  pop(didPerformWorkStackCursor, fiber);
	  pop(contextStackCursor, fiber);
	}

	function popTopLevelContextObject(fiber) {
	  pop(didPerformWorkStackCursor, fiber);
	  pop(contextStackCursor, fiber);
	}

	function pushTopLevelContextObject(fiber, context, didChange) {
	  !(contextStackCursor.current === emptyContextObject) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;

	  push(contextStackCursor, context, fiber);
	  push(didPerformWorkStackCursor, didChange, fiber);
	}

	function processChildContext(fiber, type, parentContext) {
	  var instance = fiber.stateNode;
	  var childContextTypes = type.childContextTypes;

	  // TODO (bvaughn) Replace this behavior with an invariant() in the future.
	  // It has only been added in Fiber to match the (unintentional) behavior in Stack.
	  if (typeof instance.getChildContext !== 'function') {
	    {
	      var componentName = getComponentName(type) || 'Unknown';

	      if (!warnedAboutMissingGetChildContext[componentName]) {
	        warnedAboutMissingGetChildContext[componentName] = true;
	        warningWithoutStack$1(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
	      }
	    }
	    return parentContext;
	  }

	  var childContext = void 0;
	  {
	    setCurrentPhase('getChildContext');
	  }
	  startPhaseTimer(fiber, 'getChildContext');
	  childContext = instance.getChildContext();
	  stopPhaseTimer();
	  {
	    setCurrentPhase(null);
	  }
	  for (var contextKey in childContext) {
	    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(type) || 'Unknown', contextKey) : void 0;
	  }
	  {
	    var name = getComponentName(type) || 'Unknown';
	    checkPropTypes(childContextTypes, childContext, 'child context', name,
	    // In practice, there is one case in which we won't get a stack. It's when
	    // somebody calls unstable_renderSubtreeIntoContainer() and we process
	    // context from the parent component instance. The stack will be missing
	    // because it's outside of the reconciliation, and so the pointer has not
	    // been set. This is rare and doesn't matter. We'll also remove that API.
	    getCurrentFiberStackInDev);
	  }

	  return _assign({}, parentContext, childContext);
	}

	function pushContextProvider(workInProgress) {
	  var instance = workInProgress.stateNode;
	  // We push the context as early as possible to ensure stack integrity.
	  // If the instance does not exist yet, we will push null at first,
	  // and replace it on the stack later when invalidating the context.
	  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;

	  // Remember the parent context so we can merge with it later.
	  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
	  previousContext = contextStackCursor.current;
	  push(contextStackCursor, memoizedMergedChildContext, workInProgress);
	  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);

	  return true;
	}

	function invalidateContextProvider(workInProgress, type, didChange) {
	  var instance = workInProgress.stateNode;
	  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;

	  if (didChange) {
	    // Merge parent and own context.
	    // Skip this if we're not updating due to sCU.
	    // This avoids unnecessarily recomputing memoized values.
	    var mergedContext = processChildContext(workInProgress, type, previousContext);
	    instance.__reactInternalMemoizedMergedChildContext = mergedContext;

	    // Replace the old (or empty) context with the new one.
	    // It is important to unwind the context in the reverse order.
	    pop(didPerformWorkStackCursor, workInProgress);
	    pop(contextStackCursor, workInProgress);
	    // Now push the new context and mark that it has changed.
	    push(contextStackCursor, mergedContext, workInProgress);
	    push(didPerformWorkStackCursor, didChange, workInProgress);
	  } else {
	    pop(didPerformWorkStackCursor, workInProgress);
	    push(didPerformWorkStackCursor, didChange, workInProgress);
	  }
	}

	function findCurrentUnmaskedContext(fiber) {
	  // Currently this is only used with renderSubtreeIntoContainer; not sure if it
	  // makes sense elsewhere
	  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;

	  var node = fiber;
	  do {
	    switch (node.tag) {
	      case HostRoot:
	        return node.stateNode.context;
	      case ClassComponent:
	        {
	          var Component = node.type;
	          if (isContextProvider(Component)) {
	            return node.stateNode.__reactInternalMemoizedMergedChildContext;
	          }
	          break;
	        }
	    }
	    node = node.return;
	  } while (node !== null);
	  invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.');
	}

	var onCommitFiberRoot = null;
	var onCommitFiberUnmount = null;
	var hasLoggedError = false;

	function catchErrors(fn) {
	  return function (arg) {
	    try {
	      return fn(arg);
	    } catch (err) {
	      if (!hasLoggedError) {
	        hasLoggedError = true;
	        warningWithoutStack$1(false, 'React DevTools encountered an error: %s', err);
	      }
	    }
	  };
	}

	var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';

	function injectInternals(internals) {
	  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	    // No DevTools
	    return false;
	  }
	  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
	  if (hook.isDisabled) {
	    // This isn't a real property on the hook, but it can be set to opt out
	    // of DevTools integration and associated warnings and logs.
	    // https://github.com/facebook/react/issues/3877
	    return true;
	  }
	  if (!hook.supportsFiber) {
	    {
	      warningWithoutStack$1(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');
	    }
	    // DevTools exists, even though it doesn't support Fiber.
	    return true;
	  }
	  try {
	    var rendererID = hook.inject(internals);
	    // We have successfully injected, so now it is safe to set up hooks.
	    onCommitFiberRoot = catchErrors(function (root) {
	      return hook.onCommitFiberRoot(rendererID, root);
	    });
	    onCommitFiberUnmount = catchErrors(function (fiber) {
	      return hook.onCommitFiberUnmount(rendererID, fiber);
	    });
	  } catch (err) {
	    // Catch all errors because it is unsafe to throw during initialization.
	    {
	      warningWithoutStack$1(false, 'React DevTools encountered an error: %s.', err);
	    }
	  }
	  // DevTools exists
	  return true;
	}

	function onCommitRoot(root) {
	  if (typeof onCommitFiberRoot === 'function') {
	    onCommitFiberRoot(root);
	  }
	}

	function onCommitUnmount(fiber) {
	  if (typeof onCommitFiberUnmount === 'function') {
	    onCommitFiberUnmount(fiber);
	  }
	}

	// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
	// Math.pow(2, 30) - 1
	// 0b111111111111111111111111111111
	var maxSigned31BitInt = 1073741823;

	var NoWork = 0;
	var Never = 1;
	var Sync = maxSigned31BitInt;

	var UNIT_SIZE = 10;
	var MAGIC_NUMBER_OFFSET = maxSigned31BitInt - 1;

	// 1 unit of expiration time represents 10ms.
	function msToExpirationTime(ms) {
	  // Always add an offset so that we don't clash with the magic number for NoWork.
	  return MAGIC_NUMBER_OFFSET - (ms / UNIT_SIZE | 0);
	}

	function expirationTimeToMs(expirationTime) {
	  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
	}

	function ceiling(num, precision) {
	  return ((num / precision | 0) + 1) * precision;
	}

	function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
	  return MAGIC_NUMBER_OFFSET - ceiling(MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
	}

	var LOW_PRIORITY_EXPIRATION = 5000;
	var LOW_PRIORITY_BATCH_SIZE = 250;

	function computeAsyncExpiration(currentTime) {
	  return computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);
	}

	// We intentionally set a higher expiration time for interactive updates in
	// dev than in production.
	//
	// If the main thread is being blocked so long that you hit the expiration,
	// it's a problem that could be solved with better scheduling.
	//
	// People will be more likely to notice this and fix it with the long
	// expiration time in development.
	//
	// In production we opt for better UX at the risk of masking scheduling
	// problems, by expiring fast.
	var HIGH_PRIORITY_EXPIRATION = 500;
	var HIGH_PRIORITY_BATCH_SIZE = 100;

	function computeInteractiveExpiration(currentTime) {
	  return computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);
	}

	var NoContext = 0;
	var ConcurrentMode = 1;
	var StrictMode = 2;
	var ProfileMode = 4;

	var hasBadMapPolyfill = void 0;

	{
	  hasBadMapPolyfill = false;
	  try {
	    var nonExtensibleObject = Object.preventExtensions({});
	    var testMap = new Map([[nonExtensibleObject, null]]);
	    var testSet = new Set([nonExtensibleObject]);
	    // This is necessary for Rollup to not consider these unused.
	    // https://github.com/rollup/rollup/issues/1771
	    // TODO: we can remove these if Rollup fixes the bug.
	    testMap.set(0, 0);
	    testSet.add(0);
	  } catch (e) {
	    // TODO: Consider warning about bad polyfills
	    hasBadMapPolyfill = true;
	  }
	}

	// A Fiber is work on a Component that needs to be done or was done. There can
	// be more than one per component.


	var debugCounter = void 0;

	{
	  debugCounter = 1;
	}

	function FiberNode(tag, pendingProps, key, mode) {
	  // Instance
	  this.tag = tag;
	  this.key = key;
	  this.elementType = null;
	  this.type = null;
	  this.stateNode = null;

	  // Fiber
	  this.return = null;
	  this.child = null;
	  this.sibling = null;
	  this.index = 0;

	  this.ref = null;

	  this.pendingProps = pendingProps;
	  this.memoizedProps = null;
	  this.updateQueue = null;
	  this.memoizedState = null;
	  this.contextDependencies = null;

	  this.mode = mode;

	  // Effects
	  this.effectTag = NoEffect;
	  this.nextEffect = null;

	  this.firstEffect = null;
	  this.lastEffect = null;

	  this.expirationTime = NoWork;
	  this.childExpirationTime = NoWork;

	  this.alternate = null;

	  {
	    // Note: The following is done to avoid a v8 performance cliff.
	    //
	    // Initializing the fields below to smis and later updating them with
	    // double values will cause Fibers to end up having separate shapes.
	    // This behavior/bug has something to do with Object.preventExtension().
	    // Fortunately this only impacts DEV builds.
	    // Unfortunately it makes React unusably slow for some applications.
	    // To work around this, initialize the fields below with doubles.
	    //
	    // Learn more about this here:
	    // https://github.com/facebook/react/issues/14365
	    // https://bugs.chromium.org/p/v8/issues/detail?id=8538
	    this.actualDuration = Number.NaN;
	    this.actualStartTime = Number.NaN;
	    this.selfBaseDuration = Number.NaN;
	    this.treeBaseDuration = Number.NaN;

	    // It's okay to replace the initial doubles with smis after initialization.
	    // This won't trigger the performance cliff mentioned above,
	    // and it simplifies other profiler code (including DevTools).
	    this.actualDuration = 0;
	    this.actualStartTime = -1;
	    this.selfBaseDuration = 0;
	    this.treeBaseDuration = 0;
	  }

	  {
	    this._debugID = debugCounter++;
	    this._debugSource = null;
	    this._debugOwner = null;
	    this._debugIsCurrentlyTiming = false;
	    this._debugHookTypes = null;
	    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
	      Object.preventExtensions(this);
	    }
	  }
	}

	// This is a constructor function, rather than a POJO constructor, still
	// please ensure we do the following:
	// 1) Nobody should add any instance methods on this. Instance methods can be
	//    more difficult to predict when they get optimized and they are almost
	//    never inlined properly in static compilers.
	// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
	//    always know when it is a fiber.
	// 3) We might want to experiment with using numeric keys since they are easier
	//    to optimize in a non-JIT environment.
	// 4) We can easily go from a constructor to a createFiber object literal if that
	//    is faster.
	// 5) It should be easy to port this to a C struct and keep a C implementation
	//    compatible.
	var createFiber = function (tag, pendingProps, key, mode) {
	  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
	  return new FiberNode(tag, pendingProps, key, mode);
	};

	function shouldConstruct(Component) {
	  var prototype = Component.prototype;
	  return !!(prototype && prototype.isReactComponent);
	}

	function isSimpleFunctionComponent(type) {
	  return typeof type === 'function' && !shouldConstruct(type) && type.defaultProps === undefined;
	}

	function resolveLazyComponentTag(Component) {
	  if (typeof Component === 'function') {
	    return shouldConstruct(Component) ? ClassComponent : FunctionComponent;
	  } else if (Component !== undefined && Component !== null) {
	    var $$typeof = Component.$$typeof;
	    if ($$typeof === REACT_FORWARD_REF_TYPE) {
	      return ForwardRef;
	    }
	    if ($$typeof === REACT_MEMO_TYPE) {
	      return MemoComponent;
	    }
	  }
	  return IndeterminateComponent;
	}

	// This is used to create an alternate fiber to do work on.
	function createWorkInProgress(current, pendingProps, expirationTime) {
	  var workInProgress = current.alternate;
	  if (workInProgress === null) {
	    // We use a double buffering pooling technique because we know that we'll
	    // only ever need at most two versions of a tree. We pool the "other" unused
	    // node that we're free to reuse. This is lazily created to avoid allocating
	    // extra objects for things that are never updated. It also allow us to
	    // reclaim the extra memory if needed.
	    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
	    workInProgress.elementType = current.elementType;
	    workInProgress.type = current.type;
	    workInProgress.stateNode = current.stateNode;

	    {
	      // DEV-only fields
	      workInProgress._debugID = current._debugID;
	      workInProgress._debugSource = current._debugSource;
	      workInProgress._debugOwner = current._debugOwner;
	      workInProgress._debugHookTypes = current._debugHookTypes;
	    }

	    workInProgress.alternate = current;
	    current.alternate = workInProgress;
	  } else {
	    workInProgress.pendingProps = pendingProps;

	    // We already have an alternate.
	    // Reset the effect tag.
	    workInProgress.effectTag = NoEffect;

	    // The effect list is no longer valid.
	    workInProgress.nextEffect = null;
	    workInProgress.firstEffect = null;
	    workInProgress.lastEffect = null;

	    {
	      // We intentionally reset, rather than copy, actualDuration & actualStartTime.
	      // This prevents time from endlessly accumulating in new commits.
	      // This has the downside of resetting values for different priority renders,
	      // But works for yielding (the common case) and should support resuming.
	      workInProgress.actualDuration = 0;
	      workInProgress.actualStartTime = -1;
	    }
	  }

	  workInProgress.childExpirationTime = current.childExpirationTime;
	  workInProgress.expirationTime = current.expirationTime;

	  workInProgress.child = current.child;
	  workInProgress.memoizedProps = current.memoizedProps;
	  workInProgress.memoizedState = current.memoizedState;
	  workInProgress.updateQueue = current.updateQueue;
	  workInProgress.contextDependencies = current.contextDependencies;

	  // These will be overridden during the parent's reconciliation
	  workInProgress.sibling = current.sibling;
	  workInProgress.index = current.index;
	  workInProgress.ref = current.ref;

	  {
	    workInProgress.selfBaseDuration = current.selfBaseDuration;
	    workInProgress.treeBaseDuration = current.treeBaseDuration;
	  }

	  return workInProgress;
	}

	function createHostRootFiber(isConcurrent) {
	  var mode = isConcurrent ? ConcurrentMode | StrictMode : NoContext;

	  if (isDevToolsPresent) {
	    // Always collect profile timings when DevTools are present.
	    // This enables DevTools to start capturing timing at any point–
	    // Without some nodes in the tree having empty base times.
	    mode |= ProfileMode;
	  }

	  return createFiber(HostRoot, null, null, mode);
	}

	function createFiberFromTypeAndProps(type, // React$ElementType
	key, pendingProps, owner, mode, expirationTime) {
	  var fiber = void 0;

	  var fiberTag = IndeterminateComponent;
	  // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
	  var resolvedType = type;
	  if (typeof type === 'function') {
	    if (shouldConstruct(type)) {
	      fiberTag = ClassComponent;
	    }
	  } else if (typeof type === 'string') {
	    fiberTag = HostComponent;
	  } else {
	    getTag: switch (type) {
	      case REACT_FRAGMENT_TYPE:
	        return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);
	      case REACT_CONCURRENT_MODE_TYPE:
	        return createFiberFromMode(pendingProps, mode | ConcurrentMode | StrictMode, expirationTime, key);
	      case REACT_STRICT_MODE_TYPE:
	        return createFiberFromMode(pendingProps, mode | StrictMode, expirationTime, key);
	      case REACT_PROFILER_TYPE:
	        return createFiberFromProfiler(pendingProps, mode, expirationTime, key);
	      case REACT_SUSPENSE_TYPE:
	        return createFiberFromSuspense(pendingProps, mode, expirationTime, key);
	      default:
	        {
	          if (typeof type === 'object' && type !== null) {
	            switch (type.$$typeof) {
	              case REACT_PROVIDER_TYPE:
	                fiberTag = ContextProvider;
	                break getTag;
	              case REACT_CONTEXT_TYPE:
	                // This is a consumer
	                fiberTag = ContextConsumer;
	                break getTag;
	              case REACT_FORWARD_REF_TYPE:
	                fiberTag = ForwardRef;
	                break getTag;
	              case REACT_MEMO_TYPE:
	                fiberTag = MemoComponent;
	                break getTag;
	              case REACT_LAZY_TYPE:
	                fiberTag = LazyComponent;
	                resolvedType = null;
	                break getTag;
	            }
	          }
	          var info = '';
	          {
	            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
	              info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and " + 'named imports.';
	            }
	            var ownerName = owner ? getComponentName(owner.type) : null;
	            if (ownerName) {
	              info += '\n\nCheck the render method of `' + ownerName + '`.';
	            }
	          }
	          invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);
	        }
	    }
	  }

	  fiber = createFiber(fiberTag, pendingProps, key, mode);
	  fiber.elementType = type;
	  fiber.type = resolvedType;
	  fiber.expirationTime = expirationTime;

	  return fiber;
	}

	function createFiberFromElement(element, mode, expirationTime) {
	  var owner = null;
	  {
	    owner = element._owner;
	  }
	  var type = element.type;
	  var key = element.key;
	  var pendingProps = element.props;
	  var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime);
	  {
	    fiber._debugSource = element._source;
	    fiber._debugOwner = element._owner;
	  }
	  return fiber;
	}

	function createFiberFromFragment(elements, mode, expirationTime, key) {
	  var fiber = createFiber(Fragment, elements, key, mode);
	  fiber.expirationTime = expirationTime;
	  return fiber;
	}

	function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
	  {
	    if (typeof pendingProps.id !== 'string' || typeof pendingProps.onRender !== 'function') {
	      warningWithoutStack$1(false, 'Profiler must specify an "id" string and "onRender" function as props');
	    }
	  }

	  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
	  // TODO: The Profiler fiber shouldn't have a type. It has a tag.
	  fiber.elementType = REACT_PROFILER_TYPE;
	  fiber.type = REACT_PROFILER_TYPE;
	  fiber.expirationTime = expirationTime;

	  return fiber;
	}

	function createFiberFromMode(pendingProps, mode, expirationTime, key) {
	  var fiber = createFiber(Mode, pendingProps, key, mode);

	  // TODO: The Mode fiber shouldn't have a type. It has a tag.
	  var type = (mode & ConcurrentMode) === NoContext ? REACT_STRICT_MODE_TYPE : REACT_CONCURRENT_MODE_TYPE;
	  fiber.elementType = type;
	  fiber.type = type;

	  fiber.expirationTime = expirationTime;
	  return fiber;
	}

	function createFiberFromSuspense(pendingProps, mode, expirationTime, key) {
	  var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);

	  // TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
	  var type = REACT_SUSPENSE_TYPE;
	  fiber.elementType = type;
	  fiber.type = type;

	  fiber.expirationTime = expirationTime;
	  return fiber;
	}

	function createFiberFromText(content, mode, expirationTime) {
	  var fiber = createFiber(HostText, content, null, mode);
	  fiber.expirationTime = expirationTime;
	  return fiber;
	}

	function createFiberFromHostInstanceForDeletion() {
	  var fiber = createFiber(HostComponent, null, null, NoContext);
	  // TODO: These should not need a type.
	  fiber.elementType = 'DELETED';
	  fiber.type = 'DELETED';
	  return fiber;
	}

	function createFiberFromPortal(portal, mode, expirationTime) {
	  var pendingProps = portal.children !== null ? portal.children : [];
	  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
	  fiber.expirationTime = expirationTime;
	  fiber.stateNode = {
	    containerInfo: portal.containerInfo,
	    pendingChildren: null, // Used by persistent updates
	    implementation: portal.implementation
	  };
	  return fiber;
	}

	// Used for stashing WIP properties to replay failed work in DEV.
	function assignFiberPropertiesInDEV(target, source) {
	  if (target === null) {
	    // This Fiber's initial properties will always be overwritten.
	    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.
	    target = createFiber(IndeterminateComponent, null, null, NoContext);
	  }

	  // This is intentionally written as a list of all properties.
	  // We tried to use Object.assign() instead but this is called in
	  // the hottest path, and Object.assign() was too slow:
	  // https://github.com/facebook/react/issues/12502
	  // This code is DEV-only so size is not a concern.

	  target.tag = source.tag;
	  target.key = source.key;
	  target.elementType = source.elementType;
	  target.type = source.type;
	  target.stateNode = source.stateNode;
	  target.return = source.return;
	  target.child = source.child;
	  target.sibling = source.sibling;
	  target.index = source.index;
	  target.ref = source.ref;
	  target.pendingProps = source.pendingProps;
	  target.memoizedProps = source.memoizedProps;
	  target.updateQueue = source.updateQueue;
	  target.memoizedState = source.memoizedState;
	  target.contextDependencies = source.contextDependencies;
	  target.mode = source.mode;
	  target.effectTag = source.effectTag;
	  target.nextEffect = source.nextEffect;
	  target.firstEffect = source.firstEffect;
	  target.lastEffect = source.lastEffect;
	  target.expirationTime = source.expirationTime;
	  target.childExpirationTime = source.childExpirationTime;
	  target.alternate = source.alternate;
	  {
	    target.actualDuration = source.actualDuration;
	    target.actualStartTime = source.actualStartTime;
	    target.selfBaseDuration = source.selfBaseDuration;
	    target.treeBaseDuration = source.treeBaseDuration;
	  }
	  target._debugID = source._debugID;
	  target._debugSource = source._debugSource;
	  target._debugOwner = source._debugOwner;
	  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;
	  target._debugHookTypes = source._debugHookTypes;
	  return target;
	}

	// TODO: This should be lifted into the renderer.


	// The following attributes are only used by interaction tracing builds.
	// They enable interactions to be associated with their async work,
	// And expose interaction metadata to the React DevTools Profiler plugin.
	// Note that these attributes are only defined when the enableSchedulerTracing flag is enabled.


	// Exported FiberRoot type includes all properties,
	// To avoid requiring potentially error-prone :any casts throughout the project.
	// Profiling properties are only safe to access in profiling builds (when enableSchedulerTracing is true).
	// The types are defined separately within this file to ensure they stay in sync.
	// (We don't have to use an inline :any cast when enableSchedulerTracing is disabled.)


	function createFiberRoot(containerInfo, isConcurrent, hydrate) {
	  // Cyclic construction. This cheats the type system right now because
	  // stateNode is any.
	  var uninitializedFiber = createHostRootFiber(isConcurrent);

	  var root = void 0;
	  {
	    root = {
	      current: uninitializedFiber,
	      containerInfo: containerInfo,
	      pendingChildren: null,

	      earliestPendingTime: NoWork,
	      latestPendingTime: NoWork,
	      earliestSuspendedTime: NoWork,
	      latestSuspendedTime: NoWork,
	      latestPingedTime: NoWork,

	      pingCache: null,

	      didError: false,

	      pendingCommitExpirationTime: NoWork,
	      finishedWork: null,
	      timeoutHandle: noTimeout,
	      context: null,
	      pendingContext: null,
	      hydrate: hydrate,
	      nextExpirationTimeToWorkOn: NoWork,
	      expirationTime: NoWork,
	      firstBatch: null,
	      nextScheduledRoot: null,

	      interactionThreadID: tracing$1.unstable_getThreadID(),
	      memoizedInteractions: new Set(),
	      pendingInteractionMap: new Map()
	    };
	  }

	  uninitializedFiber.stateNode = root;

	  // The reason for the way the Flow types are structured in this file,
	  // Is to avoid needing :any casts everywhere interaction tracing fields are used.
	  // Unfortunately that requires an :any cast for non-interaction tracing capable builds.
	  // $FlowFixMe Remove this :any cast and replace it with something better.
	  return root;
	}

	/**
	 * Forked from fbjs/warning:
	 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
	 *
	 * Only change is we use console.warn instead of console.error,
	 * and do nothing when 'console' is not supported.
	 * This really simplifies the code.
	 * ---
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var lowPriorityWarning = function () {};

	{
	  var printWarning = function (format) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    var argIndex = 0;
	    var message = 'Warning: ' + format.replace(/%s/g, function () {
	      return args[argIndex++];
	    });
	    if (typeof console !== 'undefined') {
	      console.warn(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };

	  lowPriorityWarning = function (condition, format) {
	    if (format === undefined) {
	      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	    if (!condition) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	        args[_key2 - 2] = arguments[_key2];
	      }

	      printWarning.apply(undefined, [format].concat(args));
	    }
	  };
	}

	var lowPriorityWarning$1 = lowPriorityWarning;

	var ReactStrictModeWarnings = {
	  discardPendingWarnings: function () {},
	  flushPendingDeprecationWarnings: function () {},
	  flushPendingUnsafeLifecycleWarnings: function () {},
	  recordDeprecationWarnings: function (fiber, instance) {},
	  recordUnsafeLifecycleWarnings: function (fiber, instance) {},
	  recordLegacyContextWarning: function (fiber, instance) {},
	  flushLegacyContextWarning: function () {}
	};

	{
	  var LIFECYCLE_SUGGESTIONS = {
	    UNSAFE_componentWillMount: 'componentDidMount',
	    UNSAFE_componentWillReceiveProps: 'static getDerivedStateFromProps',
	    UNSAFE_componentWillUpdate: 'componentDidUpdate'
	  };

	  var pendingComponentWillMountWarnings = [];
	  var pendingComponentWillReceivePropsWarnings = [];
	  var pendingComponentWillUpdateWarnings = [];
	  var pendingUnsafeLifecycleWarnings = new Map();
	  var pendingLegacyContextWarning = new Map();

	  // Tracks components we have already warned about.
	  var didWarnAboutDeprecatedLifecycles = new Set();
	  var didWarnAboutUnsafeLifecycles = new Set();
	  var didWarnAboutLegacyContext = new Set();

	  var setToSortedString = function (set) {
	    var array = [];
	    set.forEach(function (value) {
	      array.push(value);
	    });
	    return array.sort().join(', ');
	  };

	  ReactStrictModeWarnings.discardPendingWarnings = function () {
	    pendingComponentWillMountWarnings = [];
	    pendingComponentWillReceivePropsWarnings = [];
	    pendingComponentWillUpdateWarnings = [];
	    pendingUnsafeLifecycleWarnings = new Map();
	    pendingLegacyContextWarning = new Map();
	  };

	  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
	    pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {
	      var lifecyclesWarningMessages = [];

	      Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {
	        var lifecycleWarnings = lifecycleWarningsMap[lifecycle];
	        if (lifecycleWarnings.length > 0) {
	          var componentNames = new Set();
	          lifecycleWarnings.forEach(function (fiber) {
	            componentNames.add(getComponentName(fiber.type) || 'Component');
	            didWarnAboutUnsafeLifecycles.add(fiber.type);
	          });

	          var formatted = lifecycle.replace('UNSAFE_', '');
	          var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];
	          var sortedComponentNames = setToSortedString(componentNames);

	          lifecyclesWarningMessages.push(formatted + ': Please update the following components to use ' + (suggestion + ' instead: ' + sortedComponentNames));
	        }
	      });

	      if (lifecyclesWarningMessages.length > 0) {
	        var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);

	        warningWithoutStack$1(false, 'Unsafe lifecycle methods were found within a strict-mode tree:%s' + '\n\n%s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-strict-mode-warnings', strictRootComponentStack, lifecyclesWarningMessages.join('\n\n'));
	      }
	    });

	    pendingUnsafeLifecycleWarnings = new Map();
	  };

	  var findStrictRoot = function (fiber) {
	    var maybeStrictRoot = null;

	    var node = fiber;
	    while (node !== null) {
	      if (node.mode & StrictMode) {
	        maybeStrictRoot = node;
	      }
	      node = node.return;
	    }

	    return maybeStrictRoot;
	  };

	  ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {
	    if (pendingComponentWillMountWarnings.length > 0) {
	      var uniqueNames = new Set();
	      pendingComponentWillMountWarnings.forEach(function (fiber) {
	        uniqueNames.add(getComponentName(fiber.type) || 'Component');
	        didWarnAboutDeprecatedLifecycles.add(fiber.type);
	      });

	      var sortedNames = setToSortedString(uniqueNames);

	      lowPriorityWarning$1(false, 'componentWillMount is deprecated and will be removed in the next major version. ' + 'Use componentDidMount instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillMount.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-async-component-lifecycle-hooks', sortedNames);

	      pendingComponentWillMountWarnings = [];
	    }

	    if (pendingComponentWillReceivePropsWarnings.length > 0) {
	      var _uniqueNames = new Set();
	      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
	        _uniqueNames.add(getComponentName(fiber.type) || 'Component');
	        didWarnAboutDeprecatedLifecycles.add(fiber.type);
	      });

	      var _sortedNames = setToSortedString(_uniqueNames);

	      lowPriorityWarning$1(false, 'componentWillReceiveProps is deprecated and will be removed in the next major version. ' + 'Use static getDerivedStateFromProps instead.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames);

	      pendingComponentWillReceivePropsWarnings = [];
	    }

	    if (pendingComponentWillUpdateWarnings.length > 0) {
	      var _uniqueNames2 = new Set();
	      pendingComponentWillUpdateWarnings.forEach(function (fiber) {
	        _uniqueNames2.add(getComponentName(fiber.type) || 'Component');
	        didWarnAboutDeprecatedLifecycles.add(fiber.type);
	      });

	      var _sortedNames2 = setToSortedString(_uniqueNames2);

	      lowPriorityWarning$1(false, 'componentWillUpdate is deprecated and will be removed in the next major version. ' + 'Use componentDidUpdate instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillUpdate.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames2);

	      pendingComponentWillUpdateWarnings = [];
	    }
	  };

	  ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {
	    // Dedup strategy: Warn once per component.
	    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {
	      return;
	    }

	    // Don't warn about react-lifecycles-compat polyfilled components.
	    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {
	      pendingComponentWillMountWarnings.push(fiber);
	    }
	    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
	      pendingComponentWillReceivePropsWarnings.push(fiber);
	    }
	    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
	      pendingComponentWillUpdateWarnings.push(fiber);
	    }
	  };

	  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
	    var strictRoot = findStrictRoot(fiber);
	    if (strictRoot === null) {
	      warningWithoutStack$1(false, 'Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');
	      return;
	    }

	    // Dedup strategy: Warn once per component.
	    // This is difficult to track any other way since component names
	    // are often vague and are likely to collide between 3rd party libraries.
	    // An expand property is probably okay to use here since it's DEV-only,
	    // and will only be set in the event of serious warnings.
	    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
	      return;
	    }

	    var warningsForRoot = void 0;
	    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {
	      warningsForRoot = {
	        UNSAFE_componentWillMount: [],
	        UNSAFE_componentWillReceiveProps: [],
	        UNSAFE_componentWillUpdate: []
	      };

	      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);
	    } else {
	      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);
	    }

	    var unsafeLifecycles = [];
	    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillMount === 'function') {
	      unsafeLifecycles.push('UNSAFE_componentWillMount');
	    }
	    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
	      unsafeLifecycles.push('UNSAFE_componentWillReceiveProps');
	    }
	    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillUpdate === 'function') {
	      unsafeLifecycles.push('UNSAFE_componentWillUpdate');
	    }

	    if (unsafeLifecycles.length > 0) {
	      unsafeLifecycles.forEach(function (lifecycle) {
	        warningsForRoot[lifecycle].push(fiber);
	      });
	    }
	  };

	  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
	    var strictRoot = findStrictRoot(fiber);
	    if (strictRoot === null) {
	      warningWithoutStack$1(false, 'Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');
	      return;
	    }

	    // Dedup strategy: Warn once per component.
	    if (didWarnAboutLegacyContext.has(fiber.type)) {
	      return;
	    }

	    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);

	    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {
	      if (warningsForRoot === undefined) {
	        warningsForRoot = [];
	        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
	      }
	      warningsForRoot.push(fiber);
	    }
	  };

	  ReactStrictModeWarnings.flushLegacyContextWarning = function () {
	    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
	      var uniqueNames = new Set();
	      fiberArray.forEach(function (fiber) {
	        uniqueNames.add(getComponentName(fiber.type) || 'Component');
	        didWarnAboutLegacyContext.add(fiber.type);
	      });

	      var sortedNames = setToSortedString(uniqueNames);
	      var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);

	      warningWithoutStack$1(false, 'Legacy context API has been detected within a strict-mode tree: %s' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-strict-mode-warnings', strictRootComponentStack, sortedNames);
	    });
	  };
	}

	// TODO: Offscreen updates should never suspend. However, a promise that
	// suspended inside an offscreen subtree should be able to ping at the priority
	// of the outer render.

	function markPendingPriorityLevel(root, expirationTime) {
	  // If there's a gap between completing a failed root and retrying it,
	  // additional updates may be scheduled. Clear `didError`, in case the update
	  // is sufficient to fix the error.
	  root.didError = false;

	  // Update the latest and earliest pending times
	  var earliestPendingTime = root.earliestPendingTime;
	  if (earliestPendingTime === NoWork) {
	    // No other pending updates.
	    root.earliestPendingTime = root.latestPendingTime = expirationTime;
	  } else {
	    if (earliestPendingTime < expirationTime) {
	      // This is the earliest pending update.
	      root.earliestPendingTime = expirationTime;
	    } else {
	      var latestPendingTime = root.latestPendingTime;
	      if (latestPendingTime > expirationTime) {
	        // This is the latest pending update
	        root.latestPendingTime = expirationTime;
	      }
	    }
	  }
	  findNextExpirationTimeToWorkOn(expirationTime, root);
	}

	function markCommittedPriorityLevels(root, earliestRemainingTime) {
	  root.didError = false;

	  if (earliestRemainingTime === NoWork) {
	    // Fast path. There's no remaining work. Clear everything.
	    root.earliestPendingTime = NoWork;
	    root.latestPendingTime = NoWork;
	    root.earliestSuspendedTime = NoWork;
	    root.latestSuspendedTime = NoWork;
	    root.latestPingedTime = NoWork;
	    findNextExpirationTimeToWorkOn(NoWork, root);
	    return;
	  }

	  if (earliestRemainingTime < root.latestPingedTime) {
	    root.latestPingedTime = NoWork;
	  }

	  // Let's see if the previous latest known pending level was just flushed.
	  var latestPendingTime = root.latestPendingTime;
	  if (latestPendingTime !== NoWork) {
	    if (latestPendingTime > earliestRemainingTime) {
	      // We've flushed all the known pending levels.
	      root.earliestPendingTime = root.latestPendingTime = NoWork;
	    } else {
	      var earliestPendingTime = root.earliestPendingTime;
	      if (earliestPendingTime > earliestRemainingTime) {
	        // We've flushed the earliest known pending level. Set this to the
	        // latest pending time.
	        root.earliestPendingTime = root.latestPendingTime;
	      }
	    }
	  }

	  // Now let's handle the earliest remaining level in the whole tree. We need to
	  // decide whether to treat it as a pending level or as suspended. Check
	  // it falls within the range of known suspended levels.

	  var earliestSuspendedTime = root.earliestSuspendedTime;
	  if (earliestSuspendedTime === NoWork) {
	    // There's no suspended work. Treat the earliest remaining level as a
	    // pending level.
	    markPendingPriorityLevel(root, earliestRemainingTime);
	    findNextExpirationTimeToWorkOn(NoWork, root);
	    return;
	  }

	  var latestSuspendedTime = root.latestSuspendedTime;
	  if (earliestRemainingTime < latestSuspendedTime) {
	    // The earliest remaining level is later than all the suspended work. That
	    // means we've flushed all the suspended work.
	    root.earliestSuspendedTime = NoWork;
	    root.latestSuspendedTime = NoWork;
	    root.latestPingedTime = NoWork;

	    // There's no suspended work. Treat the earliest remaining level as a
	    // pending level.
	    markPendingPriorityLevel(root, earliestRemainingTime);
	    findNextExpirationTimeToWorkOn(NoWork, root);
	    return;
	  }

	  if (earliestRemainingTime > earliestSuspendedTime) {
	    // The earliest remaining time is earlier than all the suspended work.
	    // Treat it as a pending update.
	    markPendingPriorityLevel(root, earliestRemainingTime);
	    findNextExpirationTimeToWorkOn(NoWork, root);
	    return;
	  }

	  // The earliest remaining time falls within the range of known suspended
	  // levels. We should treat this as suspended work.
	  findNextExpirationTimeToWorkOn(NoWork, root);
	}

	function hasLowerPriorityWork(root, erroredExpirationTime) {
	  var latestPendingTime = root.latestPendingTime;
	  var latestSuspendedTime = root.latestSuspendedTime;
	  var latestPingedTime = root.latestPingedTime;
	  return latestPendingTime !== NoWork && latestPendingTime < erroredExpirationTime || latestSuspendedTime !== NoWork && latestSuspendedTime < erroredExpirationTime || latestPingedTime !== NoWork && latestPingedTime < erroredExpirationTime;
	}

	function isPriorityLevelSuspended(root, expirationTime) {
	  var earliestSuspendedTime = root.earliestSuspendedTime;
	  var latestSuspendedTime = root.latestSuspendedTime;
	  return earliestSuspendedTime !== NoWork && expirationTime <= earliestSuspendedTime && expirationTime >= latestSuspendedTime;
	}

	function markSuspendedPriorityLevel(root, suspendedTime) {
	  root.didError = false;
	  clearPing(root, suspendedTime);

	  // First, check the known pending levels and update them if needed.
	  var earliestPendingTime = root.earliestPendingTime;
	  var latestPendingTime = root.latestPendingTime;
	  if (earliestPendingTime === suspendedTime) {
	    if (latestPendingTime === suspendedTime) {
	      // Both known pending levels were suspended. Clear them.
	      root.earliestPendingTime = root.latestPendingTime = NoWork;
	    } else {
	      // The earliest pending level was suspended. Clear by setting it to the
	      // latest pending level.
	      root.earliestPendingTime = latestPendingTime;
	    }
	  } else if (latestPendingTime === suspendedTime) {
	    // The latest pending level was suspended. Clear by setting it to the
	    // latest pending level.
	    root.latestPendingTime = earliestPendingTime;
	  }

	  // Finally, update the known suspended levels.
	  var earliestSuspendedTime = root.earliestSuspendedTime;
	  var latestSuspendedTime = root.latestSuspendedTime;
	  if (earliestSuspendedTime === NoWork) {
	    // No other suspended levels.
	    root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;
	  } else {
	    if (earliestSuspendedTime < suspendedTime) {
	      // This is the earliest suspended level.
	      root.earliestSuspendedTime = suspendedTime;
	    } else if (latestSuspendedTime > suspendedTime) {
	      // This is the latest suspended level
	      root.latestSuspendedTime = suspendedTime;
	    }
	  }

	  findNextExpirationTimeToWorkOn(suspendedTime, root);
	}

	function markPingedPriorityLevel(root, pingedTime) {
	  root.didError = false;

	  // TODO: When we add back resuming, we need to ensure the progressed work
	  // is thrown out and not reused during the restarted render. One way to
	  // invalidate the progressed work is to restart at expirationTime + 1.
	  var latestPingedTime = root.latestPingedTime;
	  if (latestPingedTime === NoWork || latestPingedTime > pingedTime) {
	    root.latestPingedTime = pingedTime;
	  }
	  findNextExpirationTimeToWorkOn(pingedTime, root);
	}

	function clearPing(root, completedTime) {
	  var latestPingedTime = root.latestPingedTime;
	  if (latestPingedTime >= completedTime) {
	    root.latestPingedTime = NoWork;
	  }
	}

	function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
	  var earliestExpirationTime = renderExpirationTime;

	  var earliestPendingTime = root.earliestPendingTime;
	  var earliestSuspendedTime = root.earliestSuspendedTime;
	  if (earliestPendingTime > earliestExpirationTime) {
	    earliestExpirationTime = earliestPendingTime;
	  }
	  if (earliestSuspendedTime > earliestExpirationTime) {
	    earliestExpirationTime = earliestSuspendedTime;
	  }
	  return earliestExpirationTime;
	}

	function didExpireAtExpirationTime(root, currentTime) {
	  var expirationTime = root.expirationTime;
	  if (expirationTime !== NoWork && currentTime <= expirationTime) {
	    // The root has expired. Flush all work up to the current time.
	    root.nextExpirationTimeToWorkOn = currentTime;
	  }
	}

	function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
	  var earliestSuspendedTime = root.earliestSuspendedTime;
	  var latestSuspendedTime = root.latestSuspendedTime;
	  var earliestPendingTime = root.earliestPendingTime;
	  var latestPingedTime = root.latestPingedTime;

	  // Work on the earliest pending time. Failing that, work on the latest
	  // pinged time.
	  var nextExpirationTimeToWorkOn = earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime;

	  // If there is no pending or pinged work, check if there's suspended work
	  // that's lower priority than what we just completed.
	  if (nextExpirationTimeToWorkOn === NoWork && (completedExpirationTime === NoWork || latestSuspendedTime < completedExpirationTime)) {
	    // The lowest priority suspended work is the work most likely to be
	    // committed next. Let's start rendering it again, so that if it times out,
	    // it's ready to commit.
	    nextExpirationTimeToWorkOn = latestSuspendedTime;
	  }

	  var expirationTime = nextExpirationTimeToWorkOn;
	  if (expirationTime !== NoWork && earliestSuspendedTime > expirationTime) {
	    // Expire using the earliest known expiration time.
	    expirationTime = earliestSuspendedTime;
	  }

	  root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;
	  root.expirationTime = expirationTime;
	}

	function resolveDefaultProps(Component, baseProps) {
	  if (Component && Component.defaultProps) {
	    // Resolve default props. Taken from ReactElement
	    var props = _assign({}, baseProps);
	    var defaultProps = Component.defaultProps;
	    for (var propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	    return props;
	  }
	  return baseProps;
	}

	function readLazyComponentType(lazyComponent) {
	  var status = lazyComponent._status;
	  var result = lazyComponent._result;
	  switch (status) {
	    case Resolved:
	      {
	        var Component = result;
	        return Component;
	      }
	    case Rejected:
	      {
	        var error = result;
	        throw error;
	      }
	    case Pending:
	      {
	        var thenable = result;
	        throw thenable;
	      }
	    default:
	      {
	        lazyComponent._status = Pending;
	        var ctor = lazyComponent._ctor;
	        var _thenable = ctor();
	        _thenable.then(function (moduleObject) {
	          if (lazyComponent._status === Pending) {
	            var defaultExport = moduleObject.default;
	            {
	              if (defaultExport === undefined) {
	                warning$1(false, 'lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + "const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
	              }
	            }
	            lazyComponent._status = Resolved;
	            lazyComponent._result = defaultExport;
	          }
	        }, function (error) {
	          if (lazyComponent._status === Pending) {
	            lazyComponent._status = Rejected;
	            lazyComponent._result = error;
	          }
	        });
	        // Handle synchronous thenables.
	        switch (lazyComponent._status) {
	          case Resolved:
	            return lazyComponent._result;
	          case Rejected:
	            throw lazyComponent._result;
	        }
	        lazyComponent._result = _thenable;
	        throw _thenable;
	      }
	  }
	}

	var fakeInternalInstance = {};
	var isArray$1 = Array.isArray;

	// React.Component uses a shared frozen object by default.
	// We'll use it to determine whether we need to initialize legacy refs.
	var emptyRefsObject = new React.Component().refs;

	var didWarnAboutStateAssignmentForComponent = void 0;
	var didWarnAboutUninitializedState = void 0;
	var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;
	var didWarnAboutLegacyLifecyclesAndDerivedState = void 0;
	var didWarnAboutUndefinedDerivedState = void 0;
	var warnOnUndefinedDerivedState = void 0;
	var warnOnInvalidCallback$1 = void 0;
	var didWarnAboutDirectlyAssigningPropsToState = void 0;
	var didWarnAboutContextTypeAndContextTypes = void 0;
	var didWarnAboutInvalidateContextType = void 0;

	{
	  didWarnAboutStateAssignmentForComponent = new Set();
	  didWarnAboutUninitializedState = new Set();
	  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
	  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
	  didWarnAboutDirectlyAssigningPropsToState = new Set();
	  didWarnAboutUndefinedDerivedState = new Set();
	  didWarnAboutContextTypeAndContextTypes = new Set();
	  didWarnAboutInvalidateContextType = new Set();

	  var didWarnOnInvalidCallback = new Set();

	  warnOnInvalidCallback$1 = function (callback, callerName) {
	    if (callback === null || typeof callback === 'function') {
	      return;
	    }
	    var key = callerName + '_' + callback;
	    if (!didWarnOnInvalidCallback.has(key)) {
	      didWarnOnInvalidCallback.add(key);
	      warningWithoutStack$1(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
	    }
	  };

	  warnOnUndefinedDerivedState = function (type, partialState) {
	    if (partialState === undefined) {
	      var componentName = getComponentName(type) || 'Component';
	      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
	        didWarnAboutUndefinedDerivedState.add(componentName);
	        warningWithoutStack$1(false, '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);
	      }
	    }
	  };

	  // This is so gross but it's at least non-critical and can be removed if
	  // it causes problems. This is meant to give a nicer error message for
	  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
	  // ...)) which otherwise throws a "_processChildContext is not a function"
	  // exception.
	  Object.defineProperty(fakeInternalInstance, '_processChildContext', {
	    enumerable: false,
	    value: function () {
	      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');
	    }
	  });
	  Object.freeze(fakeInternalInstance);
	}

	function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
	  var prevState = workInProgress.memoizedState;

	  {
	    if (workInProgress.mode & StrictMode) {
	      // Invoke the function an extra time to help detect side-effects.
	      getDerivedStateFromProps(nextProps, prevState);
	    }
	  }

	  var partialState = getDerivedStateFromProps(nextProps, prevState);

	  {
	    warnOnUndefinedDerivedState(ctor, partialState);
	  }
	  // Merge the partial state and the previous state.
	  var memoizedState = partialState === null || partialState === undefined ? prevState : _assign({}, prevState, partialState);
	  workInProgress.memoizedState = memoizedState;

	  // Once the update queue is empty, persist the derived state onto the
	  // base state.
	  var updateQueue = workInProgress.updateQueue;
	  if (updateQueue !== null && workInProgress.expirationTime === NoWork) {
	    updateQueue.baseState = memoizedState;
	  }
	}

	var classComponentUpdater = {
	  isMounted: isMounted,
	  enqueueSetState: function (inst, payload, callback) {
	    var fiber = get(inst);
	    var currentTime = requestCurrentTime();
	    var expirationTime = computeExpirationForFiber(currentTime, fiber);

	    var update = createUpdate(expirationTime);
	    update.payload = payload;
	    if (callback !== undefined && callback !== null) {
	      {
	        warnOnInvalidCallback$1(callback, 'setState');
	      }
	      update.callback = callback;
	    }

	    flushPassiveEffects();
	    enqueueUpdate(fiber, update);
	    scheduleWork(fiber, expirationTime);
	  },
	  enqueueReplaceState: function (inst, payload, callback) {
	    var fiber = get(inst);
	    var currentTime = requestCurrentTime();
	    var expirationTime = computeExpirationForFiber(currentTime, fiber);

	    var update = createUpdate(expirationTime);
	    update.tag = ReplaceState;
	    update.payload = payload;

	    if (callback !== undefined && callback !== null) {
	      {
	        warnOnInvalidCallback$1(callback, 'replaceState');
	      }
	      update.callback = callback;
	    }

	    flushPassiveEffects();
	    enqueueUpdate(fiber, update);
	    scheduleWork(fiber, expirationTime);
	  },
	  enqueueForceUpdate: function (inst, callback) {
	    var fiber = get(inst);
	    var currentTime = requestCurrentTime();
	    var expirationTime = computeExpirationForFiber(currentTime, fiber);

	    var update = createUpdate(expirationTime);
	    update.tag = ForceUpdate;

	    if (callback !== undefined && callback !== null) {
	      {
	        warnOnInvalidCallback$1(callback, 'forceUpdate');
	      }
	      update.callback = callback;
	    }

	    flushPassiveEffects();
	    enqueueUpdate(fiber, update);
	    scheduleWork(fiber, expirationTime);
	  }
	};

	function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
	  var instance = workInProgress.stateNode;
	  if (typeof instance.shouldComponentUpdate === 'function') {
	    startPhaseTimer(workInProgress, 'shouldComponentUpdate');
	    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
	    stopPhaseTimer();

	    {
	      !(shouldUpdate !== undefined) ? warningWithoutStack$1(false, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(ctor) || 'Component') : void 0;
	    }

	    return shouldUpdate;
	  }

	  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
	    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
	  }

	  return true;
	}

	function checkClassInstance(workInProgress, ctor, newProps) {
	  var instance = workInProgress.stateNode;
	  {
	    var name = getComponentName(ctor) || 'Component';
	    var renderPresent = instance.render;

	    if (!renderPresent) {
	      if (ctor.prototype && typeof ctor.prototype.render === 'function') {
	        warningWithoutStack$1(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
	      } else {
	        warningWithoutStack$1(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
	      }
	    }

	    var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
	    !noGetInitialStateOnES6 ? warningWithoutStack$1(false, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name) : void 0;
	    var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
	    !noGetDefaultPropsOnES6 ? warningWithoutStack$1(false, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name) : void 0;
	    var noInstancePropTypes = !instance.propTypes;
	    !noInstancePropTypes ? warningWithoutStack$1(false, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name) : void 0;
	    var noInstanceContextType = !instance.contextType;
	    !noInstanceContextType ? warningWithoutStack$1(false, 'contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name) : void 0;
	    var noInstanceContextTypes = !instance.contextTypes;
	    !noInstanceContextTypes ? warningWithoutStack$1(false, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name) : void 0;

	    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
	      didWarnAboutContextTypeAndContextTypes.add(ctor);
	      warningWithoutStack$1(false, '%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);
	    }

	    var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';
	    !noComponentShouldUpdate ? warningWithoutStack$1(false, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name) : void 0;
	    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
	      warningWithoutStack$1(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(ctor) || 'A pure component');
	    }
	    var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';
	    !noComponentDidUnmount ? warningWithoutStack$1(false, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name) : void 0;
	    var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';
	    !noComponentDidReceiveProps ? warningWithoutStack$1(false, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name) : void 0;
	    var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';
	    !noComponentWillRecieveProps ? warningWithoutStack$1(false, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name) : void 0;
	    var noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== 'function';
	    !noUnsafeComponentWillRecieveProps ? warningWithoutStack$1(false, '%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name) : void 0;
	    var hasMutatedProps = instance.props !== newProps;
	    !(instance.props === undefined || !hasMutatedProps) ? warningWithoutStack$1(false, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name) : void 0;
	    var noInstanceDefaultProps = !instance.defaultProps;
	    !noInstanceDefaultProps ? warningWithoutStack$1(false, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name) : void 0;

	    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
	      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
	      warningWithoutStack$1(false, '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentName(ctor));
	    }

	    var noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== 'function';
	    !noInstanceGetDerivedStateFromProps ? warningWithoutStack$1(false, '%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name) : void 0;
	    var noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromError !== 'function';
	    !noInstanceGetDerivedStateFromCatch ? warningWithoutStack$1(false, '%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name) : void 0;
	    var noStaticGetSnapshotBeforeUpdate = typeof ctor.getSnapshotBeforeUpdate !== 'function';
	    !noStaticGetSnapshotBeforeUpdate ? warningWithoutStack$1(false, '%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name) : void 0;
	    var _state = instance.state;
	    if (_state && (typeof _state !== 'object' || isArray$1(_state))) {
	      warningWithoutStack$1(false, '%s.state: must be set to an object or null', name);
	    }
	    if (typeof instance.getChildContext === 'function') {
	      !(typeof ctor.childContextTypes === 'object') ? warningWithoutStack$1(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name) : void 0;
	    }
	  }
	}

	function adoptClassInstance(workInProgress, instance) {
	  instance.updater = classComponentUpdater;
	  workInProgress.stateNode = instance;
	  // The instance needs access to the fiber so that it can schedule updates
	  set(instance, workInProgress);
	  {
	    instance._reactInternalInstance = fakeInternalInstance;
	  }
	}

	function constructClassInstance(workInProgress, ctor, props, renderExpirationTime) {
	  var isLegacyContextConsumer = false;
	  var unmaskedContext = emptyContextObject;
	  var context = null;
	  var contextType = ctor.contextType;

	  {
	    if ('contextType' in ctor) {
	      var isValid =
	      // Allow null for conditional declaration
	      contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>

	      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
	        didWarnAboutInvalidateContextType.add(ctor);

	        var addendum = '';
	        if (contextType === undefined) {
	          addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';
	        } else if (typeof contextType !== 'object') {
	          addendum = ' However, it is set to a ' + typeof contextType + '.';
	        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
	          addendum = ' Did you accidentally pass the Context.Provider instead?';
	        } else if (contextType._context !== undefined) {
	          // <Context.Consumer>
	          addendum = ' Did you accidentally pass the Context.Consumer instead?';
	        } else {
	          addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
	        }
	        warningWithoutStack$1(false, '%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentName(ctor) || 'Component', addendum);
	      }
	    }
	  }

	  if (typeof contextType === 'object' && contextType !== null) {
	    context = readContext(contextType);
	  } else {
	    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
	    var contextTypes = ctor.contextTypes;
	    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
	    context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
	  }

	  // Instantiate twice to help detect side-effects.
	  {
	    if (workInProgress.mode & StrictMode) {
	      new ctor(props, context); // eslint-disable-line no-new
	    }
	  }

	  var instance = new ctor(props, context);
	  var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
	  adoptClassInstance(workInProgress, instance);

	  {
	    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {
	      var componentName = getComponentName(ctor) || 'Component';
	      if (!didWarnAboutUninitializedState.has(componentName)) {
	        didWarnAboutUninitializedState.add(componentName);
	        warningWithoutStack$1(false, '`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);
	      }
	    }

	    // If new component APIs are defined, "unsafe" lifecycles won't be called.
	    // Warn about these lifecycles if they are present.
	    // Don't warn about react-lifecycles-compat polyfilled methods though.
	    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {
	      var foundWillMountName = null;
	      var foundWillReceivePropsName = null;
	      var foundWillUpdateName = null;
	      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {
	        foundWillMountName = 'componentWillMount';
	      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {
	        foundWillMountName = 'UNSAFE_componentWillMount';
	      }
	      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
	        foundWillReceivePropsName = 'componentWillReceiveProps';
	      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
	        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
	      }
	      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
	        foundWillUpdateName = 'componentWillUpdate';
	      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
	        foundWillUpdateName = 'UNSAFE_componentWillUpdate';
	      }
	      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
	        var _componentName = getComponentName(ctor) || 'Component';
	        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';
	        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
	          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
	          warningWithoutStack$1(false, 'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n' + 'The above lifecycles should be removed. Learn more about this warning here:\n' + 'https://fb.me/react-async-component-lifecycle-hooks', _componentName, newApiName, foundWillMountName !== null ? '\n  ' + foundWillMountName : '', foundWillReceivePropsName !== null ? '\n  ' + foundWillReceivePropsName : '', foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '');
	        }
	      }
	    }
	  }

	  // Cache unmasked context so we can avoid recreating masked context unless necessary.
	  // ReactFiberContext usually updates this cache but can't for newly-created instances.
	  if (isLegacyContextConsumer) {
	    cacheContext(workInProgress, unmaskedContext, context);
	  }

	  return instance;
	}

	function callComponentWillMount(workInProgress, instance) {
	  startPhaseTimer(workInProgress, 'componentWillMount');
	  var oldState = instance.state;

	  if (typeof instance.componentWillMount === 'function') {
	    instance.componentWillMount();
	  }
	  if (typeof instance.UNSAFE_componentWillMount === 'function') {
	    instance.UNSAFE_componentWillMount();
	  }

	  stopPhaseTimer();

	  if (oldState !== instance.state) {
	    {
	      warningWithoutStack$1(false, '%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress.type) || 'Component');
	    }
	    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
	  }
	}

	function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
	  var oldState = instance.state;
	  startPhaseTimer(workInProgress, 'componentWillReceiveProps');
	  if (typeof instance.componentWillReceiveProps === 'function') {
	    instance.componentWillReceiveProps(newProps, nextContext);
	  }
	  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
	    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
	  }
	  stopPhaseTimer();

	  if (instance.state !== oldState) {
	    {
	      var componentName = getComponentName(workInProgress.type) || 'Component';
	      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
	        didWarnAboutStateAssignmentForComponent.add(componentName);
	        warningWithoutStack$1(false, '%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
	      }
	    }
	    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
	  }
	}

	// Invokes the mount life-cycles on a previously never rendered instance.
	function mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
	  {
	    checkClassInstance(workInProgress, ctor, newProps);
	  }

	  var instance = workInProgress.stateNode;
	  instance.props = newProps;
	  instance.state = workInProgress.memoizedState;
	  instance.refs = emptyRefsObject;

	  var contextType = ctor.contextType;
	  if (typeof contextType === 'object' && contextType !== null) {
	    instance.context = readContext(contextType);
	  } else {
	    var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
	    instance.context = getMaskedContext(workInProgress, unmaskedContext);
	  }

	  {
	    if (instance.state === newProps) {
	      var componentName = getComponentName(ctor) || 'Component';
	      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
	        didWarnAboutDirectlyAssigningPropsToState.add(componentName);
	        warningWithoutStack$1(false, '%s: It is not recommended to assign props directly to state ' + "because updates to props won't be reflected in state. " + 'In most cases, it is better to use props directly.', componentName);
	      }
	    }

	    if (workInProgress.mode & StrictMode) {
	      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);

	      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
	    }
	  }

	  var updateQueue = workInProgress.updateQueue;
	  if (updateQueue !== null) {
	    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
	    instance.state = workInProgress.memoizedState;
	  }

	  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
	  if (typeof getDerivedStateFromProps === 'function') {
	    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
	    instance.state = workInProgress.memoizedState;
	  }

	  // In order to support react-lifecycles-compat polyfilled components,
	  // Unsafe lifecycles should not be invoked for components using the new APIs.
	  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
	    callComponentWillMount(workInProgress, instance);
	    // If we had additional state updates during this life-cycle, let's
	    // process them now.
	    updateQueue = workInProgress.updateQueue;
	    if (updateQueue !== null) {
	      processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
	      instance.state = workInProgress.memoizedState;
	    }
	  }

	  if (typeof instance.componentDidMount === 'function') {
	    workInProgress.effectTag |= Update;
	  }
	}

	function resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
	  var instance = workInProgress.stateNode;

	  var oldProps = workInProgress.memoizedProps;
	  instance.props = oldProps;

	  var oldContext = instance.context;
	  var contextType = ctor.contextType;
	  var nextContext = void 0;
	  if (typeof contextType === 'object' && contextType !== null) {
	    nextContext = readContext(contextType);
	  } else {
	    var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
	    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
	  }

	  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
	  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';

	  // Note: During these life-cycles, instance.props/instance.state are what
	  // ever the previously attempted to render - not the "current". However,
	  // during componentDidUpdate we pass the "current" props.

	  // In order to support react-lifecycles-compat polyfilled components,
	  // Unsafe lifecycles should not be invoked for components using the new APIs.
	  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
	    if (oldProps !== newProps || oldContext !== nextContext) {
	      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
	    }
	  }

	  resetHasForceUpdateBeforeProcessing();

	  var oldState = workInProgress.memoizedState;
	  var newState = instance.state = oldState;
	  var updateQueue = workInProgress.updateQueue;
	  if (updateQueue !== null) {
	    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
	    newState = workInProgress.memoizedState;
	  }
	  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
	    // If an update was already in progress, we should schedule an Update
	    // effect even though we're bailing out, so that cWU/cDU are called.
	    if (typeof instance.componentDidMount === 'function') {
	      workInProgress.effectTag |= Update;
	    }
	    return false;
	  }

	  if (typeof getDerivedStateFromProps === 'function') {
	    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
	    newState = workInProgress.memoizedState;
	  }

	  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

	  if (shouldUpdate) {
	    // In order to support react-lifecycles-compat polyfilled components,
	    // Unsafe lifecycles should not be invoked for components using the new APIs.
	    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
	      startPhaseTimer(workInProgress, 'componentWillMount');
	      if (typeof instance.componentWillMount === 'function') {
	        instance.componentWillMount();
	      }
	      if (typeof instance.UNSAFE_componentWillMount === 'function') {
	        instance.UNSAFE_componentWillMount();
	      }
	      stopPhaseTimer();
	    }
	    if (typeof instance.componentDidMount === 'function') {
	      workInProgress.effectTag |= Update;
	    }
	  } else {
	    // If an update was already in progress, we should schedule an Update
	    // effect even though we're bailing out, so that cWU/cDU are called.
	    if (typeof instance.componentDidMount === 'function') {
	      workInProgress.effectTag |= Update;
	    }

	    // If shouldComponentUpdate returned false, we should still update the
	    // memoized state to indicate that this work can be reused.
	    workInProgress.memoizedProps = newProps;
	    workInProgress.memoizedState = newState;
	  }

	  // Update the existing instance's state, props, and context pointers even
	  // if shouldComponentUpdate returns false.
	  instance.props = newProps;
	  instance.state = newState;
	  instance.context = nextContext;

	  return shouldUpdate;
	}

	// Invokes the update life-cycles and returns false if it shouldn't rerender.
	function updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {
	  var instance = workInProgress.stateNode;

	  var oldProps = workInProgress.memoizedProps;
	  instance.props = workInProgress.type === workInProgress.elementType ? oldProps : resolveDefaultProps(workInProgress.type, oldProps);

	  var oldContext = instance.context;
	  var contextType = ctor.contextType;
	  var nextContext = void 0;
	  if (typeof contextType === 'object' && contextType !== null) {
	    nextContext = readContext(contextType);
	  } else {
	    var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
	    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
	  }

	  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
	  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';

	  // Note: During these life-cycles, instance.props/instance.state are what
	  // ever the previously attempted to render - not the "current". However,
	  // during componentDidUpdate we pass the "current" props.

	  // In order to support react-lifecycles-compat polyfilled components,
	  // Unsafe lifecycles should not be invoked for components using the new APIs.
	  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
	    if (oldProps !== newProps || oldContext !== nextContext) {
	      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
	    }
	  }

	  resetHasForceUpdateBeforeProcessing();

	  var oldState = workInProgress.memoizedState;
	  var newState = instance.state = oldState;
	  var updateQueue = workInProgress.updateQueue;
	  if (updateQueue !== null) {
	    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
	    newState = workInProgress.memoizedState;
	  }

	  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
	    // If an update was already in progress, we should schedule an Update
	    // effect even though we're bailing out, so that cWU/cDU are called.
	    if (typeof instance.componentDidUpdate === 'function') {
	      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
	        workInProgress.effectTag |= Update;
	      }
	    }
	    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
	      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
	        workInProgress.effectTag |= Snapshot;
	      }
	    }
	    return false;
	  }

	  if (typeof getDerivedStateFromProps === 'function') {
	    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
	    newState = workInProgress.memoizedState;
	  }

	  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

	  if (shouldUpdate) {
	    // In order to support react-lifecycles-compat polyfilled components,
	    // Unsafe lifecycles should not be invoked for components using the new APIs.
	    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {
	      startPhaseTimer(workInProgress, 'componentWillUpdate');
	      if (typeof instance.componentWillUpdate === 'function') {
	        instance.componentWillUpdate(newProps, newState, nextContext);
	      }
	      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
	        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
	      }
	      stopPhaseTimer();
	    }
	    if (typeof instance.componentDidUpdate === 'function') {
	      workInProgress.effectTag |= Update;
	    }
	    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
	      workInProgress.effectTag |= Snapshot;
	    }
	  } else {
	    // If an update was already in progress, we should schedule an Update
	    // effect even though we're bailing out, so that cWU/cDU are called.
	    if (typeof instance.componentDidUpdate === 'function') {
	      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
	        workInProgress.effectTag |= Update;
	      }
	    }
	    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
	      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
	        workInProgress.effectTag |= Snapshot;
	      }
	    }

	    // If shouldComponentUpdate returned false, we should still update the
	    // memoized props/state to indicate that this work can be reused.
	    workInProgress.memoizedProps = newProps;
	    workInProgress.memoizedState = newState;
	  }

	  // Update the existing instance's state, props, and context pointers even
	  // if shouldComponentUpdate returns false.
	  instance.props = newProps;
	  instance.state = newState;
	  instance.context = nextContext;

	  return shouldUpdate;
	}

	var didWarnAboutMaps = void 0;
	var didWarnAboutGenerators = void 0;
	var didWarnAboutStringRefInStrictMode = void 0;
	var ownerHasKeyUseWarning = void 0;
	var ownerHasFunctionTypeWarning = void 0;
	var warnForMissingKey = function (child) {};

	{
	  didWarnAboutMaps = false;
	  didWarnAboutGenerators = false;
	  didWarnAboutStringRefInStrictMode = {};

	  /**
	   * Warn if there's no key explicitly set on dynamic arrays of children or
	   * object keys are not valid. This allows us to keep track of children between
	   * updates.
	   */
	  ownerHasKeyUseWarning = {};
	  ownerHasFunctionTypeWarning = {};

	  warnForMissingKey = function (child) {
	    if (child === null || typeof child !== 'object') {
	      return;
	    }
	    if (!child._store || child._store.validated || child.key != null) {
	      return;
	    }
	    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	    child._store.validated = true;

	    var currentComponentErrorInfo = 'Each child in a list should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + getCurrentFiberStackInDev();
	    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
	      return;
	    }
	    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

	    warning$1(false, 'Each child in a list should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.');
	  };
	}

	var isArray = Array.isArray;

	function coerceRef(returnFiber, current$$1, element) {
	  var mixedRef = element.ref;
	  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {
	    {
	      if (returnFiber.mode & StrictMode) {
	        var componentName = getComponentName(returnFiber.type) || 'Component';
	        if (!didWarnAboutStringRefInStrictMode[componentName]) {
	          warningWithoutStack$1(false, 'A string ref, "%s", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using createRef() instead.' + '\n%s' + '\n\nLearn more about using refs safely here:' + '\nhttps://fb.me/react-strict-mode-string-ref', mixedRef, getStackByFiberInDevAndProd(returnFiber));
	          didWarnAboutStringRefInStrictMode[componentName] = true;
	        }
	      }
	    }

	    if (element._owner) {
	      var owner = element._owner;
	      var inst = void 0;
	      if (owner) {
	        var ownerFiber = owner;
	        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Function components cannot have refs. Did you mean to use React.forwardRef()?') : void 0;
	        inst = ownerFiber.stateNode;
	      }
	      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;
	      var stringRef = '' + mixedRef;
	      // Check if previous string ref matches new string ref
	      if (current$$1 !== null && current$$1.ref !== null && typeof current$$1.ref === 'function' && current$$1.ref._stringRef === stringRef) {
	        return current$$1.ref;
	      }
	      var ref = function (value) {
	        var refs = inst.refs;
	        if (refs === emptyRefsObject) {
	          // This is a lazy pooled frozen object, so we need to initialize.
	          refs = inst.refs = {};
	        }
	        if (value === null) {
	          delete refs[stringRef];
	        } else {
	          refs[stringRef] = value;
	        }
	      };
	      ref._stringRef = stringRef;
	      return ref;
	    } else {
	      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function, a string, an object returned by React.createRef(), or null.') : void 0;
	      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component\'s render method\n3. You have multiple copies of React loaded\nSee https://fb.me/react-refs-must-have-owner for more information.', mixedRef) : void 0;
	    }
	  }
	  return mixedRef;
	}

	function throwOnInvalidObjectType(returnFiber, newChild) {
	  if (returnFiber.type !== 'textarea') {
	    var addendum = '';
	    {
	      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + getCurrentFiberStackInDev();
	    }
	    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);
	  }
	}

	function warnOnFunctionType() {
	  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + getCurrentFiberStackInDev();

	  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
	    return;
	  }
	  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;

	  warning$1(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');
	}

	// This wrapper function exists because I expect to clone the code in each path
	// to be able to optimize each path individually by branching early. This needs
	// a compiler or we can do it manually. Helpers that don't need this branching
	// live outside of this function.
	function ChildReconciler(shouldTrackSideEffects) {
	  function deleteChild(returnFiber, childToDelete) {
	    if (!shouldTrackSideEffects) {
	      // Noop.
	      return;
	    }
	    // Deletions are added in reversed order so we add it to the front.
	    // At this point, the return fiber's effect list is empty except for
	    // deletions, so we can just append the deletion to the list. The remaining
	    // effects aren't added until the complete phase. Once we implement
	    // resuming, this may not be true.
	    var last = returnFiber.lastEffect;
	    if (last !== null) {
	      last.nextEffect = childToDelete;
	      returnFiber.lastEffect = childToDelete;
	    } else {
	      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
	    }
	    childToDelete.nextEffect = null;
	    childToDelete.effectTag = Deletion;
	  }

	  function deleteRemainingChildren(returnFiber, currentFirstChild) {
	    if (!shouldTrackSideEffects) {
	      // Noop.
	      return null;
	    }

	    // TODO: For the shouldClone case, this could be micro-optimized a bit by
	    // assuming that after the first child we've already added everything.
	    var childToDelete = currentFirstChild;
	    while (childToDelete !== null) {
	      deleteChild(returnFiber, childToDelete);
	      childToDelete = childToDelete.sibling;
	    }
	    return null;
	  }

	  function mapRemainingChildren(returnFiber, currentFirstChild) {
	    // Add the remaining children to a temporary map so that we can find them by
	    // keys quickly. Implicit (null) keys get added to this set with their index
	    var existingChildren = new Map();

	    var existingChild = currentFirstChild;
	    while (existingChild !== null) {
	      if (existingChild.key !== null) {
	        existingChildren.set(existingChild.key, existingChild);
	      } else {
	        existingChildren.set(existingChild.index, existingChild);
	      }
	      existingChild = existingChild.sibling;
	    }
	    return existingChildren;
	  }

	  function useFiber(fiber, pendingProps, expirationTime) {
	    // We currently set sibling to null and index to 0 here because it is easy
	    // to forget to do before returning it. E.g. for the single child case.
	    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
	    clone.index = 0;
	    clone.sibling = null;
	    return clone;
	  }

	  function placeChild(newFiber, lastPlacedIndex, newIndex) {
	    newFiber.index = newIndex;
	    if (!shouldTrackSideEffects) {
	      // Noop.
	      return lastPlacedIndex;
	    }
	    var current$$1 = newFiber.alternate;
	    if (current$$1 !== null) {
	      var oldIndex = current$$1.index;
	      if (oldIndex < lastPlacedIndex) {
	        // This is a move.
	        newFiber.effectTag = Placement;
	        return lastPlacedIndex;
	      } else {
	        // This item can stay in place.
	        return oldIndex;
	      }
	    } else {
	      // This is an insertion.
	      newFiber.effectTag = Placement;
	      return lastPlacedIndex;
	    }
	  }

	  function placeSingleChild(newFiber) {
	    // This is simpler for the single child case. We only need to do a
	    // placement for inserting new children.
	    if (shouldTrackSideEffects && newFiber.alternate === null) {
	      newFiber.effectTag = Placement;
	    }
	    return newFiber;
	  }

	  function updateTextNode(returnFiber, current$$1, textContent, expirationTime) {
	    if (current$$1 === null || current$$1.tag !== HostText) {
	      // Insert
	      var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
	      created.return = returnFiber;
	      return created;
	    } else {
	      // Update
	      var existing = useFiber(current$$1, textContent, expirationTime);
	      existing.return = returnFiber;
	      return existing;
	    }
	  }

	  function updateElement(returnFiber, current$$1, element, expirationTime) {
	    if (current$$1 !== null && current$$1.elementType === element.type) {
	      // Move based on index
	      var existing = useFiber(current$$1, element.props, expirationTime);
	      existing.ref = coerceRef(returnFiber, current$$1, element);
	      existing.return = returnFiber;
	      {
	        existing._debugSource = element._source;
	        existing._debugOwner = element._owner;
	      }
	      return existing;
	    } else {
	      // Insert
	      var created = createFiberFromElement(element, returnFiber.mode, expirationTime);
	      created.ref = coerceRef(returnFiber, current$$1, element);
	      created.return = returnFiber;
	      return created;
	    }
	  }

	  function updatePortal(returnFiber, current$$1, portal, expirationTime) {
	    if (current$$1 === null || current$$1.tag !== HostPortal || current$$1.stateNode.containerInfo !== portal.containerInfo || current$$1.stateNode.implementation !== portal.implementation) {
	      // Insert
	      var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
	      created.return = returnFiber;
	      return created;
	    } else {
	      // Update
	      var existing = useFiber(current$$1, portal.children || [], expirationTime);
	      existing.return = returnFiber;
	      return existing;
	    }
	  }

	  function updateFragment(returnFiber, current$$1, fragment, expirationTime, key) {
	    if (current$$1 === null || current$$1.tag !== Fragment) {
	      // Insert
	      var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);
	      created.return = returnFiber;
	      return created;
	    } else {
	      // Update
	      var existing = useFiber(current$$1, fragment, expirationTime);
	      existing.return = returnFiber;
	      return existing;
	    }
	  }

	  function createChild(returnFiber, newChild, expirationTime) {
	    if (typeof newChild === 'string' || typeof newChild === 'number') {
	      // Text nodes don't have keys. If the previous node is implicitly keyed
	      // we can continue to replace it without aborting even if it is not a text
	      // node.
	      var created = createFiberFromText('' + newChild, returnFiber.mode, expirationTime);
	      created.return = returnFiber;
	      return created;
	    }

	    if (typeof newChild === 'object' && newChild !== null) {
	      switch (newChild.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	          {
	            var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);
	            _created.ref = coerceRef(returnFiber, null, newChild);
	            _created.return = returnFiber;
	            return _created;
	          }
	        case REACT_PORTAL_TYPE:
	          {
	            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);
	            _created2.return = returnFiber;
	            return _created2;
	          }
	      }

	      if (isArray(newChild) || getIteratorFn(newChild)) {
	        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);
	        _created3.return = returnFiber;
	        return _created3;
	      }

	      throwOnInvalidObjectType(returnFiber, newChild);
	    }

	    {
	      if (typeof newChild === 'function') {
	        warnOnFunctionType();
	      }
	    }

	    return null;
	  }

	  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
	    // Update the fiber if the keys match, otherwise return null.

	    var key = oldFiber !== null ? oldFiber.key : null;

	    if (typeof newChild === 'string' || typeof newChild === 'number') {
	      // Text nodes don't have keys. If the previous node is implicitly keyed
	      // we can continue to replace it without aborting even if it is not a text
	      // node.
	      if (key !== null) {
	        return null;
	      }
	      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);
	    }

	    if (typeof newChild === 'object' && newChild !== null) {
	      switch (newChild.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	          {
	            if (newChild.key === key) {
	              if (newChild.type === REACT_FRAGMENT_TYPE) {
	                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
	              }
	              return updateElement(returnFiber, oldFiber, newChild, expirationTime);
	            } else {
	              return null;
	            }
	          }
	        case REACT_PORTAL_TYPE:
	          {
	            if (newChild.key === key) {
	              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
	            } else {
	              return null;
	            }
	          }
	      }

	      if (isArray(newChild) || getIteratorFn(newChild)) {
	        if (key !== null) {
	          return null;
	        }

	        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
	      }

	      throwOnInvalidObjectType(returnFiber, newChild);
	    }

	    {
	      if (typeof newChild === 'function') {
	        warnOnFunctionType();
	      }
	    }

	    return null;
	  }

	  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
	    if (typeof newChild === 'string' || typeof newChild === 'number') {
	      // Text nodes don't have keys, so we neither have to check the old nor
	      // new node for the key. If both are text nodes, they match.
	      var matchedFiber = existingChildren.get(newIdx) || null;
	      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);
	    }

	    if (typeof newChild === 'object' && newChild !== null) {
	      switch (newChild.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	          {
	            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
	            if (newChild.type === REACT_FRAGMENT_TYPE) {
	              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
	            }
	            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
	          }
	        case REACT_PORTAL_TYPE:
	          {
	            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
	            return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);
	          }
	      }

	      if (isArray(newChild) || getIteratorFn(newChild)) {
	        var _matchedFiber3 = existingChildren.get(newIdx) || null;
	        return updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, null);
	      }

	      throwOnInvalidObjectType(returnFiber, newChild);
	    }

	    {
	      if (typeof newChild === 'function') {
	        warnOnFunctionType();
	      }
	    }

	    return null;
	  }

	  /**
	   * Warns if there is a duplicate or missing key
	   */
	  function warnOnInvalidKey(child, knownKeys) {
	    {
	      if (typeof child !== 'object' || child === null) {
	        return knownKeys;
	      }
	      switch (child.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	        case REACT_PORTAL_TYPE:
	          warnForMissingKey(child);
	          var key = child.key;
	          if (typeof key !== 'string') {
	            break;
	          }
	          if (knownKeys === null) {
	            knownKeys = new Set();
	            knownKeys.add(key);
	            break;
	          }
	          if (!knownKeys.has(key)) {
	            knownKeys.add(key);
	            break;
	          }
	          warning$1(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);
	          break;
	        default:
	          break;
	      }
	    }
	    return knownKeys;
	  }

	  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
	    // This algorithm can't optimize by searching from both ends since we
	    // don't have backpointers on fibers. I'm trying to see how far we can get
	    // with that model. If it ends up not being worth the tradeoffs, we can
	    // add it later.

	    // Even with a two ended optimization, we'd want to optimize for the case
	    // where there are few changes and brute force the comparison instead of
	    // going for the Map. It'd like to explore hitting that path first in
	    // forward-only mode and only go for the Map once we notice that we need
	    // lots of look ahead. This doesn't handle reversal as well as two ended
	    // search but that's unusual. Besides, for the two ended optimization to
	    // work on Iterables, we'd need to copy the whole set.

	    // In this first iteration, we'll just live with hitting the bad case
	    // (adding everything to a Map) in for every insert/move.

	    // If you change this code, also update reconcileChildrenIterator() which
	    // uses the same algorithm.

	    {
	      // First, validate keys.
	      var knownKeys = null;
	      for (var i = 0; i < newChildren.length; i++) {
	        var child = newChildren[i];
	        knownKeys = warnOnInvalidKey(child, knownKeys);
	      }
	    }

	    var resultingFirstChild = null;
	    var previousNewFiber = null;

	    var oldFiber = currentFirstChild;
	    var lastPlacedIndex = 0;
	    var newIdx = 0;
	    var nextOldFiber = null;
	    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
	      if (oldFiber.index > newIdx) {
	        nextOldFiber = oldFiber;
	        oldFiber = null;
	      } else {
	        nextOldFiber = oldFiber.sibling;
	      }
	      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
	      if (newFiber === null) {
	        // TODO: This breaks on empty slots like null children. That's
	        // unfortunate because it triggers the slow path all the time. We need
	        // a better way to communicate whether this was a miss or null,
	        // boolean, undefined, etc.
	        if (oldFiber === null) {
	          oldFiber = nextOldFiber;
	        }
	        break;
	      }
	      if (shouldTrackSideEffects) {
	        if (oldFiber && newFiber.alternate === null) {
	          // We matched the slot, but we didn't reuse the existing fiber, so we
	          // need to delete the existing child.
	          deleteChild(returnFiber, oldFiber);
	        }
	      }
	      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
	      if (previousNewFiber === null) {
	        // TODO: Move out of the loop. This only happens for the first run.
	        resultingFirstChild = newFiber;
	      } else {
	        // TODO: Defer siblings if we're not at the right index for this slot.
	        // I.e. if we had null values before, then we want to defer this
	        // for each null value. However, we also don't want to call updateSlot
	        // with the previous one.
	        previousNewFiber.sibling = newFiber;
	      }
	      previousNewFiber = newFiber;
	      oldFiber = nextOldFiber;
	    }

	    if (newIdx === newChildren.length) {
	      // We've reached the end of the new children. We can delete the rest.
	      deleteRemainingChildren(returnFiber, oldFiber);
	      return resultingFirstChild;
	    }

	    if (oldFiber === null) {
	      // If we don't have any more existing children we can choose a fast path
	      // since the rest will all be insertions.
	      for (; newIdx < newChildren.length; newIdx++) {
	        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
	        if (!_newFiber) {
	          continue;
	        }
	        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
	        if (previousNewFiber === null) {
	          // TODO: Move out of the loop. This only happens for the first run.
	          resultingFirstChild = _newFiber;
	        } else {
	          previousNewFiber.sibling = _newFiber;
	        }
	        previousNewFiber = _newFiber;
	      }
	      return resultingFirstChild;
	    }

	    // Add all children to a key map for quick lookups.
	    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

	    // Keep scanning and use the map to restore deleted items as moves.
	    for (; newIdx < newChildren.length; newIdx++) {
	      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);
	      if (_newFiber2) {
	        if (shouldTrackSideEffects) {
	          if (_newFiber2.alternate !== null) {
	            // The new fiber is a work in progress, but if there exists a
	            // current, that means that we reused the fiber. We need to delete
	            // it from the child list so that we don't add it to the deletion
	            // list.
	            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
	          }
	        }
	        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
	        if (previousNewFiber === null) {
	          resultingFirstChild = _newFiber2;
	        } else {
	          previousNewFiber.sibling = _newFiber2;
	        }
	        previousNewFiber = _newFiber2;
	      }
	    }

	    if (shouldTrackSideEffects) {
	      // Any existing children that weren't consumed above were deleted. We need
	      // to add them to the deletion list.
	      existingChildren.forEach(function (child) {
	        return deleteChild(returnFiber, child);
	      });
	    }

	    return resultingFirstChild;
	  }

	  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
	    // This is the same implementation as reconcileChildrenArray(),
	    // but using the iterator instead.

	    var iteratorFn = getIteratorFn(newChildrenIterable);
	    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;

	    {
	      // We don't support rendering Generators because it's a mutation.
	      // See https://github.com/facebook/react/issues/12995
	      if (typeof Symbol === 'function' &&
	      // $FlowFixMe Flow doesn't know about toStringTag
	      newChildrenIterable[Symbol.toStringTag] === 'Generator') {
	        !didWarnAboutGenerators ? warning$1(false, 'Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.') : void 0;
	        didWarnAboutGenerators = true;
	      }

	      // Warn about using Maps as children
	      if (newChildrenIterable.entries === iteratorFn) {
	        !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;
	        didWarnAboutMaps = true;
	      }

	      // First, validate keys.
	      // We'll get a different iterator later for the main pass.
	      var _newChildren = iteratorFn.call(newChildrenIterable);
	      if (_newChildren) {
	        var knownKeys = null;
	        var _step = _newChildren.next();
	        for (; !_step.done; _step = _newChildren.next()) {
	          var child = _step.value;
	          knownKeys = warnOnInvalidKey(child, knownKeys);
	        }
	      }
	    }

	    var newChildren = iteratorFn.call(newChildrenIterable);
	    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;

	    var resultingFirstChild = null;
	    var previousNewFiber = null;

	    var oldFiber = currentFirstChild;
	    var lastPlacedIndex = 0;
	    var newIdx = 0;
	    var nextOldFiber = null;

	    var step = newChildren.next();
	    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
	      if (oldFiber.index > newIdx) {
	        nextOldFiber = oldFiber;
	        oldFiber = null;
	      } else {
	        nextOldFiber = oldFiber.sibling;
	      }
	      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
	      if (newFiber === null) {
	        // TODO: This breaks on empty slots like null children. That's
	        // unfortunate because it triggers the slow path all the time. We need
	        // a better way to communicate whether this was a miss or null,
	        // boolean, undefined, etc.
	        if (!oldFiber) {
	          oldFiber = nextOldFiber;
	        }
	        break;
	      }
	      if (shouldTrackSideEffects) {
	        if (oldFiber && newFiber.alternate === null) {
	          // We matched the slot, but we didn't reuse the existing fiber, so we
	          // need to delete the existing child.
	          deleteChild(returnFiber, oldFiber);
	        }
	      }
	      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
	      if (previousNewFiber === null) {
	        // TODO: Move out of the loop. This only happens for the first run.
	        resultingFirstChild = newFiber;
	      } else {
	        // TODO: Defer siblings if we're not at the right index for this slot.
	        // I.e. if we had null values before, then we want to defer this
	        // for each null value. However, we also don't want to call updateSlot
	        // with the previous one.
	        previousNewFiber.sibling = newFiber;
	      }
	      previousNewFiber = newFiber;
	      oldFiber = nextOldFiber;
	    }

	    if (step.done) {
	      // We've reached the end of the new children. We can delete the rest.
	      deleteRemainingChildren(returnFiber, oldFiber);
	      return resultingFirstChild;
	    }

	    if (oldFiber === null) {
	      // If we don't have any more existing children we can choose a fast path
	      // since the rest will all be insertions.
	      for (; !step.done; newIdx++, step = newChildren.next()) {
	        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
	        if (_newFiber3 === null) {
	          continue;
	        }
	        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
	        if (previousNewFiber === null) {
	          // TODO: Move out of the loop. This only happens for the first run.
	          resultingFirstChild = _newFiber3;
	        } else {
	          previousNewFiber.sibling = _newFiber3;
	        }
	        previousNewFiber = _newFiber3;
	      }
	      return resultingFirstChild;
	    }

	    // Add all children to a key map for quick lookups.
	    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

	    // Keep scanning and use the map to restore deleted items as moves.
	    for (; !step.done; newIdx++, step = newChildren.next()) {
	      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
	      if (_newFiber4 !== null) {
	        if (shouldTrackSideEffects) {
	          if (_newFiber4.alternate !== null) {
	            // The new fiber is a work in progress, but if there exists a
	            // current, that means that we reused the fiber. We need to delete
	            // it from the child list so that we don't add it to the deletion
	            // list.
	            existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
	          }
	        }
	        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
	        if (previousNewFiber === null) {
	          resultingFirstChild = _newFiber4;
	        } else {
	          previousNewFiber.sibling = _newFiber4;
	        }
	        previousNewFiber = _newFiber4;
	      }
	    }

	    if (shouldTrackSideEffects) {
	      // Any existing children that weren't consumed above were deleted. We need
	      // to add them to the deletion list.
	      existingChildren.forEach(function (child) {
	        return deleteChild(returnFiber, child);
	      });
	    }

	    return resultingFirstChild;
	  }

	  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
	    // There's no need to check for keys on text nodes since we don't have a
	    // way to define them.
	    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
	      // We already have an existing node so let's just update it and delete
	      // the rest.
	      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
	      var existing = useFiber(currentFirstChild, textContent, expirationTime);
	      existing.return = returnFiber;
	      return existing;
	    }
	    // The existing first child is not a text node so we need to create one
	    // and delete the existing ones.
	    deleteRemainingChildren(returnFiber, currentFirstChild);
	    var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
	    created.return = returnFiber;
	    return created;
	  }

	  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
	    var key = element.key;
	    var child = currentFirstChild;
	    while (child !== null) {
	      // TODO: If key === null and child.key === null, then this only applies to
	      // the first item in the list.
	      if (child.key === key) {
	        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.elementType === element.type) {
	          deleteRemainingChildren(returnFiber, child.sibling);
	          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
	          existing.ref = coerceRef(returnFiber, child, element);
	          existing.return = returnFiber;
	          {
	            existing._debugSource = element._source;
	            existing._debugOwner = element._owner;
	          }
	          return existing;
	        } else {
	          deleteRemainingChildren(returnFiber, child);
	          break;
	        }
	      } else {
	        deleteChild(returnFiber, child);
	      }
	      child = child.sibling;
	    }

	    if (element.type === REACT_FRAGMENT_TYPE) {
	      var created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);
	      created.return = returnFiber;
	      return created;
	    } else {
	      var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);
	      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
	      _created4.return = returnFiber;
	      return _created4;
	    }
	  }

	  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
	    var key = portal.key;
	    var child = currentFirstChild;
	    while (child !== null) {
	      // TODO: If key === null and child.key === null, then this only applies to
	      // the first item in the list.
	      if (child.key === key) {
	        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
	          deleteRemainingChildren(returnFiber, child.sibling);
	          var existing = useFiber(child, portal.children || [], expirationTime);
	          existing.return = returnFiber;
	          return existing;
	        } else {
	          deleteRemainingChildren(returnFiber, child);
	          break;
	        }
	      } else {
	        deleteChild(returnFiber, child);
	      }
	      child = child.sibling;
	    }

	    var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
	    created.return = returnFiber;
	    return created;
	  }

	  // This API will tag the children with the side-effect of the reconciliation
	  // itself. They will be added to the side-effect list as we pass through the
	  // children and the parent.
	  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
	    // This function is not recursive.
	    // If the top level item is an array, we treat it as a set of children,
	    // not as a fragment. Nested arrays on the other hand will be treated as
	    // fragment nodes. Recursion happens at the normal flow.

	    // Handle top level unkeyed fragments as if they were arrays.
	    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
	    // We treat the ambiguous cases above the same.
	    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
	    if (isUnkeyedTopLevelFragment) {
	      newChild = newChild.props.children;
	    }

	    // Handle object types
	    var isObject = typeof newChild === 'object' && newChild !== null;

	    if (isObject) {
	      switch (newChild.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));
	        case REACT_PORTAL_TYPE:
	          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
	      }
	    }

	    if (typeof newChild === 'string' || typeof newChild === 'number') {
	      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));
	    }

	    if (isArray(newChild)) {
	      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
	    }

	    if (getIteratorFn(newChild)) {
	      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
	    }

	    if (isObject) {
	      throwOnInvalidObjectType(returnFiber, newChild);
	    }

	    {
	      if (typeof newChild === 'function') {
	        warnOnFunctionType();
	      }
	    }
	    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {
	      // If the new child is undefined, and the return fiber is a composite
	      // component, throw an error. If Fiber return types are disabled,
	      // we already threw above.
	      switch (returnFiber.tag) {
	        case ClassComponent:
	          {
	            {
	              var instance = returnFiber.stateNode;
	              if (instance.render._isMockFunction) {
	                // We allow auto-mocks to proceed as if they're returning null.
	                break;
	              }
	            }
	          }
	        // Intentionally fall through to the next case, which handles both
	        // functions and classes
	        // eslint-disable-next-lined no-fallthrough
	        case FunctionComponent:
	          {
	            var Component = returnFiber.type;
	            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');
	          }
	      }
	    }

	    // Remaining cases are all treated as empty.
	    return deleteRemainingChildren(returnFiber, currentFirstChild);
	  }

	  return reconcileChildFibers;
	}

	var reconcileChildFibers = ChildReconciler(true);
	var mountChildFibers = ChildReconciler(false);

	function cloneChildFibers(current$$1, workInProgress) {
	  !(current$$1 === null || workInProgress.child === current$$1.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;

	  if (workInProgress.child === null) {
	    return;
	  }

	  var currentChild = workInProgress.child;
	  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
	  workInProgress.child = newChild;

	  newChild.return = workInProgress;
	  while (currentChild.sibling !== null) {
	    currentChild = currentChild.sibling;
	    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
	    newChild.return = workInProgress;
	  }
	  newChild.sibling = null;
	}

	var NO_CONTEXT = {};

	var contextStackCursor$1 = createCursor(NO_CONTEXT);
	var contextFiberStackCursor = createCursor(NO_CONTEXT);
	var rootInstanceStackCursor = createCursor(NO_CONTEXT);

	function requiredContext(c) {
	  !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	  return c;
	}

	function getRootHostContainer() {
	  var rootInstance = requiredContext(rootInstanceStackCursor.current);
	  return rootInstance;
	}

	function pushHostContainer(fiber, nextRootInstance) {
	  // Push current root instance onto the stack;
	  // This allows us to reset root when portals are popped.
	  push(rootInstanceStackCursor, nextRootInstance, fiber);
	  // Track the context and the Fiber that provided it.
	  // This enables us to pop only Fibers that provide unique contexts.
	  push(contextFiberStackCursor, fiber, fiber);

	  // Finally, we need to push the host context to the stack.
	  // However, we can't just call getRootHostContext() and push it because
	  // we'd have a different number of entries on the stack depending on
	  // whether getRootHostContext() throws somewhere in renderer code or not.
	  // So we push an empty value first. This lets us safely unwind on errors.
	  push(contextStackCursor$1, NO_CONTEXT, fiber);
	  var nextRootContext = getRootHostContext(nextRootInstance);
	  // Now that we know this function doesn't throw, replace it.
	  pop(contextStackCursor$1, fiber);
	  push(contextStackCursor$1, nextRootContext, fiber);
	}

	function popHostContainer(fiber) {
	  pop(contextStackCursor$1, fiber);
	  pop(contextFiberStackCursor, fiber);
	  pop(rootInstanceStackCursor, fiber);
	}

	function getHostContext() {
	  var context = requiredContext(contextStackCursor$1.current);
	  return context;
	}

	function pushHostContext(fiber) {
	  var rootInstance = requiredContext(rootInstanceStackCursor.current);
	  var context = requiredContext(contextStackCursor$1.current);
	  var nextContext = getChildHostContext(context, fiber.type, rootInstance);

	  // Don't push this Fiber's context unless it's unique.
	  if (context === nextContext) {
	    return;
	  }

	  // Track the context and the Fiber that provided it.
	  // This enables us to pop only Fibers that provide unique contexts.
	  push(contextFiberStackCursor, fiber, fiber);
	  push(contextStackCursor$1, nextContext, fiber);
	}

	function popHostContext(fiber) {
	  // Do not pop unless this Fiber provided the current context.
	  // pushHostContext() only pushes Fibers that provide unique contexts.
	  if (contextFiberStackCursor.current !== fiber) {
	    return;
	  }

	  pop(contextStackCursor$1, fiber);
	  pop(contextFiberStackCursor, fiber);
	}

	var NoEffect$1 = /*             */0;
	var UnmountSnapshot = /*      */2;
	var UnmountMutation = /*      */4;
	var MountMutation = /*        */8;
	var UnmountLayout = /*        */16;
	var MountLayout = /*          */32;
	var MountPassive = /*         */64;
	var UnmountPassive = /*       */128;

	var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;


	var didWarnAboutMismatchedHooksForComponent = void 0;
	{
	  didWarnAboutMismatchedHooksForComponent = new Set();
	}

	// These are set right before calling the component.
	var renderExpirationTime = NoWork;
	// The work-in-progress fiber. I've named it differently to distinguish it from
	// the work-in-progress hook.
	var currentlyRenderingFiber$1 = null;

	// Hooks are stored as a linked list on the fiber's memoizedState field. The
	// current hook list is the list that belongs to the current fiber. The
	// work-in-progress hook list is a new list that will be added to the
	// work-in-progress fiber.
	var currentHook = null;
	var nextCurrentHook = null;
	var firstWorkInProgressHook = null;
	var workInProgressHook = null;
	var nextWorkInProgressHook = null;

	var remainingExpirationTime = NoWork;
	var componentUpdateQueue = null;
	var sideEffectTag = 0;

	// Updates scheduled during render will trigger an immediate re-render at the
	// end of the current pass. We can't store these updates on the normal queue,
	// because if the work is aborted, they should be discarded. Because this is
	// a relatively rare case, we also don't want to add an additional field to
	// either the hook or queue object types. So we store them in a lazily create
	// map of queue -> render-phase updates, which are discarded once the component
	// completes without re-rendering.

	// Whether an update was scheduled during the currently executing render pass.
	var didScheduleRenderPhaseUpdate = false;
	// Lazily created map of render-phase updates
	var renderPhaseUpdates = null;
	// Counter to prevent infinite loops.
	var numberOfReRenders = 0;
	var RE_RENDER_LIMIT = 25;

	// In DEV, this is the name of the currently executing primitive hook
	var currentHookNameInDev = null;

	// In DEV, this list ensures that hooks are called in the same order between renders.
	// The list stores the order of hooks used during the initial render (mount).
	// Subsequent renders (updates) reference this list.
	var hookTypesDev = null;
	var hookTypesUpdateIndexDev = -1;

	function mountHookTypesDev() {
	  {
	    var hookName = currentHookNameInDev;

	    if (hookTypesDev === null) {
	      hookTypesDev = [hookName];
	    } else {
	      hookTypesDev.push(hookName);
	    }
	  }
	}

	function updateHookTypesDev() {
	  {
	    var hookName = currentHookNameInDev;

	    if (hookTypesDev !== null) {
	      hookTypesUpdateIndexDev++;
	      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
	        warnOnHookMismatchInDev(hookName);
	      }
	    }
	  }
	}

	function warnOnHookMismatchInDev(currentHookName) {
	  {
	    var componentName = getComponentName(currentlyRenderingFiber$1.type);
	    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
	      didWarnAboutMismatchedHooksForComponent.add(componentName);

	      if (hookTypesDev !== null) {
	        var table = '';

	        var secondColumnStart = 30;

	        for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
	          var oldHookName = hookTypesDev[i];
	          var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;

	          var row = i + 1 + '. ' + oldHookName;

	          // Extra space so second column lines up
	          // lol @ IE not supporting String#repeat
	          while (row.length < secondColumnStart) {
	            row += ' ';
	          }

	          row += newHookName + '\n';

	          table += row;
	        }

	        warning$1(false, 'React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\n\n' + '   Previous render            Next render\n' + '   ------------------------------------------------------\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', componentName, table);
	      }
	    }
	  }
	}

	function throwInvalidHookError() {
	  invariant(false, 'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.');
	}

	function areHookInputsEqual(nextDeps, prevDeps) {
	  if (prevDeps === null) {
	    {
	      warning$1(false, '%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);
	    }
	    return false;
	  }

	  {
	    // Don't bother comparing lengths in prod because these arrays should be
	    // passed inline.
	    if (nextDeps.length !== prevDeps.length) {
	      warning$1(false, 'The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\n\n' + 'Previous: %s\n' + 'Incoming: %s', currentHookNameInDev, '[' + nextDeps.join(', ') + ']', '[' + prevDeps.join(', ') + ']');
	    }
	  }
	  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
	    if (is(nextDeps[i], prevDeps[i])) {
	      continue;
	    }
	    return false;
	  }
	  return true;
	}

	function renderWithHooks(current, workInProgress, Component, props, refOrContext, nextRenderExpirationTime) {
	  renderExpirationTime = nextRenderExpirationTime;
	  currentlyRenderingFiber$1 = workInProgress;
	  nextCurrentHook = current !== null ? current.memoizedState : null;

	  {
	    hookTypesDev = current !== null ? current._debugHookTypes : null;
	    hookTypesUpdateIndexDev = -1;
	  }

	  // The following should have already been reset
	  // currentHook = null;
	  // workInProgressHook = null;

	  // remainingExpirationTime = NoWork;
	  // componentUpdateQueue = null;

	  // didScheduleRenderPhaseUpdate = false;
	  // renderPhaseUpdates = null;
	  // numberOfReRenders = 0;
	  // sideEffectTag = 0;

	  // TODO Warn if no hooks are used at all during mount, then some are used during update.
	  // Currently we will identify the update render as a mount because nextCurrentHook === null.
	  // This is tricky because it's valid for certain types of components (e.g. React.lazy)

	  // Using nextCurrentHook to differentiate between mount/update only works if at least one stateful hook is used.
	  // Non-stateful hooks (e.g. context) don't get added to memoizedState,
	  // so nextCurrentHook would be null during updates and mounts.
	  {
	    if (nextCurrentHook !== null) {
	      ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
	    } else if (hookTypesDev !== null) {
	      // This dispatcher handles an edge case where a component is updating,
	      // but no stateful hooks have been used.
	      // We want to match the production code behavior (which will use HooksDispatcherOnMount),
	      // but with the extra DEV validation to ensure hooks ordering hasn't changed.
	      // This dispatcher does that.
	      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
	    } else {
	      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
	    }
	  }

	  var children = Component(props, refOrContext);

	  if (didScheduleRenderPhaseUpdate) {
	    do {
	      didScheduleRenderPhaseUpdate = false;
	      numberOfReRenders += 1;

	      // Start over from the beginning of the list
	      nextCurrentHook = current !== null ? current.memoizedState : null;
	      nextWorkInProgressHook = firstWorkInProgressHook;

	      currentHook = null;
	      workInProgressHook = null;
	      componentUpdateQueue = null;

	      {
	        // Also validate hook order for cascading updates.
	        hookTypesUpdateIndexDev = -1;
	      }

	      ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;

	      children = Component(props, refOrContext);
	    } while (didScheduleRenderPhaseUpdate);

	    renderPhaseUpdates = null;
	    numberOfReRenders = 0;
	  }

	  // We can assume the previous dispatcher is always this one, since we set it
	  // at the beginning of the render phase and there's no re-entrancy.
	  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;

	  var renderedWork = currentlyRenderingFiber$1;

	  renderedWork.memoizedState = firstWorkInProgressHook;
	  renderedWork.expirationTime = remainingExpirationTime;
	  renderedWork.updateQueue = componentUpdateQueue;
	  renderedWork.effectTag |= sideEffectTag;

	  {
	    renderedWork._debugHookTypes = hookTypesDev;
	  }

	  // This check uses currentHook so that it works the same in DEV and prod bundles.
	  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.
	  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;

	  renderExpirationTime = NoWork;
	  currentlyRenderingFiber$1 = null;

	  currentHook = null;
	  nextCurrentHook = null;
	  firstWorkInProgressHook = null;
	  workInProgressHook = null;
	  nextWorkInProgressHook = null;

	  {
	    currentHookNameInDev = null;
	    hookTypesDev = null;
	    hookTypesUpdateIndexDev = -1;
	  }

	  remainingExpirationTime = NoWork;
	  componentUpdateQueue = null;
	  sideEffectTag = 0;

	  // These were reset above
	  // didScheduleRenderPhaseUpdate = false;
	  // renderPhaseUpdates = null;
	  // numberOfReRenders = 0;

	  !!didRenderTooFewHooks ? invariant(false, 'Rendered fewer hooks than expected. This may be caused by an accidental early return statement.') : void 0;

	  return children;
	}

	function bailoutHooks(current, workInProgress, expirationTime) {
	  workInProgress.updateQueue = current.updateQueue;
	  workInProgress.effectTag &= ~(Passive | Update);
	  if (current.expirationTime <= expirationTime) {
	    current.expirationTime = NoWork;
	  }
	}

	function resetHooks() {
	  // We can assume the previous dispatcher is always this one, since we set it
	  // at the beginning of the render phase and there's no re-entrancy.
	  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;

	  // This is used to reset the state of this module when a component throws.
	  // It's also called inside mountIndeterminateComponent if we determine the
	  // component is a module-style component.
	  renderExpirationTime = NoWork;
	  currentlyRenderingFiber$1 = null;

	  currentHook = null;
	  nextCurrentHook = null;
	  firstWorkInProgressHook = null;
	  workInProgressHook = null;
	  nextWorkInProgressHook = null;

	  {
	    hookTypesDev = null;
	    hookTypesUpdateIndexDev = -1;

	    currentHookNameInDev = null;
	  }

	  remainingExpirationTime = NoWork;
	  componentUpdateQueue = null;
	  sideEffectTag = 0;

	  didScheduleRenderPhaseUpdate = false;
	  renderPhaseUpdates = null;
	  numberOfReRenders = 0;
	}

	function mountWorkInProgressHook() {
	  var hook = {
	    memoizedState: null,

	    baseState: null,
	    queue: null,
	    baseUpdate: null,

	    next: null
	  };

	  if (workInProgressHook === null) {
	    // This is the first hook in the list
	    firstWorkInProgressHook = workInProgressHook = hook;
	  } else {
	    // Append to the end of the list
	    workInProgressHook = workInProgressHook.next = hook;
	  }
	  return workInProgressHook;
	}

	function updateWorkInProgressHook() {
	  // This function is used both for updates and for re-renders triggered by a
	  // render phase update. It assumes there is either a current hook we can
	  // clone, or a work-in-progress hook from a previous render pass that we can
	  // use as a base. When we reach the end of the base list, we must switch to
	  // the dispatcher used for mounts.
	  if (nextWorkInProgressHook !== null) {
	    // There's already a work-in-progress. Reuse it.
	    workInProgressHook = nextWorkInProgressHook;
	    nextWorkInProgressHook = workInProgressHook.next;

	    currentHook = nextCurrentHook;
	    nextCurrentHook = currentHook !== null ? currentHook.next : null;
	  } else {
	    // Clone from the current hook.
	    !(nextCurrentHook !== null) ? invariant(false, 'Rendered more hooks than during the previous render.') : void 0;
	    currentHook = nextCurrentHook;

	    var newHook = {
	      memoizedState: currentHook.memoizedState,

	      baseState: currentHook.baseState,
	      queue: currentHook.queue,
	      baseUpdate: currentHook.baseUpdate,

	      next: null
	    };

	    if (workInProgressHook === null) {
	      // This is the first hook in the list.
	      workInProgressHook = firstWorkInProgressHook = newHook;
	    } else {
	      // Append to the end of the list.
	      workInProgressHook = workInProgressHook.next = newHook;
	    }
	    nextCurrentHook = currentHook.next;
	  }
	  return workInProgressHook;
	}

	function createFunctionComponentUpdateQueue() {
	  return {
	    lastEffect: null
	  };
	}

	function basicStateReducer(state, action) {
	  return typeof action === 'function' ? action(state) : action;
	}

	function mountReducer(reducer, initialArg, init) {
	  var hook = mountWorkInProgressHook();
	  var initialState = void 0;
	  if (init !== undefined) {
	    initialState = init(initialArg);
	  } else {
	    initialState = initialArg;
	  }
	  hook.memoizedState = hook.baseState = initialState;
	  var queue = hook.queue = {
	    last: null,
	    dispatch: null,
	    lastRenderedReducer: reducer,
	    lastRenderedState: initialState
	  };
	  var dispatch = queue.dispatch = dispatchAction.bind(null,
	  // Flow doesn't know this is non-null, but we do.
	  currentlyRenderingFiber$1, queue);
	  return [hook.memoizedState, dispatch];
	}

	function updateReducer(reducer, initialArg, init) {
	  var hook = updateWorkInProgressHook();
	  var queue = hook.queue;
	  !(queue !== null) ? invariant(false, 'Should have a queue. This is likely a bug in React. Please file an issue.') : void 0;

	  queue.lastRenderedReducer = reducer;

	  if (numberOfReRenders > 0) {
	    // This is a re-render. Apply the new render phase updates to the previous
	    var _dispatch = queue.dispatch;
	    if (renderPhaseUpdates !== null) {
	      // Render phase updates are stored in a map of queue -> linked list
	      var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
	      if (firstRenderPhaseUpdate !== undefined) {
	        renderPhaseUpdates.delete(queue);
	        var newState = hook.memoizedState;
	        var update = firstRenderPhaseUpdate;
	        do {
	          // Process this render phase update. We don't have to check the
	          // priority because it will always be the same as the current
	          // render's.
	          var _action = update.action;
	          newState = reducer(newState, _action);
	          update = update.next;
	        } while (update !== null);

	        // Mark that the fiber performed work, but only if the new state is
	        // different from the current state.
	        if (!is(newState, hook.memoizedState)) {
	          markWorkInProgressReceivedUpdate();
	        }

	        hook.memoizedState = newState;
	        // Don't persist the state accumlated from the render phase updates to
	        // the base state unless the queue is empty.
	        // TODO: Not sure if this is the desired semantics, but it's what we
	        // do for gDSFP. I can't remember why.
	        if (hook.baseUpdate === queue.last) {
	          hook.baseState = newState;
	        }

	        queue.lastRenderedState = newState;

	        return [newState, _dispatch];
	      }
	    }
	    return [hook.memoizedState, _dispatch];
	  }

	  // The last update in the entire queue
	  var last = queue.last;
	  // The last update that is part of the base state.
	  var baseUpdate = hook.baseUpdate;
	  var baseState = hook.baseState;

	  // Find the first unprocessed update.
	  var first = void 0;
	  if (baseUpdate !== null) {
	    if (last !== null) {
	      // For the first update, the queue is a circular linked list where
	      // `queue.last.next = queue.first`. Once the first update commits, and
	      // the `baseUpdate` is no longer empty, we can unravel the list.
	      last.next = null;
	    }
	    first = baseUpdate.next;
	  } else {
	    first = last !== null ? last.next : null;
	  }
	  if (first !== null) {
	    var _newState = baseState;
	    var newBaseState = null;
	    var newBaseUpdate = null;
	    var prevUpdate = baseUpdate;
	    var _update = first;
	    var didSkip = false;
	    do {
	      var updateExpirationTime = _update.expirationTime;
	      if (updateExpirationTime < renderExpirationTime) {
	        // Priority is insufficient. Skip this update. If this is the first
	        // skipped update, the previous update/state is the new base
	        // update/state.
	        if (!didSkip) {
	          didSkip = true;
	          newBaseUpdate = prevUpdate;
	          newBaseState = _newState;
	        }
	        // Update the remaining priority in the queue.
	        if (updateExpirationTime > remainingExpirationTime) {
	          remainingExpirationTime = updateExpirationTime;
	        }
	      } else {
	        // Process this update.
	        if (_update.eagerReducer === reducer) {
	          // If this update was processed eagerly, and its reducer matches the
	          // current reducer, we can use the eagerly computed state.
	          _newState = _update.eagerState;
	        } else {
	          var _action2 = _update.action;
	          _newState = reducer(_newState, _action2);
	        }
	      }
	      prevUpdate = _update;
	      _update = _update.next;
	    } while (_update !== null && _update !== first);

	    if (!didSkip) {
	      newBaseUpdate = prevUpdate;
	      newBaseState = _newState;
	    }

	    // Mark that the fiber performed work, but only if the new state is
	    // different from the current state.
	    if (!is(_newState, hook.memoizedState)) {
	      markWorkInProgressReceivedUpdate();
	    }

	    hook.memoizedState = _newState;
	    hook.baseUpdate = newBaseUpdate;
	    hook.baseState = newBaseState;

	    queue.lastRenderedState = _newState;
	  }

	  var dispatch = queue.dispatch;
	  return [hook.memoizedState, dispatch];
	}

	function mountState(initialState) {
	  var hook = mountWorkInProgressHook();
	  if (typeof initialState === 'function') {
	    initialState = initialState();
	  }
	  hook.memoizedState = hook.baseState = initialState;
	  var queue = hook.queue = {
	    last: null,
	    dispatch: null,
	    lastRenderedReducer: basicStateReducer,
	    lastRenderedState: initialState
	  };
	  var dispatch = queue.dispatch = dispatchAction.bind(null,
	  // Flow doesn't know this is non-null, but we do.
	  currentlyRenderingFiber$1, queue);
	  return [hook.memoizedState, dispatch];
	}

	function updateState(initialState) {
	  return updateReducer(basicStateReducer, initialState);
	}

	function pushEffect(tag, create, destroy, deps) {
	  var effect = {
	    tag: tag,
	    create: create,
	    destroy: destroy,
	    deps: deps,
	    // Circular
	    next: null
	  };
	  if (componentUpdateQueue === null) {
	    componentUpdateQueue = createFunctionComponentUpdateQueue();
	    componentUpdateQueue.lastEffect = effect.next = effect;
	  } else {
	    var _lastEffect = componentUpdateQueue.lastEffect;
	    if (_lastEffect === null) {
	      componentUpdateQueue.lastEffect = effect.next = effect;
	    } else {
	      var firstEffect = _lastEffect.next;
	      _lastEffect.next = effect;
	      effect.next = firstEffect;
	      componentUpdateQueue.lastEffect = effect;
	    }
	  }
	  return effect;
	}

	function mountRef(initialValue) {
	  var hook = mountWorkInProgressHook();
	  var ref = { current: initialValue };
	  {
	    Object.seal(ref);
	  }
	  hook.memoizedState = ref;
	  return ref;
	}

	function updateRef(initialValue) {
	  var hook = updateWorkInProgressHook();
	  return hook.memoizedState;
	}

	function mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
	  var hook = mountWorkInProgressHook();
	  var nextDeps = deps === undefined ? null : deps;
	  sideEffectTag |= fiberEffectTag;
	  hook.memoizedState = pushEffect(hookEffectTag, create, undefined, nextDeps);
	}

	function updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
	  var hook = updateWorkInProgressHook();
	  var nextDeps = deps === undefined ? null : deps;
	  var destroy = undefined;

	  if (currentHook !== null) {
	    var prevEffect = currentHook.memoizedState;
	    destroy = prevEffect.destroy;
	    if (nextDeps !== null) {
	      var prevDeps = prevEffect.deps;
	      if (areHookInputsEqual(nextDeps, prevDeps)) {
	        pushEffect(NoEffect$1, create, destroy, nextDeps);
	        return;
	      }
	    }
	  }

	  sideEffectTag |= fiberEffectTag;
	  hook.memoizedState = pushEffect(hookEffectTag, create, destroy, nextDeps);
	}

	function mountEffect(create, deps) {
	  return mountEffectImpl(Update | Passive, UnmountPassive | MountPassive, create, deps);
	}

	function updateEffect(create, deps) {
	  return updateEffectImpl(Update | Passive, UnmountPassive | MountPassive, create, deps);
	}

	function mountLayoutEffect(create, deps) {
	  return mountEffectImpl(Update, UnmountMutation | MountLayout, create, deps);
	}

	function updateLayoutEffect(create, deps) {
	  return updateEffectImpl(Update, UnmountMutation | MountLayout, create, deps);
	}

	function imperativeHandleEffect(create, ref) {
	  if (typeof ref === 'function') {
	    var refCallback = ref;
	    var _inst = create();
	    refCallback(_inst);
	    return function () {
	      refCallback(null);
	    };
	  } else if (ref !== null && ref !== undefined) {
	    var refObject = ref;
	    {
	      !refObject.hasOwnProperty('current') ? warning$1(false, 'Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}') : void 0;
	    }
	    var _inst2 = create();
	    refObject.current = _inst2;
	    return function () {
	      refObject.current = null;
	    };
	  }
	}

	function mountImperativeHandle(ref, create, deps) {
	  {
	    !(typeof create === 'function') ? warning$1(false, 'Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null') : void 0;
	  }

	  // TODO: If deps are provided, should we skip comparing the ref itself?
	  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;

	  return mountEffectImpl(Update, UnmountMutation | MountLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
	}

	function updateImperativeHandle(ref, create, deps) {
	  {
	    !(typeof create === 'function') ? warning$1(false, 'Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null') : void 0;
	  }

	  // TODO: If deps are provided, should we skip comparing the ref itself?
	  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;

	  return updateEffectImpl(Update, UnmountMutation | MountLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
	}

	function mountDebugValue(value, formatterFn) {
	  // This hook is normally a no-op.
	  // The react-debug-hooks package injects its own implementation
	  // so that e.g. DevTools can display custom hook values.
	}

	var updateDebugValue = mountDebugValue;

	function mountCallback(callback, deps) {
	  var hook = mountWorkInProgressHook();
	  var nextDeps = deps === undefined ? null : deps;
	  hook.memoizedState = [callback, nextDeps];
	  return callback;
	}

	function updateCallback(callback, deps) {
	  var hook = updateWorkInProgressHook();
	  var nextDeps = deps === undefined ? null : deps;
	  var prevState = hook.memoizedState;
	  if (prevState !== null) {
	    if (nextDeps !== null) {
	      var prevDeps = prevState[1];
	      if (areHookInputsEqual(nextDeps, prevDeps)) {
	        return prevState[0];
	      }
	    }
	  }
	  hook.memoizedState = [callback, nextDeps];
	  return callback;
	}

	function mountMemo(nextCreate, deps) {
	  var hook = mountWorkInProgressHook();
	  var nextDeps = deps === undefined ? null : deps;
	  var nextValue = nextCreate();
	  hook.memoizedState = [nextValue, nextDeps];
	  return nextValue;
	}

	function updateMemo(nextCreate, deps) {
	  var hook = updateWorkInProgressHook();
	  var nextDeps = deps === undefined ? null : deps;
	  var prevState = hook.memoizedState;
	  if (prevState !== null) {
	    // Assume these are defined. If they're not, areHookInputsEqual will warn.
	    if (nextDeps !== null) {
	      var prevDeps = prevState[1];
	      if (areHookInputsEqual(nextDeps, prevDeps)) {
	        return prevState[0];
	      }
	    }
	  }
	  var nextValue = nextCreate();
	  hook.memoizedState = [nextValue, nextDeps];
	  return nextValue;
	}

	// in a test-like environment, we want to warn if dispatchAction()
	// is called outside of a batchedUpdates/TestUtils.act(...) call.
	var shouldWarnForUnbatchedSetState = false;

	{
	  // jest isn't a 'global', it's just exposed to tests via a wrapped function
	  // further, this isn't a test file, so flow doesn't recognize the symbol. So...
	  // $FlowExpectedError - because requirements don't give a damn about your type sigs.
	  if ('undefined' !== typeof jest) {
	    shouldWarnForUnbatchedSetState = true;
	  }
	}

	function dispatchAction(fiber, queue, action) {
	  !(numberOfReRenders < RE_RENDER_LIMIT) ? invariant(false, 'Too many re-renders. React limits the number of renders to prevent an infinite loop.') : void 0;

	  {
	    !(arguments.length <= 3) ? warning$1(false, "State updates from the useState() and useReducer() Hooks don't support the " + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().') : void 0;
	  }

	  var alternate = fiber.alternate;
	  if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
	    // This is a render phase update. Stash it in a lazily-created map of
	    // queue -> linked list of updates. After this render pass, we'll restart
	    // and apply the stashed updates on top of the work-in-progress hook.
	    didScheduleRenderPhaseUpdate = true;
	    var update = {
	      expirationTime: renderExpirationTime,
	      action: action,
	      eagerReducer: null,
	      eagerState: null,
	      next: null
	    };
	    if (renderPhaseUpdates === null) {
	      renderPhaseUpdates = new Map();
	    }
	    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
	    if (firstRenderPhaseUpdate === undefined) {
	      renderPhaseUpdates.set(queue, update);
	    } else {
	      // Append the update to the end of the list.
	      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
	      while (lastRenderPhaseUpdate.next !== null) {
	        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
	      }
	      lastRenderPhaseUpdate.next = update;
	    }
	  } else {
	    flushPassiveEffects();

	    var currentTime = requestCurrentTime();
	    var _expirationTime = computeExpirationForFiber(currentTime, fiber);

	    var _update2 = {
	      expirationTime: _expirationTime,
	      action: action,
	      eagerReducer: null,
	      eagerState: null,
	      next: null
	    };

	    // Append the update to the end of the list.
	    var _last = queue.last;
	    if (_last === null) {
	      // This is the first update. Create a circular list.
	      _update2.next = _update2;
	    } else {
	      var first = _last.next;
	      if (first !== null) {
	        // Still circular.
	        _update2.next = first;
	      }
	      _last.next = _update2;
	    }
	    queue.last = _update2;

	    if (fiber.expirationTime === NoWork && (alternate === null || alternate.expirationTime === NoWork)) {
	      // The queue is currently empty, which means we can eagerly compute the
	      // next state before entering the render phase. If the new state is the
	      // same as the current state, we may be able to bail out entirely.
	      var _lastRenderedReducer = queue.lastRenderedReducer;
	      if (_lastRenderedReducer !== null) {
	        var prevDispatcher = void 0;
	        {
	          prevDispatcher = ReactCurrentDispatcher$1.current;
	          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
	        }
	        try {
	          var currentState = queue.lastRenderedState;
	          var _eagerState = _lastRenderedReducer(currentState, action);
	          // Stash the eagerly computed state, and the reducer used to compute
	          // it, on the update object. If the reducer hasn't changed by the
	          // time we enter the render phase, then the eager state can be used
	          // without calling the reducer again.
	          _update2.eagerReducer = _lastRenderedReducer;
	          _update2.eagerState = _eagerState;
	          if (is(_eagerState, currentState)) {
	            // Fast path. We can bail out without scheduling React to re-render.
	            // It's still possible that we'll need to rebase this update later,
	            // if the component re-renders for a different reason and by that
	            // time the reducer has changed.
	            return;
	          }
	        } catch (error) {
	          // Suppress the error. It will throw again in the render phase.
	        } finally {
	          {
	            ReactCurrentDispatcher$1.current = prevDispatcher;
	          }
	        }
	      }
	    }
	    {
	      if (shouldWarnForUnbatchedSetState === true) {
	        warnIfNotCurrentlyBatchingInDev(fiber);
	      }
	    }
	    scheduleWork(fiber, _expirationTime);
	  }
	}

	var ContextOnlyDispatcher = {
	  readContext: readContext,

	  useCallback: throwInvalidHookError,
	  useContext: throwInvalidHookError,
	  useEffect: throwInvalidHookError,
	  useImperativeHandle: throwInvalidHookError,
	  useLayoutEffect: throwInvalidHookError,
	  useMemo: throwInvalidHookError,
	  useReducer: throwInvalidHookError,
	  useRef: throwInvalidHookError,
	  useState: throwInvalidHookError,
	  useDebugValue: throwInvalidHookError
	};

	var HooksDispatcherOnMountInDEV = null;
	var HooksDispatcherOnMountWithHookTypesInDEV = null;
	var HooksDispatcherOnUpdateInDEV = null;
	var InvalidNestedHooksDispatcherOnMountInDEV = null;
	var InvalidNestedHooksDispatcherOnUpdateInDEV = null;

	{
	  var warnInvalidContextAccess = function () {
	    warning$1(false, 'Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
	  };

	  var warnInvalidHookAccess = function () {
	    warning$1(false, 'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://fb.me/rules-of-hooks');
	  };

	  HooksDispatcherOnMountInDEV = {
	    readContext: function (context, observedBits) {
	      return readContext(context, observedBits);
	    },
	    useCallback: function (callback, deps) {
	      currentHookNameInDev = 'useCallback';
	      mountHookTypesDev();
	      return mountCallback(callback, deps);
	    },
	    useContext: function (context, observedBits) {
	      currentHookNameInDev = 'useContext';
	      mountHookTypesDev();
	      return readContext(context, observedBits);
	    },
	    useEffect: function (create, deps) {
	      currentHookNameInDev = 'useEffect';
	      mountHookTypesDev();
	      return mountEffect(create, deps);
	    },
	    useImperativeHandle: function (ref, create, deps) {
	      currentHookNameInDev = 'useImperativeHandle';
	      mountHookTypesDev();
	      return mountImperativeHandle(ref, create, deps);
	    },
	    useLayoutEffect: function (create, deps) {
	      currentHookNameInDev = 'useLayoutEffect';
	      mountHookTypesDev();
	      return mountLayoutEffect(create, deps);
	    },
	    useMemo: function (create, deps) {
	      currentHookNameInDev = 'useMemo';
	      mountHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountMemo(create, deps);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useReducer: function (reducer, initialArg, init) {
	      currentHookNameInDev = 'useReducer';
	      mountHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountReducer(reducer, initialArg, init);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useRef: function (initialValue) {
	      currentHookNameInDev = 'useRef';
	      mountHookTypesDev();
	      return mountRef(initialValue);
	    },
	    useState: function (initialState) {
	      currentHookNameInDev = 'useState';
	      mountHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountState(initialState);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useDebugValue: function (value, formatterFn) {
	      currentHookNameInDev = 'useDebugValue';
	      mountHookTypesDev();
	      return mountDebugValue(value, formatterFn);
	    }
	  };

	  HooksDispatcherOnMountWithHookTypesInDEV = {
	    readContext: function (context, observedBits) {
	      return readContext(context, observedBits);
	    },
	    useCallback: function (callback, deps) {
	      currentHookNameInDev = 'useCallback';
	      updateHookTypesDev();
	      return mountCallback(callback, deps);
	    },
	    useContext: function (context, observedBits) {
	      currentHookNameInDev = 'useContext';
	      updateHookTypesDev();
	      return readContext(context, observedBits);
	    },
	    useEffect: function (create, deps) {
	      currentHookNameInDev = 'useEffect';
	      updateHookTypesDev();
	      return mountEffect(create, deps);
	    },
	    useImperativeHandle: function (ref, create, deps) {
	      currentHookNameInDev = 'useImperativeHandle';
	      updateHookTypesDev();
	      return mountImperativeHandle(ref, create, deps);
	    },
	    useLayoutEffect: function (create, deps) {
	      currentHookNameInDev = 'useLayoutEffect';
	      updateHookTypesDev();
	      return mountLayoutEffect(create, deps);
	    },
	    useMemo: function (create, deps) {
	      currentHookNameInDev = 'useMemo';
	      updateHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountMemo(create, deps);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useReducer: function (reducer, initialArg, init) {
	      currentHookNameInDev = 'useReducer';
	      updateHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountReducer(reducer, initialArg, init);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useRef: function (initialValue) {
	      currentHookNameInDev = 'useRef';
	      updateHookTypesDev();
	      return mountRef(initialValue);
	    },
	    useState: function (initialState) {
	      currentHookNameInDev = 'useState';
	      updateHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountState(initialState);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useDebugValue: function (value, formatterFn) {
	      currentHookNameInDev = 'useDebugValue';
	      updateHookTypesDev();
	      return mountDebugValue(value, formatterFn);
	    }
	  };

	  HooksDispatcherOnUpdateInDEV = {
	    readContext: function (context, observedBits) {
	      return readContext(context, observedBits);
	    },
	    useCallback: function (callback, deps) {
	      currentHookNameInDev = 'useCallback';
	      updateHookTypesDev();
	      return updateCallback(callback, deps);
	    },
	    useContext: function (context, observedBits) {
	      currentHookNameInDev = 'useContext';
	      updateHookTypesDev();
	      return readContext(context, observedBits);
	    },
	    useEffect: function (create, deps) {
	      currentHookNameInDev = 'useEffect';
	      updateHookTypesDev();
	      return updateEffect(create, deps);
	    },
	    useImperativeHandle: function (ref, create, deps) {
	      currentHookNameInDev = 'useImperativeHandle';
	      updateHookTypesDev();
	      return updateImperativeHandle(ref, create, deps);
	    },
	    useLayoutEffect: function (create, deps) {
	      currentHookNameInDev = 'useLayoutEffect';
	      updateHookTypesDev();
	      return updateLayoutEffect(create, deps);
	    },
	    useMemo: function (create, deps) {
	      currentHookNameInDev = 'useMemo';
	      updateHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return updateMemo(create, deps);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useReducer: function (reducer, initialArg, init) {
	      currentHookNameInDev = 'useReducer';
	      updateHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return updateReducer(reducer, initialArg, init);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useRef: function (initialValue) {
	      currentHookNameInDev = 'useRef';
	      updateHookTypesDev();
	      return updateRef(initialValue);
	    },
	    useState: function (initialState) {
	      currentHookNameInDev = 'useState';
	      updateHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return updateState(initialState);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useDebugValue: function (value, formatterFn) {
	      currentHookNameInDev = 'useDebugValue';
	      updateHookTypesDev();
	      return updateDebugValue(value, formatterFn);
	    }
	  };

	  InvalidNestedHooksDispatcherOnMountInDEV = {
	    readContext: function (context, observedBits) {
	      warnInvalidContextAccess();
	      return readContext(context, observedBits);
	    },
	    useCallback: function (callback, deps) {
	      currentHookNameInDev = 'useCallback';
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountCallback(callback, deps);
	    },
	    useContext: function (context, observedBits) {
	      currentHookNameInDev = 'useContext';
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return readContext(context, observedBits);
	    },
	    useEffect: function (create, deps) {
	      currentHookNameInDev = 'useEffect';
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountEffect(create, deps);
	    },
	    useImperativeHandle: function (ref, create, deps) {
	      currentHookNameInDev = 'useImperativeHandle';
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountImperativeHandle(ref, create, deps);
	    },
	    useLayoutEffect: function (create, deps) {
	      currentHookNameInDev = 'useLayoutEffect';
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountLayoutEffect(create, deps);
	    },
	    useMemo: function (create, deps) {
	      currentHookNameInDev = 'useMemo';
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountMemo(create, deps);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useReducer: function (reducer, initialArg, init) {
	      currentHookNameInDev = 'useReducer';
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountReducer(reducer, initialArg, init);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useRef: function (initialValue) {
	      currentHookNameInDev = 'useRef';
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountRef(initialValue);
	    },
	    useState: function (initialState) {
	      currentHookNameInDev = 'useState';
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountState(initialState);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useDebugValue: function (value, formatterFn) {
	      currentHookNameInDev = 'useDebugValue';
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountDebugValue(value, formatterFn);
	    }
	  };

	  InvalidNestedHooksDispatcherOnUpdateInDEV = {
	    readContext: function (context, observedBits) {
	      warnInvalidContextAccess();
	      return readContext(context, observedBits);
	    },
	    useCallback: function (callback, deps) {
	      currentHookNameInDev = 'useCallback';
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateCallback(callback, deps);
	    },
	    useContext: function (context, observedBits) {
	      currentHookNameInDev = 'useContext';
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return readContext(context, observedBits);
	    },
	    useEffect: function (create, deps) {
	      currentHookNameInDev = 'useEffect';
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateEffect(create, deps);
	    },
	    useImperativeHandle: function (ref, create, deps) {
	      currentHookNameInDev = 'useImperativeHandle';
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateImperativeHandle(ref, create, deps);
	    },
	    useLayoutEffect: function (create, deps) {
	      currentHookNameInDev = 'useLayoutEffect';
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateLayoutEffect(create, deps);
	    },
	    useMemo: function (create, deps) {
	      currentHookNameInDev = 'useMemo';
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return updateMemo(create, deps);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useReducer: function (reducer, initialArg, init) {
	      currentHookNameInDev = 'useReducer';
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return updateReducer(reducer, initialArg, init);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useRef: function (initialValue) {
	      currentHookNameInDev = 'useRef';
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateRef(initialValue);
	    },
	    useState: function (initialState) {
	      currentHookNameInDev = 'useState';
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      var prevDispatcher = ReactCurrentDispatcher$1.current;
	      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return updateState(initialState);
	      } finally {
	        ReactCurrentDispatcher$1.current = prevDispatcher;
	      }
	    },
	    useDebugValue: function (value, formatterFn) {
	      currentHookNameInDev = 'useDebugValue';
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateDebugValue(value, formatterFn);
	    }
	  };
	}

	var commitTime = 0;
	var profilerStartTime = -1;

	function getCommitTime() {
	  return commitTime;
	}

	function recordCommitTime() {
	  commitTime = scheduler$1.unstable_now();
	}

	function startProfilerTimer(fiber) {

	  profilerStartTime = scheduler$1.unstable_now();

	  if (fiber.actualStartTime < 0) {
	    fiber.actualStartTime = scheduler$1.unstable_now();
	  }
	}

	function stopProfilerTimerIfRunning(fiber) {
	  profilerStartTime = -1;
	}

	function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {

	  if (profilerStartTime >= 0) {
	    var elapsedTime = scheduler$1.unstable_now() - profilerStartTime;
	    fiber.actualDuration += elapsedTime;
	    if (overrideBaseTime) {
	      fiber.selfBaseDuration = elapsedTime;
	    }
	    profilerStartTime = -1;
	  }
	}

	// The deepest Fiber on the stack involved in a hydration context.
	// This may have been an insertion or a hydration.
	var hydrationParentFiber = null;
	var nextHydratableInstance = null;
	var isHydrating = false;

	function enterHydrationState(fiber) {

	  var parentInstance = fiber.stateNode.containerInfo;
	  nextHydratableInstance = getFirstHydratableChild(parentInstance);
	  hydrationParentFiber = fiber;
	  isHydrating = true;
	  return true;
	}

	function deleteHydratableInstance(returnFiber, instance) {
	  {
	    switch (returnFiber.tag) {
	      case HostRoot:
	        didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
	        break;
	      case HostComponent:
	        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
	        break;
	    }
	  }

	  var childToDelete = createFiberFromHostInstanceForDeletion();
	  childToDelete.stateNode = instance;
	  childToDelete.return = returnFiber;
	  childToDelete.effectTag = Deletion;

	  // This might seem like it belongs on progressedFirstDeletion. However,
	  // these children are not part of the reconciliation list of children.
	  // Even if we abort and rereconcile the children, that will try to hydrate
	  // again and the nodes are still in the host tree so these will be
	  // recreated.
	  if (returnFiber.lastEffect !== null) {
	    returnFiber.lastEffect.nextEffect = childToDelete;
	    returnFiber.lastEffect = childToDelete;
	  } else {
	    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
	  }
	}

	function insertNonHydratedInstance(returnFiber, fiber) {
	  fiber.effectTag |= Placement;
	  {
	    switch (returnFiber.tag) {
	      case HostRoot:
	        {
	          var parentContainer = returnFiber.stateNode.containerInfo;
	          switch (fiber.tag) {
	            case HostComponent:
	              var type = fiber.type;
	              var props = fiber.pendingProps;
	              didNotFindHydratableContainerInstance(parentContainer, type, props);
	              break;
	            case HostText:
	              var text = fiber.pendingProps;
	              didNotFindHydratableContainerTextInstance(parentContainer, text);
	              break;
	            case SuspenseComponent:
	              
	              break;
	          }
	          break;
	        }
	      case HostComponent:
	        {
	          var parentType = returnFiber.type;
	          var parentProps = returnFiber.memoizedProps;
	          var parentInstance = returnFiber.stateNode;
	          switch (fiber.tag) {
	            case HostComponent:
	              var _type = fiber.type;
	              var _props = fiber.pendingProps;
	              didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
	              break;
	            case HostText:
	              var _text = fiber.pendingProps;
	              didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
	              break;
	            case SuspenseComponent:
	              didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);
	              break;
	          }
	          break;
	        }
	      default:
	        return;
	    }
	  }
	}

	function tryHydrate(fiber, nextInstance) {
	  switch (fiber.tag) {
	    case HostComponent:
	      {
	        var type = fiber.type;
	        var props = fiber.pendingProps;
	        var instance = canHydrateInstance(nextInstance, type, props);
	        if (instance !== null) {
	          fiber.stateNode = instance;
	          return true;
	        }
	        return false;
	      }
	    case HostText:
	      {
	        var text = fiber.pendingProps;
	        var textInstance = canHydrateTextInstance(nextInstance, text);
	        if (textInstance !== null) {
	          fiber.stateNode = textInstance;
	          return true;
	        }
	        return false;
	      }
	    case SuspenseComponent:
	      {
	        return false;
	      }
	    default:
	      return false;
	  }
	}

	function tryToClaimNextHydratableInstance(fiber) {
	  if (!isHydrating) {
	    return;
	  }
	  var nextInstance = nextHydratableInstance;
	  if (!nextInstance) {
	    // Nothing to hydrate. Make it an insertion.
	    insertNonHydratedInstance(hydrationParentFiber, fiber);
	    isHydrating = false;
	    hydrationParentFiber = fiber;
	    return;
	  }
	  var firstAttemptedInstance = nextInstance;
	  if (!tryHydrate(fiber, nextInstance)) {
	    // If we can't hydrate this instance let's try the next one.
	    // We use this as a heuristic. It's based on intuition and not data so it
	    // might be flawed or unnecessary.
	    nextInstance = getNextHydratableSibling(firstAttemptedInstance);
	    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
	      // Nothing to hydrate. Make it an insertion.
	      insertNonHydratedInstance(hydrationParentFiber, fiber);
	      isHydrating = false;
	      hydrationParentFiber = fiber;
	      return;
	    }
	    // We matched the next one, we'll now assume that the first one was
	    // superfluous and we'll delete it. Since we can't eagerly delete it
	    // we'll have to schedule a deletion. To do that, this node needs a dummy
	    // fiber associated with it.
	    deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
	  }
	  hydrationParentFiber = fiber;
	  nextHydratableInstance = getFirstHydratableChild(nextInstance);
	}

	function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {

	  var instance = fiber.stateNode;
	  var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
	  // TODO: Type this specific to this type of component.
	  fiber.updateQueue = updatePayload;
	  // If the update payload indicates that there is a change or if there
	  // is a new ref we mark this as an update.
	  if (updatePayload !== null) {
	    return true;
	  }
	  return false;
	}

	function prepareToHydrateHostTextInstance(fiber) {

	  var textInstance = fiber.stateNode;
	  var textContent = fiber.memoizedProps;
	  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
	  {
	    if (shouldUpdate) {
	      // We assume that prepareToHydrateHostTextInstance is called in a context where the
	      // hydration parent is the parent host component of this host text.
	      var returnFiber = hydrationParentFiber;
	      if (returnFiber !== null) {
	        switch (returnFiber.tag) {
	          case HostRoot:
	            {
	              var parentContainer = returnFiber.stateNode.containerInfo;
	              didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
	              break;
	            }
	          case HostComponent:
	            {
	              var parentType = returnFiber.type;
	              var parentProps = returnFiber.memoizedProps;
	              var parentInstance = returnFiber.stateNode;
	              didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
	              break;
	            }
	        }
	      }
	    }
	  }
	  return shouldUpdate;
	}

	function popToNextHostParent(fiber) {
	  var parent = fiber.return;
	  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== DehydratedSuspenseComponent) {
	    parent = parent.return;
	  }
	  hydrationParentFiber = parent;
	}

	function popHydrationState(fiber) {
	  if (fiber !== hydrationParentFiber) {
	    // We're deeper than the current hydration context, inside an inserted
	    // tree.
	    return false;
	  }
	  if (!isHydrating) {
	    // If we're not currently hydrating but we're in a hydration context, then
	    // we were an insertion and now need to pop up reenter hydration of our
	    // siblings.
	    popToNextHostParent(fiber);
	    isHydrating = true;
	    return false;
	  }

	  var type = fiber.type;

	  // If we have any remaining hydratable nodes, we need to delete them now.
	  // We only do this deeper than head and body since they tend to have random
	  // other nodes in them. We also ignore components with pure text content in
	  // side of them.
	  // TODO: Better heuristic.
	  if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
	    var nextInstance = nextHydratableInstance;
	    while (nextInstance) {
	      deleteHydratableInstance(fiber, nextInstance);
	      nextInstance = getNextHydratableSibling(nextInstance);
	    }
	  }

	  popToNextHostParent(fiber);
	  nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
	  return true;
	}

	function resetHydrationState() {

	  hydrationParentFiber = null;
	  nextHydratableInstance = null;
	  isHydrating = false;
	}

	var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;

	var didReceiveUpdate = false;

	var didWarnAboutBadClass = void 0;
	var didWarnAboutContextTypeOnFunctionComponent = void 0;
	var didWarnAboutGetDerivedStateOnFunctionComponent = void 0;
	var didWarnAboutFunctionRefs = void 0;
	var didWarnAboutReassigningProps = void 0;

	{
	  didWarnAboutBadClass = {};
	  didWarnAboutContextTypeOnFunctionComponent = {};
	  didWarnAboutGetDerivedStateOnFunctionComponent = {};
	  didWarnAboutFunctionRefs = {};
	  didWarnAboutReassigningProps = false;
	}

	function reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime) {
	  if (current$$1 === null) {
	    // If this is a fresh new component that hasn't been rendered yet, we
	    // won't update its child set by applying minimal side-effects. Instead,
	    // we will add them all to the child before it gets rendered. That means
	    // we can optimize this reconciliation pass by not tracking side-effects.
	    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
	  } else {
	    // If the current child is the same as the work in progress, it means that
	    // we haven't yet started any work on these children. Therefore, we use
	    // the clone algorithm to create a copy of all the current children.

	    // If we had any progressed work already, that is invalid at this point so
	    // let's throw it out.
	    workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, nextChildren, renderExpirationTime);
	  }
	}

	function forceUnmountCurrentAndReconcile(current$$1, workInProgress, nextChildren, renderExpirationTime) {
	  // This function is fork of reconcileChildren. It's used in cases where we
	  // want to reconcile without matching against the existing set. This has the
	  // effect of all current children being unmounted; even if the type and key
	  // are the same, the old child is unmounted and a new child is created.
	  //
	  // To do this, we're going to go through the reconcile algorithm twice. In
	  // the first pass, we schedule a deletion for all the current children by
	  // passing null.
	  workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, null, renderExpirationTime);
	  // In the second pass, we mount the new children. The trick here is that we
	  // pass null in place of where we usually pass the current child set. This has
	  // the effect of remounting all children regardless of whether their their
	  // identity matches.
	  workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
	}

	function updateForwardRef(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
	  // TODO: current can be non-null here even if the component
	  // hasn't yet mounted. This happens after the first render suspends.
	  // We'll need to figure out if this is fine or can cause issues.

	  {
	    if (workInProgress.type !== workInProgress.elementType) {
	      // Lazy component props can't be validated in createElement
	      // because they're only guaranteed to be resolved here.
	      var innerPropTypes = Component.propTypes;
	      if (innerPropTypes) {
	        checkPropTypes(innerPropTypes, nextProps, // Resolved props
	        'prop', getComponentName(Component), getCurrentFiberStackInDev);
	      }
	    }
	  }

	  var render = Component.render;
	  var ref = workInProgress.ref;

	  // The rest is a fork of updateFunctionComponent
	  var nextChildren = void 0;
	  prepareToReadContext(workInProgress, renderExpirationTime);
	  {
	    ReactCurrentOwner$3.current = workInProgress;
	    setCurrentPhase('render');
	    nextChildren = renderWithHooks(current$$1, workInProgress, render, nextProps, ref, renderExpirationTime);
	    if (workInProgress.mode & StrictMode) {
	      // Only double-render components with Hooks
	      if (workInProgress.memoizedState !== null) {
	        nextChildren = renderWithHooks(current$$1, workInProgress, render, nextProps, ref, renderExpirationTime);
	      }
	    }
	    setCurrentPhase(null);
	  }

	  if (current$$1 !== null && !didReceiveUpdate) {
	    bailoutHooks(current$$1, workInProgress, renderExpirationTime);
	    return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
	  }

	  // React DevTools reads this flag.
	  workInProgress.effectTag |= PerformedWork;
	  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
	  return workInProgress.child;
	}

	function updateMemoComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
	  if (current$$1 === null) {
	    var type = Component.type;
	    if (isSimpleFunctionComponent(type) && Component.compare === null &&
	    // SimpleMemoComponent codepath doesn't resolve outer props either.
	    Component.defaultProps === undefined) {
	      // If this is a plain function component without default props,
	      // and with only the default shallow comparison, we upgrade it
	      // to a SimpleMemoComponent to allow fast path updates.
	      workInProgress.tag = SimpleMemoComponent;
	      workInProgress.type = type;
	      {
	        validateFunctionComponentInDev(workInProgress, type);
	      }
	      return updateSimpleMemoComponent(current$$1, workInProgress, type, nextProps, updateExpirationTime, renderExpirationTime);
	    }
	    {
	      var innerPropTypes = type.propTypes;
	      if (innerPropTypes) {
	        // Inner memo component props aren't currently validated in createElement.
	        // We could move it there, but we'd still need this for lazy code path.
	        checkPropTypes(innerPropTypes, nextProps, // Resolved props
	        'prop', getComponentName(type), getCurrentFiberStackInDev);
	      }
	    }
	    var child = createFiberFromTypeAndProps(Component.type, null, nextProps, null, workInProgress.mode, renderExpirationTime);
	    child.ref = workInProgress.ref;
	    child.return = workInProgress;
	    workInProgress.child = child;
	    return child;
	  }
	  {
	    var _type = Component.type;
	    var _innerPropTypes = _type.propTypes;
	    if (_innerPropTypes) {
	      // Inner memo component props aren't currently validated in createElement.
	      // We could move it there, but we'd still need this for lazy code path.
	      checkPropTypes(_innerPropTypes, nextProps, // Resolved props
	      'prop', getComponentName(_type), getCurrentFiberStackInDev);
	    }
	  }
	  var currentChild = current$$1.child; // This is always exactly one child
	  if (updateExpirationTime < renderExpirationTime) {
	    // This will be the props with resolved defaultProps,
	    // unlike current.memoizedProps which will be the unresolved ones.
	    var prevProps = currentChild.memoizedProps;
	    // Default to shallow comparison
	    var compare = Component.compare;
	    compare = compare !== null ? compare : shallowEqual;
	    if (compare(prevProps, nextProps) && current$$1.ref === workInProgress.ref) {
	      return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
	    }
	  }
	  // React DevTools reads this flag.
	  workInProgress.effectTag |= PerformedWork;
	  var newChild = createWorkInProgress(currentChild, nextProps, renderExpirationTime);
	  newChild.ref = workInProgress.ref;
	  newChild.return = workInProgress;
	  workInProgress.child = newChild;
	  return newChild;
	}

	function updateSimpleMemoComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
	  // TODO: current can be non-null here even if the component
	  // hasn't yet mounted. This happens when the inner render suspends.
	  // We'll need to figure out if this is fine or can cause issues.

	  {
	    if (workInProgress.type !== workInProgress.elementType) {
	      // Lazy component props can't be validated in createElement
	      // because they're only guaranteed to be resolved here.
	      var outerMemoType = workInProgress.elementType;
	      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
	        // We warn when you define propTypes on lazy()
	        // so let's just skip over it to find memo() outer wrapper.
	        // Inner props for memo are validated later.
	        outerMemoType = refineResolvedLazyComponent(outerMemoType);
	      }
	      var outerPropTypes = outerMemoType && outerMemoType.propTypes;
	      if (outerPropTypes) {
	        checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)
	        'prop', getComponentName(outerMemoType), getCurrentFiberStackInDev);
	      }
	      // Inner propTypes will be validated in the function component path.
	    }
	  }
	  if (current$$1 !== null) {
	    var prevProps = current$$1.memoizedProps;
	    if (shallowEqual(prevProps, nextProps) && current$$1.ref === workInProgress.ref) {
	      didReceiveUpdate = false;
	      if (updateExpirationTime < renderExpirationTime) {
	        return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
	      }
	    }
	  }
	  return updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime);
	}

	function updateFragment(current$$1, workInProgress, renderExpirationTime) {
	  var nextChildren = workInProgress.pendingProps;
	  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
	  return workInProgress.child;
	}

	function updateMode(current$$1, workInProgress, renderExpirationTime) {
	  var nextChildren = workInProgress.pendingProps.children;
	  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
	  return workInProgress.child;
	}

	function updateProfiler(current$$1, workInProgress, renderExpirationTime) {
	  {
	    workInProgress.effectTag |= Update;
	  }
	  var nextProps = workInProgress.pendingProps;
	  var nextChildren = nextProps.children;
	  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
	  return workInProgress.child;
	}

	function markRef(current$$1, workInProgress) {
	  var ref = workInProgress.ref;
	  if (current$$1 === null && ref !== null || current$$1 !== null && current$$1.ref !== ref) {
	    // Schedule a Ref effect
	    workInProgress.effectTag |= Ref;
	  }
	}

	function updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
	  {
	    if (workInProgress.type !== workInProgress.elementType) {
	      // Lazy component props can't be validated in createElement
	      // because they're only guaranteed to be resolved here.
	      var innerPropTypes = Component.propTypes;
	      if (innerPropTypes) {
	        checkPropTypes(innerPropTypes, nextProps, // Resolved props
	        'prop', getComponentName(Component), getCurrentFiberStackInDev);
	      }
	    }
	  }

	  var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
	  var context = getMaskedContext(workInProgress, unmaskedContext);

	  var nextChildren = void 0;
	  prepareToReadContext(workInProgress, renderExpirationTime);
	  {
	    ReactCurrentOwner$3.current = workInProgress;
	    setCurrentPhase('render');
	    nextChildren = renderWithHooks(current$$1, workInProgress, Component, nextProps, context, renderExpirationTime);
	    if (workInProgress.mode & StrictMode) {
	      // Only double-render components with Hooks
	      if (workInProgress.memoizedState !== null) {
	        nextChildren = renderWithHooks(current$$1, workInProgress, Component, nextProps, context, renderExpirationTime);
	      }
	    }
	    setCurrentPhase(null);
	  }

	  if (current$$1 !== null && !didReceiveUpdate) {
	    bailoutHooks(current$$1, workInProgress, renderExpirationTime);
	    return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
	  }

	  // React DevTools reads this flag.
	  workInProgress.effectTag |= PerformedWork;
	  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
	  return workInProgress.child;
	}

	function updateClassComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
	  {
	    if (workInProgress.type !== workInProgress.elementType) {
	      // Lazy component props can't be validated in createElement
	      // because they're only guaranteed to be resolved here.
	      var innerPropTypes = Component.propTypes;
	      if (innerPropTypes) {
	        checkPropTypes(innerPropTypes, nextProps, // Resolved props
	        'prop', getComponentName(Component), getCurrentFiberStackInDev);
	      }
	    }
	  }

	  // Push context providers early to prevent context stack mismatches.
	  // During mounting we don't know the child context yet as the instance doesn't exist.
	  // We will invalidate the child context in finishClassComponent() right after rendering.
	  var hasContext = void 0;
	  if (isContextProvider(Component)) {
	    hasContext = true;
	    pushContextProvider(workInProgress);
	  } else {
	    hasContext = false;
	  }
	  prepareToReadContext(workInProgress, renderExpirationTime);

	  var instance = workInProgress.stateNode;
	  var shouldUpdate = void 0;
	  if (instance === null) {
	    if (current$$1 !== null) {
	      // An class component without an instance only mounts if it suspended
	      // inside a non- concurrent tree, in an inconsistent state. We want to
	      // tree it like a new mount, even though an empty version of it already
	      // committed. Disconnect the alternate pointers.
	      current$$1.alternate = null;
	      workInProgress.alternate = null;
	      // Since this is conceptually a new fiber, schedule a Placement effect
	      workInProgress.effectTag |= Placement;
	    }
	    // In the initial pass we might need to construct the instance.
	    constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
	    mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
	    shouldUpdate = true;
	  } else if (current$$1 === null) {
	    // In a resume, we'll already have an instance we can reuse.
	    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
	  } else {
	    shouldUpdate = updateClassInstance(current$$1, workInProgress, Component, nextProps, renderExpirationTime);
	  }
	  var nextUnitOfWork = finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);
	  {
	    var inst = workInProgress.stateNode;
	    if (inst.props !== nextProps) {
	      !didWarnAboutReassigningProps ? warning$1(false, 'It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentName(workInProgress.type) || 'a component') : void 0;
	      didWarnAboutReassigningProps = true;
	    }
	  }
	  return nextUnitOfWork;
	}

	function finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {
	  // Refs should update even if shouldComponentUpdate returns false
	  markRef(current$$1, workInProgress);

	  var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;

	  if (!shouldUpdate && !didCaptureError) {
	    // Context providers should defer to sCU for rendering
	    if (hasContext) {
	      invalidateContextProvider(workInProgress, Component, false);
	    }

	    return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
	  }

	  var instance = workInProgress.stateNode;

	  // Rerender
	  ReactCurrentOwner$3.current = workInProgress;
	  var nextChildren = void 0;
	  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {
	    // If we captured an error, but getDerivedStateFrom catch is not defined,
	    // unmount all the children. componentDidCatch will schedule an update to
	    // re-render a fallback. This is temporary until we migrate everyone to
	    // the new API.
	    // TODO: Warn in a future release.
	    nextChildren = null;

	    {
	      stopProfilerTimerIfRunning(workInProgress);
	    }
	  } else {
	    {
	      setCurrentPhase('render');
	      nextChildren = instance.render();
	      if (workInProgress.mode & StrictMode) {
	        instance.render();
	      }
	      setCurrentPhase(null);
	    }
	  }

	  // React DevTools reads this flag.
	  workInProgress.effectTag |= PerformedWork;
	  if (current$$1 !== null && didCaptureError) {
	    // If we're recovering from an error, reconcile without reusing any of
	    // the existing children. Conceptually, the normal children and the children
	    // that are shown on error are two different sets, so we shouldn't reuse
	    // normal children even if their identities match.
	    forceUnmountCurrentAndReconcile(current$$1, workInProgress, nextChildren, renderExpirationTime);
	  } else {
	    reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
	  }

	  // Memoize state using the values we just used to render.
	  // TODO: Restructure so we never read values from the instance.
	  workInProgress.memoizedState = instance.state;

	  // The context might have changed so we need to recalculate it.
	  if (hasContext) {
	    invalidateContextProvider(workInProgress, Component, true);
	  }

	  return workInProgress.child;
	}

	function pushHostRootContext(workInProgress) {
	  var root = workInProgress.stateNode;
	  if (root.pendingContext) {
	    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
	  } else if (root.context) {
	    // Should always be set
	    pushTopLevelContextObject(workInProgress, root.context, false);
	  }
	  pushHostContainer(workInProgress, root.containerInfo);
	}

	function updateHostRoot(current$$1, workInProgress, renderExpirationTime) {
	  pushHostRootContext(workInProgress);
	  var updateQueue = workInProgress.updateQueue;
	  !(updateQueue !== null) ? invariant(false, 'If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	  var nextProps = workInProgress.pendingProps;
	  var prevState = workInProgress.memoizedState;
	  var prevChildren = prevState !== null ? prevState.element : null;
	  processUpdateQueue(workInProgress, updateQueue, nextProps, null, renderExpirationTime);
	  var nextState = workInProgress.memoizedState;
	  // Caution: React DevTools currently depends on this property
	  // being called "element".
	  var nextChildren = nextState.element;
	  if (nextChildren === prevChildren) {
	    // If the state is the same as before, that's a bailout because we had
	    // no work that expires at this time.
	    resetHydrationState();
	    return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
	  }
	  var root = workInProgress.stateNode;
	  if ((current$$1 === null || current$$1.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
	    // If we don't have any current children this might be the first pass.
	    // We always try to hydrate. If this isn't a hydration pass there won't
	    // be any children to hydrate which is effectively the same thing as
	    // not hydrating.

	    // This is a bit of a hack. We track the host root as a placement to
	    // know that we're currently in a mounting state. That way isMounted
	    // works as expected. We must reset this before committing.
	    // TODO: Delete this when we delete isMounted and findDOMNode.
	    workInProgress.effectTag |= Placement;

	    // Ensure that children mount into this root without tracking
	    // side-effects. This ensures that we don't store Placement effects on
	    // nodes that will be hydrated.
	    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
	  } else {
	    // Otherwise reset hydration state in case we aborted and resumed another
	    // root.
	    reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
	    resetHydrationState();
	  }
	  return workInProgress.child;
	}

	function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {
	  pushHostContext(workInProgress);

	  if (current$$1 === null) {
	    tryToClaimNextHydratableInstance(workInProgress);
	  }

	  var type = workInProgress.type;
	  var nextProps = workInProgress.pendingProps;
	  var prevProps = current$$1 !== null ? current$$1.memoizedProps : null;

	  var nextChildren = nextProps.children;
	  var isDirectTextChild = shouldSetTextContent(type, nextProps);

	  if (isDirectTextChild) {
	    // We special case a direct text child of a host node. This is a common
	    // case. We won't handle it as a reified child. We will instead handle
	    // this in the host environment that also have access to this prop. That
	    // avoids allocating another HostText fiber and traversing it.
	    nextChildren = null;
	  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
	    // If we're switching from a direct text child to a normal child, or to
	    // empty, we need to schedule the text content to be reset.
	    workInProgress.effectTag |= ContentReset;
	  }

	  markRef(current$$1, workInProgress);

	  // Check the host config to see if the children are offscreen/hidden.
	  if (renderExpirationTime !== Never && workInProgress.mode & ConcurrentMode && shouldDeprioritizeSubtree(type, nextProps)) {
	    // Schedule this fiber to re-render at offscreen priority. Then bailout.
	    workInProgress.expirationTime = workInProgress.childExpirationTime = Never;
	    return null;
	  }

	  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
	  return workInProgress.child;
	}

	function updateHostText(current$$1, workInProgress) {
	  if (current$$1 === null) {
	    tryToClaimNextHydratableInstance(workInProgress);
	  }
	  // Nothing to do here. This is terminal. We'll do the completion step
	  // immediately after.
	  return null;
	}

	function mountLazyComponent(_current, workInProgress, elementType, updateExpirationTime, renderExpirationTime) {
	  if (_current !== null) {
	    // An lazy component only mounts if it suspended inside a non-
	    // concurrent tree, in an inconsistent state. We want to treat it like
	    // a new mount, even though an empty version of it already committed.
	    // Disconnect the alternate pointers.
	    _current.alternate = null;
	    workInProgress.alternate = null;
	    // Since this is conceptually a new fiber, schedule a Placement effect
	    workInProgress.effectTag |= Placement;
	  }

	  var props = workInProgress.pendingProps;
	  // We can't start a User Timing measurement with correct label yet.
	  // Cancel and resume right after we know the tag.
	  cancelWorkTimer(workInProgress);
	  var Component = readLazyComponentType(elementType);
	  // Store the unwrapped component in the type.
	  workInProgress.type = Component;
	  var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);
	  startWorkTimer(workInProgress);
	  var resolvedProps = resolveDefaultProps(Component, props);
	  var child = void 0;
	  switch (resolvedTag) {
	    case FunctionComponent:
	      {
	        {
	          validateFunctionComponentInDev(workInProgress, Component);
	        }
	        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);
	        break;
	      }
	    case ClassComponent:
	      {
	        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);
	        break;
	      }
	    case ForwardRef:
	      {
	        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderExpirationTime);
	        break;
	      }
	    case MemoComponent:
	      {
	        {
	          if (workInProgress.type !== workInProgress.elementType) {
	            var outerPropTypes = Component.propTypes;
	            if (outerPropTypes) {
	              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only
	              'prop', getComponentName(Component), getCurrentFiberStackInDev);
	            }
	          }
	        }
	        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too
	        updateExpirationTime, renderExpirationTime);
	        break;
	      }
	    default:
	      {
	        var hint = '';
	        {
	          if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {
	            hint = ' Did you wrap a component in React.lazy() more than once?';
	          }
	        }
	        // This message intentionally doesn't mention ForwardRef or MemoComponent
	        // because the fact that it's a separate type of work is an
	        // implementation detail.
	        invariant(false, 'Element type is invalid. Received a promise that resolves to: %s. Lazy element type must resolve to a class or function.%s', Component, hint);
	      }
	  }
	  return child;
	}

	function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderExpirationTime) {
	  if (_current !== null) {
	    // An incomplete component only mounts if it suspended inside a non-
	    // concurrent tree, in an inconsistent state. We want to treat it like
	    // a new mount, even though an empty version of it already committed.
	    // Disconnect the alternate pointers.
	    _current.alternate = null;
	    workInProgress.alternate = null;
	    // Since this is conceptually a new fiber, schedule a Placement effect
	    workInProgress.effectTag |= Placement;
	  }

	  // Promote the fiber to a class and try rendering again.
	  workInProgress.tag = ClassComponent;

	  // The rest of this function is a fork of `updateClassComponent`

	  // Push context providers early to prevent context stack mismatches.
	  // During mounting we don't know the child context yet as the instance doesn't exist.
	  // We will invalidate the child context in finishClassComponent() right after rendering.
	  var hasContext = void 0;
	  if (isContextProvider(Component)) {
	    hasContext = true;
	    pushContextProvider(workInProgress);
	  } else {
	    hasContext = false;
	  }
	  prepareToReadContext(workInProgress, renderExpirationTime);

	  constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
	  mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);

	  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);
	}

	function mountIndeterminateComponent(_current, workInProgress, Component, renderExpirationTime) {
	  if (_current !== null) {
	    // An indeterminate component only mounts if it suspended inside a non-
	    // concurrent tree, in an inconsistent state. We want to treat it like
	    // a new mount, even though an empty version of it already committed.
	    // Disconnect the alternate pointers.
	    _current.alternate = null;
	    workInProgress.alternate = null;
	    // Since this is conceptually a new fiber, schedule a Placement effect
	    workInProgress.effectTag |= Placement;
	  }

	  var props = workInProgress.pendingProps;
	  var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
	  var context = getMaskedContext(workInProgress, unmaskedContext);

	  prepareToReadContext(workInProgress, renderExpirationTime);

	  var value = void 0;

	  {
	    if (Component.prototype && typeof Component.prototype.render === 'function') {
	      var componentName = getComponentName(Component) || 'Unknown';

	      if (!didWarnAboutBadClass[componentName]) {
	        warningWithoutStack$1(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);
	        didWarnAboutBadClass[componentName] = true;
	      }
	    }

	    if (workInProgress.mode & StrictMode) {
	      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
	    }

	    ReactCurrentOwner$3.current = workInProgress;
	    value = renderWithHooks(null, workInProgress, Component, props, context, renderExpirationTime);
	  }
	  // React DevTools reads this flag.
	  workInProgress.effectTag |= PerformedWork;

	  if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
	    // Proceed under the assumption that this is a class instance
	    workInProgress.tag = ClassComponent;

	    // Throw out any hooks that were used.
	    resetHooks();

	    // Push context providers early to prevent context stack mismatches.
	    // During mounting we don't know the child context yet as the instance doesn't exist.
	    // We will invalidate the child context in finishClassComponent() right after rendering.
	    var hasContext = false;
	    if (isContextProvider(Component)) {
	      hasContext = true;
	      pushContextProvider(workInProgress);
	    } else {
	      hasContext = false;
	    }

	    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;

	    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
	    if (typeof getDerivedStateFromProps === 'function') {
	      applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);
	    }

	    adoptClassInstance(workInProgress, value);
	    mountClassInstance(workInProgress, Component, props, renderExpirationTime);
	    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);
	  } else {
	    // Proceed under the assumption that this is a function component
	    workInProgress.tag = FunctionComponent;
	    {
	      if (workInProgress.mode & StrictMode) {
	        // Only double-render components with Hooks
	        if (workInProgress.memoizedState !== null) {
	          value = renderWithHooks(null, workInProgress, Component, props, context, renderExpirationTime);
	        }
	      }
	    }
	    reconcileChildren(null, workInProgress, value, renderExpirationTime);
	    {
	      validateFunctionComponentInDev(workInProgress, Component);
	    }
	    return workInProgress.child;
	  }
	}

	function validateFunctionComponentInDev(workInProgress, Component) {
	  if (Component) {
	    !!Component.childContextTypes ? warningWithoutStack$1(false, '%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	  if (workInProgress.ref !== null) {
	    var info = '';
	    var ownerName = getCurrentFiberOwnerNameInDevOrNull();
	    if (ownerName) {
	      info += '\n\nCheck the render method of `' + ownerName + '`.';
	    }

	    var warningKey = ownerName || workInProgress._debugID || '';
	    var debugSource = workInProgress._debugSource;
	    if (debugSource) {
	      warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
	    }
	    if (!didWarnAboutFunctionRefs[warningKey]) {
	      didWarnAboutFunctionRefs[warningKey] = true;
	      warning$1(false, 'Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);
	    }
	  }

	  if (typeof Component.getDerivedStateFromProps === 'function') {
	    var componentName = getComponentName(Component) || 'Unknown';

	    if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {
	      warningWithoutStack$1(false, '%s: Function components do not support getDerivedStateFromProps.', componentName);
	      didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;
	    }
	  }

	  if (typeof Component.contextType === 'object' && Component.contextType !== null) {
	    var _componentName = getComponentName(Component) || 'Unknown';

	    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName]) {
	      warningWithoutStack$1(false, '%s: Function components do not support contextType.', _componentName);
	      didWarnAboutContextTypeOnFunctionComponent[_componentName] = true;
	    }
	  }
	}

	function updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime) {
	  var mode = workInProgress.mode;
	  var nextProps = workInProgress.pendingProps;

	  // We should attempt to render the primary children unless this boundary
	  // already suspended during this render (`alreadyCaptured` is true).
	  var nextState = workInProgress.memoizedState;

	  var nextDidTimeout = void 0;
	  if ((workInProgress.effectTag & DidCapture) === NoEffect) {
	    // This is the first attempt.
	    nextState = null;
	    nextDidTimeout = false;
	  } else {
	    // Something in this boundary's subtree already suspended. Switch to
	    // rendering the fallback children.
	    nextState = {
	      timedOutAt: nextState !== null ? nextState.timedOutAt : NoWork
	    };
	    nextDidTimeout = true;
	    workInProgress.effectTag &= ~DidCapture;
	  }

	  // This next part is a bit confusing. If the children timeout, we switch to
	  // showing the fallback children in place of the "primary" children.
	  // However, we don't want to delete the primary children because then their
	  // state will be lost (both the React state and the host state, e.g.
	  // uncontrolled form inputs). Instead we keep them mounted and hide them.
	  // Both the fallback children AND the primary children are rendered at the
	  // same time. Once the primary children are un-suspended, we can delete
	  // the fallback children — don't need to preserve their state.
	  //
	  // The two sets of children are siblings in the host environment, but
	  // semantically, for purposes of reconciliation, they are two separate sets.
	  // So we store them using two fragment fibers.
	  //
	  // However, we want to avoid allocating extra fibers for every placeholder.
	  // They're only necessary when the children time out, because that's the
	  // only time when both sets are mounted.
	  //
	  // So, the extra fragment fibers are only used if the children time out.
	  // Otherwise, we render the primary children directly. This requires some
	  // custom reconciliation logic to preserve the state of the primary
	  // children. It's essentially a very basic form of re-parenting.

	  // `child` points to the child fiber. In the normal case, this is the first
	  // fiber of the primary children set. In the timed-out case, it's a
	  // a fragment fiber containing the primary children.
	  var child = void 0;
	  // `next` points to the next fiber React should render. In the normal case,
	  // it's the same as `child`: the first fiber of the primary children set.
	  // In the timed-out case, it's a fragment fiber containing the *fallback*
	  // children -- we skip over the primary children entirely.
	  var next = void 0;
	  if (current$$1 === null) {

	    // This is the initial mount. This branch is pretty simple because there's
	    // no previous state that needs to be preserved.
	    if (nextDidTimeout) {
	      // Mount separate fragments for primary and fallback children.
	      var nextFallbackChildren = nextProps.fallback;
	      var primaryChildFragment = createFiberFromFragment(null, mode, NoWork, null);

	      if ((workInProgress.mode & ConcurrentMode) === NoContext) {
	        // Outside of concurrent mode, we commit the effects from the
	        var progressedState = workInProgress.memoizedState;
	        var progressedPrimaryChild = progressedState !== null ? workInProgress.child.child : workInProgress.child;
	        primaryChildFragment.child = progressedPrimaryChild;
	      }

	      var fallbackChildFragment = createFiberFromFragment(nextFallbackChildren, mode, renderExpirationTime, null);
	      primaryChildFragment.sibling = fallbackChildFragment;
	      child = primaryChildFragment;
	      // Skip the primary children, and continue working on the
	      // fallback children.
	      next = fallbackChildFragment;
	      child.return = next.return = workInProgress;
	    } else {
	      // Mount the primary children without an intermediate fragment fiber.
	      var nextPrimaryChildren = nextProps.children;
	      child = next = mountChildFibers(workInProgress, null, nextPrimaryChildren, renderExpirationTime);
	    }
	  } else {
	    // This is an update. This branch is more complicated because we need to
	    // ensure the state of the primary children is preserved.
	    var prevState = current$$1.memoizedState;
	    var prevDidTimeout = prevState !== null;
	    if (prevDidTimeout) {
	      // The current tree already timed out. That means each child set is
	      var currentPrimaryChildFragment = current$$1.child;
	      var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
	      if (nextDidTimeout) {
	        // Still timed out. Reuse the current primary children by cloning
	        // its fragment. We're going to skip over these entirely.
	        var _nextFallbackChildren = nextProps.fallback;
	        var _primaryChildFragment = createWorkInProgress(currentPrimaryChildFragment, currentPrimaryChildFragment.pendingProps, NoWork);

	        if ((workInProgress.mode & ConcurrentMode) === NoContext) {
	          // Outside of concurrent mode, we commit the effects from the
	          var _progressedState = workInProgress.memoizedState;
	          var _progressedPrimaryChild = _progressedState !== null ? workInProgress.child.child : workInProgress.child;
	          if (_progressedPrimaryChild !== currentPrimaryChildFragment.child) {
	            _primaryChildFragment.child = _progressedPrimaryChild;
	          }
	        }

	        // Because primaryChildFragment is a new fiber that we're inserting as the
	        // parent of a new tree, we need to set its treeBaseDuration.
	        if (workInProgress.mode & ProfileMode) {
	          // treeBaseDuration is the sum of all the child tree base durations.
	          var treeBaseDuration = 0;
	          var hiddenChild = _primaryChildFragment.child;
	          while (hiddenChild !== null) {
	            treeBaseDuration += hiddenChild.treeBaseDuration;
	            hiddenChild = hiddenChild.sibling;
	          }
	          _primaryChildFragment.treeBaseDuration = treeBaseDuration;
	        }

	        // Clone the fallback child fragment, too. These we'll continue
	        // working on.
	        var _fallbackChildFragment = _primaryChildFragment.sibling = createWorkInProgress(currentFallbackChildFragment, _nextFallbackChildren, currentFallbackChildFragment.expirationTime);
	        child = _primaryChildFragment;
	        _primaryChildFragment.childExpirationTime = NoWork;
	        // Skip the primary children, and continue working on the
	        // fallback children.
	        next = _fallbackChildFragment;
	        child.return = next.return = workInProgress;
	      } else {
	        // No longer suspended. Switch back to showing the primary children,
	        // and remove the intermediate fragment fiber.
	        var _nextPrimaryChildren = nextProps.children;
	        var currentPrimaryChild = currentPrimaryChildFragment.child;
	        var primaryChild = reconcileChildFibers(workInProgress, currentPrimaryChild, _nextPrimaryChildren, renderExpirationTime);

	        // If this render doesn't suspend, we need to delete the fallback
	        // children. Wait until the complete phase, after we've confirmed the
	        // fallback is no longer needed.
	        // TODO: Would it be better to store the fallback fragment on
	        // the stateNode?

	        // Continue rendering the children, like we normally do.
	        child = next = primaryChild;
	      }
	    } else {
	      // The current tree has not already timed out. That means the primary
	      // children are not wrapped in a fragment fiber.
	      var _currentPrimaryChild = current$$1.child;
	      if (nextDidTimeout) {
	        // Timed out. Wrap the children in a fragment fiber to keep them
	        // separate from the fallback children.
	        var _nextFallbackChildren2 = nextProps.fallback;
	        var _primaryChildFragment2 = createFiberFromFragment(
	        // It shouldn't matter what the pending props are because we aren't
	        // going to render this fragment.
	        null, mode, NoWork, null);
	        _primaryChildFragment2.child = _currentPrimaryChild;

	        // Even though we're creating a new fiber, there are no new children,
	        // because we're reusing an already mounted tree. So we don't need to
	        // schedule a placement.
	        // primaryChildFragment.effectTag |= Placement;

	        if ((workInProgress.mode & ConcurrentMode) === NoContext) {
	          // Outside of concurrent mode, we commit the effects from the
	          var _progressedState2 = workInProgress.memoizedState;
	          var _progressedPrimaryChild2 = _progressedState2 !== null ? workInProgress.child.child : workInProgress.child;
	          _primaryChildFragment2.child = _progressedPrimaryChild2;
	        }

	        // Because primaryChildFragment is a new fiber that we're inserting as the
	        // parent of a new tree, we need to set its treeBaseDuration.
	        if (workInProgress.mode & ProfileMode) {
	          // treeBaseDuration is the sum of all the child tree base durations.
	          var _treeBaseDuration = 0;
	          var _hiddenChild = _primaryChildFragment2.child;
	          while (_hiddenChild !== null) {
	            _treeBaseDuration += _hiddenChild.treeBaseDuration;
	            _hiddenChild = _hiddenChild.sibling;
	          }
	          _primaryChildFragment2.treeBaseDuration = _treeBaseDuration;
	        }

	        // Create a fragment from the fallback children, too.
	        var _fallbackChildFragment2 = _primaryChildFragment2.sibling = createFiberFromFragment(_nextFallbackChildren2, mode, renderExpirationTime, null);
	        _fallbackChildFragment2.effectTag |= Placement;
	        child = _primaryChildFragment2;
	        _primaryChildFragment2.childExpirationTime = NoWork;
	        // Skip the primary children, and continue working on the
	        // fallback children.
	        next = _fallbackChildFragment2;
	        child.return = next.return = workInProgress;
	      } else {
	        // Still haven't timed out.  Continue rendering the children, like we
	        // normally do.
	        var _nextPrimaryChildren2 = nextProps.children;
	        next = child = reconcileChildFibers(workInProgress, _currentPrimaryChild, _nextPrimaryChildren2, renderExpirationTime);
	      }
	    }
	    workInProgress.stateNode = current$$1.stateNode;
	  }

	  workInProgress.memoizedState = nextState;
	  workInProgress.child = child;
	  return next;
	}

	function updatePortalComponent(current$$1, workInProgress, renderExpirationTime) {
	  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
	  var nextChildren = workInProgress.pendingProps;
	  if (current$$1 === null) {
	    // Portals are special because we don't append the children during mount
	    // but at commit. Therefore we need to track insertions which the normal
	    // flow doesn't do during mount. This doesn't happen at the root because
	    // the root always starts with a "current" with a null child.
	    // TODO: Consider unifying this with how the root works.
	    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
	  } else {
	    reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
	  }
	  return workInProgress.child;
	}

	function updateContextProvider(current$$1, workInProgress, renderExpirationTime) {
	  var providerType = workInProgress.type;
	  var context = providerType._context;

	  var newProps = workInProgress.pendingProps;
	  var oldProps = workInProgress.memoizedProps;

	  var newValue = newProps.value;

	  {
	    var providerPropTypes = workInProgress.type.propTypes;

	    if (providerPropTypes) {
	      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider', getCurrentFiberStackInDev);
	    }
	  }

	  pushProvider(workInProgress, newValue);

	  if (oldProps !== null) {
	    var oldValue = oldProps.value;
	    var changedBits = calculateChangedBits(context, newValue, oldValue);
	    if (changedBits === 0) {
	      // No change. Bailout early if children are the same.
	      if (oldProps.children === newProps.children && !hasContextChanged()) {
	        return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
	      }
	    } else {
	      // The context value changed. Search for matching consumers and schedule
	      // them to update.
	      propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);
	    }
	  }

	  var newChildren = newProps.children;
	  reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);
	  return workInProgress.child;
	}

	var hasWarnedAboutUsingContextAsConsumer = false;

	function updateContextConsumer(current$$1, workInProgress, renderExpirationTime) {
	  var context = workInProgress.type;
	  // The logic below for Context differs depending on PROD or DEV mode. In
	  // DEV mode, we create a separate object for Context.Consumer that acts
	  // like a proxy to Context. This proxy object adds unnecessary code in PROD
	  // so we use the old behaviour (Context.Consumer references Context) to
	  // reduce size and overhead. The separate object references context via
	  // a property called "_context", which also gives us the ability to check
	  // in DEV mode if this property exists or not and warn if it does not.
	  {
	    if (context._context === undefined) {
	      // This may be because it's a Context (rather than a Consumer).
	      // Or it may be because it's older React where they're the same thing.
	      // We only want to warn if we're sure it's a new React.
	      if (context !== context.Consumer) {
	        if (!hasWarnedAboutUsingContextAsConsumer) {
	          hasWarnedAboutUsingContextAsConsumer = true;
	          warning$1(false, 'Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
	        }
	      }
	    } else {
	      context = context._context;
	    }
	  }
	  var newProps = workInProgress.pendingProps;
	  var render = newProps.children;

	  {
	    !(typeof render === 'function') ? warningWithoutStack$1(false, 'A context consumer was rendered with multiple children, or a child ' + "that isn't a function. A context consumer expects a single child " + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.') : void 0;
	  }

	  prepareToReadContext(workInProgress, renderExpirationTime);
	  var newValue = readContext(context, newProps.unstable_observedBits);
	  var newChildren = void 0;
	  {
	    ReactCurrentOwner$3.current = workInProgress;
	    setCurrentPhase('render');
	    newChildren = render(newValue);
	    setCurrentPhase(null);
	  }

	  // React DevTools reads this flag.
	  workInProgress.effectTag |= PerformedWork;
	  reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);
	  return workInProgress.child;
	}

	function markWorkInProgressReceivedUpdate() {
	  didReceiveUpdate = true;
	}

	function bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) {
	  cancelWorkTimer(workInProgress);

	  if (current$$1 !== null) {
	    // Reuse previous context list
	    workInProgress.contextDependencies = current$$1.contextDependencies;
	  }

	  {
	    // Don't update "base" render times for bailouts.
	    stopProfilerTimerIfRunning(workInProgress);
	  }

	  // Check if the children have any pending work.
	  var childExpirationTime = workInProgress.childExpirationTime;
	  if (childExpirationTime < renderExpirationTime) {
	    // The children don't have any work either. We can skip them.
	    // TODO: Once we add back resuming, we should check if the children are
	    // a work-in-progress set. If so, we need to transfer their effects.
	    return null;
	  } else {
	    // This fiber doesn't have work, but its subtree does. Clone the child
	    // fibers and continue.
	    cloneChildFibers(current$$1, workInProgress);
	    return workInProgress.child;
	  }
	}

	function beginWork(current$$1, workInProgress, renderExpirationTime) {
	  var updateExpirationTime = workInProgress.expirationTime;

	  if (current$$1 !== null) {
	    var oldProps = current$$1.memoizedProps;
	    var newProps = workInProgress.pendingProps;

	    if (oldProps !== newProps || hasContextChanged()) {
	      // If props or context changed, mark the fiber as having performed work.
	      // This may be unset if the props are determined to be equal later (memo).
	      didReceiveUpdate = true;
	    } else if (updateExpirationTime < renderExpirationTime) {
	      didReceiveUpdate = false;
	      // This fiber does not have any pending work. Bailout without entering
	      // the begin phase. There's still some bookkeeping we that needs to be done
	      // in this optimized path, mostly pushing stuff onto the stack.
	      switch (workInProgress.tag) {
	        case HostRoot:
	          pushHostRootContext(workInProgress);
	          resetHydrationState();
	          break;
	        case HostComponent:
	          pushHostContext(workInProgress);
	          break;
	        case ClassComponent:
	          {
	            var Component = workInProgress.type;
	            if (isContextProvider(Component)) {
	              pushContextProvider(workInProgress);
	            }
	            break;
	          }
	        case HostPortal:
	          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
	          break;
	        case ContextProvider:
	          {
	            var newValue = workInProgress.memoizedProps.value;
	            pushProvider(workInProgress, newValue);
	            break;
	          }
	        case Profiler:
	          {
	            workInProgress.effectTag |= Update;
	          }
	          break;
	        case SuspenseComponent:
	          {
	            var state = workInProgress.memoizedState;
	            var didTimeout = state !== null;
	            if (didTimeout) {
	              // If this boundary is currently timed out, we need to decide
	              // whether to retry the primary children, or to skip over it and
	              // go straight to the fallback. Check the priority of the primary
	              var primaryChildFragment = workInProgress.child;
	              var primaryChildExpirationTime = primaryChildFragment.childExpirationTime;
	              if (primaryChildExpirationTime !== NoWork && primaryChildExpirationTime >= renderExpirationTime) {
	                // The primary children have pending work. Use the normal path
	                // to attempt to render the primary children again.
	                return updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime);
	              } else {
	                // The primary children do not have pending work with sufficient
	                // priority. Bailout.
	                var child = bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
	                if (child !== null) {
	                  // The fallback children have pending work. Skip over the
	                  // primary children and work on the fallback.
	                  return child.sibling;
	                } else {
	                  return null;
	                }
	              }
	            }
	            break;
	          }
	        case DehydratedSuspenseComponent:

	      }
	      return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
	    }
	  } else {
	    didReceiveUpdate = false;
	  }

	  // Before entering the begin phase, clear the expiration time.
	  workInProgress.expirationTime = NoWork;

	  switch (workInProgress.tag) {
	    case IndeterminateComponent:
	      {
	        var elementType = workInProgress.elementType;
	        return mountIndeterminateComponent(current$$1, workInProgress, elementType, renderExpirationTime);
	      }
	    case LazyComponent:
	      {
	        var _elementType = workInProgress.elementType;
	        return mountLazyComponent(current$$1, workInProgress, _elementType, updateExpirationTime, renderExpirationTime);
	      }
	    case FunctionComponent:
	      {
	        var _Component = workInProgress.type;
	        var unresolvedProps = workInProgress.pendingProps;
	        var resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
	        return updateFunctionComponent(current$$1, workInProgress, _Component, resolvedProps, renderExpirationTime);
	      }
	    case ClassComponent:
	      {
	        var _Component2 = workInProgress.type;
	        var _unresolvedProps = workInProgress.pendingProps;
	        var _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);
	        return updateClassComponent(current$$1, workInProgress, _Component2, _resolvedProps, renderExpirationTime);
	      }
	    case HostRoot:
	      return updateHostRoot(current$$1, workInProgress, renderExpirationTime);
	    case HostComponent:
	      return updateHostComponent(current$$1, workInProgress, renderExpirationTime);
	    case HostText:
	      return updateHostText(current$$1, workInProgress);
	    case SuspenseComponent:
	      return updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime);
	    case HostPortal:
	      return updatePortalComponent(current$$1, workInProgress, renderExpirationTime);
	    case ForwardRef:
	      {
	        var type = workInProgress.type;
	        var _unresolvedProps2 = workInProgress.pendingProps;
	        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
	        return updateForwardRef(current$$1, workInProgress, type, _resolvedProps2, renderExpirationTime);
	      }
	    case Fragment:
	      return updateFragment(current$$1, workInProgress, renderExpirationTime);
	    case Mode:
	      return updateMode(current$$1, workInProgress, renderExpirationTime);
	    case Profiler:
	      return updateProfiler(current$$1, workInProgress, renderExpirationTime);
	    case ContextProvider:
	      return updateContextProvider(current$$1, workInProgress, renderExpirationTime);
	    case ContextConsumer:
	      return updateContextConsumer(current$$1, workInProgress, renderExpirationTime);
	    case MemoComponent:
	      {
	        var _type2 = workInProgress.type;
	        var _unresolvedProps3 = workInProgress.pendingProps;
	        // Resolve outer props first, then resolve inner props.
	        var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
	        {
	          if (workInProgress.type !== workInProgress.elementType) {
	            var outerPropTypes = _type2.propTypes;
	            if (outerPropTypes) {
	              checkPropTypes(outerPropTypes, _resolvedProps3, // Resolved for outer only
	              'prop', getComponentName(_type2), getCurrentFiberStackInDev);
	            }
	          }
	        }
	        _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
	        return updateMemoComponent(current$$1, workInProgress, _type2, _resolvedProps3, updateExpirationTime, renderExpirationTime);
	      }
	    case SimpleMemoComponent:
	      {
	        return updateSimpleMemoComponent(current$$1, workInProgress, workInProgress.type, workInProgress.pendingProps, updateExpirationTime, renderExpirationTime);
	      }
	    case IncompleteClassComponent:
	      {
	        var _Component3 = workInProgress.type;
	        var _unresolvedProps4 = workInProgress.pendingProps;
	        var _resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);
	        return mountIncompleteClassComponent(current$$1, workInProgress, _Component3, _resolvedProps4, renderExpirationTime);
	      }
	    case DehydratedSuspenseComponent:
	      {
	        break;
	      }
	  }
	  invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
	}

	var valueCursor = createCursor(null);

	var rendererSigil = void 0;
	{
	  // Use this to detect multiple renderers using the same context
	  rendererSigil = {};
	}

	var currentlyRenderingFiber = null;
	var lastContextDependency = null;
	var lastContextWithAllBitsObserved = null;

	var isDisallowedContextReadInDEV = false;

	function resetContextDependences() {
	  // This is called right before React yields execution, to ensure `readContext`
	  // cannot be called outside the render phase.
	  currentlyRenderingFiber = null;
	  lastContextDependency = null;
	  lastContextWithAllBitsObserved = null;
	  {
	    isDisallowedContextReadInDEV = false;
	  }
	}

	function enterDisallowedContextReadInDEV() {
	  {
	    isDisallowedContextReadInDEV = true;
	  }
	}

	function exitDisallowedContextReadInDEV() {
	  {
	    isDisallowedContextReadInDEV = false;
	  }
	}

	function pushProvider(providerFiber, nextValue) {
	  var context = providerFiber.type._context;

	  {
	    push(valueCursor, context._currentValue, providerFiber);

	    context._currentValue = nextValue;
	    {
	      !(context._currentRenderer === undefined || context._currentRenderer === null || context._currentRenderer === rendererSigil) ? warningWithoutStack$1(false, 'Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.') : void 0;
	      context._currentRenderer = rendererSigil;
	    }
	  }
	}

	function popProvider(providerFiber) {
	  var currentValue = valueCursor.current;

	  pop(valueCursor, providerFiber);

	  var context = providerFiber.type._context;
	  {
	    context._currentValue = currentValue;
	  }
	}

	function calculateChangedBits(context, newValue, oldValue) {
	  if (is(oldValue, newValue)) {
	    // No change
	    return 0;
	  } else {
	    var changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : maxSigned31BitInt;

	    {
	      !((changedBits & maxSigned31BitInt) === changedBits) ? warning$1(false, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits) : void 0;
	    }
	    return changedBits | 0;
	  }
	}

	function scheduleWorkOnParentPath(parent, renderExpirationTime) {
	  // Update the child expiration time of all the ancestors, including
	  // the alternates.
	  var node = parent;
	  while (node !== null) {
	    var alternate = node.alternate;
	    if (node.childExpirationTime < renderExpirationTime) {
	      node.childExpirationTime = renderExpirationTime;
	      if (alternate !== null && alternate.childExpirationTime < renderExpirationTime) {
	        alternate.childExpirationTime = renderExpirationTime;
	      }
	    } else if (alternate !== null && alternate.childExpirationTime < renderExpirationTime) {
	      alternate.childExpirationTime = renderExpirationTime;
	    } else {
	      // Neither alternate was updated, which means the rest of the
	      // ancestor path already has sufficient priority.
	      break;
	    }
	    node = node.return;
	  }
	}

	function propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {
	  var fiber = workInProgress.child;
	  if (fiber !== null) {
	    // Set the return pointer of the child to the work-in-progress fiber.
	    fiber.return = workInProgress;
	  }
	  while (fiber !== null) {
	    var nextFiber = void 0;

	    // Visit this fiber.
	    var list = fiber.contextDependencies;
	    if (list !== null) {
	      nextFiber = fiber.child;

	      var dependency = list.first;
	      while (dependency !== null) {
	        // Check if the context matches.
	        if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
	          // Match! Schedule an update on this fiber.

	          if (fiber.tag === ClassComponent) {
	            // Schedule a force update on the work-in-progress.
	            var update = createUpdate(renderExpirationTime);
	            update.tag = ForceUpdate;
	            // TODO: Because we don't have a work-in-progress, this will add the
	            // update to the current fiber, too, which means it will persist even if
	            // this render is thrown away. Since it's a race condition, not sure it's
	            // worth fixing.
	            enqueueUpdate(fiber, update);
	          }

	          if (fiber.expirationTime < renderExpirationTime) {
	            fiber.expirationTime = renderExpirationTime;
	          }
	          var alternate = fiber.alternate;
	          if (alternate !== null && alternate.expirationTime < renderExpirationTime) {
	            alternate.expirationTime = renderExpirationTime;
	          }

	          scheduleWorkOnParentPath(fiber.return, renderExpirationTime);

	          // Mark the expiration time on the list, too.
	          if (list.expirationTime < renderExpirationTime) {
	            list.expirationTime = renderExpirationTime;
	          }

	          // Since we already found a match, we can stop traversing the
	          // dependency list.
	          break;
	        }
	        dependency = dependency.next;
	      }
	    } else if (fiber.tag === ContextProvider) {
	      // Don't scan deeper if this is a matching provider
	      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
	    } else {
	      // Traverse down.
	      nextFiber = fiber.child;
	    }

	    if (nextFiber !== null) {
	      // Set the return pointer of the child to the work-in-progress fiber.
	      nextFiber.return = fiber;
	    } else {
	      // No child. Traverse to next sibling.
	      nextFiber = fiber;
	      while (nextFiber !== null) {
	        if (nextFiber === workInProgress) {
	          // We're back to the root of this subtree. Exit.
	          nextFiber = null;
	          break;
	        }
	        var sibling = nextFiber.sibling;
	        if (sibling !== null) {
	          // Set the return pointer of the sibling to the work-in-progress fiber.
	          sibling.return = nextFiber.return;
	          nextFiber = sibling;
	          break;
	        }
	        // No more siblings. Traverse up.
	        nextFiber = nextFiber.return;
	      }
	    }
	    fiber = nextFiber;
	  }
	}

	function prepareToReadContext(workInProgress, renderExpirationTime) {
	  currentlyRenderingFiber = workInProgress;
	  lastContextDependency = null;
	  lastContextWithAllBitsObserved = null;

	  var currentDependencies = workInProgress.contextDependencies;
	  if (currentDependencies !== null && currentDependencies.expirationTime >= renderExpirationTime) {
	    // Context list has a pending update. Mark that this fiber performed work.
	    markWorkInProgressReceivedUpdate();
	  }

	  // Reset the work-in-progress list
	  workInProgress.contextDependencies = null;
	}

	function readContext(context, observedBits) {
	  {
	    // This warning would fire if you read context inside a Hook like useMemo.
	    // Unlike the class check below, it's not enforced in production for perf.
	    !!isDisallowedContextReadInDEV ? warning$1(false, 'Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().') : void 0;
	  }

	  if (lastContextWithAllBitsObserved === context) ; else if (observedBits === false || observedBits === 0) ; else {
	    var resolvedObservedBits = void 0; // Avoid deopting on observable arguments or heterogeneous types.
	    if (typeof observedBits !== 'number' || observedBits === maxSigned31BitInt) {
	      // Observe all updates.
	      lastContextWithAllBitsObserved = context;
	      resolvedObservedBits = maxSigned31BitInt;
	    } else {
	      resolvedObservedBits = observedBits;
	    }

	    var contextItem = {
	      context: context,
	      observedBits: resolvedObservedBits,
	      next: null
	    };

	    if (lastContextDependency === null) {
	      !(currentlyRenderingFiber !== null) ? invariant(false, 'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().') : void 0;

	      // This is the first dependency for this component. Create a new list.
	      lastContextDependency = contextItem;
	      currentlyRenderingFiber.contextDependencies = {
	        first: contextItem,
	        expirationTime: NoWork
	      };
	    } else {
	      // Append a new context item.
	      lastContextDependency = lastContextDependency.next = contextItem;
	    }
	  }
	  return context._currentValue;
	}

	// UpdateQueue is a linked list of prioritized updates.
	//
	// Like fibers, update queues come in pairs: a current queue, which represents
	// the visible state of the screen, and a work-in-progress queue, which can be
	// mutated and processed asynchronously before it is committed — a form of
	// double buffering. If a work-in-progress render is discarded before finishing,
	// we create a new work-in-progress by cloning the current queue.
	//
	// Both queues share a persistent, singly-linked list structure. To schedule an
	// update, we append it to the end of both queues. Each queue maintains a
	// pointer to first update in the persistent list that hasn't been processed.
	// The work-in-progress pointer always has a position equal to or greater than
	// the current queue, since we always work on that one. The current queue's
	// pointer is only updated during the commit phase, when we swap in the
	// work-in-progress.
	//
	// For example:
	//
	//   Current pointer:           A - B - C - D - E - F
	//   Work-in-progress pointer:              D - E - F
	//                                          ^
	//                                          The work-in-progress queue has
	//                                          processed more updates than current.
	//
	// The reason we append to both queues is because otherwise we might drop
	// updates without ever processing them. For example, if we only add updates to
	// the work-in-progress queue, some updates could be lost whenever a work-in
	// -progress render restarts by cloning from current. Similarly, if we only add
	// updates to the current queue, the updates will be lost whenever an already
	// in-progress queue commits and swaps with the current queue. However, by
	// adding to both queues, we guarantee that the update will be part of the next
	// work-in-progress. (And because the work-in-progress queue becomes the
	// current queue once it commits, there's no danger of applying the same
	// update twice.)
	//
	// Prioritization
	// --------------
	//
	// Updates are not sorted by priority, but by insertion; new updates are always
	// appended to the end of the list.
	//
	// The priority is still important, though. When processing the update queue
	// during the render phase, only the updates with sufficient priority are
	// included in the result. If we skip an update because it has insufficient
	// priority, it remains in the queue to be processed later, during a lower
	// priority render. Crucially, all updates subsequent to a skipped update also
	// remain in the queue *regardless of their priority*. That means high priority
	// updates are sometimes processed twice, at two separate priorities. We also
	// keep track of a base state, that represents the state before the first
	// update in the queue is applied.
	//
	// For example:
	//
	//   Given a base state of '', and the following queue of updates
	//
	//     A1 - B2 - C1 - D2
	//
	//   where the number indicates the priority, and the update is applied to the
	//   previous state by appending a letter, React will process these updates as
	//   two separate renders, one per distinct priority level:
	//
	//   First render, at priority 1:
	//     Base state: ''
	//     Updates: [A1, C1]
	//     Result state: 'AC'
	//
	//   Second render, at priority 2:
	//     Base state: 'A'            <-  The base state does not include C1,
	//                                    because B2 was skipped.
	//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2
	//     Result state: 'ABCD'
	//
	// Because we process updates in insertion order, and rebase high priority
	// updates when preceding updates are skipped, the final result is deterministic
	// regardless of priority. Intermediate state may vary according to system
	// resources, but the final state is always the same.

	var UpdateState = 0;
	var ReplaceState = 1;
	var ForceUpdate = 2;
	var CaptureUpdate = 3;

	// Global state that is reset at the beginning of calling `processUpdateQueue`.
	// It should only be read right after calling `processUpdateQueue`, via
	// `checkHasForceUpdateAfterProcessing`.
	var hasForceUpdate = false;

	var didWarnUpdateInsideUpdate = void 0;
	var currentlyProcessingQueue = void 0;
	var resetCurrentlyProcessingQueue = void 0;
	{
	  didWarnUpdateInsideUpdate = false;
	  currentlyProcessingQueue = null;
	  resetCurrentlyProcessingQueue = function () {
	    currentlyProcessingQueue = null;
	  };
	}

	function createUpdateQueue(baseState) {
	  var queue = {
	    baseState: baseState,
	    firstUpdate: null,
	    lastUpdate: null,
	    firstCapturedUpdate: null,
	    lastCapturedUpdate: null,
	    firstEffect: null,
	    lastEffect: null,
	    firstCapturedEffect: null,
	    lastCapturedEffect: null
	  };
	  return queue;
	}

	function cloneUpdateQueue(currentQueue) {
	  var queue = {
	    baseState: currentQueue.baseState,
	    firstUpdate: currentQueue.firstUpdate,
	    lastUpdate: currentQueue.lastUpdate,

	    // TODO: With resuming, if we bail out and resuse the child tree, we should
	    // keep these effects.
	    firstCapturedUpdate: null,
	    lastCapturedUpdate: null,

	    firstEffect: null,
	    lastEffect: null,

	    firstCapturedEffect: null,
	    lastCapturedEffect: null
	  };
	  return queue;
	}

	function createUpdate(expirationTime) {
	  return {
	    expirationTime: expirationTime,

	    tag: UpdateState,
	    payload: null,
	    callback: null,

	    next: null,
	    nextEffect: null
	  };
	}

	function appendUpdateToQueue(queue, update) {
	  // Append the update to the end of the list.
	  if (queue.lastUpdate === null) {
	    // Queue is empty
	    queue.firstUpdate = queue.lastUpdate = update;
	  } else {
	    queue.lastUpdate.next = update;
	    queue.lastUpdate = update;
	  }
	}

	function enqueueUpdate(fiber, update) {
	  // Update queues are created lazily.
	  var alternate = fiber.alternate;
	  var queue1 = void 0;
	  var queue2 = void 0;
	  if (alternate === null) {
	    // There's only one fiber.
	    queue1 = fiber.updateQueue;
	    queue2 = null;
	    if (queue1 === null) {
	      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
	    }
	  } else {
	    // There are two owners.
	    queue1 = fiber.updateQueue;
	    queue2 = alternate.updateQueue;
	    if (queue1 === null) {
	      if (queue2 === null) {
	        // Neither fiber has an update queue. Create new ones.
	        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
	        queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState);
	      } else {
	        // Only one fiber has an update queue. Clone to create a new one.
	        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);
	      }
	    } else {
	      if (queue2 === null) {
	        // Only one fiber has an update queue. Clone to create a new one.
	        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);
	      }
	    }
	  }
	  if (queue2 === null || queue1 === queue2) {
	    // There's only a single queue.
	    appendUpdateToQueue(queue1, update);
	  } else {
	    // There are two queues. We need to append the update to both queues,
	    // while accounting for the persistent structure of the list — we don't
	    // want the same update to be added multiple times.
	    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {
	      // One of the queues is not empty. We must add the update to both queues.
	      appendUpdateToQueue(queue1, update);
	      appendUpdateToQueue(queue2, update);
	    } else {
	      // Both queues are non-empty. The last update is the same in both lists,
	      // because of structural sharing. So, only append to one of the lists.
	      appendUpdateToQueue(queue1, update);
	      // But we still need to update the `lastUpdate` pointer of queue2.
	      queue2.lastUpdate = update;
	    }
	  }

	  {
	    if (fiber.tag === ClassComponent && (currentlyProcessingQueue === queue1 || queue2 !== null && currentlyProcessingQueue === queue2) && !didWarnUpdateInsideUpdate) {
	      warningWithoutStack$1(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');
	      didWarnUpdateInsideUpdate = true;
	    }
	  }
	}

	function enqueueCapturedUpdate(workInProgress, update) {
	  // Captured updates go into a separate list, and only on the work-in-
	  // progress queue.
	  var workInProgressQueue = workInProgress.updateQueue;
	  if (workInProgressQueue === null) {
	    workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState);
	  } else {
	    // TODO: I put this here rather than createWorkInProgress so that we don't
	    // clone the queue unnecessarily. There's probably a better way to
	    // structure this.
	    workInProgressQueue = ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);
	  }

	  // Append the update to the end of the list.
	  if (workInProgressQueue.lastCapturedUpdate === null) {
	    // This is the first render phase update
	    workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;
	  } else {
	    workInProgressQueue.lastCapturedUpdate.next = update;
	    workInProgressQueue.lastCapturedUpdate = update;
	  }
	}

	function ensureWorkInProgressQueueIsAClone(workInProgress, queue) {
	  var current = workInProgress.alternate;
	  if (current !== null) {
	    // If the work-in-progress queue is equal to the current queue,
	    // we need to clone it first.
	    if (queue === current.updateQueue) {
	      queue = workInProgress.updateQueue = cloneUpdateQueue(queue);
	    }
	  }
	  return queue;
	}

	function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
	  switch (update.tag) {
	    case ReplaceState:
	      {
	        var _payload = update.payload;
	        if (typeof _payload === 'function') {
	          // Updater function
	          {
	            enterDisallowedContextReadInDEV();
	            if (workInProgress.mode & StrictMode) {
	              _payload.call(instance, prevState, nextProps);
	            }
	          }
	          var nextState = _payload.call(instance, prevState, nextProps);
	          {
	            exitDisallowedContextReadInDEV();
	          }
	          return nextState;
	        }
	        // State object
	        return _payload;
	      }
	    case CaptureUpdate:
	      {
	        workInProgress.effectTag = workInProgress.effectTag & ~ShouldCapture | DidCapture;
	      }
	    // Intentional fallthrough
	    case UpdateState:
	      {
	        var _payload2 = update.payload;
	        var partialState = void 0;
	        if (typeof _payload2 === 'function') {
	          // Updater function
	          {
	            enterDisallowedContextReadInDEV();
	            if (workInProgress.mode & StrictMode) {
	              _payload2.call(instance, prevState, nextProps);
	            }
	          }
	          partialState = _payload2.call(instance, prevState, nextProps);
	          {
	            exitDisallowedContextReadInDEV();
	          }
	        } else {
	          // Partial state object
	          partialState = _payload2;
	        }
	        if (partialState === null || partialState === undefined) {
	          // Null and undefined are treated as no-ops.
	          return prevState;
	        }
	        // Merge the partial state and the previous state.
	        return _assign({}, prevState, partialState);
	      }
	    case ForceUpdate:
	      {
	        hasForceUpdate = true;
	        return prevState;
	      }
	  }
	  return prevState;
	}

	function processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {
	  hasForceUpdate = false;

	  queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);

	  {
	    currentlyProcessingQueue = queue;
	  }

	  // These values may change as we process the queue.
	  var newBaseState = queue.baseState;
	  var newFirstUpdate = null;
	  var newExpirationTime = NoWork;

	  // Iterate through the list of updates to compute the result.
	  var update = queue.firstUpdate;
	  var resultState = newBaseState;
	  while (update !== null) {
	    var updateExpirationTime = update.expirationTime;
	    if (updateExpirationTime < renderExpirationTime) {
	      // This update does not have sufficient priority. Skip it.
	      if (newFirstUpdate === null) {
	        // This is the first skipped update. It will be the first update in
	        // the new list.
	        newFirstUpdate = update;
	        // Since this is the first update that was skipped, the current result
	        // is the new base state.
	        newBaseState = resultState;
	      }
	      // Since this update will remain in the list, update the remaining
	      // expiration time.
	      if (newExpirationTime < updateExpirationTime) {
	        newExpirationTime = updateExpirationTime;
	      }
	    } else {
	      // This update does have sufficient priority. Process it and compute
	      // a new result.
	      resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
	      var _callback = update.callback;
	      if (_callback !== null) {
	        workInProgress.effectTag |= Callback;
	        // Set this to null, in case it was mutated during an aborted render.
	        update.nextEffect = null;
	        if (queue.lastEffect === null) {
	          queue.firstEffect = queue.lastEffect = update;
	        } else {
	          queue.lastEffect.nextEffect = update;
	          queue.lastEffect = update;
	        }
	      }
	    }
	    // Continue to the next update.
	    update = update.next;
	  }

	  // Separately, iterate though the list of captured updates.
	  var newFirstCapturedUpdate = null;
	  update = queue.firstCapturedUpdate;
	  while (update !== null) {
	    var _updateExpirationTime = update.expirationTime;
	    if (_updateExpirationTime < renderExpirationTime) {
	      // This update does not have sufficient priority. Skip it.
	      if (newFirstCapturedUpdate === null) {
	        // This is the first skipped captured update. It will be the first
	        // update in the new list.
	        newFirstCapturedUpdate = update;
	        // If this is the first update that was skipped, the current result is
	        // the new base state.
	        if (newFirstUpdate === null) {
	          newBaseState = resultState;
	        }
	      }
	      // Since this update will remain in the list, update the remaining
	      // expiration time.
	      if (newExpirationTime < _updateExpirationTime) {
	        newExpirationTime = _updateExpirationTime;
	      }
	    } else {
	      // This update does have sufficient priority. Process it and compute
	      // a new result.
	      resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
	      var _callback2 = update.callback;
	      if (_callback2 !== null) {
	        workInProgress.effectTag |= Callback;
	        // Set this to null, in case it was mutated during an aborted render.
	        update.nextEffect = null;
	        if (queue.lastCapturedEffect === null) {
	          queue.firstCapturedEffect = queue.lastCapturedEffect = update;
	        } else {
	          queue.lastCapturedEffect.nextEffect = update;
	          queue.lastCapturedEffect = update;
	        }
	      }
	    }
	    update = update.next;
	  }

	  if (newFirstUpdate === null) {
	    queue.lastUpdate = null;
	  }
	  if (newFirstCapturedUpdate === null) {
	    queue.lastCapturedUpdate = null;
	  } else {
	    workInProgress.effectTag |= Callback;
	  }
	  if (newFirstUpdate === null && newFirstCapturedUpdate === null) {
	    // We processed every update, without skipping. That means the new base
	    // state is the same as the result state.
	    newBaseState = resultState;
	  }

	  queue.baseState = newBaseState;
	  queue.firstUpdate = newFirstUpdate;
	  queue.firstCapturedUpdate = newFirstCapturedUpdate;

	  // Set the remaining expiration time to be whatever is remaining in the queue.
	  // This should be fine because the only two other things that contribute to
	  // expiration time are props and context. We're already in the middle of the
	  // begin phase by the time we start processing the queue, so we've already
	  // dealt with the props. Context in components that specify
	  // shouldComponentUpdate is tricky; but we'll have to account for
	  // that regardless.
	  workInProgress.expirationTime = newExpirationTime;
	  workInProgress.memoizedState = resultState;

	  {
	    currentlyProcessingQueue = null;
	  }
	}

	function callCallback(callback, context) {
	  !(typeof callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', callback) : void 0;
	  callback.call(context);
	}

	function resetHasForceUpdateBeforeProcessing() {
	  hasForceUpdate = false;
	}

	function checkHasForceUpdateAfterProcessing() {
	  return hasForceUpdate;
	}

	function commitUpdateQueue(finishedWork, finishedQueue, instance, renderExpirationTime) {
	  // If the finished render included captured updates, and there are still
	  // lower priority updates left over, we need to keep the captured updates
	  // in the queue so that they are rebased and not dropped once we process the
	  // queue again at the lower priority.
	  if (finishedQueue.firstCapturedUpdate !== null) {
	    // Join the captured update list to the end of the normal list.
	    if (finishedQueue.lastUpdate !== null) {
	      finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;
	      finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;
	    }
	    // Clear the list of captured updates.
	    finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;
	  }

	  // Commit the effects
	  commitUpdateEffects(finishedQueue.firstEffect, instance);
	  finishedQueue.firstEffect = finishedQueue.lastEffect = null;

	  commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);
	  finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;
	}

	function commitUpdateEffects(effect, instance) {
	  while (effect !== null) {
	    var _callback3 = effect.callback;
	    if (_callback3 !== null) {
	      effect.callback = null;
	      callCallback(_callback3, instance);
	    }
	    effect = effect.nextEffect;
	  }
	}

	function createCapturedValue(value, source) {
	  // If the value is an error, call this function immediately after it is thrown
	  // so the stack is accurate.
	  return {
	    value: value,
	    source: source,
	    stack: getStackByFiberInDevAndProd(source)
	  };
	}

	function markUpdate(workInProgress) {
	  // Tag the fiber with an update effect. This turns a Placement into
	  // a PlacementAndUpdate.
	  workInProgress.effectTag |= Update;
	}

	function markRef$1(workInProgress) {
	  workInProgress.effectTag |= Ref;
	}

	var appendAllChildren = void 0;
	var updateHostContainer = void 0;
	var updateHostComponent$1 = void 0;
	var updateHostText$1 = void 0;
	{
	  // Mutation mode

	  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {
	    // We only have the top Fiber that was created but we need recurse down its
	    // children to find all the terminal nodes.
	    var node = workInProgress.child;
	    while (node !== null) {
	      if (node.tag === HostComponent || node.tag === HostText) {
	        appendInitialChild(parent, node.stateNode);
	      } else if (node.tag === HostPortal) ; else if (node.child !== null) {
	        node.child.return = node;
	        node = node.child;
	        continue;
	      }
	      if (node === workInProgress) {
	        return;
	      }
	      while (node.sibling === null) {
	        if (node.return === null || node.return === workInProgress) {
	          return;
	        }
	        node = node.return;
	      }
	      node.sibling.return = node.return;
	      node = node.sibling;
	    }
	  };

	  updateHostContainer = function (workInProgress) {
	    // Noop
	  };
	  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {
	    // If we have an alternate, that means this is an update and we need to
	    // schedule a side-effect to do the updates.
	    var oldProps = current.memoizedProps;
	    if (oldProps === newProps) {
	      // In mutation mode, this is sufficient for a bailout because
	      // we won't touch this node even if children changed.
	      return;
	    }

	    // If we get updated because one of our children updated, we don't
	    // have newProps so we'll have to reuse them.
	    // TODO: Split the update API as separate for the props vs. children.
	    // Even better would be if children weren't special cased at all tho.
	    var instance = workInProgress.stateNode;
	    var currentHostContext = getHostContext();
	    // TODO: Experiencing an error where oldProps is null. Suggests a host
	    // component is hitting the resume path. Figure out why. Possibly
	    // related to `hidden`.
	    var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
	    // TODO: Type this specific to this type of component.
	    workInProgress.updateQueue = updatePayload;
	    // If the update payload indicates that there is a change or if there
	    // is a new ref we mark this as an update. All the work is done in commitWork.
	    if (updatePayload) {
	      markUpdate(workInProgress);
	    }
	  };
	  updateHostText$1 = function (current, workInProgress, oldText, newText) {
	    // If the text differs, mark it as an update. All the work in done in commitWork.
	    if (oldText !== newText) {
	      markUpdate(workInProgress);
	    }
	  };
	}

	function completeWork(current, workInProgress, renderExpirationTime) {
	  var newProps = workInProgress.pendingProps;

	  switch (workInProgress.tag) {
	    case IndeterminateComponent:
	      break;
	    case LazyComponent:
	      break;
	    case SimpleMemoComponent:
	    case FunctionComponent:
	      break;
	    case ClassComponent:
	      {
	        var Component = workInProgress.type;
	        if (isContextProvider(Component)) {
	          popContext(workInProgress);
	        }
	        break;
	      }
	    case HostRoot:
	      {
	        popHostContainer(workInProgress);
	        popTopLevelContextObject(workInProgress);
	        var fiberRoot = workInProgress.stateNode;
	        if (fiberRoot.pendingContext) {
	          fiberRoot.context = fiberRoot.pendingContext;
	          fiberRoot.pendingContext = null;
	        }
	        if (current === null || current.child === null) {
	          // If we hydrated, pop so that we can delete any remaining children
	          // that weren't hydrated.
	          popHydrationState(workInProgress);
	          // This resets the hacky state to fix isMounted before committing.
	          // TODO: Delete this when we delete isMounted and findDOMNode.
	          workInProgress.effectTag &= ~Placement;
	        }
	        updateHostContainer(workInProgress);
	        break;
	      }
	    case HostComponent:
	      {
	        popHostContext(workInProgress);
	        var rootContainerInstance = getRootHostContainer();
	        var type = workInProgress.type;
	        if (current !== null && workInProgress.stateNode != null) {
	          updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);

	          if (current.ref !== workInProgress.ref) {
	            markRef$1(workInProgress);
	          }
	        } else {
	          if (!newProps) {
	            !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	            // This can happen when we abort work.
	            break;
	          }

	          var currentHostContext = getHostContext();
	          // TODO: Move createInstance to beginWork and keep it on a context
	          // "stack" as the parent. Then append children as we go in beginWork
	          // or completeWork depending on we want to add then top->down or
	          // bottom->up. Top->down is faster in IE11.
	          var wasHydrated = popHydrationState(workInProgress);
	          if (wasHydrated) {
	            // TODO: Move this and createInstance step into the beginPhase
	            // to consolidate.
	            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {
	              // If changes to the hydrated node needs to be applied at the
	              // commit-phase we mark this as such.
	              markUpdate(workInProgress);
	            }
	          } else {
	            var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);

	            appendAllChildren(instance, workInProgress, false, false);

	            // Certain renderers require commit-time effects for initial mount.
	            // (eg DOM renderer supports auto-focus for certain elements).
	            // Make sure such renderers get scheduled for later work.
	            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {
	              markUpdate(workInProgress);
	            }
	            workInProgress.stateNode = instance;
	          }

	          if (workInProgress.ref !== null) {
	            // If there is a ref on a host node we need to schedule a callback
	            markRef$1(workInProgress);
	          }
	        }
	        break;
	      }
	    case HostText:
	      {
	        var newText = newProps;
	        if (current && workInProgress.stateNode != null) {
	          var oldText = current.memoizedProps;
	          // If we have an alternate, that means this is an update and we need
	          // to schedule a side-effect to do the updates.
	          updateHostText$1(current, workInProgress, oldText, newText);
	        } else {
	          if (typeof newText !== 'string') {
	            !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	            // This can happen when we abort work.
	          }
	          var _rootContainerInstance = getRootHostContainer();
	          var _currentHostContext = getHostContext();
	          var _wasHydrated = popHydrationState(workInProgress);
	          if (_wasHydrated) {
	            if (prepareToHydrateHostTextInstance(workInProgress)) {
	              markUpdate(workInProgress);
	            }
	          } else {
	            workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
	          }
	        }
	        break;
	      }
	    case ForwardRef:
	      break;
	    case SuspenseComponent:
	      {
	        var nextState = workInProgress.memoizedState;
	        if ((workInProgress.effectTag & DidCapture) !== NoEffect) {
	          // Something suspended. Re-render with the fallback children.
	          workInProgress.expirationTime = renderExpirationTime;
	          // Do not reset the effect list.
	          return workInProgress;
	        }

	        var nextDidTimeout = nextState !== null;
	        var prevDidTimeout = current !== null && current.memoizedState !== null;

	        if (current !== null && !nextDidTimeout && prevDidTimeout) {
	          // We just switched from the fallback to the normal children. Delete
	          // the fallback.
	          // TODO: Would it be better to store the fallback fragment on
	          var currentFallbackChild = current.child.sibling;
	          if (currentFallbackChild !== null) {
	            // Deletions go at the beginning of the return fiber's effect list
	            var first = workInProgress.firstEffect;
	            if (first !== null) {
	              workInProgress.firstEffect = currentFallbackChild;
	              currentFallbackChild.nextEffect = first;
	            } else {
	              workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild;
	              currentFallbackChild.nextEffect = null;
	            }
	            currentFallbackChild.effectTag = Deletion;
	          }
	        }

	        if (nextDidTimeout || prevDidTimeout) {
	          // If the children are hidden, or if they were previous hidden, schedule
	          // an effect to toggle their visibility. This is also used to attach a
	          // retry listener to the promise.
	          workInProgress.effectTag |= Update;
	        }
	        break;
	      }
	    case Fragment:
	      break;
	    case Mode:
	      break;
	    case Profiler:
	      break;
	    case HostPortal:
	      popHostContainer(workInProgress);
	      updateHostContainer(workInProgress);
	      break;
	    case ContextProvider:
	      // Pop provider fiber
	      popProvider(workInProgress);
	      break;
	    case ContextConsumer:
	      break;
	    case MemoComponent:
	      break;
	    case IncompleteClassComponent:
	      {
	        // Same as class component case. I put it down here so that the tags are
	        // sequential to ensure this switch is compiled to a jump table.
	        var _Component = workInProgress.type;
	        if (isContextProvider(_Component)) {
	          popContext(workInProgress);
	        }
	        break;
	      }
	    case DehydratedSuspenseComponent:
	      {
	        break;
	      }
	    default:
	      invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
	  }

	  return null;
	}

	function shouldCaptureSuspense(workInProgress) {
	  // In order to capture, the Suspense component must have a fallback prop.
	  if (workInProgress.memoizedProps.fallback === undefined) {
	    return false;
	  }
	  // If it was the primary children that just suspended, capture and render the
	  // fallback. Otherwise, don't capture and bubble to the next boundary.
	  var nextState = workInProgress.memoizedState;
	  return nextState === null;
	}

	function logCapturedError(capturedError) {

	  var error = capturedError.error;
	  {
	    var componentName = capturedError.componentName,
	        componentStack = capturedError.componentStack,
	        errorBoundaryName = capturedError.errorBoundaryName,
	        errorBoundaryFound = capturedError.errorBoundaryFound,
	        willRetry = capturedError.willRetry;

	    // Browsers support silencing uncaught errors by calling
	    // `preventDefault()` in window `error` handler.
	    // We record this information as an expando on the error.

	    if (error != null && error._suppressLogging) {
	      if (errorBoundaryFound && willRetry) {
	        // The error is recoverable and was silenced.
	        // Ignore it and don't print the stack addendum.
	        // This is handy for testing error boundaries without noise.
	        return;
	      }
	      // The error is fatal. Since the silencing might have
	      // been accidental, we'll surface it anyway.
	      // However, the browser would have silenced the original error
	      // so we'll print it first, and then print the stack addendum.
	      console.error(error);
	      // For a more detailed description of this block, see:
	      // https://github.com/facebook/react/pull/13384
	    }

	    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';

	    var errorBoundaryMessage = void 0;
	    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
	    if (errorBoundaryFound && errorBoundaryName) {
	      if (willRetry) {
	        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');
	      } else {
	        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';
	      }
	    } else {
	      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';
	    }
	    var combinedMessage = '' + componentNameMessage + componentStack + '\n\n' + ('' + errorBoundaryMessage);

	    // In development, we provide our own message with just the component stack.
	    // We don't include the original error message and JS stack because the browser
	    // has already printed it. Even if the application swallows the error, it is still
	    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
	    console.error(combinedMessage);
	  }
	}

	var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
	{
	  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
	}

	var PossiblyWeakSet$1 = typeof WeakSet === 'function' ? WeakSet : Set;

	function logError(boundary, errorInfo) {
	  var source = errorInfo.source;
	  var stack = errorInfo.stack;
	  if (stack === null && source !== null) {
	    stack = getStackByFiberInDevAndProd(source);
	  }

	  var capturedError = {
	    componentName: source !== null ? getComponentName(source.type) : null,
	    componentStack: stack !== null ? stack : '',
	    error: errorInfo.value,
	    errorBoundary: null,
	    errorBoundaryName: null,
	    errorBoundaryFound: false,
	    willRetry: false
	  };

	  if (boundary !== null && boundary.tag === ClassComponent) {
	    capturedError.errorBoundary = boundary.stateNode;
	    capturedError.errorBoundaryName = getComponentName(boundary.type);
	    capturedError.errorBoundaryFound = true;
	    capturedError.willRetry = true;
	  }

	  try {
	    logCapturedError(capturedError);
	  } catch (e) {
	    // This method must not throw, or React internal state will get messed up.
	    // If console.error is overridden, or logCapturedError() shows a dialog that throws,
	    // we want to report this error outside of the normal stack as a last resort.
	    // https://github.com/facebook/react/issues/13188
	    setTimeout(function () {
	      throw e;
	    });
	  }
	}

	var callComponentWillUnmountWithTimer = function (current$$1, instance) {
	  startPhaseTimer(current$$1, 'componentWillUnmount');
	  instance.props = current$$1.memoizedProps;
	  instance.state = current$$1.memoizedState;
	  instance.componentWillUnmount();
	  stopPhaseTimer();
	};

	// Capture errors so they don't interrupt unmounting.
	function safelyCallComponentWillUnmount(current$$1, instance) {
	  {
	    invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current$$1, instance);
	    if (hasCaughtError()) {
	      var unmountError = clearCaughtError();
	      captureCommitPhaseError(current$$1, unmountError);
	    }
	  }
	}

	function safelyDetachRef(current$$1) {
	  var ref = current$$1.ref;
	  if (ref !== null) {
	    if (typeof ref === 'function') {
	      {
	        invokeGuardedCallback(null, ref, null, null);
	        if (hasCaughtError()) {
	          var refError = clearCaughtError();
	          captureCommitPhaseError(current$$1, refError);
	        }
	      }
	    } else {
	      ref.current = null;
	    }
	  }
	}

	function safelyCallDestroy(current$$1, destroy) {
	  {
	    invokeGuardedCallback(null, destroy, null);
	    if (hasCaughtError()) {
	      var error = clearCaughtError();
	      captureCommitPhaseError(current$$1, error);
	    }
	  }
	}

	function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
	  switch (finishedWork.tag) {
	    case FunctionComponent:
	    case ForwardRef:
	    case SimpleMemoComponent:
	      {
	        commitHookEffectList(UnmountSnapshot, NoEffect$1, finishedWork);
	        return;
	      }
	    case ClassComponent:
	      {
	        if (finishedWork.effectTag & Snapshot) {
	          if (current$$1 !== null) {
	            var prevProps = current$$1.memoizedProps;
	            var prevState = current$$1.memoizedState;
	            startPhaseTimer(finishedWork, 'getSnapshotBeforeUpdate');
	            var instance = finishedWork.stateNode;
	            // We could update instance props and state here,
	            // but instead we rely on them being set during last render.
	            // TODO: revisit this when we implement resuming.
	            {
	              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
	                !(instance.props === finishedWork.memoizedProps) ? warning$1(false, 'Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance') : void 0;
	                !(instance.state === finishedWork.memoizedState) ? warning$1(false, 'Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance') : void 0;
	              }
	            }
	            var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
	            {
	              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
	              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
	                didWarnSet.add(finishedWork.type);
	                warningWithoutStack$1(false, '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentName(finishedWork.type));
	              }
	            }
	            instance.__reactInternalSnapshotBeforeUpdate = snapshot;
	            stopPhaseTimer();
	          }
	        }
	        return;
	      }
	    case HostRoot:
	    case HostComponent:
	    case HostText:
	    case HostPortal:
	    case IncompleteClassComponent:
	      // Nothing to do for these component types
	      return;
	    default:
	      {
	        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
	      }
	  }
	}

	function commitHookEffectList(unmountTag, mountTag, finishedWork) {
	  var updateQueue = finishedWork.updateQueue;
	  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
	  if (lastEffect !== null) {
	    var firstEffect = lastEffect.next;
	    var effect = firstEffect;
	    do {
	      if ((effect.tag & unmountTag) !== NoEffect$1) {
	        // Unmount
	        var destroy = effect.destroy;
	        effect.destroy = undefined;
	        if (destroy !== undefined) {
	          destroy();
	        }
	      }
	      if ((effect.tag & mountTag) !== NoEffect$1) {
	        // Mount
	        var create = effect.create;
	        effect.destroy = create();

	        {
	          var _destroy = effect.destroy;
	          if (_destroy !== undefined && typeof _destroy !== 'function') {
	            var addendum = void 0;
	            if (_destroy === null) {
	              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';
	            } else if (typeof _destroy.then === 'function') {
	              addendum = '\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\n\n' + 'useEffect(() => {\n' + '  async function fetchData() {\n' + '    // You can await here\n' + '    const response = await MyAPI.getData(someId);\n' + '    // ...\n' + '  }\n' + '  fetchData();\n' + '}, [someId]); // Or [] if effect doesn\'t need props or state\n\n' + 'Learn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching';
	            } else {
	              addendum = ' You returned: ' + _destroy;
	            }
	            warningWithoutStack$1(false, 'An effect function must not return anything besides a function, ' + 'which is used for clean-up.%s%s', addendum, getStackByFiberInDevAndProd(finishedWork));
	          }
	        }
	      }
	      effect = effect.next;
	    } while (effect !== firstEffect);
	  }
	}

	function commitPassiveHookEffects(finishedWork) {
	  commitHookEffectList(UnmountPassive, NoEffect$1, finishedWork);
	  commitHookEffectList(NoEffect$1, MountPassive, finishedWork);
	}

	function commitLifeCycles(finishedRoot, current$$1, finishedWork, committedExpirationTime) {
	  switch (finishedWork.tag) {
	    case FunctionComponent:
	    case ForwardRef:
	    case SimpleMemoComponent:
	      {
	        commitHookEffectList(UnmountLayout, MountLayout, finishedWork);
	        break;
	      }
	    case ClassComponent:
	      {
	        var instance = finishedWork.stateNode;
	        if (finishedWork.effectTag & Update) {
	          if (current$$1 === null) {
	            startPhaseTimer(finishedWork, 'componentDidMount');
	            // We could update instance props and state here,
	            // but instead we rely on them being set during last render.
	            // TODO: revisit this when we implement resuming.
	            {
	              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
	                !(instance.props === finishedWork.memoizedProps) ? warning$1(false, 'Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance') : void 0;
	                !(instance.state === finishedWork.memoizedState) ? warning$1(false, 'Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance') : void 0;
	              }
	            }
	            instance.componentDidMount();
	            stopPhaseTimer();
	          } else {
	            var prevProps = finishedWork.elementType === finishedWork.type ? current$$1.memoizedProps : resolveDefaultProps(finishedWork.type, current$$1.memoizedProps);
	            var prevState = current$$1.memoizedState;
	            startPhaseTimer(finishedWork, 'componentDidUpdate');
	            // We could update instance props and state here,
	            // but instead we rely on them being set during last render.
	            // TODO: revisit this when we implement resuming.
	            {
	              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
	                !(instance.props === finishedWork.memoizedProps) ? warning$1(false, 'Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance') : void 0;
	                !(instance.state === finishedWork.memoizedState) ? warning$1(false, 'Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance') : void 0;
	              }
	            }
	            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
	            stopPhaseTimer();
	          }
	        }
	        var updateQueue = finishedWork.updateQueue;
	        if (updateQueue !== null) {
	          {
	            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
	              !(instance.props === finishedWork.memoizedProps) ? warning$1(false, 'Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance') : void 0;
	              !(instance.state === finishedWork.memoizedState) ? warning$1(false, 'Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance') : void 0;
	            }
	          }
	          // We could update instance props and state here,
	          // but instead we rely on them being set during last render.
	          // TODO: revisit this when we implement resuming.
	          commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);
	        }
	        return;
	      }
	    case HostRoot:
	      {
	        var _updateQueue = finishedWork.updateQueue;
	        if (_updateQueue !== null) {
	          var _instance = null;
	          if (finishedWork.child !== null) {
	            switch (finishedWork.child.tag) {
	              case HostComponent:
	                _instance = getPublicInstance(finishedWork.child.stateNode);
	                break;
	              case ClassComponent:
	                _instance = finishedWork.child.stateNode;
	                break;
	            }
	          }
	          commitUpdateQueue(finishedWork, _updateQueue, _instance, committedExpirationTime);
	        }
	        return;
	      }
	    case HostComponent:
	      {
	        var _instance2 = finishedWork.stateNode;

	        // Renderers may schedule work to be done after host components are mounted
	        // (eg DOM renderer may schedule auto-focus for inputs and form controls).
	        // These effects should only be committed when components are first mounted,
	        // aka when there is no current/alternate.
	        if (current$$1 === null && finishedWork.effectTag & Update) {
	          var type = finishedWork.type;
	          var props = finishedWork.memoizedProps;
	          commitMount(_instance2, type, props, finishedWork);
	        }

	        return;
	      }
	    case HostText:
	      {
	        // We have no life-cycles associated with text.
	        return;
	      }
	    case HostPortal:
	      {
	        // We have no life-cycles associated with portals.
	        return;
	      }
	    case Profiler:
	      {
	        {
	          var onRender = finishedWork.memoizedProps.onRender;

	          {
	            onRender(finishedWork.memoizedProps.id, current$$1 === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);
	          }
	        }
	        return;
	      }
	    case SuspenseComponent:
	      break;
	    case IncompleteClassComponent:
	      break;
	    default:
	      {
	        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
	      }
	  }
	}

	function hideOrUnhideAllChildren(finishedWork, isHidden) {
	  {
	    // We only have the top Fiber that was inserted but we need to recurse down its
	    var node = finishedWork;
	    while (true) {
	      if (node.tag === HostComponent) {
	        var instance = node.stateNode;
	        if (isHidden) {
	          hideInstance(instance);
	        } else {
	          unhideInstance(node.stateNode, node.memoizedProps);
	        }
	      } else if (node.tag === HostText) {
	        var _instance3 = node.stateNode;
	        if (isHidden) {
	          hideTextInstance(_instance3);
	        } else {
	          unhideTextInstance(_instance3, node.memoizedProps);
	        }
	      } else if (node.tag === SuspenseComponent && node.memoizedState !== null) {
	        // Found a nested Suspense component that timed out. Skip over the
	        var fallbackChildFragment = node.child.sibling;
	        fallbackChildFragment.return = node;
	        node = fallbackChildFragment;
	        continue;
	      } else if (node.child !== null) {
	        node.child.return = node;
	        node = node.child;
	        continue;
	      }
	      if (node === finishedWork) {
	        return;
	      }
	      while (node.sibling === null) {
	        if (node.return === null || node.return === finishedWork) {
	          return;
	        }
	        node = node.return;
	      }
	      node.sibling.return = node.return;
	      node = node.sibling;
	    }
	  }
	}

	function commitAttachRef(finishedWork) {
	  var ref = finishedWork.ref;
	  if (ref !== null) {
	    var instance = finishedWork.stateNode;
	    var instanceToUse = void 0;
	    switch (finishedWork.tag) {
	      case HostComponent:
	        instanceToUse = getPublicInstance(instance);
	        break;
	      default:
	        instanceToUse = instance;
	    }
	    if (typeof ref === 'function') {
	      ref(instanceToUse);
	    } else {
	      {
	        if (!ref.hasOwnProperty('current')) {
	          warningWithoutStack$1(false, 'Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().%s', getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));
	        }
	      }

	      ref.current = instanceToUse;
	    }
	  }
	}

	function commitDetachRef(current$$1) {
	  var currentRef = current$$1.ref;
	  if (currentRef !== null) {
	    if (typeof currentRef === 'function') {
	      currentRef(null);
	    } else {
	      currentRef.current = null;
	    }
	  }
	}

	// User-originating errors (lifecycles and refs) should not interrupt
	// deletion, so don't let them throw. Host-originating errors should
	// interrupt deletion, so it's okay
	function commitUnmount(current$$1) {
	  onCommitUnmount(current$$1);

	  switch (current$$1.tag) {
	    case FunctionComponent:
	    case ForwardRef:
	    case MemoComponent:
	    case SimpleMemoComponent:
	      {
	        var updateQueue = current$$1.updateQueue;
	        if (updateQueue !== null) {
	          var lastEffect = updateQueue.lastEffect;
	          if (lastEffect !== null) {
	            var firstEffect = lastEffect.next;
	            var effect = firstEffect;
	            do {
	              var destroy = effect.destroy;
	              if (destroy !== undefined) {
	                safelyCallDestroy(current$$1, destroy);
	              }
	              effect = effect.next;
	            } while (effect !== firstEffect);
	          }
	        }
	        break;
	      }
	    case ClassComponent:
	      {
	        safelyDetachRef(current$$1);
	        var instance = current$$1.stateNode;
	        if (typeof instance.componentWillUnmount === 'function') {
	          safelyCallComponentWillUnmount(current$$1, instance);
	        }
	        return;
	      }
	    case HostComponent:
	      {
	        safelyDetachRef(current$$1);
	        return;
	      }
	    case HostPortal:
	      {
	        // TODO: this is recursive.
	        // We are also not using this parent because
	        // the portal will get pushed immediately.
	        {
	          unmountHostComponents(current$$1);
	        }
	        return;
	      }
	  }
	}

	function commitNestedUnmounts(root) {
	  // While we're inside a removed host node we don't want to call
	  // removeChild on the inner nodes because they're removed by the top
	  // call anyway. We also want to call componentWillUnmount on all
	  // composites before this host node is removed from the tree. Therefore
	  var node = root;
	  while (true) {
	    commitUnmount(node);
	    // Visit children because they may contain more composite or host nodes.
	    // Skip portals because commitUnmount() currently visits them recursively.
	    if (node.child !== null && (
	    // If we use mutation we drill down into portals using commitUnmount above.
	    // If we don't use mutation we drill down into portals here instead.
	    node.tag !== HostPortal)) {
	      node.child.return = node;
	      node = node.child;
	      continue;
	    }
	    if (node === root) {
	      return;
	    }
	    while (node.sibling === null) {
	      if (node.return === null || node.return === root) {
	        return;
	      }
	      node = node.return;
	    }
	    node.sibling.return = node.return;
	    node = node.sibling;
	  }
	}

	function detachFiber(current$$1) {
	  // Cut off the return pointers to disconnect it from the tree. Ideally, we
	  // should clear the child pointer of the parent alternate to let this
	  // get GC:ed but we don't know which for sure which parent is the current
	  // one so we'll settle for GC:ing the subtree of this child. This child
	  // itself will be GC:ed when the parent updates the next time.
	  current$$1.return = null;
	  current$$1.child = null;
	  current$$1.memoizedState = null;
	  current$$1.updateQueue = null;
	  var alternate = current$$1.alternate;
	  if (alternate !== null) {
	    alternate.return = null;
	    alternate.child = null;
	    alternate.memoizedState = null;
	    alternate.updateQueue = null;
	  }
	}

	function getHostParentFiber(fiber) {
	  var parent = fiber.return;
	  while (parent !== null) {
	    if (isHostParent(parent)) {
	      return parent;
	    }
	    parent = parent.return;
	  }
	  invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');
	}

	function isHostParent(fiber) {
	  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
	}

	function getHostSibling(fiber) {
	  // We're going to search forward into the tree until we find a sibling host
	  // node. Unfortunately, if multiple insertions are done in a row we have to
	  // search past them. This leads to exponential search for the next sibling.
	  var node = fiber;
	  siblings: while (true) {
	    // If we didn't find anything, let's try the next sibling.
	    while (node.sibling === null) {
	      if (node.return === null || isHostParent(node.return)) {
	        // If we pop out of the root or hit the parent the fiber we are the
	        // last sibling.
	        return null;
	      }
	      node = node.return;
	    }
	    node.sibling.return = node.return;
	    node = node.sibling;
	    while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedSuspenseComponent) {
	      // If it is not host node and, we might have a host node inside it.
	      // Try to search down until we find one.
	      if (node.effectTag & Placement) {
	        // If we don't have a child, try the siblings instead.
	        continue siblings;
	      }
	      // If we don't have a child, try the siblings instead.
	      // We also skip portals because they are not part of this host tree.
	      if (node.child === null || node.tag === HostPortal) {
	        continue siblings;
	      } else {
	        node.child.return = node;
	        node = node.child;
	      }
	    }
	    // Check if this host node is stable or about to be placed.
	    if (!(node.effectTag & Placement)) {
	      // Found it!
	      return node.stateNode;
	    }
	  }
	}

	function commitPlacement(finishedWork) {

	  // Recursively insert all host nodes into the parent.
	  var parentFiber = getHostParentFiber(finishedWork);

	  // Note: these two variables *must* always be updated together.
	  var parent = void 0;
	  var isContainer = void 0;

	  switch (parentFiber.tag) {
	    case HostComponent:
	      parent = parentFiber.stateNode;
	      isContainer = false;
	      break;
	    case HostRoot:
	      parent = parentFiber.stateNode.containerInfo;
	      isContainer = true;
	      break;
	    case HostPortal:
	      parent = parentFiber.stateNode.containerInfo;
	      isContainer = true;
	      break;
	    default:
	      invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');
	  }
	  if (parentFiber.effectTag & ContentReset) {
	    // Reset the text content of the parent before doing any insertions
	    resetTextContent(parent);
	    // Clear ContentReset from the effect tag
	    parentFiber.effectTag &= ~ContentReset;
	  }

	  var before = getHostSibling(finishedWork);
	  // We only have the top Fiber that was inserted but we need to recurse down its
	  // children to find all the terminal nodes.
	  var node = finishedWork;
	  while (true) {
	    if (node.tag === HostComponent || node.tag === HostText) {
	      if (before) {
	        if (isContainer) {
	          insertInContainerBefore(parent, node.stateNode, before);
	        } else {
	          insertBefore(parent, node.stateNode, before);
	        }
	      } else {
	        if (isContainer) {
	          appendChildToContainer(parent, node.stateNode);
	        } else {
	          appendChild(parent, node.stateNode);
	        }
	      }
	    } else if (node.tag === HostPortal) ; else if (node.child !== null) {
	      node.child.return = node;
	      node = node.child;
	      continue;
	    }
	    if (node === finishedWork) {
	      return;
	    }
	    while (node.sibling === null) {
	      if (node.return === null || node.return === finishedWork) {
	        return;
	      }
	      node = node.return;
	    }
	    node.sibling.return = node.return;
	    node = node.sibling;
	  }
	}

	function unmountHostComponents(current$$1) {
	  // We only have the top Fiber that was deleted but we need to recurse down its
	  var node = current$$1;

	  // Each iteration, currentParent is populated with node's host parent if not
	  // currentParentIsValid.
	  var currentParentIsValid = false;

	  // Note: these two variables *must* always be updated together.
	  var currentParent = void 0;
	  var currentParentIsContainer = void 0;

	  while (true) {
	    if (!currentParentIsValid) {
	      var parent = node.return;
	      findParent: while (true) {
	        !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	        switch (parent.tag) {
	          case HostComponent:
	            currentParent = parent.stateNode;
	            currentParentIsContainer = false;
	            break findParent;
	          case HostRoot:
	            currentParent = parent.stateNode.containerInfo;
	            currentParentIsContainer = true;
	            break findParent;
	          case HostPortal:
	            currentParent = parent.stateNode.containerInfo;
	            currentParentIsContainer = true;
	            break findParent;
	        }
	        parent = parent.return;
	      }
	      currentParentIsValid = true;
	    }

	    if (node.tag === HostComponent || node.tag === HostText) {
	      commitNestedUnmounts(node);
	      // After all the children have unmounted, it is now safe to remove the
	      // node from the tree.
	      if (currentParentIsContainer) {
	        removeChildFromContainer(currentParent, node.stateNode);
	      } else {
	        removeChild(currentParent, node.stateNode);
	      }
	      // Don't visit children because we already visited them.
	    } else if (node.tag === HostPortal) {
	      if (node.child !== null) {
	        // When we go into a portal, it becomes the parent to remove from.
	        // We will reassign it back when we pop the portal on the way up.
	        currentParent = node.stateNode.containerInfo;
	        currentParentIsContainer = true;
	        // Visit children because portals might contain host components.
	        node.child.return = node;
	        node = node.child;
	        continue;
	      }
	    } else {
	      commitUnmount(node);
	      // Visit children because we may find more host components below.
	      if (node.child !== null) {
	        node.child.return = node;
	        node = node.child;
	        continue;
	      }
	    }
	    if (node === current$$1) {
	      return;
	    }
	    while (node.sibling === null) {
	      if (node.return === null || node.return === current$$1) {
	        return;
	      }
	      node = node.return;
	      if (node.tag === HostPortal) {
	        // When we go out of the portal, we need to restore the parent.
	        // Since we don't keep a stack of them, we will search for it.
	        currentParentIsValid = false;
	      }
	    }
	    node.sibling.return = node.return;
	    node = node.sibling;
	  }
	}

	function commitDeletion(current$$1) {
	  {
	    // Recursively delete all host nodes from the parent.
	    // Detach refs and call componentWillUnmount() on the whole subtree.
	    unmountHostComponents(current$$1);
	  }
	  detachFiber(current$$1);
	}

	function commitWork(current$$1, finishedWork) {

	  switch (finishedWork.tag) {
	    case FunctionComponent:
	    case ForwardRef:
	    case MemoComponent:
	    case SimpleMemoComponent:
	      {
	        // Note: We currently never use MountMutation, but useLayout uses
	        // UnmountMutation.
	        commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
	        return;
	      }
	    case ClassComponent:
	      {
	        return;
	      }
	    case HostComponent:
	      {
	        var instance = finishedWork.stateNode;
	        if (instance != null) {
	          // Commit the work prepared earlier.
	          var newProps = finishedWork.memoizedProps;
	          // For hydration we reuse the update path but we treat the oldProps
	          // as the newProps. The updatePayload will contain the real change in
	          // this case.
	          var oldProps = current$$1 !== null ? current$$1.memoizedProps : newProps;
	          var type = finishedWork.type;
	          // TODO: Type the updateQueue to be specific to host components.
	          var updatePayload = finishedWork.updateQueue;
	          finishedWork.updateQueue = null;
	          if (updatePayload !== null) {
	            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
	          }
	        }
	        return;
	      }
	    case HostText:
	      {
	        !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	        var textInstance = finishedWork.stateNode;
	        var newText = finishedWork.memoizedProps;
	        // For hydration we reuse the update path but we treat the oldProps
	        // as the newProps. The updatePayload will contain the real change in
	        // this case.
	        var oldText = current$$1 !== null ? current$$1.memoizedProps : newText;
	        commitTextUpdate(textInstance, oldText, newText);
	        return;
	      }
	    case HostRoot:
	      {
	        return;
	      }
	    case Profiler:
	      {
	        return;
	      }
	    case SuspenseComponent:
	      {
	        var newState = finishedWork.memoizedState;

	        var newDidTimeout = void 0;
	        var primaryChildParent = finishedWork;
	        if (newState === null) {
	          newDidTimeout = false;
	        } else {
	          newDidTimeout = true;
	          primaryChildParent = finishedWork.child;
	          if (newState.timedOutAt === NoWork) {
	            // If the children had not already timed out, record the time.
	            // This is used to compute the elapsed time during subsequent
	            // attempts to render the children.
	            newState.timedOutAt = requestCurrentTime();
	          }
	        }

	        if (primaryChildParent !== null) {
	          hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);
	        }

	        // If this boundary just timed out, then it will have a set of thenables.
	        // For each thenable, attach a listener so that when it resolves, React
	        // attempts to re-render the boundary in the primary (pre-timeout) state.
	        var thenables = finishedWork.updateQueue;
	        if (thenables !== null) {
	          finishedWork.updateQueue = null;
	          var retryCache = finishedWork.stateNode;
	          if (retryCache === null) {
	            retryCache = finishedWork.stateNode = new PossiblyWeakSet$1();
	          }
	          thenables.forEach(function (thenable) {
	            // Memoize using the boundary fiber to prevent redundant listeners.
	            var retry = retryTimedOutBoundary.bind(null, finishedWork, thenable);
	            {
	              retry = tracing$1.unstable_wrap(retry);
	            }
	            if (!retryCache.has(thenable)) {
	              retryCache.add(thenable);
	              thenable.then(retry, retry);
	            }
	          });
	        }

	        return;
	      }
	    case IncompleteClassComponent:
	      {
	        return;
	      }
	    default:
	      {
	        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
	      }
	  }
	}

	function commitResetTextContent(current$$1) {
	  resetTextContent(current$$1.stateNode);
	}
	var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;

	function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
	  var update = createUpdate(expirationTime);
	  // Unmount the root by rendering null.
	  update.tag = CaptureUpdate;
	  // Caution: React DevTools currently depends on this property
	  // being called "element".
	  update.payload = { element: null };
	  var error = errorInfo.value;
	  update.callback = function () {
	    onUncaughtError(error);
	    logError(fiber, errorInfo);
	  };
	  return update;
	}

	function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
	  var update = createUpdate(expirationTime);
	  update.tag = CaptureUpdate;
	  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
	  if (typeof getDerivedStateFromError === 'function') {
	    var error = errorInfo.value;
	    update.payload = function () {
	      return getDerivedStateFromError(error);
	    };
	  }

	  var inst = fiber.stateNode;
	  if (inst !== null && typeof inst.componentDidCatch === 'function') {
	    update.callback = function callback() {
	      if (typeof getDerivedStateFromError !== 'function') {
	        // To preserve the preexisting retry behavior of error boundaries,
	        // we keep track of which ones already failed during this batch.
	        // This gets reset before we yield back to the browser.
	        // TODO: Warn in strict mode if getDerivedStateFromError is
	        // not defined.
	        markLegacyErrorBoundaryAsFailed(this);
	      }
	      var error = errorInfo.value;
	      var stack = errorInfo.stack;
	      logError(fiber, errorInfo);
	      this.componentDidCatch(error, {
	        componentStack: stack !== null ? stack : ''
	      });
	      {
	        if (typeof getDerivedStateFromError !== 'function') {
	          // If componentDidCatch is the only error boundary method defined,
	          // then it needs to call setState to recover from errors.
	          // If no state update is scheduled then the boundary will swallow the error.
	          !(fiber.expirationTime === Sync) ? warningWithoutStack$1(false, '%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentName(fiber.type) || 'Unknown') : void 0;
	        }
	      }
	    };
	  }
	  return update;
	}

	function attachPingListener(root, renderExpirationTime, thenable) {
	  // Attach a listener to the promise to "ping" the root and retry. But
	  // only if one does not already exist for the current render expiration
	  // time (which acts like a "thread ID" here).
	  var pingCache = root.pingCache;
	  var threadIDs = void 0;
	  if (pingCache === null) {
	    pingCache = root.pingCache = new PossiblyWeakMap();
	    threadIDs = new Set();
	    pingCache.set(thenable, threadIDs);
	  } else {
	    threadIDs = pingCache.get(thenable);
	    if (threadIDs === undefined) {
	      threadIDs = new Set();
	      pingCache.set(thenable, threadIDs);
	    }
	  }
	  if (!threadIDs.has(renderExpirationTime)) {
	    // Memoize using the thread ID to prevent redundant listeners.
	    threadIDs.add(renderExpirationTime);
	    var ping = pingSuspendedRoot.bind(null, root, thenable, renderExpirationTime);
	    {
	      ping = tracing$1.unstable_wrap(ping);
	    }
	    thenable.then(ping, ping);
	  }
	}

	function throwException(root, returnFiber, sourceFiber, value, renderExpirationTime) {
	  // The source fiber did not complete.
	  sourceFiber.effectTag |= Incomplete;
	  // Its effect list is no longer valid.
	  sourceFiber.firstEffect = sourceFiber.lastEffect = null;

	  if (value !== null && typeof value === 'object' && typeof value.then === 'function') {
	    // This is a thenable.
	    var thenable = value;

	    // Find the earliest timeout threshold of all the placeholders in the
	    // ancestor path. We could avoid this traversal by storing the thresholds on
	    // the stack, but we choose not to because we only hit this path if we're
	    // IO-bound (i.e. if something suspends). Whereas the stack is used even in
	    // the non-IO- bound case.
	    var _workInProgress = returnFiber;
	    var earliestTimeoutMs = -1;
	    var startTimeMs = -1;
	    do {
	      if (_workInProgress.tag === SuspenseComponent) {
	        var current$$1 = _workInProgress.alternate;
	        if (current$$1 !== null) {
	          var currentState = current$$1.memoizedState;
	          if (currentState !== null) {
	            // Reached a boundary that already timed out. Do not search
	            // any further.
	            var timedOutAt = currentState.timedOutAt;
	            startTimeMs = expirationTimeToMs(timedOutAt);
	            // Do not search any further.
	            break;
	          }
	        }
	        var timeoutPropMs = _workInProgress.pendingProps.maxDuration;
	        if (typeof timeoutPropMs === 'number') {
	          if (timeoutPropMs <= 0) {
	            earliestTimeoutMs = 0;
	          } else if (earliestTimeoutMs === -1 || timeoutPropMs < earliestTimeoutMs) {
	            earliestTimeoutMs = timeoutPropMs;
	          }
	        }
	      }
	      // If there is a DehydratedSuspenseComponent we don't have to do anything because
	      // if something suspends inside it, we will simply leave that as dehydrated. It
	      // will never timeout.
	      _workInProgress = _workInProgress.return;
	    } while (_workInProgress !== null);

	    // Schedule the nearest Suspense to re-render the timed out view.
	    _workInProgress = returnFiber;
	    do {
	      if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress)) {
	        // Found the nearest boundary.

	        // Stash the promise on the boundary fiber. If the boundary times out, we'll
	        var thenables = _workInProgress.updateQueue;
	        if (thenables === null) {
	          var updateQueue = new Set();
	          updateQueue.add(thenable);
	          _workInProgress.updateQueue = updateQueue;
	        } else {
	          thenables.add(thenable);
	        }

	        // If the boundary is outside of concurrent mode, we should *not*
	        // suspend the commit. Pretend as if the suspended component rendered
	        // null and keep rendering. In the commit phase, we'll schedule a
	        // subsequent synchronous update to re-render the Suspense.
	        //
	        // Note: It doesn't matter whether the component that suspended was
	        // inside a concurrent mode tree. If the Suspense is outside of it, we
	        // should *not* suspend the commit.
	        if ((_workInProgress.mode & ConcurrentMode) === NoEffect) {
	          _workInProgress.effectTag |= DidCapture;

	          // We're going to commit this fiber even though it didn't complete.
	          // But we shouldn't call any lifecycle methods or callbacks. Remove
	          // all lifecycle effect tags.
	          sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);

	          if (sourceFiber.tag === ClassComponent) {
	            var currentSourceFiber = sourceFiber.alternate;
	            if (currentSourceFiber === null) {
	              // This is a new mount. Change the tag so it's not mistaken for a
	              // completed class component. For example, we should not call
	              // componentWillUnmount if it is deleted.
	              sourceFiber.tag = IncompleteClassComponent;
	            } else {
	              // When we try rendering again, we should not reuse the current fiber,
	              // since it's known to be in an inconsistent state. Use a force updte to
	              // prevent a bail out.
	              var update = createUpdate(Sync);
	              update.tag = ForceUpdate;
	              enqueueUpdate(sourceFiber, update);
	            }
	          }

	          // The source fiber did not complete. Mark it with Sync priority to
	          // indicate that it still has pending work.
	          sourceFiber.expirationTime = Sync;

	          // Exit without suspending.
	          return;
	        }

	        // Confirmed that the boundary is in a concurrent mode tree. Continue
	        // with the normal suspend path.

	        attachPingListener(root, renderExpirationTime, thenable);

	        var absoluteTimeoutMs = void 0;
	        if (earliestTimeoutMs === -1) {
	          // If no explicit threshold is given, default to an arbitrarily large
	          // value. The actual size doesn't matter because the threshold for the
	          // whole tree will be clamped to the expiration time.
	          absoluteTimeoutMs = maxSigned31BitInt;
	        } else {
	          if (startTimeMs === -1) {
	            // This suspend happened outside of any already timed-out
	            // placeholders. We don't know exactly when the update was
	            // scheduled, but we can infer an approximate start time from the
	            // expiration time. First, find the earliest uncommitted expiration
	            // time in the tree, including work that is suspended. Then subtract
	            // the offset used to compute an async update's expiration time.
	            // This will cause high priority (interactive) work to expire
	            // earlier than necessary, but we can account for this by adjusting
	            // for the Just Noticeable Difference.
	            var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, renderExpirationTime);
	            var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);
	            startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
	          }
	          absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
	        }

	        // Mark the earliest timeout in the suspended fiber's ancestor path.
	        // After completing the root, we'll take the largest of all the
	        // suspended fiber's timeouts and use it to compute a timeout for the
	        // whole tree.
	        renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);

	        _workInProgress.effectTag |= ShouldCapture;
	        _workInProgress.expirationTime = renderExpirationTime;
	        return;
	      }
	      // This boundary already captured during this render. Continue to the next
	      // boundary.
	      _workInProgress = _workInProgress.return;
	    } while (_workInProgress !== null);
	    // No boundary was found. Fallthrough to error mode.
	    // TODO: Use invariant so the message is stripped in prod?
	    value = new Error((getComponentName(sourceFiber.type) || 'A React component') + ' suspended while rendering, but no fallback UI was specified.\n' + '\n' + 'Add a <Suspense fallback=...> component higher in the tree to ' + 'provide a loading indicator or placeholder to display.' + getStackByFiberInDevAndProd(sourceFiber));
	  }

	  // We didn't find a boundary that could handle this type of exception. Start
	  // over and traverse parent path again, this time treating the exception
	  // as an error.
	  renderDidError();
	  value = createCapturedValue(value, sourceFiber);
	  var workInProgress = returnFiber;
	  do {
	    switch (workInProgress.tag) {
	      case HostRoot:
	        {
	          var _errorInfo = value;
	          workInProgress.effectTag |= ShouldCapture;
	          workInProgress.expirationTime = renderExpirationTime;
	          var _update = createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime);
	          enqueueCapturedUpdate(workInProgress, _update);
	          return;
	        }
	      case ClassComponent:
	        // Capture and retry
	        var errorInfo = value;
	        var ctor = workInProgress.type;
	        var instance = workInProgress.stateNode;
	        if ((workInProgress.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {
	          workInProgress.effectTag |= ShouldCapture;
	          workInProgress.expirationTime = renderExpirationTime;
	          // Schedule the error boundary to re-render using updated state
	          var _update2 = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);
	          enqueueCapturedUpdate(workInProgress, _update2);
	          return;
	        }
	        break;
	      default:
	        break;
	    }
	    workInProgress = workInProgress.return;
	  } while (workInProgress !== null);
	}

	function unwindWork(workInProgress, renderExpirationTime) {
	  switch (workInProgress.tag) {
	    case ClassComponent:
	      {
	        var Component = workInProgress.type;
	        if (isContextProvider(Component)) {
	          popContext(workInProgress);
	        }
	        var effectTag = workInProgress.effectTag;
	        if (effectTag & ShouldCapture) {
	          workInProgress.effectTag = effectTag & ~ShouldCapture | DidCapture;
	          return workInProgress;
	        }
	        return null;
	      }
	    case HostRoot:
	      {
	        popHostContainer(workInProgress);
	        popTopLevelContextObject(workInProgress);
	        var _effectTag = workInProgress.effectTag;
	        !((_effectTag & DidCapture) === NoEffect) ? invariant(false, 'The root failed to unmount after an error. This is likely a bug in React. Please file an issue.') : void 0;
	        workInProgress.effectTag = _effectTag & ~ShouldCapture | DidCapture;
	        return workInProgress;
	      }
	    case HostComponent:
	      {
	        // TODO: popHydrationState
	        popHostContext(workInProgress);
	        return null;
	      }
	    case SuspenseComponent:
	      {
	        var _effectTag2 = workInProgress.effectTag;
	        if (_effectTag2 & ShouldCapture) {
	          workInProgress.effectTag = _effectTag2 & ~ShouldCapture | DidCapture;
	          // Captured a suspense effect. Re-render the boundary.
	          return workInProgress;
	        }
	        return null;
	      }
	    case DehydratedSuspenseComponent:
	      {
	        return null;
	      }
	    case HostPortal:
	      popHostContainer(workInProgress);
	      return null;
	    case ContextProvider:
	      popProvider(workInProgress);
	      return null;
	    default:
	      return null;
	  }
	}

	function unwindInterruptedWork(interruptedWork) {
	  switch (interruptedWork.tag) {
	    case ClassComponent:
	      {
	        var childContextTypes = interruptedWork.type.childContextTypes;
	        if (childContextTypes !== null && childContextTypes !== undefined) {
	          popContext(interruptedWork);
	        }
	        break;
	      }
	    case HostRoot:
	      {
	        popHostContainer(interruptedWork);
	        popTopLevelContextObject(interruptedWork);
	        break;
	      }
	    case HostComponent:
	      {
	        popHostContext(interruptedWork);
	        break;
	      }
	    case HostPortal:
	      popHostContainer(interruptedWork);
	      break;
	    case ContextProvider:
	      popProvider(interruptedWork);
	      break;
	    default:
	      break;
	  }
	}

	var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
	var ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;


	var didWarnAboutStateTransition = void 0;
	var didWarnSetStateChildContext = void 0;
	var warnAboutUpdateOnUnmounted = void 0;
	var warnAboutInvalidUpdates = void 0;

	{
	  // Provide explicit error message when production+profiling bundle of e.g. react-dom
	  // is used with production (non-profiling) bundle of scheduler/tracing
	  !(tracing$1.__interactionsRef != null && tracing$1.__interactionsRef.current != null) ? invariant(false, 'It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling') : void 0;
	}

	{
	  didWarnAboutStateTransition = false;
	  didWarnSetStateChildContext = false;
	  var didWarnStateUpdateForUnmountedComponent = {};

	  warnAboutUpdateOnUnmounted = function (fiber, isClass) {
	    // We show the whole stack but dedupe on the top component's name because
	    // the problematic code almost always lies inside that component.
	    var componentName = getComponentName(fiber.type) || 'ReactComponent';
	    if (didWarnStateUpdateForUnmountedComponent[componentName]) {
	      return;
	    }
	    warningWithoutStack$1(false, "Can't perform a React state update on an unmounted component. This " + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in %s.%s', isClass ? 'the componentWillUnmount method' : 'a useEffect cleanup function', getStackByFiberInDevAndProd(fiber));
	    didWarnStateUpdateForUnmountedComponent[componentName] = true;
	  };

	  warnAboutInvalidUpdates = function (instance) {
	    switch (phase) {
	      case 'getChildContext':
	        if (didWarnSetStateChildContext) {
	          return;
	        }
	        warningWithoutStack$1(false, 'setState(...): Cannot call setState() inside getChildContext()');
	        didWarnSetStateChildContext = true;
	        break;
	      case 'render':
	        if (didWarnAboutStateTransition) {
	          return;
	        }
	        warningWithoutStack$1(false, 'Cannot update during an existing state transition (such as within ' + '`render`). Render methods should be a pure function of props and state.');
	        didWarnAboutStateTransition = true;
	        break;
	    }
	  };
	}

	// Used to ensure computeUniqueAsyncExpiration is monotonically decreasing.
	var lastUniqueAsyncExpiration = Sync - 1;

	var isWorking = false;

	// The next work in progress fiber that we're currently working on.
	var nextUnitOfWork = null;
	var nextRoot = null;
	// The time at which we're currently rendering work.
	var nextRenderExpirationTime = NoWork;
	var nextLatestAbsoluteTimeoutMs = -1;
	var nextRenderDidError = false;

	// The next fiber with an effect that we're currently committing.
	var nextEffect = null;

	var isCommitting$1 = false;
	var rootWithPendingPassiveEffects = null;
	var passiveEffectCallbackHandle = null;
	var passiveEffectCallback = null;

	var legacyErrorBoundariesThatAlreadyFailed = null;

	// Used for performance tracking.
	var interruptedBy = null;

	var stashedWorkInProgressProperties = void 0;
	var replayUnitOfWork = void 0;
	var mayReplayFailedUnitOfWork = void 0;
	var isReplayingFailedUnitOfWork = void 0;
	var originalReplayError = void 0;
	var rethrowOriginalError = void 0;
	{
	  stashedWorkInProgressProperties = null;
	  mayReplayFailedUnitOfWork = true;
	  isReplayingFailedUnitOfWork = false;
	  originalReplayError = null;
	  replayUnitOfWork = function (failedUnitOfWork, thrownValue, isYieldy) {
	    if (thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function') {
	      // Don't replay promises. Treat everything else like an error.
	      // TODO: Need to figure out a different strategy if/when we add
	      // support for catching other types.
	      return;
	    }

	    // Restore the original state of the work-in-progress
	    if (stashedWorkInProgressProperties === null) {
	      // This should never happen. Don't throw because this code is DEV-only.
	      warningWithoutStack$1(false, 'Could not replay rendering after an error. This is likely a bug in React. ' + 'Please file an issue.');
	      return;
	    }
	    assignFiberPropertiesInDEV(failedUnitOfWork, stashedWorkInProgressProperties);

	    switch (failedUnitOfWork.tag) {
	      case HostRoot:
	        popHostContainer(failedUnitOfWork);
	        popTopLevelContextObject(failedUnitOfWork);
	        break;
	      case HostComponent:
	        popHostContext(failedUnitOfWork);
	        break;
	      case ClassComponent:
	        {
	          var Component = failedUnitOfWork.type;
	          if (isContextProvider(Component)) {
	            popContext(failedUnitOfWork);
	          }
	          break;
	        }
	      case HostPortal:
	        popHostContainer(failedUnitOfWork);
	        break;
	      case ContextProvider:
	        popProvider(failedUnitOfWork);
	        break;
	    }
	    // Replay the begin phase.
	    isReplayingFailedUnitOfWork = true;
	    originalReplayError = thrownValue;
	    invokeGuardedCallback(null, workLoop, null, isYieldy);
	    isReplayingFailedUnitOfWork = false;
	    originalReplayError = null;
	    if (hasCaughtError()) {
	      var replayError = clearCaughtError();
	      if (replayError != null && thrownValue != null) {
	        try {
	          // Reading the expando property is intentionally
	          // inside `try` because it might be a getter or Proxy.
	          if (replayError._suppressLogging) {
	            // Also suppress logging for the original error.
	            thrownValue._suppressLogging = true;
	          }
	        } catch (inner) {
	          // Ignore.
	        }
	      }
	    } else {
	      // If the begin phase did not fail the second time, set this pointer
	      // back to the original value.
	      nextUnitOfWork = failedUnitOfWork;
	    }
	  };
	  rethrowOriginalError = function () {
	    throw originalReplayError;
	  };
	}

	function resetStack() {
	  if (nextUnitOfWork !== null) {
	    var interruptedWork = nextUnitOfWork.return;
	    while (interruptedWork !== null) {
	      unwindInterruptedWork(interruptedWork);
	      interruptedWork = interruptedWork.return;
	    }
	  }

	  {
	    ReactStrictModeWarnings.discardPendingWarnings();
	    checkThatStackIsEmpty();
	  }

	  nextRoot = null;
	  nextRenderExpirationTime = NoWork;
	  nextLatestAbsoluteTimeoutMs = -1;
	  nextRenderDidError = false;
	  nextUnitOfWork = null;
	}

	function commitAllHostEffects() {
	  while (nextEffect !== null) {
	    {
	      setCurrentFiber(nextEffect);
	    }
	    recordEffect();

	    var effectTag = nextEffect.effectTag;

	    if (effectTag & ContentReset) {
	      commitResetTextContent(nextEffect);
	    }

	    if (effectTag & Ref) {
	      var current$$1 = nextEffect.alternate;
	      if (current$$1 !== null) {
	        commitDetachRef(current$$1);
	      }
	    }

	    // The following switch statement is only concerned about placement,
	    // updates, and deletions. To avoid needing to add a case for every
	    // possible bitmap value, we remove the secondary effects from the
	    // effect tag and switch on that value.
	    var primaryEffectTag = effectTag & (Placement | Update | Deletion);
	    switch (primaryEffectTag) {
	      case Placement:
	        {
	          commitPlacement(nextEffect);
	          // Clear the "placement" from effect tag so that we know that this is inserted, before
	          // any life-cycles like componentDidMount gets called.
	          // TODO: findDOMNode doesn't rely on this any more but isMounted
	          // does and isMounted is deprecated anyway so we should be able
	          // to kill this.
	          nextEffect.effectTag &= ~Placement;
	          break;
	        }
	      case PlacementAndUpdate:
	        {
	          // Placement
	          commitPlacement(nextEffect);
	          // Clear the "placement" from effect tag so that we know that this is inserted, before
	          // any life-cycles like componentDidMount gets called.
	          nextEffect.effectTag &= ~Placement;

	          // Update
	          var _current = nextEffect.alternate;
	          commitWork(_current, nextEffect);
	          break;
	        }
	      case Update:
	        {
	          var _current2 = nextEffect.alternate;
	          commitWork(_current2, nextEffect);
	          break;
	        }
	      case Deletion:
	        {
	          commitDeletion(nextEffect);
	          break;
	        }
	    }
	    nextEffect = nextEffect.nextEffect;
	  }

	  {
	    resetCurrentFiber();
	  }
	}

	function commitBeforeMutationLifecycles() {
	  while (nextEffect !== null) {
	    {
	      setCurrentFiber(nextEffect);
	    }

	    var effectTag = nextEffect.effectTag;
	    if (effectTag & Snapshot) {
	      recordEffect();
	      var current$$1 = nextEffect.alternate;
	      commitBeforeMutationLifeCycles(current$$1, nextEffect);
	    }

	    nextEffect = nextEffect.nextEffect;
	  }

	  {
	    resetCurrentFiber();
	  }
	}

	function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
	  {
	    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
	    ReactStrictModeWarnings.flushLegacyContextWarning();
	  }
	  while (nextEffect !== null) {
	    {
	      setCurrentFiber(nextEffect);
	    }
	    var effectTag = nextEffect.effectTag;

	    if (effectTag & (Update | Callback)) {
	      recordEffect();
	      var current$$1 = nextEffect.alternate;
	      commitLifeCycles(finishedRoot, current$$1, nextEffect, committedExpirationTime);
	    }

	    if (effectTag & Ref) {
	      recordEffect();
	      commitAttachRef(nextEffect);
	    }

	    if (effectTag & Passive) {
	      rootWithPendingPassiveEffects = finishedRoot;
	    }

	    nextEffect = nextEffect.nextEffect;
	  }
	  {
	    resetCurrentFiber();
	  }
	}

	function commitPassiveEffects(root, firstEffect) {
	  rootWithPendingPassiveEffects = null;
	  passiveEffectCallbackHandle = null;
	  passiveEffectCallback = null;

	  // Set this to true to prevent re-entrancy
	  var previousIsRendering = isRendering;
	  isRendering = true;

	  var effect = firstEffect;
	  do {
	    {
	      setCurrentFiber(effect);
	    }

	    if (effect.effectTag & Passive) {
	      var didError = false;
	      var error = void 0;
	      {
	        invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);
	        if (hasCaughtError()) {
	          didError = true;
	          error = clearCaughtError();
	        }
	      }
	      if (didError) {
	        captureCommitPhaseError(effect, error);
	      }
	    }
	    effect = effect.nextEffect;
	  } while (effect !== null);
	  {
	    resetCurrentFiber();
	  }

	  isRendering = previousIsRendering;

	  // Check if work was scheduled by one of the effects
	  var rootExpirationTime = root.expirationTime;
	  if (rootExpirationTime !== NoWork) {
	    requestWork(root, rootExpirationTime);
	  }
	  // Flush any sync work that was scheduled by effects
	  if (!isBatchingUpdates && !isRendering) {
	    performSyncWork();
	  }
	}

	function isAlreadyFailedLegacyErrorBoundary(instance) {
	  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
	}

	function markLegacyErrorBoundaryAsFailed(instance) {
	  if (legacyErrorBoundariesThatAlreadyFailed === null) {
	    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
	  } else {
	    legacyErrorBoundariesThatAlreadyFailed.add(instance);
	  }
	}

	function flushPassiveEffects() {
	  if (passiveEffectCallbackHandle !== null) {
	    cancelPassiveEffects(passiveEffectCallbackHandle);
	  }
	  if (passiveEffectCallback !== null) {
	    // We call the scheduled callback instead of commitPassiveEffects directly
	    // to ensure tracing works correctly.
	    passiveEffectCallback();
	  }
	}

	function commitRoot(root, finishedWork) {
	  isWorking = true;
	  isCommitting$1 = true;
	  startCommitTimer();

	  !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	  var committedExpirationTime = root.pendingCommitExpirationTime;
	  !(committedExpirationTime !== NoWork) ? invariant(false, 'Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	  root.pendingCommitExpirationTime = NoWork;

	  // Update the pending priority levels to account for the work that we are
	  // about to commit. This needs to happen before calling the lifecycles, since
	  // they may schedule additional updates.
	  var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;
	  var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
	  var earliestRemainingTimeBeforeCommit = childExpirationTimeBeforeCommit > updateExpirationTimeBeforeCommit ? childExpirationTimeBeforeCommit : updateExpirationTimeBeforeCommit;
	  markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);

	  var prevInteractions = null;
	  {
	    // Restore any pending interactions at this point,
	    // So that cascading work triggered during the render phase will be accounted for.
	    prevInteractions = tracing$1.__interactionsRef.current;
	    tracing$1.__interactionsRef.current = root.memoizedInteractions;
	  }

	  // Reset this to null before calling lifecycles
	  ReactCurrentOwner$2.current = null;

	  var firstEffect = void 0;
	  if (finishedWork.effectTag > PerformedWork) {
	    // A fiber's effect list consists only of its children, not itself. So if
	    // the root has an effect, we need to add it to the end of the list. The
	    // resulting list is the set that would belong to the root's parent, if
	    // it had one; that is, all the effects in the tree including the root.
	    if (finishedWork.lastEffect !== null) {
	      finishedWork.lastEffect.nextEffect = finishedWork;
	      firstEffect = finishedWork.firstEffect;
	    } else {
	      firstEffect = finishedWork;
	    }
	  } else {
	    // There is no effect on the root.
	    firstEffect = finishedWork.firstEffect;
	  }

	  prepareForCommit(root.containerInfo);

	  // Invoke instances of getSnapshotBeforeUpdate before mutation.
	  nextEffect = firstEffect;
	  startCommitSnapshotEffectsTimer();
	  while (nextEffect !== null) {
	    var didError = false;
	    var error = void 0;
	    {
	      invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);
	      if (hasCaughtError()) {
	        didError = true;
	        error = clearCaughtError();
	      }
	    }
	    if (didError) {
	      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	      captureCommitPhaseError(nextEffect, error);
	      // Clean-up
	      if (nextEffect !== null) {
	        nextEffect = nextEffect.nextEffect;
	      }
	    }
	  }
	  stopCommitSnapshotEffectsTimer();

	  {
	    // Mark the current commit time to be shared by all Profilers in this batch.
	    // This enables them to be grouped later.
	    recordCommitTime();
	  }

	  // Commit all the side-effects within a tree. We'll do this in two passes.
	  // The first pass performs all the host insertions, updates, deletions and
	  // ref unmounts.
	  nextEffect = firstEffect;
	  startCommitHostEffectsTimer();
	  while (nextEffect !== null) {
	    var _didError = false;
	    var _error = void 0;
	    {
	      invokeGuardedCallback(null, commitAllHostEffects, null);
	      if (hasCaughtError()) {
	        _didError = true;
	        _error = clearCaughtError();
	      }
	    }
	    if (_didError) {
	      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	      captureCommitPhaseError(nextEffect, _error);
	      // Clean-up
	      if (nextEffect !== null) {
	        nextEffect = nextEffect.nextEffect;
	      }
	    }
	  }
	  stopCommitHostEffectsTimer();

	  resetAfterCommit(root.containerInfo);

	  // The work-in-progress tree is now the current tree. This must come after
	  // the first pass of the commit phase, so that the previous tree is still
	  // current during componentWillUnmount, but before the second pass, so that
	  // the finished work is current during componentDidMount/Update.
	  root.current = finishedWork;

	  // In the second pass we'll perform all life-cycles and ref callbacks.
	  // Life-cycles happen as a separate pass so that all placements, updates,
	  // and deletions in the entire tree have already been invoked.
	  // This pass also triggers any renderer-specific initial effects.
	  nextEffect = firstEffect;
	  startCommitLifeCyclesTimer();
	  while (nextEffect !== null) {
	    var _didError2 = false;
	    var _error2 = void 0;
	    {
	      invokeGuardedCallback(null, commitAllLifeCycles, null, root, committedExpirationTime);
	      if (hasCaughtError()) {
	        _didError2 = true;
	        _error2 = clearCaughtError();
	      }
	    }
	    if (_didError2) {
	      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	      captureCommitPhaseError(nextEffect, _error2);
	      if (nextEffect !== null) {
	        nextEffect = nextEffect.nextEffect;
	      }
	    }
	  }

	  if (firstEffect !== null && rootWithPendingPassiveEffects !== null) {
	    // This commit included a passive effect. These do not need to fire until
	    // after the next paint. Schedule an callback to fire them in an async
	    // event. To ensure serial execution, the callback will be flushed early if
	    // we enter rootWithPendingPassiveEffects commit phase before then.
	    var callback = commitPassiveEffects.bind(null, root, firstEffect);
	    {
	      // TODO: Avoid this extra callback by mutating the tracing ref directly,
	      // like we do at the beginning of commitRoot. I've opted not to do that
	      // here because that code is still in flux.
	      callback = tracing$1.unstable_wrap(callback);
	    }
	    passiveEffectCallbackHandle = scheduler$1.unstable_runWithPriority(scheduler$1.unstable_NormalPriority, function () {
	      return schedulePassiveEffects(callback);
	    });
	    passiveEffectCallback = callback;
	  }

	  isCommitting$1 = false;
	  isWorking = false;
	  stopCommitLifeCyclesTimer();
	  stopCommitTimer();
	  onCommitRoot(finishedWork.stateNode);

	  var updateExpirationTimeAfterCommit = finishedWork.expirationTime;
	  var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;
	  var earliestRemainingTimeAfterCommit = childExpirationTimeAfterCommit > updateExpirationTimeAfterCommit ? childExpirationTimeAfterCommit : updateExpirationTimeAfterCommit;
	  if (earliestRemainingTimeAfterCommit === NoWork) {
	    // If there's no remaining work, we can clear the set of already failed
	    // error boundaries.
	    legacyErrorBoundariesThatAlreadyFailed = null;
	  }
	  onCommit(root, earliestRemainingTimeAfterCommit);

	  {
	    tracing$1.__interactionsRef.current = prevInteractions;

	    var subscriber = void 0;

	    try {
	      subscriber = tracing$1.__subscriberRef.current;
	      if (subscriber !== null && root.memoizedInteractions.size > 0) {
	        var threadID = computeThreadID(committedExpirationTime, root.interactionThreadID);
	        subscriber.onWorkStopped(root.memoizedInteractions, threadID);
	      }
	    } catch (error) {
	      // It's not safe for commitRoot() to throw.
	      // Store the error for now and we'll re-throw in finishRendering().
	      if (!hasUnhandledError) {
	        hasUnhandledError = true;
	        unhandledError = error;
	      }
	    } finally {
	      // Clear completed interactions from the pending Map.
	      // Unless the render was suspended or cascading work was scheduled,
	      // In which case– leave pending interactions until the subsequent render.
	      var pendingInteractionMap = root.pendingInteractionMap;
	      pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
	        // Only decrement the pending interaction count if we're done.
	        // If there's still work at the current priority,
	        // That indicates that we are waiting for suspense data.
	        if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {
	          pendingInteractionMap.delete(scheduledExpirationTime);

	          scheduledInteractions.forEach(function (interaction) {
	            interaction.__count--;

	            if (subscriber !== null && interaction.__count === 0) {
	              try {
	                subscriber.onInteractionScheduledWorkCompleted(interaction);
	              } catch (error) {
	                // It's not safe for commitRoot() to throw.
	                // Store the error for now and we'll re-throw in finishRendering().
	                if (!hasUnhandledError) {
	                  hasUnhandledError = true;
	                  unhandledError = error;
	                }
	              }
	            }
	          });
	        }
	      });
	    }
	  }
	}

	function resetChildExpirationTime(workInProgress, renderTime) {
	  if (renderTime !== Never && workInProgress.childExpirationTime === Never) {
	    // The children of this component are hidden. Don't bubble their
	    // expiration times.
	    return;
	  }

	  var newChildExpirationTime = NoWork;

	  // Bubble up the earliest expiration time.
	  if (workInProgress.mode & ProfileMode) {
	    // We're in profiling mode.
	    // Let's use this same traversal to update the render durations.
	    var actualDuration = workInProgress.actualDuration;
	    var treeBaseDuration = workInProgress.selfBaseDuration;

	    // When a fiber is cloned, its actualDuration is reset to 0.
	    // This value will only be updated if work is done on the fiber (i.e. it doesn't bailout).
	    // When work is done, it should bubble to the parent's actualDuration.
	    // If the fiber has not been cloned though, (meaning no work was done),
	    // Then this value will reflect the amount of time spent working on a previous render.
	    // In that case it should not bubble.
	    // We determine whether it was cloned by comparing the child pointer.
	    var shouldBubbleActualDurations = workInProgress.alternate === null || workInProgress.child !== workInProgress.alternate.child;

	    var child = workInProgress.child;
	    while (child !== null) {
	      var childUpdateExpirationTime = child.expirationTime;
	      var childChildExpirationTime = child.childExpirationTime;
	      if (childUpdateExpirationTime > newChildExpirationTime) {
	        newChildExpirationTime = childUpdateExpirationTime;
	      }
	      if (childChildExpirationTime > newChildExpirationTime) {
	        newChildExpirationTime = childChildExpirationTime;
	      }
	      if (shouldBubbleActualDurations) {
	        actualDuration += child.actualDuration;
	      }
	      treeBaseDuration += child.treeBaseDuration;
	      child = child.sibling;
	    }
	    workInProgress.actualDuration = actualDuration;
	    workInProgress.treeBaseDuration = treeBaseDuration;
	  } else {
	    var _child = workInProgress.child;
	    while (_child !== null) {
	      var _childUpdateExpirationTime = _child.expirationTime;
	      var _childChildExpirationTime = _child.childExpirationTime;
	      if (_childUpdateExpirationTime > newChildExpirationTime) {
	        newChildExpirationTime = _childUpdateExpirationTime;
	      }
	      if (_childChildExpirationTime > newChildExpirationTime) {
	        newChildExpirationTime = _childChildExpirationTime;
	      }
	      _child = _child.sibling;
	    }
	  }

	  workInProgress.childExpirationTime = newChildExpirationTime;
	}

	function completeUnitOfWork(workInProgress) {
	  // Attempt to complete the current unit of work, then move to the
	  // next sibling. If there are no more siblings, return to the
	  // parent fiber.
	  while (true) {
	    // The current, flushed, state of this fiber is the alternate.
	    // Ideally nothing should rely on this, but relying on it here
	    // means that we don't need an additional field on the work in
	    // progress.
	    var current$$1 = workInProgress.alternate;
	    {
	      setCurrentFiber(workInProgress);
	    }

	    var returnFiber = workInProgress.return;
	    var siblingFiber = workInProgress.sibling;

	    if ((workInProgress.effectTag & Incomplete) === NoEffect) {
	      {
	        // Don't replay if it fails during completion phase.
	        mayReplayFailedUnitOfWork = false;
	      }
	      // This fiber completed.
	      // Remember we're completing this unit so we can find a boundary if it fails.
	      nextUnitOfWork = workInProgress;
	      {
	        if (workInProgress.mode & ProfileMode) {
	          startProfilerTimer(workInProgress);
	        }
	        nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);
	        if (workInProgress.mode & ProfileMode) {
	          // Update render duration assuming we didn't error.
	          stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
	        }
	      }
	      {
	        // We're out of completion phase so replaying is fine now.
	        mayReplayFailedUnitOfWork = true;
	      }
	      stopWorkTimer(workInProgress);
	      resetChildExpirationTime(workInProgress, nextRenderExpirationTime);
	      {
	        resetCurrentFiber();
	      }

	      if (nextUnitOfWork !== null) {
	        // Completing this fiber spawned new work. Work on that next.
	        return nextUnitOfWork;
	      }

	      if (returnFiber !== null &&
	      // Do not append effects to parents if a sibling failed to complete
	      (returnFiber.effectTag & Incomplete) === NoEffect) {
	        // Append all the effects of the subtree and this fiber onto the effect
	        // list of the parent. The completion order of the children affects the
	        // side-effect order.
	        if (returnFiber.firstEffect === null) {
	          returnFiber.firstEffect = workInProgress.firstEffect;
	        }
	        if (workInProgress.lastEffect !== null) {
	          if (returnFiber.lastEffect !== null) {
	            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
	          }
	          returnFiber.lastEffect = workInProgress.lastEffect;
	        }

	        // If this fiber had side-effects, we append it AFTER the children's
	        // side-effects. We can perform certain side-effects earlier if
	        // needed, by doing multiple passes over the effect list. We don't want
	        // to schedule our own side-effect on our own list because if end up
	        // reusing children we'll schedule this effect onto itself since we're
	        // at the end.
	        var effectTag = workInProgress.effectTag;
	        // Skip both NoWork and PerformedWork tags when creating the effect list.
	        // PerformedWork effect is read by React DevTools but shouldn't be committed.
	        if (effectTag > PerformedWork) {
	          if (returnFiber.lastEffect !== null) {
	            returnFiber.lastEffect.nextEffect = workInProgress;
	          } else {
	            returnFiber.firstEffect = workInProgress;
	          }
	          returnFiber.lastEffect = workInProgress;
	        }
	      }

	      if (siblingFiber !== null) {
	        // If there is more work to do in this returnFiber, do that next.
	        return siblingFiber;
	      } else if (returnFiber !== null) {
	        // If there's no more work in this returnFiber. Complete the returnFiber.
	        workInProgress = returnFiber;
	        continue;
	      } else {
	        // We've reached the root.
	        return null;
	      }
	    } else {
	      if (workInProgress.mode & ProfileMode) {
	        // Record the render duration for the fiber that errored.
	        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);

	        // Include the time spent working on failed children before continuing.
	        var actualDuration = workInProgress.actualDuration;
	        var child = workInProgress.child;
	        while (child !== null) {
	          actualDuration += child.actualDuration;
	          child = child.sibling;
	        }
	        workInProgress.actualDuration = actualDuration;
	      }

	      // This fiber did not complete because something threw. Pop values off
	      // the stack without entering the complete phase. If this is a boundary,
	      // capture values if possible.
	      var next = unwindWork(workInProgress, nextRenderExpirationTime);
	      // Because this fiber did not complete, don't reset its expiration time.
	      if (workInProgress.effectTag & DidCapture) {
	        // Restarting an error boundary
	        stopFailedWorkTimer(workInProgress);
	      } else {
	        stopWorkTimer(workInProgress);
	      }

	      {
	        resetCurrentFiber();
	      }

	      if (next !== null) {
	        stopWorkTimer(workInProgress);

	        // If completing this work spawned new work, do that next. We'll come
	        // back here again.
	        // Since we're restarting, remove anything that is not a host effect
	        // from the effect tag.
	        next.effectTag &= HostEffectMask;
	        return next;
	      }

	      if (returnFiber !== null) {
	        // Mark the parent fiber as incomplete and clear its effect list.
	        returnFiber.firstEffect = returnFiber.lastEffect = null;
	        returnFiber.effectTag |= Incomplete;
	      }

	      if (siblingFiber !== null) {
	        // If there is more work to do in this returnFiber, do that next.
	        return siblingFiber;
	      } else if (returnFiber !== null) {
	        // If there's no more work in this returnFiber. Complete the returnFiber.
	        workInProgress = returnFiber;
	        continue;
	      } else {
	        return null;
	      }
	    }
	  }

	  // Without this explicit null return Flow complains of invalid return type
	  // TODO Remove the above while(true) loop
	  // eslint-disable-next-line no-unreachable
	  return null;
	}

	function performUnitOfWork(workInProgress) {
	  // The current, flushed, state of this fiber is the alternate.
	  // Ideally nothing should rely on this, but relying on it here
	  // means that we don't need an additional field on the work in
	  // progress.
	  var current$$1 = workInProgress.alternate;

	  // See if beginning this work spawns more work.
	  startWorkTimer(workInProgress);
	  {
	    setCurrentFiber(workInProgress);
	  }

	  {
	    stashedWorkInProgressProperties = assignFiberPropertiesInDEV(stashedWorkInProgressProperties, workInProgress);
	  }

	  var next = void 0;
	  {
	    if (workInProgress.mode & ProfileMode) {
	      startProfilerTimer(workInProgress);
	    }

	    next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
	    workInProgress.memoizedProps = workInProgress.pendingProps;

	    if (workInProgress.mode & ProfileMode) {
	      // Record the render duration assuming we didn't bailout (or error).
	      stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
	    }
	  }

	  {
	    resetCurrentFiber();
	    if (isReplayingFailedUnitOfWork) {
	      // Currently replaying a failed unit of work. This should be unreachable,
	      // because the render phase is meant to be idempotent, and it should
	      // have thrown again. Since it didn't, rethrow the original error, so
	      // React's internal stack is not misaligned.
	      rethrowOriginalError();
	    }
	  }

	  if (next === null) {
	    // If this doesn't spawn new work, complete the current work.
	    next = completeUnitOfWork(workInProgress);
	  }

	  ReactCurrentOwner$2.current = null;

	  return next;
	}

	function workLoop(isYieldy) {
	  if (!isYieldy) {
	    // Flush work without yielding
	    while (nextUnitOfWork !== null) {
	      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
	    }
	  } else {
	    // Flush asynchronous work until there's a higher priority event
	    while (nextUnitOfWork !== null && !shouldYieldToRenderer()) {
	      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
	    }
	  }
	}

	function renderRoot(root, isYieldy) {
	  !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;

	  flushPassiveEffects();

	  isWorking = true;
	  var previousDispatcher = ReactCurrentDispatcher.current;
	  ReactCurrentDispatcher.current = ContextOnlyDispatcher;

	  var expirationTime = root.nextExpirationTimeToWorkOn;

	  // Check if we're starting from a fresh stack, or if we're resuming from
	  // previously yielded work.
	  if (expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null) {
	    // Reset the stack and start working from the root.
	    resetStack();
	    nextRoot = root;
	    nextRenderExpirationTime = expirationTime;
	    nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime);
	    root.pendingCommitExpirationTime = NoWork;

	    {
	      // Determine which interactions this batch of work currently includes,
	      // So that we can accurately attribute time spent working on it,
	      var interactions = new Set();
	      root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
	        if (scheduledExpirationTime >= expirationTime) {
	          scheduledInteractions.forEach(function (interaction) {
	            return interactions.add(interaction);
	          });
	        }
	      });

	      // Store the current set of interactions on the FiberRoot for a few reasons:
	      // We can re-use it in hot functions like renderRoot() without having to recalculate it.
	      // We will also use it in commitWork() to pass to any Profiler onRender() hooks.
	      // This also provides DevTools with a way to access it when the onCommitRoot() hook is called.
	      root.memoizedInteractions = interactions;

	      if (interactions.size > 0) {
	        var subscriber = tracing$1.__subscriberRef.current;
	        if (subscriber !== null) {
	          var threadID = computeThreadID(expirationTime, root.interactionThreadID);
	          try {
	            subscriber.onWorkStarted(interactions, threadID);
	          } catch (error) {
	            // Work thrown by an interaction tracing subscriber should be rethrown,
	            // But only once it's safe (to avoid leaving the scheduler in an invalid state).
	            // Store the error for now and we'll re-throw in finishRendering().
	            if (!hasUnhandledError) {
	              hasUnhandledError = true;
	              unhandledError = error;
	            }
	          }
	        }
	      }
	    }
	  }

	  var prevInteractions = null;
	  {
	    // We're about to start new traced work.
	    // Restore pending interactions so cascading work triggered during the render phase will be accounted for.
	    prevInteractions = tracing$1.__interactionsRef.current;
	    tracing$1.__interactionsRef.current = root.memoizedInteractions;
	  }

	  var didFatal = false;

	  startWorkLoopTimer(nextUnitOfWork);

	  do {
	    try {
	      workLoop(isYieldy);
	    } catch (thrownValue) {
	      resetContextDependences();
	      resetHooks();

	      // Reset in case completion throws.
	      // This is only used in DEV and when replaying is on.
	      var mayReplay = void 0;
	      {
	        mayReplay = mayReplayFailedUnitOfWork;
	        mayReplayFailedUnitOfWork = true;
	      }

	      if (nextUnitOfWork === null) {
	        // This is a fatal error.
	        didFatal = true;
	        onUncaughtError(thrownValue);
	      } else {
	        if (nextUnitOfWork.mode & ProfileMode) {
	          // Record the time spent rendering before an error was thrown.
	          // This avoids inaccurate Profiler durations in the case of a suspended render.
	          stopProfilerTimerIfRunningAndRecordDelta(nextUnitOfWork, true);
	        }

	        {
	          // Reset global debug state
	          // We assume this is defined in DEV
	          resetCurrentlyProcessingQueue();
	        }

	        {
	          if (mayReplay) {
	            var failedUnitOfWork = nextUnitOfWork;
	            replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);
	          }
	        }

	        // TODO: we already know this isn't true in some cases.
	        // At least this shows a nicer error message until we figure out the cause.
	        // https://github.com/facebook/react/issues/12449#issuecomment-386727431
	        !(nextUnitOfWork !== null) ? invariant(false, 'Failed to replay rendering after an error. This is likely caused by a bug in React. Please file an issue with a reproducing case to help us find it.') : void 0;

	        var sourceFiber = nextUnitOfWork;
	        var returnFiber = sourceFiber.return;
	        if (returnFiber === null) {
	          // This is the root. The root could capture its own errors. However,
	          // we don't know if it errors before or after we pushed the host
	          // context. This information is needed to avoid a stack mismatch.
	          // Because we're not sure, treat this as a fatal error. We could track
	          // which phase it fails in, but doesn't seem worth it. At least
	          // for now.
	          didFatal = true;
	          onUncaughtError(thrownValue);
	        } else {
	          throwException(root, returnFiber, sourceFiber, thrownValue, nextRenderExpirationTime);
	          nextUnitOfWork = completeUnitOfWork(sourceFiber);
	          continue;
	        }
	      }
	    }
	    break;
	  } while (true);

	  {
	    // Traced work is done for now; restore the previous interactions.
	    tracing$1.__interactionsRef.current = prevInteractions;
	  }

	  // We're done performing work. Time to clean up.
	  isWorking = false;
	  ReactCurrentDispatcher.current = previousDispatcher;
	  resetContextDependences();
	  resetHooks();

	  // Yield back to main thread.
	  if (didFatal) {
	    var _didCompleteRoot = false;
	    stopWorkLoopTimer(interruptedBy, _didCompleteRoot);
	    interruptedBy = null;
	    // There was a fatal error.
	    {
	      resetStackAfterFatalErrorInDev();
	    }
	    // `nextRoot` points to the in-progress root. A non-null value indicates
	    // that we're in the middle of an async render. Set it to null to indicate
	    // there's no more work to be done in the current batch.
	    nextRoot = null;
	    onFatal(root);
	    return;
	  }

	  if (nextUnitOfWork !== null) {
	    // There's still remaining async work in this tree, but we ran out of time
	    // in the current frame. Yield back to the renderer. Unless we're
	    // interrupted by a higher priority update, we'll continue later from where
	    // we left off.
	    var _didCompleteRoot2 = false;
	    stopWorkLoopTimer(interruptedBy, _didCompleteRoot2);
	    interruptedBy = null;
	    onYield(root);
	    return;
	  }

	  // We completed the whole tree.
	  var didCompleteRoot = true;
	  stopWorkLoopTimer(interruptedBy, didCompleteRoot);
	  var rootWorkInProgress = root.current.alternate;
	  !(rootWorkInProgress !== null) ? invariant(false, 'Finished root should have a work-in-progress. This error is likely caused by a bug in React. Please file an issue.') : void 0;

	  // `nextRoot` points to the in-progress root. A non-null value indicates
	  // that we're in the middle of an async render. Set it to null to indicate
	  // there's no more work to be done in the current batch.
	  nextRoot = null;
	  interruptedBy = null;

	  if (nextRenderDidError) {
	    // There was an error
	    if (hasLowerPriorityWork(root, expirationTime)) {
	      // There's lower priority work. If so, it may have the effect of fixing
	      // the exception that was just thrown. Exit without committing. This is
	      // similar to a suspend, but without a timeout because we're not waiting
	      // for a promise to resolve. React will restart at the lower
	      // priority level.
	      markSuspendedPriorityLevel(root, expirationTime);
	      var suspendedExpirationTime = expirationTime;
	      var rootExpirationTime = root.expirationTime;
	      onSuspend(root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1 // Indicates no timeout
	      );
	      return;
	    } else if (
	    // There's no lower priority work, but we're rendering asynchronously.
	    // Synchronously attempt to render the same level one more time. This is
	    // similar to a suspend, but without a timeout because we're not waiting
	    // for a promise to resolve.
	    !root.didError && isYieldy) {
	      root.didError = true;
	      var _suspendedExpirationTime = root.nextExpirationTimeToWorkOn = expirationTime;
	      var _rootExpirationTime = root.expirationTime = Sync;
	      onSuspend(root, rootWorkInProgress, _suspendedExpirationTime, _rootExpirationTime, -1 // Indicates no timeout
	      );
	      return;
	    }
	  }

	  if (isYieldy && nextLatestAbsoluteTimeoutMs !== -1) {
	    // The tree was suspended.
	    var _suspendedExpirationTime2 = expirationTime;
	    markSuspendedPriorityLevel(root, _suspendedExpirationTime2);

	    // Find the earliest uncommitted expiration time in the tree, including
	    // work that is suspended. The timeout threshold cannot be longer than
	    // the overall expiration.
	    var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, expirationTime);
	    var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);
	    if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {
	      nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;
	    }

	    // Subtract the current time from the absolute timeout to get the number
	    // of milliseconds until the timeout. In other words, convert an absolute
	    // timestamp to a relative time. This is the value that is passed
	    // to `setTimeout`.
	    var currentTimeMs = expirationTimeToMs(requestCurrentTime());
	    var msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;
	    msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;

	    // TODO: Account for the Just Noticeable Difference

	    var _rootExpirationTime2 = root.expirationTime;
	    onSuspend(root, rootWorkInProgress, _suspendedExpirationTime2, _rootExpirationTime2, msUntilTimeout);
	    return;
	  }

	  // Ready to commit.
	  onComplete(root, rootWorkInProgress, expirationTime);
	}

	function captureCommitPhaseError(sourceFiber, value) {
	  var expirationTime = Sync;
	  var fiber = sourceFiber.return;
	  while (fiber !== null) {
	    switch (fiber.tag) {
	      case ClassComponent:
	        var ctor = fiber.type;
	        var instance = fiber.stateNode;
	        if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
	          var errorInfo = createCapturedValue(value, sourceFiber);
	          var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);
	          enqueueUpdate(fiber, update);
	          scheduleWork(fiber, expirationTime);
	          return;
	        }
	        break;
	      case HostRoot:
	        {
	          var _errorInfo = createCapturedValue(value, sourceFiber);
	          var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);
	          enqueueUpdate(fiber, _update);
	          scheduleWork(fiber, expirationTime);
	          return;
	        }
	    }
	    fiber = fiber.return;
	  }

	  if (sourceFiber.tag === HostRoot) {
	    // Error was thrown at the root. There is no parent, so the root
	    // itself should capture it.
	    var rootFiber = sourceFiber;
	    var _errorInfo2 = createCapturedValue(value, rootFiber);
	    var _update2 = createRootErrorUpdate(rootFiber, _errorInfo2, expirationTime);
	    enqueueUpdate(rootFiber, _update2);
	    scheduleWork(rootFiber, expirationTime);
	  }
	}

	function computeThreadID(expirationTime, interactionThreadID) {
	  // Interaction threads are unique per root and expiration time.
	  return expirationTime * 1000 + interactionThreadID;
	}

	// Creates a unique async expiration time.
	function computeUniqueAsyncExpiration() {
	  var currentTime = requestCurrentTime();
	  var result = computeAsyncExpiration(currentTime);
	  if (result >= lastUniqueAsyncExpiration) {
	    // Since we assume the current time monotonically increases, we only hit
	    // this branch when computeUniqueAsyncExpiration is fired multiple times
	    // within a 200ms window (or whatever the async bucket size is).
	    result = lastUniqueAsyncExpiration - 1;
	  }
	  lastUniqueAsyncExpiration = result;
	  return lastUniqueAsyncExpiration;
	}

	function computeExpirationForFiber(currentTime, fiber) {
	  var priorityLevel = scheduler$1.unstable_getCurrentPriorityLevel();

	  var expirationTime = void 0;
	  if ((fiber.mode & ConcurrentMode) === NoContext) {
	    // Outside of concurrent mode, updates are always synchronous.
	    expirationTime = Sync;
	  } else if (isWorking && !isCommitting$1) {
	    // During render phase, updates expire during as the current render.
	    expirationTime = nextRenderExpirationTime;
	  } else {
	    switch (priorityLevel) {
	      case scheduler$1.unstable_ImmediatePriority:
	        expirationTime = Sync;
	        break;
	      case scheduler$1.unstable_UserBlockingPriority:
	        expirationTime = computeInteractiveExpiration(currentTime);
	        break;
	      case scheduler$1.unstable_NormalPriority:
	        // This is a normal, concurrent update
	        expirationTime = computeAsyncExpiration(currentTime);
	        break;
	      case scheduler$1.unstable_LowPriority:
	      case scheduler$1.unstable_IdlePriority:
	        expirationTime = Never;
	        break;
	      default:
	        invariant(false, 'Unknown priority level. This error is likely caused by a bug in React. Please file an issue.');
	    }

	    // If we're in the middle of rendering a tree, do not update at the same
	    // expiration time that is already rendering.
	    if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {
	      expirationTime -= 1;
	    }
	  }

	  // Keep track of the lowest pending interactive expiration time. This
	  // allows us to synchronously flush all interactive updates
	  // when needed.
	  // TODO: Move this to renderer?
	  if (priorityLevel === scheduler$1.unstable_UserBlockingPriority && (lowestPriorityPendingInteractiveExpirationTime === NoWork || expirationTime < lowestPriorityPendingInteractiveExpirationTime)) {
	    lowestPriorityPendingInteractiveExpirationTime = expirationTime;
	  }

	  return expirationTime;
	}

	function renderDidSuspend(root, absoluteTimeoutMs, suspendedTime) {
	  // Schedule the timeout.
	  if (absoluteTimeoutMs >= 0 && nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs) {
	    nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;
	  }
	}

	function renderDidError() {
	  nextRenderDidError = true;
	}

	function pingSuspendedRoot(root, thenable, pingTime) {
	  // A promise that previously suspended React from committing has resolved.
	  // If React is still suspended, try again at the previous level (pingTime).

	  var pingCache = root.pingCache;
	  if (pingCache !== null) {
	    // The thenable resolved, so we no longer need to memoize, because it will
	    // never be thrown again.
	    pingCache.delete(thenable);
	  }

	  if (nextRoot !== null && nextRenderExpirationTime === pingTime) {
	    // Received a ping at the same priority level at which we're currently
	    // rendering. Restart from the root.
	    nextRoot = null;
	  } else {
	    // Confirm that the root is still suspended at this level. Otherwise exit.
	    if (isPriorityLevelSuspended(root, pingTime)) {
	      // Ping at the original level
	      markPingedPriorityLevel(root, pingTime);
	      var rootExpirationTime = root.expirationTime;
	      if (rootExpirationTime !== NoWork) {
	        requestWork(root, rootExpirationTime);
	      }
	    }
	  }
	}

	function retryTimedOutBoundary(boundaryFiber, thenable) {
	  // The boundary fiber (a Suspense component) previously timed out and was
	  // rendered in its fallback state. One of the promises that suspended it has
	  // resolved, which means at least part of the tree was likely unblocked. Try
	  var retryCache = void 0;
	  {
	    retryCache = boundaryFiber.stateNode;
	  }
	  if (retryCache !== null) {
	    // The thenable resolved, so we no longer need to memoize, because it will
	    // never be thrown again.
	    retryCache.delete(thenable);
	  }

	  var currentTime = requestCurrentTime();
	  var retryTime = computeExpirationForFiber(currentTime, boundaryFiber);
	  var root = scheduleWorkToRoot(boundaryFiber, retryTime);
	  if (root !== null) {
	    markPendingPriorityLevel(root, retryTime);
	    var rootExpirationTime = root.expirationTime;
	    if (rootExpirationTime !== NoWork) {
	      requestWork(root, rootExpirationTime);
	    }
	  }
	}

	function scheduleWorkToRoot(fiber, expirationTime) {
	  recordScheduleUpdate();

	  {
	    if (fiber.tag === ClassComponent) {
	      var instance = fiber.stateNode;
	      warnAboutInvalidUpdates(instance);
	    }
	  }

	  // Update the source fiber's expiration time
	  if (fiber.expirationTime < expirationTime) {
	    fiber.expirationTime = expirationTime;
	  }
	  var alternate = fiber.alternate;
	  if (alternate !== null && alternate.expirationTime < expirationTime) {
	    alternate.expirationTime = expirationTime;
	  }
	  // Walk the parent path to the root and update the child expiration time.
	  var node = fiber.return;
	  var root = null;
	  if (node === null && fiber.tag === HostRoot) {
	    root = fiber.stateNode;
	  } else {
	    while (node !== null) {
	      alternate = node.alternate;
	      if (node.childExpirationTime < expirationTime) {
	        node.childExpirationTime = expirationTime;
	        if (alternate !== null && alternate.childExpirationTime < expirationTime) {
	          alternate.childExpirationTime = expirationTime;
	        }
	      } else if (alternate !== null && alternate.childExpirationTime < expirationTime) {
	        alternate.childExpirationTime = expirationTime;
	      }
	      if (node.return === null && node.tag === HostRoot) {
	        root = node.stateNode;
	        break;
	      }
	      node = node.return;
	    }
	  }

	  {
	    if (root !== null) {
	      var interactions = tracing$1.__interactionsRef.current;
	      if (interactions.size > 0) {
	        var pendingInteractionMap = root.pendingInteractionMap;
	        var pendingInteractions = pendingInteractionMap.get(expirationTime);
	        if (pendingInteractions != null) {
	          interactions.forEach(function (interaction) {
	            if (!pendingInteractions.has(interaction)) {
	              // Update the pending async work count for previously unscheduled interaction.
	              interaction.__count++;
	            }

	            pendingInteractions.add(interaction);
	          });
	        } else {
	          pendingInteractionMap.set(expirationTime, new Set(interactions));

	          // Update the pending async work count for the current interactions.
	          interactions.forEach(function (interaction) {
	            interaction.__count++;
	          });
	        }

	        var subscriber = tracing$1.__subscriberRef.current;
	        if (subscriber !== null) {
	          var threadID = computeThreadID(expirationTime, root.interactionThreadID);
	          subscriber.onWorkScheduled(interactions, threadID);
	        }
	      }
	    }
	  }
	  return root;
	}

	function warnIfNotCurrentlyBatchingInDev(fiber) {
	  {
	    if (isRendering === false && isBatchingUpdates === false) {
	      warningWithoutStack$1(false, 'An update to %s inside a test was not wrapped in act(...).\n\n' + 'When testing, code that causes React state updates should be wrapped into act(...):\n\n' + 'act(() => {\n' + '  /* fire events that update state */\n' + '});\n' + '/* assert on the output */\n\n' + "This ensures that you're testing the behavior the user would see in the browser." + ' Learn more at https://fb.me/react-wrap-tests-with-act' + '%s', getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));
	    }
	  }
	}

	function scheduleWork(fiber, expirationTime) {
	  var root = scheduleWorkToRoot(fiber, expirationTime);
	  if (root === null) {
	    {
	      switch (fiber.tag) {
	        case ClassComponent:
	          warnAboutUpdateOnUnmounted(fiber, true);
	          break;
	        case FunctionComponent:
	        case ForwardRef:
	        case MemoComponent:
	        case SimpleMemoComponent:
	          warnAboutUpdateOnUnmounted(fiber, false);
	          break;
	      }
	    }
	    return;
	  }

	  if (!isWorking && nextRenderExpirationTime !== NoWork && expirationTime > nextRenderExpirationTime) {
	    // This is an interruption. (Used for performance tracking.)
	    interruptedBy = fiber;
	    resetStack();
	  }
	  markPendingPriorityLevel(root, expirationTime);
	  if (
	  // If we're in the render phase, we don't need to schedule this root
	  // for an update, because we'll do it before we exit...
	  !isWorking || isCommitting$1 ||
	  // ...unless this is a different root than the one we're rendering.
	  nextRoot !== root) {
	    var rootExpirationTime = root.expirationTime;
	    requestWork(root, rootExpirationTime);
	  }
	  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
	    // Reset this back to zero so subsequent updates don't throw.
	    nestedUpdateCount = 0;
	    invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');
	  }
	}

	function syncUpdates(fn, a, b, c, d) {
	  return scheduler$1.unstable_runWithPriority(scheduler$1.unstable_ImmediatePriority, function () {
	    return fn(a, b, c, d);
	  });
	}

	// TODO: Everything below this is written as if it has been lifted to the
	// renderers. I'll do this in a follow-up.

	// Linked-list of roots
	var firstScheduledRoot = null;
	var lastScheduledRoot = null;

	var callbackExpirationTime = NoWork;
	var callbackID = void 0;
	var isRendering = false;
	var nextFlushedRoot = null;
	var nextFlushedExpirationTime = NoWork;
	var lowestPriorityPendingInteractiveExpirationTime = NoWork;
	var hasUnhandledError = false;
	var unhandledError = null;

	var isBatchingUpdates = false;
	var isUnbatchingUpdates = false;

	var completedBatches = null;

	var originalStartTimeMs = scheduler$1.unstable_now();
	var currentRendererTime = msToExpirationTime(originalStartTimeMs);
	var currentSchedulerTime = currentRendererTime;

	// Use these to prevent an infinite loop of nested updates
	var NESTED_UPDATE_LIMIT = 50;
	var nestedUpdateCount = 0;
	var lastCommittedRootDuringThisBatch = null;

	function recomputeCurrentRendererTime() {
	  var currentTimeMs = scheduler$1.unstable_now() - originalStartTimeMs;
	  currentRendererTime = msToExpirationTime(currentTimeMs);
	}

	function scheduleCallbackWithExpirationTime(root, expirationTime) {
	  if (callbackExpirationTime !== NoWork) {
	    // A callback is already scheduled. Check its expiration time (timeout).
	    if (expirationTime < callbackExpirationTime) {
	      // Existing callback has sufficient timeout. Exit.
	      return;
	    } else {
	      if (callbackID !== null) {
	        // Existing callback has insufficient timeout. Cancel and schedule a
	        // new one.
	        scheduler$1.unstable_cancelCallback(callbackID);
	      }
	    }
	    // The request callback timer is already running. Don't start a new one.
	  } else {
	    startRequestCallbackTimer();
	  }

	  callbackExpirationTime = expirationTime;
	  var currentMs = scheduler$1.unstable_now() - originalStartTimeMs;
	  var expirationTimeMs = expirationTimeToMs(expirationTime);
	  var timeout = expirationTimeMs - currentMs;
	  callbackID = scheduler$1.unstable_scheduleCallback(performAsyncWork, { timeout: timeout });
	}

	// For every call to renderRoot, one of onFatal, onComplete, onSuspend, and
	// onYield is called upon exiting. We use these in lieu of returning a tuple.
	// I've also chosen not to inline them into renderRoot because these will
	// eventually be lifted into the renderer.
	function onFatal(root) {
	  root.finishedWork = null;
	}

	function onComplete(root, finishedWork, expirationTime) {
	  root.pendingCommitExpirationTime = expirationTime;
	  root.finishedWork = finishedWork;
	}

	function onSuspend(root, finishedWork, suspendedExpirationTime, rootExpirationTime, msUntilTimeout) {
	  root.expirationTime = rootExpirationTime;
	  if (msUntilTimeout === 0 && !shouldYieldToRenderer()) {
	    // Don't wait an additional tick. Commit the tree immediately.
	    root.pendingCommitExpirationTime = suspendedExpirationTime;
	    root.finishedWork = finishedWork;
	  } else if (msUntilTimeout > 0) {
	    // Wait `msUntilTimeout` milliseconds before committing.
	    root.timeoutHandle = scheduleTimeout(onTimeout.bind(null, root, finishedWork, suspendedExpirationTime), msUntilTimeout);
	  }
	}

	function onYield(root) {
	  root.finishedWork = null;
	}

	function onTimeout(root, finishedWork, suspendedExpirationTime) {
	  // The root timed out. Commit it.
	  root.pendingCommitExpirationTime = suspendedExpirationTime;
	  root.finishedWork = finishedWork;
	  // Read the current time before entering the commit phase. We can be
	  // certain this won't cause tearing related to batching of event updates
	  // because we're at the top of a timer event.
	  recomputeCurrentRendererTime();
	  currentSchedulerTime = currentRendererTime;
	  flushRoot(root, suspendedExpirationTime);
	}

	function onCommit(root, expirationTime) {
	  root.expirationTime = expirationTime;
	  root.finishedWork = null;
	}

	function requestCurrentTime() {
	  // requestCurrentTime is called by the scheduler to compute an expiration
	  // time.
	  //
	  // Expiration times are computed by adding to the current time (the start
	  // time). However, if two updates are scheduled within the same event, we
	  // should treat their start times as simultaneous, even if the actual clock
	  // time has advanced between the first and second call.

	  // In other words, because expiration times determine how updates are batched,
	  // we want all updates of like priority that occur within the same event to
	  // receive the same expiration time. Otherwise we get tearing.
	  //
	  // We keep track of two separate times: the current "renderer" time and the
	  // current "scheduler" time. The renderer time can be updated whenever; it
	  // only exists to minimize the calls performance.now.
	  //
	  // But the scheduler time can only be updated if there's no pending work, or
	  // if we know for certain that we're not in the middle of an event.

	  if (isRendering) {
	    // We're already rendering. Return the most recently read time.
	    return currentSchedulerTime;
	  }
	  // Check if there's pending work.
	  findHighestPriorityRoot();
	  if (nextFlushedExpirationTime === NoWork || nextFlushedExpirationTime === Never) {
	    // If there's no pending work, or if the pending work is offscreen, we can
	    // read the current time without risk of tearing.
	    recomputeCurrentRendererTime();
	    currentSchedulerTime = currentRendererTime;
	    return currentSchedulerTime;
	  }
	  // There's already pending work. We might be in the middle of a browser
	  // event. If we were to read the current time, it could cause multiple updates
	  // within the same event to receive different expiration times, leading to
	  // tearing. Return the last read time. During the next idle callback, the
	  // time will be updated.
	  return currentSchedulerTime;
	}

	// requestWork is called by the scheduler whenever a root receives an update.
	// It's up to the renderer to call renderRoot at some point in the future.
	function requestWork(root, expirationTime) {
	  addRootToSchedule(root, expirationTime);
	  if (isRendering) {
	    // Prevent reentrancy. Remaining work will be scheduled at the end of
	    // the currently rendering batch.
	    return;
	  }

	  if (isBatchingUpdates) {
	    // Flush work at the end of the batch.
	    if (isUnbatchingUpdates) {
	      // ...unless we're inside unbatchedUpdates, in which case we should
	      // flush it now.
	      nextFlushedRoot = root;
	      nextFlushedExpirationTime = Sync;
	      performWorkOnRoot(root, Sync, false);
	    }
	    return;
	  }

	  // TODO: Get rid of Sync and use current time?
	  if (expirationTime === Sync) {
	    performSyncWork();
	  } else {
	    scheduleCallbackWithExpirationTime(root, expirationTime);
	  }
	}

	function addRootToSchedule(root, expirationTime) {
	  // Add the root to the schedule.
	  // Check if this root is already part of the schedule.
	  if (root.nextScheduledRoot === null) {
	    // This root is not already scheduled. Add it.
	    root.expirationTime = expirationTime;
	    if (lastScheduledRoot === null) {
	      firstScheduledRoot = lastScheduledRoot = root;
	      root.nextScheduledRoot = root;
	    } else {
	      lastScheduledRoot.nextScheduledRoot = root;
	      lastScheduledRoot = root;
	      lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
	    }
	  } else {
	    // This root is already scheduled, but its priority may have increased.
	    var remainingExpirationTime = root.expirationTime;
	    if (expirationTime > remainingExpirationTime) {
	      // Update the priority.
	      root.expirationTime = expirationTime;
	    }
	  }
	}

	function findHighestPriorityRoot() {
	  var highestPriorityWork = NoWork;
	  var highestPriorityRoot = null;
	  if (lastScheduledRoot !== null) {
	    var previousScheduledRoot = lastScheduledRoot;
	    var root = firstScheduledRoot;
	    while (root !== null) {
	      var remainingExpirationTime = root.expirationTime;
	      if (remainingExpirationTime === NoWork) {
	        // This root no longer has work. Remove it from the scheduler.

	        // TODO: This check is redudant, but Flow is confused by the branch
	        // below where we set lastScheduledRoot to null, even though we break
	        // from the loop right after.
	        !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	        if (root === root.nextScheduledRoot) {
	          // This is the only root in the list.
	          root.nextScheduledRoot = null;
	          firstScheduledRoot = lastScheduledRoot = null;
	          break;
	        } else if (root === firstScheduledRoot) {
	          // This is the first root in the list.
	          var next = root.nextScheduledRoot;
	          firstScheduledRoot = next;
	          lastScheduledRoot.nextScheduledRoot = next;
	          root.nextScheduledRoot = null;
	        } else if (root === lastScheduledRoot) {
	          // This is the last root in the list.
	          lastScheduledRoot = previousScheduledRoot;
	          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
	          root.nextScheduledRoot = null;
	          break;
	        } else {
	          previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
	          root.nextScheduledRoot = null;
	        }
	        root = previousScheduledRoot.nextScheduledRoot;
	      } else {
	        if (remainingExpirationTime > highestPriorityWork) {
	          // Update the priority, if it's higher
	          highestPriorityWork = remainingExpirationTime;
	          highestPriorityRoot = root;
	        }
	        if (root === lastScheduledRoot) {
	          break;
	        }
	        if (highestPriorityWork === Sync) {
	          // Sync is highest priority by definition so
	          // we can stop searching.
	          break;
	        }
	        previousScheduledRoot = root;
	        root = root.nextScheduledRoot;
	      }
	    }
	  }

	  nextFlushedRoot = highestPriorityRoot;
	  nextFlushedExpirationTime = highestPriorityWork;
	}

	// TODO: This wrapper exists because many of the older tests (the ones that use
	// flushDeferredPri) rely on the number of times `shouldYield` is called. We
	// should get rid of it.
	var didYield = false;
	function shouldYieldToRenderer() {
	  if (didYield) {
	    return true;
	  }
	  if (scheduler$1.unstable_shouldYield()) {
	    didYield = true;
	    return true;
	  }
	  return false;
	}

	function performAsyncWork() {
	  try {
	    if (!shouldYieldToRenderer()) {
	      // The callback timed out. That means at least one update has expired.
	      // Iterate through the root schedule. If they contain expired work, set
	      // the next render expiration time to the current time. This has the effect
	      // of flushing all expired work in a single batch, instead of flushing each
	      // level one at a time.
	      if (firstScheduledRoot !== null) {
	        recomputeCurrentRendererTime();
	        var root = firstScheduledRoot;
	        do {
	          didExpireAtExpirationTime(root, currentRendererTime);
	          // The root schedule is circular, so this is never null.
	          root = root.nextScheduledRoot;
	        } while (root !== firstScheduledRoot);
	      }
	    }
	    performWork(NoWork, true);
	  } finally {
	    didYield = false;
	  }
	}

	function performSyncWork() {
	  performWork(Sync, false);
	}

	function performWork(minExpirationTime, isYieldy) {
	  // Keep working on roots until there's no more work, or until there's a higher
	  // priority event.
	  findHighestPriorityRoot();

	  if (isYieldy) {
	    recomputeCurrentRendererTime();
	    currentSchedulerTime = currentRendererTime;

	    {
	      var didExpire = nextFlushedExpirationTime > currentRendererTime;
	      var timeout = expirationTimeToMs(nextFlushedExpirationTime);
	      stopRequestCallbackTimer(didExpire, timeout);
	    }

	    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && minExpirationTime <= nextFlushedExpirationTime && !(didYield && currentRendererTime > nextFlushedExpirationTime)) {
	      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime > nextFlushedExpirationTime);
	      findHighestPriorityRoot();
	      recomputeCurrentRendererTime();
	      currentSchedulerTime = currentRendererTime;
	    }
	  } else {
	    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && minExpirationTime <= nextFlushedExpirationTime) {
	      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
	      findHighestPriorityRoot();
	    }
	  }

	  // We're done flushing work. Either we ran out of time in this callback,
	  // or there's no more work left with sufficient priority.

	  // If we're inside a callback, set this to false since we just completed it.
	  if (isYieldy) {
	    callbackExpirationTime = NoWork;
	    callbackID = null;
	  }
	  // If there's work left over, schedule a new callback.
	  if (nextFlushedExpirationTime !== NoWork) {
	    scheduleCallbackWithExpirationTime(nextFlushedRoot, nextFlushedExpirationTime);
	  }

	  // Clean-up.
	  finishRendering();
	}

	function flushRoot(root, expirationTime) {
	  !!isRendering ? invariant(false, 'work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method.') : void 0;
	  // Perform work on root as if the given expiration time is the current time.
	  // This has the effect of synchronously flushing all work up to and
	  // including the given time.
	  nextFlushedRoot = root;
	  nextFlushedExpirationTime = expirationTime;
	  performWorkOnRoot(root, expirationTime, false);
	  // Flush any sync work that was scheduled by lifecycles
	  performSyncWork();
	}

	function finishRendering() {
	  nestedUpdateCount = 0;
	  lastCommittedRootDuringThisBatch = null;

	  if (completedBatches !== null) {
	    var batches = completedBatches;
	    completedBatches = null;
	    for (var i = 0; i < batches.length; i++) {
	      var batch = batches[i];
	      try {
	        batch._onComplete();
	      } catch (error) {
	        if (!hasUnhandledError) {
	          hasUnhandledError = true;
	          unhandledError = error;
	        }
	      }
	    }
	  }

	  if (hasUnhandledError) {
	    var error = unhandledError;
	    unhandledError = null;
	    hasUnhandledError = false;
	    throw error;
	  }
	}

	function performWorkOnRoot(root, expirationTime, isYieldy) {
	  !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;

	  isRendering = true;

	  // Check if this is async work or sync/expired work.
	  if (!isYieldy) {
	    // Flush work without yielding.
	    // TODO: Non-yieldy work does not necessarily imply expired work. A renderer
	    // may want to perform some work without yielding, but also without
	    // requiring the root to complete (by triggering placeholders).

	    var finishedWork = root.finishedWork;
	    if (finishedWork !== null) {
	      // This root is already complete. We can commit it.
	      completeRoot(root, finishedWork, expirationTime);
	    } else {
	      root.finishedWork = null;
	      // If this root previously suspended, clear its existing timeout, since
	      // we're about to try rendering again.
	      var timeoutHandle = root.timeoutHandle;
	      if (timeoutHandle !== noTimeout) {
	        root.timeoutHandle = noTimeout;
	        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
	        cancelTimeout(timeoutHandle);
	      }
	      renderRoot(root, isYieldy);
	      finishedWork = root.finishedWork;
	      if (finishedWork !== null) {
	        // We've completed the root. Commit it.
	        completeRoot(root, finishedWork, expirationTime);
	      }
	    }
	  } else {
	    // Flush async work.
	    var _finishedWork = root.finishedWork;
	    if (_finishedWork !== null) {
	      // This root is already complete. We can commit it.
	      completeRoot(root, _finishedWork, expirationTime);
	    } else {
	      root.finishedWork = null;
	      // If this root previously suspended, clear its existing timeout, since
	      // we're about to try rendering again.
	      var _timeoutHandle = root.timeoutHandle;
	      if (_timeoutHandle !== noTimeout) {
	        root.timeoutHandle = noTimeout;
	        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
	        cancelTimeout(_timeoutHandle);
	      }
	      renderRoot(root, isYieldy);
	      _finishedWork = root.finishedWork;
	      if (_finishedWork !== null) {
	        // We've completed the root. Check the if we should yield one more time
	        // before committing.
	        if (!shouldYieldToRenderer()) {
	          // Still time left. Commit the root.
	          completeRoot(root, _finishedWork, expirationTime);
	        } else {
	          // There's no time left. Mark this root as complete. We'll come
	          // back and commit it later.
	          root.finishedWork = _finishedWork;
	        }
	      }
	    }
	  }

	  isRendering = false;
	}

	function completeRoot(root, finishedWork, expirationTime) {
	  // Check if there's a batch that matches this expiration time.
	  var firstBatch = root.firstBatch;
	  if (firstBatch !== null && firstBatch._expirationTime >= expirationTime) {
	    if (completedBatches === null) {
	      completedBatches = [firstBatch];
	    } else {
	      completedBatches.push(firstBatch);
	    }
	    if (firstBatch._defer) {
	      // This root is blocked from committing by a batch. Unschedule it until
	      // we receive another update.
	      root.finishedWork = finishedWork;
	      root.expirationTime = NoWork;
	      return;
	    }
	  }

	  // Commit the root.
	  root.finishedWork = null;

	  // Check if this is a nested update (a sync update scheduled during the
	  // commit phase).
	  if (root === lastCommittedRootDuringThisBatch) {
	    // If the next root is the same as the previous root, this is a nested
	    // update. To prevent an infinite loop, increment the nested update count.
	    nestedUpdateCount++;
	  } else {
	    // Reset whenever we switch roots.
	    lastCommittedRootDuringThisBatch = root;
	    nestedUpdateCount = 0;
	  }
	  scheduler$1.unstable_runWithPriority(scheduler$1.unstable_ImmediatePriority, function () {
	    commitRoot(root, finishedWork);
	  });
	}

	function onUncaughtError(error) {
	  !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
	  // Unschedule this root so we don't work on it again until there's
	  // another update.
	  nextFlushedRoot.expirationTime = NoWork;
	  if (!hasUnhandledError) {
	    hasUnhandledError = true;
	    unhandledError = error;
	  }
	}

	// TODO: Batching should be implemented at the renderer level, not inside
	// the reconciler.
	function batchedUpdates$1(fn, a) {
	  var previousIsBatchingUpdates = isBatchingUpdates;
	  isBatchingUpdates = true;
	  try {
	    return fn(a);
	  } finally {
	    isBatchingUpdates = previousIsBatchingUpdates;
	    if (!isBatchingUpdates && !isRendering) {
	      performSyncWork();
	    }
	  }
	}

	// TODO: Batching should be implemented at the renderer level, not inside
	// the reconciler.
	function unbatchedUpdates(fn, a) {
	  if (isBatchingUpdates && !isUnbatchingUpdates) {
	    isUnbatchingUpdates = true;
	    try {
	      return fn(a);
	    } finally {
	      isUnbatchingUpdates = false;
	    }
	  }
	  return fn(a);
	}

	// TODO: Batching should be implemented at the renderer level, not within
	// the reconciler.
	function flushSync(fn, a) {
	  !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;
	  var previousIsBatchingUpdates = isBatchingUpdates;
	  isBatchingUpdates = true;
	  try {
	    return syncUpdates(fn, a);
	  } finally {
	    isBatchingUpdates = previousIsBatchingUpdates;
	    performSyncWork();
	  }
	}

	function interactiveUpdates$1(fn, a, b) {
	  // If there are any pending interactive updates, synchronously flush them.
	  // This needs to happen before we read any handlers, because the effect of
	  // the previous event may influence which handlers are called during
	  // this event.
	  if (!isBatchingUpdates && !isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {
	    // Synchronously flush pending interactive updates.
	    performWork(lowestPriorityPendingInteractiveExpirationTime, false);
	    lowestPriorityPendingInteractiveExpirationTime = NoWork;
	  }
	  var previousIsBatchingUpdates = isBatchingUpdates;
	  isBatchingUpdates = true;
	  try {
	    return scheduler$1.unstable_runWithPriority(scheduler$1.unstable_UserBlockingPriority, function () {
	      return fn(a, b);
	    });
	  } finally {
	    isBatchingUpdates = previousIsBatchingUpdates;
	    if (!isBatchingUpdates && !isRendering) {
	      performSyncWork();
	    }
	  }
	}

	function flushInteractiveUpdates$1() {
	  if (!isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {
	    // Synchronously flush pending interactive updates.
	    performWork(lowestPriorityPendingInteractiveExpirationTime, false);
	    lowestPriorityPendingInteractiveExpirationTime = NoWork;
	  }
	}

	function flushControlled(fn) {
	  var previousIsBatchingUpdates = isBatchingUpdates;
	  isBatchingUpdates = true;
	  try {
	    syncUpdates(fn);
	  } finally {
	    isBatchingUpdates = previousIsBatchingUpdates;
	    if (!isBatchingUpdates && !isRendering) {
	      performSyncWork();
	    }
	  }
	}

	// 0 is PROD, 1 is DEV.
	// Might add PROFILE later.


	var didWarnAboutNestedUpdates = void 0;
	var didWarnAboutFindNodeInStrictMode = void 0;

	{
	  didWarnAboutNestedUpdates = false;
	  didWarnAboutFindNodeInStrictMode = {};
	}

	function getContextForSubtree(parentComponent) {
	  if (!parentComponent) {
	    return emptyContextObject;
	  }

	  var fiber = get(parentComponent);
	  var parentContext = findCurrentUnmaskedContext(fiber);

	  if (fiber.tag === ClassComponent) {
	    var Component = fiber.type;
	    if (isContextProvider(Component)) {
	      return processChildContext(fiber, Component, parentContext);
	    }
	  }

	  return parentContext;
	}

	function scheduleRootUpdate(current$$1, element, expirationTime, callback) {
	  {
	    if (phase === 'render' && current !== null && !didWarnAboutNestedUpdates) {
	      didWarnAboutNestedUpdates = true;
	      warningWithoutStack$1(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(current.type) || 'Unknown');
	    }
	  }

	  var update = createUpdate(expirationTime);
	  // Caution: React DevTools currently depends on this property
	  // being called "element".
	  update.payload = { element: element };

	  callback = callback === undefined ? null : callback;
	  if (callback !== null) {
	    !(typeof callback === 'function') ? warningWithoutStack$1(false, 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback) : void 0;
	    update.callback = callback;
	  }

	  flushPassiveEffects();
	  enqueueUpdate(current$$1, update);
	  scheduleWork(current$$1, expirationTime);

	  return expirationTime;
	}

	function updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) {
	  // TODO: If this is a nested container, this won't be the root.
	  var current$$1 = container.current;

	  var context = getContextForSubtree(parentComponent);
	  if (container.context === null) {
	    container.context = context;
	  } else {
	    container.pendingContext = context;
	  }

	  return scheduleRootUpdate(current$$1, element, expirationTime, callback);
	}

	function findHostInstance(component) {
	  var fiber = get(component);
	  if (fiber === undefined) {
	    if (typeof component.render === 'function') {
	      invariant(false, 'Unable to find node on an unmounted component.');
	    } else {
	      invariant(false, 'Argument appears to not be a ReactComponent. Keys: %s', Object.keys(component));
	    }
	  }
	  var hostFiber = findCurrentHostFiber(fiber);
	  if (hostFiber === null) {
	    return null;
	  }
	  return hostFiber.stateNode;
	}

	function findHostInstanceWithWarning(component, methodName) {
	  {
	    var fiber = get(component);
	    if (fiber === undefined) {
	      if (typeof component.render === 'function') {
	        invariant(false, 'Unable to find node on an unmounted component.');
	      } else {
	        invariant(false, 'Argument appears to not be a ReactComponent. Keys: %s', Object.keys(component));
	      }
	    }
	    var hostFiber = findCurrentHostFiber(fiber);
	    if (hostFiber === null) {
	      return null;
	    }
	    if (hostFiber.mode & StrictMode) {
	      var componentName = getComponentName(fiber.type) || 'Component';
	      if (!didWarnAboutFindNodeInStrictMode[componentName]) {
	        didWarnAboutFindNodeInStrictMode[componentName] = true;
	        if (fiber.mode & StrictMode) {
	          warningWithoutStack$1(false, '%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference.' + '\n%s' + '\n\nLearn more about using refs safely here:' + '\nhttps://fb.me/react-strict-mode-find-node', methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));
	        } else {
	          warningWithoutStack$1(false, '%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference.' + '\n%s' + '\n\nLearn more about using refs safely here:' + '\nhttps://fb.me/react-strict-mode-find-node', methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));
	        }
	      }
	    }
	    return hostFiber.stateNode;
	  }
	  return findHostInstance(component);
	}

	function createContainer(containerInfo, isConcurrent, hydrate) {
	  return createFiberRoot(containerInfo, isConcurrent, hydrate);
	}

	function updateContainer(element, container, parentComponent, callback) {
	  var current$$1 = container.current;
	  var currentTime = requestCurrentTime();
	  var expirationTime = computeExpirationForFiber(currentTime, current$$1);
	  return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);
	}

	function getPublicRootInstance(container) {
	  var containerFiber = container.current;
	  if (!containerFiber.child) {
	    return null;
	  }
	  switch (containerFiber.child.tag) {
	    case HostComponent:
	      return getPublicInstance(containerFiber.child.stateNode);
	    default:
	      return containerFiber.child.stateNode;
	  }
	}

	function findHostInstanceWithNoPortals(fiber) {
	  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
	  if (hostFiber === null) {
	    return null;
	  }
	  return hostFiber.stateNode;
	}

	var overrideProps = null;

	{
	  var copyWithSetImpl = function (obj, path, idx, value) {
	    if (idx >= path.length) {
	      return value;
	    }
	    var key = path[idx];
	    var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
	    // $FlowFixMe number or string is fine here
	    updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);
	    return updated;
	  };

	  var copyWithSet = function (obj, path, value) {
	    return copyWithSetImpl(obj, path, 0, value);
	  };

	  // Support DevTools props for function components, forwardRef, memo, host components, etc.
	  overrideProps = function (fiber, path, value) {
	    flushPassiveEffects();
	    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
	    if (fiber.alternate) {
	      fiber.alternate.pendingProps = fiber.pendingProps;
	    }
	    scheduleWork(fiber, Sync);
	  };
	}

	function injectIntoDevTools(devToolsConfig) {
	  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
	  var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;


	  return injectInternals(_assign({}, devToolsConfig, {
	    overrideProps: overrideProps,
	    currentDispatcherRef: ReactCurrentDispatcher,
	    findHostInstanceByFiber: function (fiber) {
	      var hostFiber = findCurrentHostFiber(fiber);
	      if (hostFiber === null) {
	        return null;
	      }
	      return hostFiber.stateNode;
	    },
	    findFiberByHostInstance: function (instance) {
	      if (!findFiberByHostInstance) {
	        // Might not be implemented by the renderer.
	        return null;
	      }
	      return findFiberByHostInstance(instance);
	    }
	  }));
	}

	// This file intentionally does *not* have the Flow annotation.
	// Don't add it. See `./inline-typed.js` for an explanation.

	function createPortal$1(children, containerInfo,
	// TODO: figure out the API for cross-renderer implementation.
	implementation) {
	  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	  return {
	    // This tag allow us to uniquely identify this as a React Portal
	    $$typeof: REACT_PORTAL_TYPE,
	    key: key == null ? null : '' + key,
	    children: children,
	    containerInfo: containerInfo,
	    implementation: implementation
	  };
	}

	// TODO: this is special because it gets imported during build.

	var ReactVersion = '16.8.6';

	// TODO: This type is shared between the reconciler and ReactDOM, but will
	// eventually be lifted out to the renderer.

	var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;

	var topLevelUpdateWarnings = void 0;
	var warnOnInvalidCallback = void 0;
	var didWarnAboutUnstableCreatePortal = false;

	{
	  if (typeof Map !== 'function' ||
	  // $FlowIssue Flow incorrectly thinks Map has no prototype
	  Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' ||
	  // $FlowIssue Flow incorrectly thinks Set has no prototype
	  Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
	    warningWithoutStack$1(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
	  }

	  topLevelUpdateWarnings = function (container) {
	    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
	      var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);
	      if (hostInstance) {
	        !(hostInstance.parentNode === container) ? warningWithoutStack$1(false, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.') : void 0;
	      }
	    }

	    var isRootRenderedBySomeReact = !!container._reactRootContainer;
	    var rootEl = getReactRootElementInContainer(container);
	    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));

	    !(!hasNonRootReactChild || isRootRenderedBySomeReact) ? warningWithoutStack$1(false, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

	    !(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY') ? warningWithoutStack$1(false, 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
	  };

	  warnOnInvalidCallback = function (callback, callerName) {
	    !(callback === null || typeof callback === 'function') ? warningWithoutStack$1(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback) : void 0;
	  };
	}

	setRestoreImplementation(restoreControlledState$1);

	function ReactBatch(root) {
	  var expirationTime = computeUniqueAsyncExpiration();
	  this._expirationTime = expirationTime;
	  this._root = root;
	  this._next = null;
	  this._callbacks = null;
	  this._didComplete = false;
	  this._hasChildren = false;
	  this._children = null;
	  this._defer = true;
	}
	ReactBatch.prototype.render = function (children) {
	  !this._defer ? invariant(false, 'batch.render: Cannot render a batch that already committed.') : void 0;
	  this._hasChildren = true;
	  this._children = children;
	  var internalRoot = this._root._internalRoot;
	  var expirationTime = this._expirationTime;
	  var work = new ReactWork();
	  updateContainerAtExpirationTime(children, internalRoot, null, expirationTime, work._onCommit);
	  return work;
	};
	ReactBatch.prototype.then = function (onComplete) {
	  if (this._didComplete) {
	    onComplete();
	    return;
	  }
	  var callbacks = this._callbacks;
	  if (callbacks === null) {
	    callbacks = this._callbacks = [];
	  }
	  callbacks.push(onComplete);
	};
	ReactBatch.prototype.commit = function () {
	  var internalRoot = this._root._internalRoot;
	  var firstBatch = internalRoot.firstBatch;
	  !(this._defer && firstBatch !== null) ? invariant(false, 'batch.commit: Cannot commit a batch multiple times.') : void 0;

	  if (!this._hasChildren) {
	    // This batch is empty. Return.
	    this._next = null;
	    this._defer = false;
	    return;
	  }

	  var expirationTime = this._expirationTime;

	  // Ensure this is the first batch in the list.
	  if (firstBatch !== this) {
	    // This batch is not the earliest batch. We need to move it to the front.
	    // Update its expiration time to be the expiration time of the earliest
	    // batch, so that we can flush it without flushing the other batches.
	    if (this._hasChildren) {
	      expirationTime = this._expirationTime = firstBatch._expirationTime;
	      // Rendering this batch again ensures its children will be the final state
	      // when we flush (updates are processed in insertion order: last
	      // update wins).
	      // TODO: This forces a restart. Should we print a warning?
	      this.render(this._children);
	    }

	    // Remove the batch from the list.
	    var previous = null;
	    var batch = firstBatch;
	    while (batch !== this) {
	      previous = batch;
	      batch = batch._next;
	    }
	    !(previous !== null) ? invariant(false, 'batch.commit: Cannot commit a batch multiple times.') : void 0;
	    previous._next = batch._next;

	    // Add it to the front.
	    this._next = firstBatch;
	    firstBatch = internalRoot.firstBatch = this;
	  }

	  // Synchronously flush all the work up to this batch's expiration time.
	  this._defer = false;
	  flushRoot(internalRoot, expirationTime);

	  // Pop the batch from the list.
	  var next = this._next;
	  this._next = null;
	  firstBatch = internalRoot.firstBatch = next;

	  // Append the next earliest batch's children to the update queue.
	  if (firstBatch !== null && firstBatch._hasChildren) {
	    firstBatch.render(firstBatch._children);
	  }
	};
	ReactBatch.prototype._onComplete = function () {
	  if (this._didComplete) {
	    return;
	  }
	  this._didComplete = true;
	  var callbacks = this._callbacks;
	  if (callbacks === null) {
	    return;
	  }
	  // TODO: Error handling.
	  for (var i = 0; i < callbacks.length; i++) {
	    var _callback = callbacks[i];
	    _callback();
	  }
	};

	function ReactWork() {
	  this._callbacks = null;
	  this._didCommit = false;
	  // TODO: Avoid need to bind by replacing callbacks in the update queue with
	  // list of Work objects.
	  this._onCommit = this._onCommit.bind(this);
	}
	ReactWork.prototype.then = function (onCommit) {
	  if (this._didCommit) {
	    onCommit();
	    return;
	  }
	  var callbacks = this._callbacks;
	  if (callbacks === null) {
	    callbacks = this._callbacks = [];
	  }
	  callbacks.push(onCommit);
	};
	ReactWork.prototype._onCommit = function () {
	  if (this._didCommit) {
	    return;
	  }
	  this._didCommit = true;
	  var callbacks = this._callbacks;
	  if (callbacks === null) {
	    return;
	  }
	  // TODO: Error handling.
	  for (var i = 0; i < callbacks.length; i++) {
	    var _callback2 = callbacks[i];
	    !(typeof _callback2 === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback2) : void 0;
	    _callback2();
	  }
	};

	function ReactRoot(container, isConcurrent, hydrate) {
	  var root = createContainer(container, isConcurrent, hydrate);
	  this._internalRoot = root;
	}
	ReactRoot.prototype.render = function (children, callback) {
	  var root = this._internalRoot;
	  var work = new ReactWork();
	  callback = callback === undefined ? null : callback;
	  {
	    warnOnInvalidCallback(callback, 'render');
	  }
	  if (callback !== null) {
	    work.then(callback);
	  }
	  updateContainer(children, root, null, work._onCommit);
	  return work;
	};
	ReactRoot.prototype.unmount = function (callback) {
	  var root = this._internalRoot;
	  var work = new ReactWork();
	  callback = callback === undefined ? null : callback;
	  {
	    warnOnInvalidCallback(callback, 'render');
	  }
	  if (callback !== null) {
	    work.then(callback);
	  }
	  updateContainer(null, root, null, work._onCommit);
	  return work;
	};
	ReactRoot.prototype.legacy_renderSubtreeIntoContainer = function (parentComponent, children, callback) {
	  var root = this._internalRoot;
	  var work = new ReactWork();
	  callback = callback === undefined ? null : callback;
	  {
	    warnOnInvalidCallback(callback, 'render');
	  }
	  if (callback !== null) {
	    work.then(callback);
	  }
	  updateContainer(children, root, parentComponent, work._onCommit);
	  return work;
	};
	ReactRoot.prototype.createBatch = function () {
	  var batch = new ReactBatch(this);
	  var expirationTime = batch._expirationTime;

	  var internalRoot = this._internalRoot;
	  var firstBatch = internalRoot.firstBatch;
	  if (firstBatch === null) {
	    internalRoot.firstBatch = batch;
	    batch._next = null;
	  } else {
	    // Insert sorted by expiration time then insertion order
	    var insertAfter = null;
	    var insertBefore = firstBatch;
	    while (insertBefore !== null && insertBefore._expirationTime >= expirationTime) {
	      insertAfter = insertBefore;
	      insertBefore = insertBefore._next;
	    }
	    batch._next = insertBefore;
	    if (insertAfter !== null) {
	      insertAfter._next = batch;
	    }
	  }

	  return batch;
	};

	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
	}

	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }

	  if (container.nodeType === DOCUMENT_NODE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}

	function shouldHydrateDueToLegacyHeuristic(container) {
	  var rootElement = getReactRootElementInContainer(container);
	  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
	}

	setBatchingImplementation(batchedUpdates$1, interactiveUpdates$1, flushInteractiveUpdates$1);

	var warnedAboutHydrateAPI = false;

	function legacyCreateRootFromDOMContainer(container, forceHydrate) {
	  var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
	  // First clear any existing content.
	  if (!shouldHydrate) {
	    var warned = false;
	    var rootSibling = void 0;
	    while (rootSibling = container.lastChild) {
	      {
	        if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
	          warned = true;
	          warningWithoutStack$1(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
	        }
	      }
	      container.removeChild(rootSibling);
	    }
	  }
	  {
	    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
	      warnedAboutHydrateAPI = true;
	      lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
	    }
	  }
	  // Legacy roots are not async by default.
	  var isConcurrent = false;
	  return new ReactRoot(container, isConcurrent, shouldHydrate);
	}

	function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
	  {
	    topLevelUpdateWarnings(container);
	  }

	  // TODO: Without `any` type, Flow says "Property cannot be accessed on any
	  // member of intersection type." Whyyyyyy.
	  var root = container._reactRootContainer;
	  if (!root) {
	    // Initial mount
	    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);
	    if (typeof callback === 'function') {
	      var originalCallback = callback;
	      callback = function () {
	        var instance = getPublicRootInstance(root._internalRoot);
	        originalCallback.call(instance);
	      };
	    }
	    // Initial mount should not be batched.
	    unbatchedUpdates(function () {
	      if (parentComponent != null) {
	        root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);
	      } else {
	        root.render(children, callback);
	      }
	    });
	  } else {
	    if (typeof callback === 'function') {
	      var _originalCallback = callback;
	      callback = function () {
	        var instance = getPublicRootInstance(root._internalRoot);
	        _originalCallback.call(instance);
	      };
	    }
	    // Update
	    if (parentComponent != null) {
	      root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);
	    } else {
	      root.render(children, callback);
	    }
	  }
	  return getPublicRootInstance(root._internalRoot);
	}

	function createPortal$$1(children, container) {
	  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;
	  // TODO: pass ReactDOM portal implementation as third argument
	  return createPortal$1(children, container, null, key);
	}

	var ReactDOM = {
	  createPortal: createPortal$$1,

	  findDOMNode: function (componentOrElement) {
	    {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null && owner.stateNode !== null) {
	        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
	        !warnedAboutRefsInRender ? warningWithoutStack$1(false, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner.type) || 'A component') : void 0;
	        owner.stateNode._warnedAboutRefsInRender = true;
	      }
	    }
	    if (componentOrElement == null) {
	      return null;
	    }
	    if (componentOrElement.nodeType === ELEMENT_NODE) {
	      return componentOrElement;
	    }
	    {
	      return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');
	    }
	    return findHostInstance(componentOrElement);
	  },
	  hydrate: function (element, container, callback) {
	    !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;
	    {
	      !!container._reactHasBeenPassedToCreateRootDEV ? warningWithoutStack$1(false, 'You are calling ReactDOM.hydrate() on a container that was previously ' + 'passed to ReactDOM.%s(). This is not supported. ' + 'Did you mean to call createRoot(container, {hydrate: true}).render(element)?', 'unstable_createRoot') : void 0;
	    }
	    // TODO: throw or warn if we couldn't hydrate?
	    return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
	  },
	  render: function (element, container, callback) {
	    !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;
	    {
	      !!container._reactHasBeenPassedToCreateRootDEV ? warningWithoutStack$1(false, 'You are calling ReactDOM.render() on a container that was previously ' + 'passed to ReactDOM.%s(). This is not supported. ' + 'Did you mean to call root.render(element)?', 'unstable_createRoot') : void 0;
	    }
	    return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
	  },
	  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {
	    !isValidContainer(containerNode) ? invariant(false, 'Target container is not a DOM element.') : void 0;
	    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;
	    return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
	  },
	  unmountComponentAtNode: function (container) {
	    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;

	    {
	      !!container._reactHasBeenPassedToCreateRootDEV ? warningWithoutStack$1(false, 'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' + 'passed to ReactDOM.%s(). This is not supported. Did you mean to call root.unmount()?', 'unstable_createRoot') : void 0;
	    }

	    if (container._reactRootContainer) {
	      {
	        var rootEl = getReactRootElementInContainer(container);
	        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);
	        !!renderedByDifferentReact ? warningWithoutStack$1(false, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.') : void 0;
	      }

	      // Unmount should not be batched.
	      unbatchedUpdates(function () {
	        legacyRenderSubtreeIntoContainer(null, null, container, false, function () {
	          container._reactRootContainer = null;
	        });
	      });
	      // If you call unmountComponentAtNode twice in quick succession, you'll
	      // get `true` twice. That's probably fine?
	      return true;
	    } else {
	      {
	        var _rootEl = getReactRootElementInContainer(container);
	        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));

	        // Check if the container itself is a React root node.
	        var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

	        !!hasNonRootReactChild ? warningWithoutStack$1(false, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }

	      return false;
	    }
	  },


	  // Temporary alias since we already shipped React 16 RC with it.
	  // TODO: remove in React 17.
	  unstable_createPortal: function () {
	    if (!didWarnAboutUnstableCreatePortal) {
	      didWarnAboutUnstableCreatePortal = true;
	      lowPriorityWarning$1(false, 'The ReactDOM.unstable_createPortal() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactDOM.createPortal() instead. It has the exact same API, ' + 'but without the "unstable_" prefix.');
	    }
	    return createPortal$$1.apply(undefined, arguments);
	  },


	  unstable_batchedUpdates: batchedUpdates$1,

	  unstable_interactiveUpdates: interactiveUpdates$1,

	  flushSync: flushSync,

	  unstable_createRoot: createRoot,
	  unstable_flushControlled: flushControlled,

	  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
	    // Keep in sync with ReactDOMUnstableNativeDependencies.js
	    // and ReactTestUtils.js. This is an array for better minification.
	    Events: [getInstanceFromNode$1, getNodeFromInstance$1, getFiberCurrentPropsFromNode$1, injection.injectEventPluginsByName, eventNameDispatchConfigs, accumulateTwoPhaseDispatches, accumulateDirectDispatches, enqueueStateRestore, restoreStateIfNeeded, dispatchEvent, runEventsInBatch]
	  }
	};

	function createRoot(container, options) {
	  var functionName = 'unstable_createRoot';
	  !isValidContainer(container) ? invariant(false, '%s(...): Target container is not a DOM element.', functionName) : void 0;
	  {
	    !!container._reactRootContainer ? warningWithoutStack$1(false, 'You are calling ReactDOM.%s() on a container that was previously ' + 'passed to ReactDOM.render(). This is not supported.', 'unstable_createRoot') : void 0;
	    container._reactHasBeenPassedToCreateRootDEV = true;
	  }
	  var hydrate = options != null && options.hydrate === true;
	  return new ReactRoot(container, true, hydrate);
	}

	var foundDevTools = injectIntoDevTools({
	  findFiberByHostInstance: getClosestInstanceFromNode,
	  bundleType: 1,
	  version: ReactVersion,
	  rendererPackageName: 'react-dom'
	});

	{
	  if (!foundDevTools && canUseDOM && window.top === window.self) {
	    // If we're in Chrome or Firefox, provide a download link if not installed.
	    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	      var protocol = window.location.protocol;
	      // Don't warn in exotic cases like chrome-extension://.
	      if (/^(https?|file):$/.test(protocol)) {
	        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');
	      }
	    }
	  }
	}



	var ReactDOM$2 = Object.freeze({
		default: ReactDOM
	});

	var ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;

	// TODO: decide on the top-level export form.
	// This is hacky but makes it work with both Rollup and Jest.
	var reactDom = ReactDOM$3.default || ReactDOM$3;

	module.exports = reactDom;
	  })();
	}
	});

	var reactDom = createCommonjsModule(function (module) {

	{
	  module.exports = reactDom_development;
	}
	});

	/**
	 * Template7 1.4.1
	 * Mobile-first HTML template engine
	 * 
	 * http://www.idangero.us/template7/
	 * 
	 * Copyright 2019, Vladimir Kharlampidi
	 * The iDangero.us
	 * http://www.idangero.us/
	 * 
	 * Licensed under MIT
	 * 
	 * Released on: February 5, 2019
	 */

	var t7ctx;
	if (typeof window !== 'undefined') {
	  t7ctx = window;
	} else if (typeof global !== 'undefined') {
	  t7ctx = global;
	} else {
	  t7ctx = undefined;
	}

	var Template7Context = t7ctx;

	var Template7Utils = {
	  quoteSingleRexExp: new RegExp('\'', 'g'),
	  quoteDoubleRexExp: new RegExp('"', 'g'),
	  isFunction: function isFunction(func) {
	    return typeof func === 'function';
	  },
	  escape: function escape(string) {
	    if ( string === void 0 ) string = '';

	    return string
	      .replace(/&/g, '&amp;')
	      .replace(/</g, '&lt;')
	      .replace(/>/g, '&gt;')
	      .replace(/"/g, '&quot;')
	      .replace(/'/g, '&#039;');
	  },
	  helperToSlices: function helperToSlices(string) {
	    var quoteDoubleRexExp = Template7Utils.quoteDoubleRexExp;
	    var quoteSingleRexExp = Template7Utils.quoteSingleRexExp;
	    var helperParts = string.replace(/[{}#}]/g, '').trim().split(' ');
	    var slices = [];
	    var shiftIndex;
	    var i;
	    var j;
	    for (i = 0; i < helperParts.length; i += 1) {
	      var part = helperParts[i];
	      var blockQuoteRegExp = (void 0);
	      var openingQuote = (void 0);
	      if (i === 0) { slices.push(part); }
	      else if (part.indexOf('"') === 0 || part.indexOf('\'') === 0) {
	        blockQuoteRegExp = part.indexOf('"') === 0 ? quoteDoubleRexExp : quoteSingleRexExp;
	        openingQuote = part.indexOf('"') === 0 ? '"' : '\'';
	        // Plain String
	        if (part.match(blockQuoteRegExp).length === 2) {
	          // One word string
	          slices.push(part);
	        } else {
	          // Find closed Index
	          shiftIndex = 0;
	          for (j = i + 1; j < helperParts.length; j += 1) {
	            part += " " + (helperParts[j]);
	            if (helperParts[j].indexOf(openingQuote) >= 0) {
	              shiftIndex = j;
	              slices.push(part);
	              break;
	            }
	          }
	          if (shiftIndex) { i = shiftIndex; }
	        }
	      } else if (part.indexOf('=') > 0) {
	        // Hash
	        var hashParts = part.split('=');
	        var hashName = hashParts[0];
	        var hashContent = hashParts[1];
	        if (!blockQuoteRegExp) {
	          blockQuoteRegExp = hashContent.indexOf('"') === 0 ? quoteDoubleRexExp : quoteSingleRexExp;
	          openingQuote = hashContent.indexOf('"') === 0 ? '"' : '\'';
	        }
	        if (hashContent.match(blockQuoteRegExp).length !== 2) {
	          shiftIndex = 0;
	          for (j = i + 1; j < helperParts.length; j += 1) {
	            hashContent += " " + (helperParts[j]);
	            if (helperParts[j].indexOf(openingQuote) >= 0) {
	              shiftIndex = j;
	              break;
	            }
	          }
	          if (shiftIndex) { i = shiftIndex; }
	        }
	        var hash = [hashName, hashContent.replace(blockQuoteRegExp, '')];
	        slices.push(hash);
	      } else {
	        // Plain variable
	        slices.push(part);
	      }
	    }
	    return slices;
	  },
	  stringToBlocks: function stringToBlocks(string) {
	    var blocks = [];
	    var i;
	    var j;
	    if (!string) { return []; }
	    var stringBlocks = string.split(/({{[^{^}]*}})/);
	    for (i = 0; i < stringBlocks.length; i += 1) {
	      var block = stringBlocks[i];
	      if (block === '') { continue; }
	      if (block.indexOf('{{') < 0) {
	        blocks.push({
	          type: 'plain',
	          content: block,
	        });
	      } else {
	        if (block.indexOf('{/') >= 0) {
	          continue;
	        }
	        block = block
	          .replace(/{{([#/])*([ ])*/, '{{$1')
	          .replace(/([ ])*}}/, '}}');
	        if (block.indexOf('{#') < 0 && block.indexOf(' ') < 0 && block.indexOf('else') < 0) {
	          // Simple variable
	          blocks.push({
	            type: 'variable',
	            contextName: block.replace(/[{}]/g, ''),
	          });
	          continue;
	        }
	        // Helpers
	        var helperSlices = Template7Utils.helperToSlices(block);
	        var helperName = helperSlices[0];
	        var isPartial = helperName === '>';
	        var helperContext = [];
	        var helperHash = {};
	        for (j = 1; j < helperSlices.length; j += 1) {
	          var slice = helperSlices[j];
	          if (Array.isArray(slice)) {
	            // Hash
	            helperHash[slice[0]] = slice[1] === 'false' ? false : slice[1];
	          } else {
	            helperContext.push(slice);
	          }
	        }

	        if (block.indexOf('{#') >= 0) {
	          // Condition/Helper
	          var helperContent = '';
	          var elseContent = '';
	          var toSkip = 0;
	          var shiftIndex = (void 0);
	          var foundClosed = false;
	          var foundElse = false;
	          var depth = 0;
	          for (j = i + 1; j < stringBlocks.length; j += 1) {
	            if (stringBlocks[j].indexOf('{{#') >= 0) {
	              depth += 1;
	            }
	            if (stringBlocks[j].indexOf('{{/') >= 0) {
	              depth -= 1;
	            }
	            if (stringBlocks[j].indexOf(("{{#" + helperName)) >= 0) {
	              helperContent += stringBlocks[j];
	              if (foundElse) { elseContent += stringBlocks[j]; }
	              toSkip += 1;
	            } else if (stringBlocks[j].indexOf(("{{/" + helperName)) >= 0) {
	              if (toSkip > 0) {
	                toSkip -= 1;
	                helperContent += stringBlocks[j];
	                if (foundElse) { elseContent += stringBlocks[j]; }
	              } else {
	                shiftIndex = j;
	                foundClosed = true;
	                break;
	              }
	            } else if (stringBlocks[j].indexOf('else') >= 0 && depth === 0) {
	              foundElse = true;
	            } else {
	              if (!foundElse) { helperContent += stringBlocks[j]; }
	              if (foundElse) { elseContent += stringBlocks[j]; }
	            }
	          }
	          if (foundClosed) {
	            if (shiftIndex) { i = shiftIndex; }
	            if (helperName === 'raw') {
	              blocks.push({
	                type: 'plain',
	                content: helperContent,
	              });
	            } else {
	              blocks.push({
	                type: 'helper',
	                helperName: helperName,
	                contextName: helperContext,
	                content: helperContent,
	                inverseContent: elseContent,
	                hash: helperHash,
	              });
	            }
	          }
	        } else if (block.indexOf(' ') > 0) {
	          if (isPartial) {
	            helperName = '_partial';
	            if (helperContext[0]) {
	              if (helperContext[0].indexOf('[') === 0) { helperContext[0] = helperContext[0].replace(/[[\]]/g, ''); }
	              else { helperContext[0] = "\"" + (helperContext[0].replace(/"|'/g, '')) + "\""; }
	            }
	          }
	          blocks.push({
	            type: 'helper',
	            helperName: helperName,
	            contextName: helperContext,
	            hash: helperHash,
	          });
	        }
	      }
	    }
	    return blocks;
	  },
	  parseJsVariable: function parseJsVariable(expression, replace, object) {
	    return expression.split(/([+ \-*/^()&=|<>!%:?])/g).reduce(function (arr, part) {
	      if (!part) {
	        return arr;
	      }
	      if (part.indexOf(replace) < 0) {
	        arr.push(part);
	        return arr;
	      }
	      if (!object) {
	        arr.push(JSON.stringify(''));
	        return arr;
	      }

	      var variable = object;
	      if (part.indexOf((replace + ".")) >= 0) {
	        part.split((replace + "."))[1].split('.').forEach(function (partName) {
	          if (partName in variable) { variable = variable[partName]; }
	          else { variable = undefined; }
	        });
	      }
	      if (typeof variable === 'string') {
	        variable = JSON.stringify(variable);
	      }
	      if (variable === undefined) { variable = 'undefined'; }

	      arr.push(variable);
	      return arr;
	    }, []).join('');
	  },
	  parseJsParents: function parseJsParents(expression, parents) {
	    return expression.split(/([+ \-*^()&=|<>!%:?])/g).reduce(function (arr, part) {
	      if (!part) {
	        return arr;
	      }

	      if (part.indexOf('../') < 0) {
	        arr.push(part);
	        return arr;
	      }

	      if (!parents || parents.length === 0) {
	        arr.push(JSON.stringify(''));
	        return arr;
	      }

	      var levelsUp = part.split('../').length - 1;
	      var parentData = levelsUp > parents.length ? parents[parents.length - 1] : parents[levelsUp - 1];

	      var variable = parentData;
	      var parentPart = part.replace(/..\//g, '');
	      parentPart.split('.').forEach(function (partName) {
	        if (typeof variable[partName] !== 'undefined') { variable = variable[partName]; }
	        else { variable = 'undefined'; }
	      });
	      if (variable === false || variable === true) {
	        arr.push(JSON.stringify(variable));
	        return arr;
	      }
	      if (variable === null || variable === 'undefined') {
	        arr.push(JSON.stringify(''));
	        return arr;
	      }
	      arr.push(JSON.stringify(variable));
	      return arr;
	    }, []).join('');
	  },
	  getCompileVar: function getCompileVar(name, ctx, data) {
	    if ( data === void 0 ) data = 'data_1';

	    var variable = ctx;
	    var parts;
	    var levelsUp = 0;
	    var newDepth;
	    if (name.indexOf('../') === 0) {
	      levelsUp = name.split('../').length - 1;
	      newDepth = variable.split('_')[1] - levelsUp;
	      variable = "ctx_" + (newDepth >= 1 ? newDepth : 1);
	      parts = name.split('../')[levelsUp].split('.');
	    } else if (name.indexOf('@global') === 0) {
	      variable = 'Template7.global';
	      parts = name.split('@global.')[1].split('.');
	    } else if (name.indexOf('@root') === 0) {
	      variable = 'root';
	      parts = name.split('@root.')[1].split('.');
	    } else {
	      parts = name.split('.');
	    }
	    for (var i = 0; i < parts.length; i += 1) {
	      var part = parts[i];
	      if (part.indexOf('@') === 0) {
	        var dataLevel = data.split('_')[1];
	        if (levelsUp > 0) {
	          dataLevel = newDepth;
	        }
	        if (i > 0) {
	          variable += "[(data_" + dataLevel + " && data_" + dataLevel + "." + (part.replace('@', '')) + ")]";
	        } else {
	          variable = "(data_" + dataLevel + " && data_" + dataLevel + "." + (part.replace('@', '')) + ")";
	        }
	      } else if (Number.isFinite ? Number.isFinite(part) : Template7Context.isFinite(part)) {
	        variable += "[" + part + "]";
	      } else if (part === 'this' || part.indexOf('this.') >= 0 || part.indexOf('this[') >= 0 || part.indexOf('this(') >= 0) {
	        variable = part.replace('this', ctx);
	      } else {
	        variable += "." + part;
	      }
	    }
	    return variable;
	  },
	  getCompiledArguments: function getCompiledArguments(contextArray, ctx, data) {
	    var arr = [];
	    for (var i = 0; i < contextArray.length; i += 1) {
	      if (/^['"]/.test(contextArray[i])) { arr.push(contextArray[i]); }
	      else if (/^(true|false|\d+)$/.test(contextArray[i])) { arr.push(contextArray[i]); }
	      else {
	        arr.push(Template7Utils.getCompileVar(contextArray[i], ctx, data));
	      }
	    }

	    return arr.join(', ');
	  },
	};

	/* eslint no-eval: "off" */

	var Template7Helpers = {
	  _partial: function _partial(partialName, options) {
	    var ctx = this;
	    var p = Template7Class.partials[partialName];
	    if (!p || (p && !p.template)) { return ''; }
	    if (!p.compiled) {
	      p.compiled = new Template7Class(p.template).compile();
	    }
	    Object.keys(options.hash).forEach(function (hashName) {
	      ctx[hashName] = options.hash[hashName];
	    });
	    return p.compiled(ctx, options.data, options.root);
	  },
	  escape: function escape(context) {
	    if (typeof context !== 'string') {
	      throw new Error('Template7: Passed context to "escape" helper should be a string');
	    }
	    return Template7Utils.escape(context);
	  },
	  if: function if$1(context, options) {
	    var ctx = context;
	    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
	    if (ctx) {
	      return options.fn(this, options.data);
	    }

	    return options.inverse(this, options.data);
	  },
	  unless: function unless(context, options) {
	    var ctx = context;
	    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
	    if (!ctx) {
	      return options.fn(this, options.data);
	    }

	    return options.inverse(this, options.data);
	  },
	  each: function each(context, options) {
	    var ctx = context;
	    var ret = '';
	    var i = 0;
	    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
	    if (Array.isArray(ctx)) {
	      if (options.hash.reverse) {
	        ctx = ctx.reverse();
	      }
	      for (i = 0; i < ctx.length; i += 1) {
	        ret += options.fn(ctx[i], { first: i === 0, last: i === ctx.length - 1, index: i });
	      }
	      if (options.hash.reverse) {
	        ctx = ctx.reverse();
	      }
	    } else {
	      // eslint-disable-next-line
	      for (var key in ctx) {
	        i += 1;
	        ret += options.fn(ctx[key], { key: key });
	      }
	    }
	    if (i > 0) { return ret; }
	    return options.inverse(this);
	  },
	  with: function with$1(context, options) {
	    var ctx = context;
	    if (Template7Utils.isFunction(ctx)) { ctx = context.call(this); }
	    return options.fn(ctx);
	  },
	  join: function join(context, options) {
	    var ctx = context;
	    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
	    return ctx.join(options.hash.delimiter || options.hash.delimeter);
	  },
	  js: function js(expression, options) {
	    var data = options.data;
	    var func;
	    var execute = expression;
	    ('index first last key').split(' ').forEach(function (prop) {
	      if (typeof data[prop] !== 'undefined') {
	        var re1 = new RegExp(("this.@" + prop), 'g');
	        var re2 = new RegExp(("@" + prop), 'g');
	        execute = execute
	          .replace(re1, JSON.stringify(data[prop]))
	          .replace(re2, JSON.stringify(data[prop]));
	      }
	    });
	    if (options.root && execute.indexOf('@root') >= 0) {
	      execute = Template7Utils.parseJsVariable(execute, '@root', options.root);
	    }
	    if (execute.indexOf('@global') >= 0) {
	      execute = Template7Utils.parseJsVariable(execute, '@global', Template7Context.Template7.global);
	    }
	    if (execute.indexOf('../') >= 0) {
	      execute = Template7Utils.parseJsParents(execute, options.parents);
	    }
	    if (execute.indexOf('return') >= 0) {
	      func = "(function(){" + execute + "})";
	    } else {
	      func = "(function(){return (" + execute + ")})";
	    }
	    return eval(func).call(this);
	  },
	  js_if: function js_if(expression, options) {
	    var data = options.data;
	    var func;
	    var execute = expression;
	    ('index first last key').split(' ').forEach(function (prop) {
	      if (typeof data[prop] !== 'undefined') {
	        var re1 = new RegExp(("this.@" + prop), 'g');
	        var re2 = new RegExp(("@" + prop), 'g');
	        execute = execute
	          .replace(re1, JSON.stringify(data[prop]))
	          .replace(re2, JSON.stringify(data[prop]));
	      }
	    });
	    if (options.root && execute.indexOf('@root') >= 0) {
	      execute = Template7Utils.parseJsVariable(execute, '@root', options.root);
	    }
	    if (execute.indexOf('@global') >= 0) {
	      execute = Template7Utils.parseJsVariable(execute, '@global', Template7Context.Template7.global);
	    }
	    if (execute.indexOf('../') >= 0) {
	      execute = Template7Utils.parseJsParents(execute, options.parents);
	    }
	    if (execute.indexOf('return') >= 0) {
	      func = "(function(){" + execute + "})";
	    } else {
	      func = "(function(){return (" + execute + ")})";
	    }
	    var condition = eval(func).call(this);
	    if (condition) {
	      return options.fn(this, options.data);
	    }

	    return options.inverse(this, options.data);
	  },
	};
	Template7Helpers.js_compare = Template7Helpers.js_if;

	var Template7Options = {};
	var Template7Partials = {};

	var Template7Class = function Template7Class(template) {
	  var t = this;
	  t.template = template;
	};

	var staticAccessors = { options: { configurable: true },partials: { configurable: true },helpers: { configurable: true } };
	Template7Class.prototype.compile = function compile (template, depth) {
	    if ( template === void 0 ) template = this.template;
	    if ( depth === void 0 ) depth = 1;

	  var t = this;
	  if (t.compiled) { return t.compiled; }

	  if (typeof template !== 'string') {
	    throw new Error('Template7: Template must be a string');
	  }
	  var stringToBlocks = Template7Utils.stringToBlocks;
	    var getCompileVar = Template7Utils.getCompileVar;
	    var getCompiledArguments = Template7Utils.getCompiledArguments;

	  var blocks = stringToBlocks(template);
	  var ctx = "ctx_" + depth;
	  var data = "data_" + depth;
	  if (blocks.length === 0) {
	    return function empty() { return ''; };
	  }

	  function getCompileFn(block, newDepth) {
	    if (block.content) { return t.compile(block.content, newDepth); }
	    return function empty() { return ''; };
	  }
	  function getCompileInverse(block, newDepth) {
	    if (block.inverseContent) { return t.compile(block.inverseContent, newDepth); }
	    return function empty() { return ''; };
	  }

	  var resultString = '';
	  if (depth === 1) {
	    resultString += "(function (" + ctx + ", " + data + ", root) {\n";
	  } else {
	    resultString += "(function (" + ctx + ", " + data + ") {\n";
	  }
	  if (depth === 1) {
	    resultString += 'function isArray(arr){return Array.isArray(arr);}\n';
	    resultString += 'function isFunction(func){return (typeof func === \'function\');}\n';
	    resultString += 'function c(val, ctx) {if (typeof val !== "undefined" && val !== null) {if (isFunction(val)) {return val.call(ctx);} else return val;} else return "";}\n';
	    resultString += 'root = root || ctx_1 || {};\n';
	  }
	  resultString += 'var r = \'\';\n';
	  var i;
	  for (i = 0; i < blocks.length; i += 1) {
	    var block = blocks[i];
	    // Plain block
	    if (block.type === 'plain') {
	      // eslint-disable-next-line
	      resultString += "r +='" + ((block.content).replace(/\r/g, '\\r').replace(/\n/g, '\\n').replace(/'/g, '\\' + '\'')) + "';";
	      continue;
	    }
	    var variable = (void 0);
	    var compiledArguments = (void 0);
	    // Variable block
	    if (block.type === 'variable') {
	      variable = getCompileVar(block.contextName, ctx, data);
	      resultString += "r += c(" + variable + ", " + ctx + ");";
	    }
	    // Helpers block
	    if (block.type === 'helper') {
	      var parents = (void 0);
	      if (ctx !== 'ctx_1') {
	        var level = ctx.split('_')[1];
	        var parentsString = "ctx_" + (level - 1);
	        for (var j = level - 2; j >= 1; j -= 1) {
	          parentsString += ", ctx_" + j;
	        }
	        parents = "[" + parentsString + "]";
	      } else {
	        parents = "[" + ctx + "]";
	      }
	      var dynamicHelper = (void 0);
	      if (block.helperName.indexOf('[') === 0) {
	        block.helperName = getCompileVar(block.helperName.replace(/[[\]]/g, ''), ctx, data);
	        dynamicHelper = true;
	      }
	      if (dynamicHelper || block.helperName in Template7Helpers) {
	        compiledArguments = getCompiledArguments(block.contextName, ctx, data);
	        resultString += "r += (Template7Helpers" + (dynamicHelper ? ("[" + (block.helperName) + "]") : ("." + (block.helperName))) + ").call(" + ctx + ", " + (compiledArguments && ((compiledArguments + ", "))) + "{hash:" + (JSON.stringify(block.hash)) + ", data: " + data + " || {}, fn: " + (getCompileFn(block, depth + 1)) + ", inverse: " + (getCompileInverse(block, depth + 1)) + ", root: root, parents: " + parents + "});";
	      } else if (block.contextName.length > 0) {
	        throw new Error(("Template7: Missing helper: \"" + (block.helperName) + "\""));
	      } else {
	        variable = getCompileVar(block.helperName, ctx, data);
	        resultString += "if (" + variable + ") {";
	        resultString += "if (isArray(" + variable + ")) {";
	        resultString += "r += (Template7Helpers.each).call(" + ctx + ", " + variable + ", {hash:" + (JSON.stringify(block.hash)) + ", data: " + data + " || {}, fn: " + (getCompileFn(block, depth + 1)) + ", inverse: " + (getCompileInverse(block, depth + 1)) + ", root: root, parents: " + parents + "});";
	        resultString += '}else {';
	        resultString += "r += (Template7Helpers.with).call(" + ctx + ", " + variable + ", {hash:" + (JSON.stringify(block.hash)) + ", data: " + data + " || {}, fn: " + (getCompileFn(block, depth + 1)) + ", inverse: " + (getCompileInverse(block, depth + 1)) + ", root: root, parents: " + parents + "});";
	        resultString += '}}';
	      }
	    }
	  }
	  resultString += '\nreturn r;})';

	  if (depth === 1) {
	    // eslint-disable-next-line
	    t.compiled = eval(resultString);
	    return t.compiled;
	  }
	  return resultString;
	};
	staticAccessors.options.get = function () {
	  return Template7Options;
	};
	staticAccessors.partials.get = function () {
	  return Template7Partials;
	};
	staticAccessors.helpers.get = function () {
	  return Template7Helpers;
	};

	Object.defineProperties( Template7Class, staticAccessors );

	function Template7() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var template = args[0];
	  var data = args[1];
	  if (args.length === 2) {
	    var instance = new Template7Class(template);
	    var rendered = instance.compile()(data);
	    instance = null;
	    return (rendered);
	  }
	  return new Template7Class(template);
	}
	Template7.registerHelper = function registerHelper(name, fn) {
	  Template7Class.helpers[name] = fn;
	};
	Template7.unregisterHelper = function unregisterHelper(name) {
	  Template7Class.helpers[name] = undefined;
	  delete Template7Class.helpers[name];
	};
	Template7.registerPartial = function registerPartial(name, template) {
	  Template7Class.partials[name] = { template: template };
	};
	Template7.unregisterPartial = function unregisterPartial(name) {
	  if (Template7Class.partials[name]) {
	    Template7Class.partials[name] = undefined;
	    delete Template7Class.partials[name];
	  }
	};
	Template7.compile = function compile(template, options) {
	  var instance = new Template7Class(template, options);
	  return instance.compile();
	};

	Template7.options = Template7Class.options;
	Template7.helpers = Template7Class.helpers;
	Template7.partials = Template7Class.partials;

	/**
	 * SSR Window 1.0.1
	 * Better handling for window object in SSR environment
	 * https://github.com/nolimits4web/ssr-window
	 *
	 * Copyright 2018, Vladimir Kharlampidi
	 *
	 * Licensed under MIT
	 *
	 * Released on: July 18, 2018
	 */
	var doc = (typeof document === 'undefined') ? {
	  body: {},
	  addEventListener: function addEventListener() {},
	  removeEventListener: function removeEventListener() {},
	  activeElement: {
	    blur: function blur() {},
	    nodeName: '',
	  },
	  querySelector: function querySelector() {
	    return null;
	  },
	  querySelectorAll: function querySelectorAll() {
	    return [];
	  },
	  getElementById: function getElementById() {
	    return null;
	  },
	  createEvent: function createEvent() {
	    return {
	      initEvent: function initEvent() {},
	    };
	  },
	  createElement: function createElement() {
	    return {
	      children: [],
	      childNodes: [],
	      style: {},
	      setAttribute: function setAttribute() {},
	      getElementsByTagName: function getElementsByTagName() {
	        return [];
	      },
	    };
	  },
	  location: { hash: '' },
	} : document; // eslint-disable-line

	var win = (typeof window === 'undefined') ? {
	  document: doc,
	  navigator: {
	    userAgent: '',
	  },
	  location: {},
	  history: {},
	  CustomEvent: function CustomEvent() {
	    return this;
	  },
	  addEventListener: function addEventListener() {},
	  removeEventListener: function removeEventListener() {},
	  getComputedStyle: function getComputedStyle() {
	    return {
	      getPropertyValue: function getPropertyValue() {
	        return '';
	      },
	    };
	  },
	  Image: function Image() {},
	  Date: function Date() {},
	  screen: {},
	  setTimeout: function setTimeout() {},
	  clearTimeout: function clearTimeout() {},
	} : window; // eslint-disable-line

	/**
	 * Dom7 2.1.3
	 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
	 * http://framework7.io/docs/dom.html
	 *
	 * Copyright 2019, Vladimir Kharlampidi
	 * The iDangero.us
	 * http://www.idangero.us/
	 *
	 * Licensed under MIT
	 *
	 * Released on: February 11, 2019
	 */

	var Dom7 = function Dom7(arr) {
	  var self = this;
	  // Create array-like object
	  for (var i = 0; i < arr.length; i += 1) {
	    self[i] = arr[i];
	  }
	  self.length = arr.length;
	  // Return collection with methods
	  return this;
	};

	function $(selector, context) {
	  var arr = [];
	  var i = 0;
	  if (selector && !context) {
	    if (selector instanceof Dom7) {
	      return selector;
	    }
	  }
	  if (selector) {
	      // String
	    if (typeof selector === 'string') {
	      var els;
	      var tempParent;
	      var html = selector.trim();
	      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
	        var toCreate = 'div';
	        if (html.indexOf('<li') === 0) { toCreate = 'ul'; }
	        if (html.indexOf('<tr') === 0) { toCreate = 'tbody'; }
	        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) { toCreate = 'tr'; }
	        if (html.indexOf('<tbody') === 0) { toCreate = 'table'; }
	        if (html.indexOf('<option') === 0) { toCreate = 'select'; }
	        tempParent = doc.createElement(toCreate);
	        tempParent.innerHTML = html;
	        for (i = 0; i < tempParent.childNodes.length; i += 1) {
	          arr.push(tempParent.childNodes[i]);
	        }
	      } else {
	        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
	          // Pure ID selector
	          els = [doc.getElementById(selector.trim().split('#')[1])];
	        } else {
	          // Other selectors
	          els = (context || doc).querySelectorAll(selector.trim());
	        }
	        for (i = 0; i < els.length; i += 1) {
	          if (els[i]) { arr.push(els[i]); }
	        }
	      }
	    } else if (selector.nodeType || selector === win || selector === doc) {
	      // Node/element
	      arr.push(selector);
	    } else if (selector.length > 0 && selector[0].nodeType) {
	      // Array of elements or instance of Dom
	      for (i = 0; i < selector.length; i += 1) {
	        arr.push(selector[i]);
	      }
	    }
	  }
	  return new Dom7(arr);
	}

	$.fn = Dom7.prototype;
	$.Class = Dom7;
	$.Dom7 = Dom7;

	function unique(arr) {
	  var uniqueArray = [];
	  for (var i = 0; i < arr.length; i += 1) {
	    if (uniqueArray.indexOf(arr[i]) === -1) { uniqueArray.push(arr[i]); }
	  }
	  return uniqueArray;
	}
	function toCamelCase(string) {
	  return string.toLowerCase().replace(/-(.)/g, function (match, group1) { return group1.toUpperCase(); });
	}

	function requestAnimationFrame$1(callback) {
	  if (win.requestAnimationFrame) { return win.requestAnimationFrame(callback); }
	  else if (win.webkitRequestAnimationFrame) { return win.webkitRequestAnimationFrame(callback); }
	  return win.setTimeout(callback, 1000 / 60);
	}
	function cancelAnimationFrame$1(id) {
	  if (win.cancelAnimationFrame) { return win.cancelAnimationFrame(id); }
	  else if (win.webkitCancelAnimationFrame) { return win.webkitCancelAnimationFrame(id); }
	  return win.clearTimeout(id);
	}

	// Classes and attributes
	function addClass(className) {
	  if (typeof className === 'undefined') {
	    return this;
	  }
	  var classes = className.split(' ');
	  for (var i = 0; i < classes.length; i += 1) {
	    for (var j = 0; j < this.length; j += 1) {
	      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.add(classes[i]); }
	    }
	  }
	  return this;
	}
	function removeClass(className) {
	  var classes = className.split(' ');
	  for (var i = 0; i < classes.length; i += 1) {
	    for (var j = 0; j < this.length; j += 1) {
	      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.remove(classes[i]); }
	    }
	  }
	  return this;
	}
	function hasClass(className) {
	  if (!this[0]) { return false; }
	  return this[0].classList.contains(className);
	}
	function toggleClass(className) {
	  var classes = className.split(' ');
	  for (var i = 0; i < classes.length; i += 1) {
	    for (var j = 0; j < this.length; j += 1) {
	      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.toggle(classes[i]); }
	    }
	  }
	  return this;
	}
	function attr(attrs, value) {
	  var arguments$1 = arguments;

	  if (arguments.length === 1 && typeof attrs === 'string') {
	    // Get attr
	    if (this[0]) { return this[0].getAttribute(attrs); }
	    return undefined;
	  }

	  // Set attrs
	  for (var i = 0; i < this.length; i += 1) {
	    if (arguments$1.length === 2) {
	      // String
	      this[i].setAttribute(attrs, value);
	    } else {
	      // Object
	      // eslint-disable-next-line
	      for (var attrName in attrs) {
	        this[i][attrName] = attrs[attrName];
	        this[i].setAttribute(attrName, attrs[attrName]);
	      }
	    }
	  }
	  return this;
	}
	// eslint-disable-next-line
	function removeAttr(attr) {
	  for (var i = 0; i < this.length; i += 1) {
	    this[i].removeAttribute(attr);
	  }
	  return this;
	}
	// eslint-disable-next-line
	function prop(props, value) {
	  var arguments$1 = arguments;

	  if (arguments.length === 1 && typeof props === 'string') {
	    // Get prop
	    if (this[0]) { return this[0][props]; }
	  } else {
	    // Set props
	    for (var i = 0; i < this.length; i += 1) {
	      if (arguments$1.length === 2) {
	        // String
	        this[i][props] = value;
	      } else {
	        // Object
	        // eslint-disable-next-line
	        for (var propName in props) {
	          this[i][propName] = props[propName];
	        }
	      }
	    }
	    return this;
	  }
	}
	function data(key, value) {
	  var el;
	  if (typeof value === 'undefined') {
	    el = this[0];
	    // Get value
	    if (el) {
	      if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
	        return el.dom7ElementDataStorage[key];
	      }

	      var dataKey = el.getAttribute(("data-" + key));
	      if (dataKey) {
	        return dataKey;
	      }
	      return undefined;
	    }
	    return undefined;
	  }

	  // Set value
	  for (var i = 0; i < this.length; i += 1) {
	    el = this[i];
	    if (!el.dom7ElementDataStorage) { el.dom7ElementDataStorage = {}; }
	    el.dom7ElementDataStorage[key] = value;
	  }
	  return this;
	}
	function removeData(key) {
	  for (var i = 0; i < this.length; i += 1) {
	    var el = this[i];
	    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
	      el.dom7ElementDataStorage[key] = null;
	      delete el.dom7ElementDataStorage[key];
	    }
	  }
	}
	function dataset() {
	  var el = this[0];
	  if (!el) { return undefined; }
	  var dataset = {}; // eslint-disable-line
	  if (el.dataset) {
	    // eslint-disable-next-line
	    for (var dataKey in el.dataset) {
	      dataset[dataKey] = el.dataset[dataKey];
	    }
	  } else {
	    for (var i = 0; i < el.attributes.length; i += 1) {
	      // eslint-disable-next-line
	      var attr = el.attributes[i];
	      if (attr.name.indexOf('data-') >= 0) {
	        dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;
	      }
	    }
	  }
	  // eslint-disable-next-line
	  for (var key in dataset) {
	    if (dataset[key] === 'false') { dataset[key] = false; }
	    else if (dataset[key] === 'true') { dataset[key] = true; }
	    else if (parseFloat(dataset[key]) === dataset[key] * 1) { dataset[key] *= 1; }
	  }
	  return dataset;
	}
	function val(value) {
	  var dom = this;
	  if (typeof value === 'undefined') {
	    if (dom[0]) {
	      if (dom[0].multiple && dom[0].nodeName.toLowerCase() === 'select') {
	        var values = [];
	        for (var i = 0; i < dom[0].selectedOptions.length; i += 1) {
	          values.push(dom[0].selectedOptions[i].value);
	        }
	        return values;
	      }
	      return dom[0].value;
	    }
	    return undefined;
	  }

	  for (var i$1 = 0; i$1 < dom.length; i$1 += 1) {
	    var el = dom[i$1];
	    if (Array.isArray(value) && el.multiple && el.nodeName.toLowerCase() === 'select') {
	      for (var j = 0; j < el.options.length; j += 1) {
	        el.options[j].selected = value.indexOf(el.options[j].value) >= 0;
	      }
	    } else {
	      el.value = value;
	    }
	  }
	  return dom;
	}
	// Transforms
	// eslint-disable-next-line
	function transform(transform) {
	  for (var i = 0; i < this.length; i += 1) {
	    var elStyle = this[i].style;
	    elStyle.webkitTransform = transform;
	    elStyle.transform = transform;
	  }
	  return this;
	}
	function transition(duration) {
	  if (typeof duration !== 'string') {
	    duration = duration + "ms"; // eslint-disable-line
	  }
	  for (var i = 0; i < this.length; i += 1) {
	    var elStyle = this[i].style;
	    elStyle.webkitTransitionDuration = duration;
	    elStyle.transitionDuration = duration;
	  }
	  return this;
	}
	// Events
	function on() {
	  var assign;

	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];
	  var eventType = args[0];
	  var targetSelector = args[1];
	  var listener = args[2];
	  var capture = args[3];
	  if (typeof args[1] === 'function') {
	    (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);
	    targetSelector = undefined;
	  }
	  if (!capture) { capture = false; }

	  function handleLiveEvent(e) {
	    var target = e.target;
	    if (!target) { return; }
	    var eventData = e.target.dom7EventData || [];
	    if (eventData.indexOf(e) < 0) {
	      eventData.unshift(e);
	    }
	    if ($(target).is(targetSelector)) { listener.apply(target, eventData); }
	    else {
	      var parents = $(target).parents(); // eslint-disable-line
	      for (var k = 0; k < parents.length; k += 1) {
	        if ($(parents[k]).is(targetSelector)) { listener.apply(parents[k], eventData); }
	      }
	    }
	  }
	  function handleEvent(e) {
	    var eventData = e && e.target ? e.target.dom7EventData || [] : [];
	    if (eventData.indexOf(e) < 0) {
	      eventData.unshift(e);
	    }
	    listener.apply(this, eventData);
	  }
	  var events = eventType.split(' ');
	  var j;
	  for (var i = 0; i < this.length; i += 1) {
	    var el = this[i];
	    if (!targetSelector) {
	      for (j = 0; j < events.length; j += 1) {
	        var event = events[j];
	        if (!el.dom7Listeners) { el.dom7Listeners = {}; }
	        if (!el.dom7Listeners[event]) { el.dom7Listeners[event] = []; }
	        el.dom7Listeners[event].push({
	          listener: listener,
	          proxyListener: handleEvent,
	        });
	        el.addEventListener(event, handleEvent, capture);
	      }
	    } else {
	      // Live events
	      for (j = 0; j < events.length; j += 1) {
	        var event$1 = events[j];
	        if (!el.dom7LiveListeners) { el.dom7LiveListeners = {}; }
	        if (!el.dom7LiveListeners[event$1]) { el.dom7LiveListeners[event$1] = []; }
	        el.dom7LiveListeners[event$1].push({
	          listener: listener,
	          proxyListener: handleLiveEvent,
	        });
	        el.addEventListener(event$1, handleLiveEvent, capture);
	      }
	    }
	  }
	  return this;
	}
	function off() {
	  var assign;

	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];
	  var eventType = args[0];
	  var targetSelector = args[1];
	  var listener = args[2];
	  var capture = args[3];
	  if (typeof args[1] === 'function') {
	    (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);
	    targetSelector = undefined;
	  }
	  if (!capture) { capture = false; }

	  var events = eventType.split(' ');
	  for (var i = 0; i < events.length; i += 1) {
	    var event = events[i];
	    for (var j = 0; j < this.length; j += 1) {
	      var el = this[j];
	      var handlers = (void 0);
	      if (!targetSelector && el.dom7Listeners) {
	        handlers = el.dom7Listeners[event];
	      } else if (targetSelector && el.dom7LiveListeners) {
	        handlers = el.dom7LiveListeners[event];
	      }
	      if (handlers && handlers.length) {
	        for (var k = handlers.length - 1; k >= 0; k -= 1) {
	          var handler = handlers[k];
	          if (listener && handler.listener === listener) {
	            el.removeEventListener(event, handler.proxyListener, capture);
	            handlers.splice(k, 1);
	          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
	            el.removeEventListener(event, handler.proxyListener, capture);
	            handlers.splice(k, 1);
	          } else if (!listener) {
	            el.removeEventListener(event, handler.proxyListener, capture);
	            handlers.splice(k, 1);
	          }
	        }
	      }
	    }
	  }
	  return this;
	}
	function once() {
	  var assign;

	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];
	  var dom = this;
	  var eventName = args[0];
	  var targetSelector = args[1];
	  var listener = args[2];
	  var capture = args[3];
	  if (typeof args[1] === 'function') {
	    (assign = args, eventName = assign[0], listener = assign[1], capture = assign[2]);
	    targetSelector = undefined;
	  }
	  function onceHandler() {
	    var eventArgs = [], len = arguments.length;
	    while ( len-- ) eventArgs[ len ] = arguments[ len ];

	    listener.apply(this, eventArgs);
	    dom.off(eventName, targetSelector, onceHandler, capture);
	    if (onceHandler.dom7proxy) {
	      delete onceHandler.dom7proxy;
	    }
	  }
	  onceHandler.dom7proxy = listener;
	  return dom.on(eventName, targetSelector, onceHandler, capture);
	}
	function trigger() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var events = args[0].split(' ');
	  var eventData = args[1];
	  for (var i = 0; i < events.length; i += 1) {
	    var event = events[i];
	    for (var j = 0; j < this.length; j += 1) {
	      var el = this[j];
	      var evt = (void 0);
	      try {
	        evt = new win.CustomEvent(event, {
	          detail: eventData,
	          bubbles: true,
	          cancelable: true,
	        });
	      } catch (e) {
	        evt = doc.createEvent('Event');
	        evt.initEvent(event, true, true);
	        evt.detail = eventData;
	      }
	      // eslint-disable-next-line
	      el.dom7EventData = args.filter(function (data, dataIndex) { return dataIndex > 0; });
	      el.dispatchEvent(evt);
	      el.dom7EventData = [];
	      delete el.dom7EventData;
	    }
	  }
	  return this;
	}
	function transitionEnd(callback) {
	  var events = ['webkitTransitionEnd', 'transitionend'];
	  var dom = this;
	  var i;
	  function fireCallBack(e) {
	    /* jshint validthis:true */
	    if (e.target !== this) { return; }
	    callback.call(this, e);
	    for (i = 0; i < events.length; i += 1) {
	      dom.off(events[i], fireCallBack);
	    }
	  }
	  if (callback) {
	    for (i = 0; i < events.length; i += 1) {
	      dom.on(events[i], fireCallBack);
	    }
	  }
	  return this;
	}
	function animationEnd(callback) {
	  var events = ['webkitAnimationEnd', 'animationend'];
	  var dom = this;
	  var i;
	  function fireCallBack(e) {
	    if (e.target !== this) { return; }
	    callback.call(this, e);
	    for (i = 0; i < events.length; i += 1) {
	      dom.off(events[i], fireCallBack);
	    }
	  }
	  if (callback) {
	    for (i = 0; i < events.length; i += 1) {
	      dom.on(events[i], fireCallBack);
	    }
	  }
	  return this;
	}
	// Sizing/Styles
	function width() {
	  if (this[0] === win) {
	    return win.innerWidth;
	  }

	  if (this.length > 0) {
	    return parseFloat(this.css('width'));
	  }

	  return null;
	}
	function outerWidth(includeMargins) {
	  if (this.length > 0) {
	    if (includeMargins) {
	      // eslint-disable-next-line
	      var styles = this.styles();
	      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
	    }
	    return this[0].offsetWidth;
	  }
	  return null;
	}
	function height() {
	  if (this[0] === win) {
	    return win.innerHeight;
	  }

	  if (this.length > 0) {
	    return parseFloat(this.css('height'));
	  }

	  return null;
	}
	function outerHeight(includeMargins) {
	  if (this.length > 0) {
	    if (includeMargins) {
	      // eslint-disable-next-line
	      var styles = this.styles();
	      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
	    }
	    return this[0].offsetHeight;
	  }
	  return null;
	}
	function offset() {
	  if (this.length > 0) {
	    var el = this[0];
	    var box = el.getBoundingClientRect();
	    var body = doc.body;
	    var clientTop = el.clientTop || body.clientTop || 0;
	    var clientLeft = el.clientLeft || body.clientLeft || 0;
	    var scrollTop = el === win ? win.scrollY : el.scrollTop;
	    var scrollLeft = el === win ? win.scrollX : el.scrollLeft;
	    return {
	      top: (box.top + scrollTop) - clientTop,
	      left: (box.left + scrollLeft) - clientLeft,
	    };
	  }

	  return null;
	}
	function hide() {
	  for (var i = 0; i < this.length; i += 1) {
	    this[i].style.display = 'none';
	  }
	  return this;
	}
	function show() {
	  for (var i = 0; i < this.length; i += 1) {
	    var el = this[i];
	    if (el.style.display === 'none') {
	      el.style.display = '';
	    }
	    if (win.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
	      // Still not visible
	      el.style.display = 'block';
	    }
	  }
	  return this;
	}
	function styles() {
	  if (this[0]) { return win.getComputedStyle(this[0], null); }
	  return {};
	}
	function css(props, value) {
	  var i;
	  if (arguments.length === 1) {
	    if (typeof props === 'string') {
	      if (this[0]) { return win.getComputedStyle(this[0], null).getPropertyValue(props); }
	    } else {
	      for (i = 0; i < this.length; i += 1) {
	        // eslint-disable-next-line
	        for (var prop in props) {
	          this[i].style[prop] = props[prop];
	        }
	      }
	      return this;
	    }
	  }
	  if (arguments.length === 2 && typeof props === 'string') {
	    for (i = 0; i < this.length; i += 1) {
	      this[i].style[props] = value;
	    }
	    return this;
	  }
	  return this;
	}

	// Dom manipulation
	function toArray() {
	  var arr = [];
	  for (var i = 0; i < this.length; i += 1) {
	    arr.push(this[i]);
	  }
	  return arr;
	}
	// Iterate over the collection passing elements to `callback`
	function each(callback) {
	  // Don't bother continuing without a callback
	  if (!callback) { return this; }
	  // Iterate over the current collection
	  for (var i = 0; i < this.length; i += 1) {
	    // If the callback returns false
	    if (callback.call(this[i], i, this[i]) === false) {
	      // End the loop early
	      return this;
	    }
	  }
	  // Return `this` to allow chained DOM operations
	  return this;
	}
	function forEach(callback) {
	  // Don't bother continuing without a callback
	  if (!callback) { return this; }
	  // Iterate over the current collection
	  for (var i = 0; i < this.length; i += 1) {
	    // If the callback returns false
	    if (callback.call(this[i], this[i], i) === false) {
	      // End the loop early
	      return this;
	    }
	  }
	  // Return `this` to allow chained DOM operations
	  return this;
	}
	function filter(callback) {
	  var matchedItems = [];
	  var dom = this;
	  for (var i = 0; i < dom.length; i += 1) {
	    if (callback.call(dom[i], i, dom[i])) { matchedItems.push(dom[i]); }
	  }
	  return new Dom7(matchedItems);
	}
	function map(callback) {
	  var modifiedItems = [];
	  var dom = this;
	  for (var i = 0; i < dom.length; i += 1) {
	    modifiedItems.push(callback.call(dom[i], i, dom[i]));
	  }
	  return new Dom7(modifiedItems);
	}
	// eslint-disable-next-line
	function html(html) {
	  if (typeof html === 'undefined') {
	    return this[0] ? this[0].innerHTML : undefined;
	  }

	  for (var i = 0; i < this.length; i += 1) {
	    this[i].innerHTML = html;
	  }
	  return this;
	}
	// eslint-disable-next-line
	function text(text) {
	  if (typeof text === 'undefined') {
	    if (this[0]) {
	      return this[0].textContent.trim();
	    }
	    return null;
	  }

	  for (var i = 0; i < this.length; i += 1) {
	    this[i].textContent = text;
	  }
	  return this;
	}
	function is(selector) {
	  var el = this[0];
	  var compareWith;
	  var i;
	  if (!el || typeof selector === 'undefined') { return false; }
	  if (typeof selector === 'string') {
	    if (el.matches) { return el.matches(selector); }
	    else if (el.webkitMatchesSelector) { return el.webkitMatchesSelector(selector); }
	    else if (el.msMatchesSelector) { return el.msMatchesSelector(selector); }

	    compareWith = $(selector);
	    for (i = 0; i < compareWith.length; i += 1) {
	      if (compareWith[i] === el) { return true; }
	    }
	    return false;
	  } else if (selector === doc) { return el === doc; }
	  else if (selector === win) { return el === win; }

	  if (selector.nodeType || selector instanceof Dom7) {
	    compareWith = selector.nodeType ? [selector] : selector;
	    for (i = 0; i < compareWith.length; i += 1) {
	      if (compareWith[i] === el) { return true; }
	    }
	    return false;
	  }
	  return false;
	}
	function indexOf(el) {
	  for (var i = 0; i < this.length; i += 1) {
	    if (this[i] === el) { return i; }
	  }
	  return -1;
	}
	function index() {
	  var child = this[0];
	  var i;
	  if (child) {
	    i = 0;
	    // eslint-disable-next-line
	    while ((child = child.previousSibling) !== null) {
	      if (child.nodeType === 1) { i += 1; }
	    }
	    return i;
	  }
	  return undefined;
	}
	// eslint-disable-next-line
	function eq(index) {
	  if (typeof index === 'undefined') { return this; }
	  var length = this.length;
	  var returnIndex;
	  if (index > length - 1) {
	    return new Dom7([]);
	  }
	  if (index < 0) {
	    returnIndex = length + index;
	    if (returnIndex < 0) { return new Dom7([]); }
	    return new Dom7([this[returnIndex]]);
	  }
	  return new Dom7([this[index]]);
	}
	function append() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var newChild;

	  for (var k = 0; k < args.length; k += 1) {
	    newChild = args[k];
	    for (var i = 0; i < this.length; i += 1) {
	      if (typeof newChild === 'string') {
	        var tempDiv = doc.createElement('div');
	        tempDiv.innerHTML = newChild;
	        while (tempDiv.firstChild) {
	          this[i].appendChild(tempDiv.firstChild);
	        }
	      } else if (newChild instanceof Dom7) {
	        for (var j = 0; j < newChild.length; j += 1) {
	          this[i].appendChild(newChild[j]);
	        }
	      } else {
	        this[i].appendChild(newChild);
	      }
	    }
	  }

	  return this;
	}
	// eslint-disable-next-line
	function appendTo(parent) {
	  $(parent).append(this);
	  return this;
	}
	function prepend(newChild) {
	  var i;
	  var j;
	  for (i = 0; i < this.length; i += 1) {
	    if (typeof newChild === 'string') {
	      var tempDiv = doc.createElement('div');
	      tempDiv.innerHTML = newChild;
	      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
	        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
	      }
	    } else if (newChild instanceof Dom7) {
	      for (j = 0; j < newChild.length; j += 1) {
	        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
	      }
	    } else {
	      this[i].insertBefore(newChild, this[i].childNodes[0]);
	    }
	  }
	  return this;
	}
	// eslint-disable-next-line
	function prependTo(parent) {
	  $(parent).prepend(this);
	  return this;
	}
	function insertBefore(selector) {
	  var before = $(selector);
	  for (var i = 0; i < this.length; i += 1) {
	    if (before.length === 1) {
	      before[0].parentNode.insertBefore(this[i], before[0]);
	    } else if (before.length > 1) {
	      for (var j = 0; j < before.length; j += 1) {
	        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
	      }
	    }
	  }
	}
	function insertAfter(selector) {
	  var after = $(selector);
	  for (var i = 0; i < this.length; i += 1) {
	    if (after.length === 1) {
	      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
	    } else if (after.length > 1) {
	      for (var j = 0; j < after.length; j += 1) {
	        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
	      }
	    }
	  }
	}
	function next(selector) {
	  if (this.length > 0) {
	    if (selector) {
	      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
	        return new Dom7([this[0].nextElementSibling]);
	      }
	      return new Dom7([]);
	    }

	    if (this[0].nextElementSibling) { return new Dom7([this[0].nextElementSibling]); }
	    return new Dom7([]);
	  }
	  return new Dom7([]);
	}
	function nextAll(selector) {
	  var nextEls = [];
	  var el = this[0];
	  if (!el) { return new Dom7([]); }
	  while (el.nextElementSibling) {
	    var next = el.nextElementSibling; // eslint-disable-line
	    if (selector) {
	      if ($(next).is(selector)) { nextEls.push(next); }
	    } else { nextEls.push(next); }
	    el = next;
	  }
	  return new Dom7(nextEls);
	}
	function prev(selector) {
	  if (this.length > 0) {
	    var el = this[0];
	    if (selector) {
	      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
	        return new Dom7([el.previousElementSibling]);
	      }
	      return new Dom7([]);
	    }

	    if (el.previousElementSibling) { return new Dom7([el.previousElementSibling]); }
	    return new Dom7([]);
	  }
	  return new Dom7([]);
	}
	function prevAll(selector) {
	  var prevEls = [];
	  var el = this[0];
	  if (!el) { return new Dom7([]); }
	  while (el.previousElementSibling) {
	    var prev = el.previousElementSibling; // eslint-disable-line
	    if (selector) {
	      if ($(prev).is(selector)) { prevEls.push(prev); }
	    } else { prevEls.push(prev); }
	    el = prev;
	  }
	  return new Dom7(prevEls);
	}
	function siblings(selector) {
	  return this.nextAll(selector).add(this.prevAll(selector));
	}
	function parent(selector) {
	  var parents = []; // eslint-disable-line
	  for (var i = 0; i < this.length; i += 1) {
	    if (this[i].parentNode !== null) {
	      if (selector) {
	        if ($(this[i].parentNode).is(selector)) { parents.push(this[i].parentNode); }
	      } else {
	        parents.push(this[i].parentNode);
	      }
	    }
	  }
	  return $(unique(parents));
	}
	function parents(selector) {
	  var parents = []; // eslint-disable-line
	  for (var i = 0; i < this.length; i += 1) {
	    var parent = this[i].parentNode; // eslint-disable-line
	    while (parent) {
	      if (selector) {
	        if ($(parent).is(selector)) { parents.push(parent); }
	      } else {
	        parents.push(parent);
	      }
	      parent = parent.parentNode;
	    }
	  }
	  return $(unique(parents));
	}
	function closest(selector) {
	  var closest = this; // eslint-disable-line
	  if (typeof selector === 'undefined') {
	    return new Dom7([]);
	  }
	  if (!closest.is(selector)) {
	    closest = closest.parents(selector).eq(0);
	  }
	  return closest;
	}
	function find(selector) {
	  var foundElements = [];
	  for (var i = 0; i < this.length; i += 1) {
	    var found = this[i].querySelectorAll(selector);
	    for (var j = 0; j < found.length; j += 1) {
	      foundElements.push(found[j]);
	    }
	  }
	  return new Dom7(foundElements);
	}
	function children(selector) {
	  var children = []; // eslint-disable-line
	  for (var i = 0; i < this.length; i += 1) {
	    var childNodes = this[i].childNodes;

	    for (var j = 0; j < childNodes.length; j += 1) {
	      if (!selector) {
	        if (childNodes[j].nodeType === 1) { children.push(childNodes[j]); }
	      } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
	        children.push(childNodes[j]);
	      }
	    }
	  }
	  return new Dom7(unique(children));
	}
	function remove() {
	  for (var i = 0; i < this.length; i += 1) {
	    if (this[i].parentNode) { this[i].parentNode.removeChild(this[i]); }
	  }
	  return this;
	}
	function detach() {
	  return this.remove();
	}
	function add() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var dom = this;
	  var i;
	  var j;
	  for (i = 0; i < args.length; i += 1) {
	    var toAdd = $(args[i]);
	    for (j = 0; j < toAdd.length; j += 1) {
	      dom[dom.length] = toAdd[j];
	      dom.length += 1;
	    }
	  }
	  return dom;
	}
	function empty() {
	  for (var i = 0; i < this.length; i += 1) {
	    var el = this[i];
	    if (el.nodeType === 1) {
	      for (var j = 0; j < el.childNodes.length; j += 1) {
	        if (el.childNodes[j].parentNode) {
	          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
	        }
	      }
	      el.textContent = '';
	    }
	  }
	  return this;
	}

	var Methods = /*#__PURE__*/Object.freeze({
	  addClass: addClass,
	  removeClass: removeClass,
	  hasClass: hasClass,
	  toggleClass: toggleClass,
	  attr: attr,
	  removeAttr: removeAttr,
	  prop: prop,
	  data: data,
	  removeData: removeData,
	  dataset: dataset,
	  val: val,
	  transform: transform,
	  transition: transition,
	  on: on,
	  off: off,
	  once: once,
	  trigger: trigger,
	  transitionEnd: transitionEnd,
	  animationEnd: animationEnd,
	  width: width,
	  outerWidth: outerWidth,
	  height: height,
	  outerHeight: outerHeight,
	  offset: offset,
	  hide: hide,
	  show: show,
	  styles: styles,
	  css: css,
	  toArray: toArray,
	  each: each,
	  forEach: forEach,
	  filter: filter,
	  map: map,
	  html: html,
	  text: text,
	  is: is,
	  indexOf: indexOf,
	  index: index,
	  eq: eq,
	  append: append,
	  appendTo: appendTo,
	  prepend: prepend,
	  prependTo: prependTo,
	  insertBefore: insertBefore,
	  insertAfter: insertAfter,
	  next: next,
	  nextAll: nextAll,
	  prev: prev,
	  prevAll: prevAll,
	  siblings: siblings,
	  parent: parent,
	  parents: parents,
	  closest: closest,
	  find: find,
	  children: children,
	  remove: remove,
	  detach: detach,
	  add: add,
	  empty: empty
	});

	function scrollTo() {
	  var assign;

	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];
	  var left = args[0];
	  var top = args[1];
	  var duration = args[2];
	  var easing = args[3];
	  var callback = args[4];
	  if (args.length === 4 && typeof easing === 'function') {
	    callback = easing;
	    (assign = args, left = assign[0], top = assign[1], duration = assign[2], callback = assign[3], easing = assign[4]);
	  }
	  if (typeof easing === 'undefined') { easing = 'swing'; }

	  return this.each(function animate() {
	    var el = this;
	    var currentTop;
	    var currentLeft;
	    var maxTop;
	    var maxLeft;
	    var newTop;
	    var newLeft;
	    var scrollTop; // eslint-disable-line
	    var scrollLeft; // eslint-disable-line
	    var animateTop = top > 0 || top === 0;
	    var animateLeft = left > 0 || left === 0;
	    if (typeof easing === 'undefined') {
	      easing = 'swing';
	    }
	    if (animateTop) {
	      currentTop = el.scrollTop;
	      if (!duration) {
	        el.scrollTop = top;
	      }
	    }
	    if (animateLeft) {
	      currentLeft = el.scrollLeft;
	      if (!duration) {
	        el.scrollLeft = left;
	      }
	    }
	    if (!duration) { return; }
	    if (animateTop) {
	      maxTop = el.scrollHeight - el.offsetHeight;
	      newTop = Math.max(Math.min(top, maxTop), 0);
	    }
	    if (animateLeft) {
	      maxLeft = el.scrollWidth - el.offsetWidth;
	      newLeft = Math.max(Math.min(left, maxLeft), 0);
	    }
	    var startTime = null;
	    if (animateTop && newTop === currentTop) { animateTop = false; }
	    if (animateLeft && newLeft === currentLeft) { animateLeft = false; }
	    function render(time) {
	      if ( time === void 0 ) time = new Date().getTime();

	      if (startTime === null) {
	        startTime = time;
	      }
	      var progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
	      var easeProgress = easing === 'linear' ? progress : (0.5 - (Math.cos(progress * Math.PI) / 2));
	      var done;
	      if (animateTop) { scrollTop = currentTop + (easeProgress * (newTop - currentTop)); }
	      if (animateLeft) { scrollLeft = currentLeft + (easeProgress * (newLeft - currentLeft)); }
	      if (animateTop && newTop > currentTop && scrollTop >= newTop) {
	        el.scrollTop = newTop;
	        done = true;
	      }
	      if (animateTop && newTop < currentTop && scrollTop <= newTop) {
	        el.scrollTop = newTop;
	        done = true;
	      }
	      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
	        el.scrollLeft = newLeft;
	        done = true;
	      }
	      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
	        el.scrollLeft = newLeft;
	        done = true;
	      }

	      if (done) {
	        if (callback) { callback(); }
	        return;
	      }
	      if (animateTop) { el.scrollTop = scrollTop; }
	      if (animateLeft) { el.scrollLeft = scrollLeft; }
	      requestAnimationFrame$1(render);
	    }
	    requestAnimationFrame$1(render);
	  });
	}
	// scrollTop(top, duration, easing, callback) {
	function scrollTop() {
	  var assign;

	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];
	  var top = args[0];
	  var duration = args[1];
	  var easing = args[2];
	  var callback = args[3];
	  if (args.length === 3 && typeof easing === 'function') {
	    (assign = args, top = assign[0], duration = assign[1], callback = assign[2], easing = assign[3]);
	  }
	  var dom = this;
	  if (typeof top === 'undefined') {
	    if (dom.length > 0) { return dom[0].scrollTop; }
	    return null;
	  }
	  return dom.scrollTo(undefined, top, duration, easing, callback);
	}
	function scrollLeft() {
	  var assign;

	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];
	  var left = args[0];
	  var duration = args[1];
	  var easing = args[2];
	  var callback = args[3];
	  if (args.length === 3 && typeof easing === 'function') {
	    (assign = args, left = assign[0], duration = assign[1], callback = assign[2], easing = assign[3]);
	  }
	  var dom = this;
	  if (typeof left === 'undefined') {
	    if (dom.length > 0) { return dom[0].scrollLeft; }
	    return null;
	  }
	  return dom.scrollTo(left, undefined, duration, easing, callback);
	}

	var Scroll = /*#__PURE__*/Object.freeze({
	  scrollTo: scrollTo,
	  scrollTop: scrollTop,
	  scrollLeft: scrollLeft
	});

	function animate(initialProps, initialParams) {
	  var els = this;
	  var a = {
	    props: Object.assign({}, initialProps),
	    params: Object.assign({
	      duration: 300,
	      easing: 'swing', // or 'linear'
	      /* Callbacks
	      begin(elements)
	      complete(elements)
	      progress(elements, complete, remaining, start, tweenValue)
	      */
	    }, initialParams),

	    elements: els,
	    animating: false,
	    que: [],

	    easingProgress: function easingProgress(easing, progress) {
	      if (easing === 'swing') {
	        return 0.5 - (Math.cos(progress * Math.PI) / 2);
	      }
	      if (typeof easing === 'function') {
	        return easing(progress);
	      }
	      return progress;
	    },
	    stop: function stop() {
	      if (a.frameId) {
	        cancelAnimationFrame$1(a.frameId);
	      }
	      a.animating = false;
	      a.elements.each(function (index, el) {
	        var element = el;
	        delete element.dom7AnimateInstance;
	      });
	      a.que = [];
	    },
	    done: function done(complete) {
	      a.animating = false;
	      a.elements.each(function (index, el) {
	        var element = el;
	        delete element.dom7AnimateInstance;
	      });
	      if (complete) { complete(els); }
	      if (a.que.length > 0) {
	        var que = a.que.shift();
	        a.animate(que[0], que[1]);
	      }
	    },
	    animate: function animate(props, params) {
	      if (a.animating) {
	        a.que.push([props, params]);
	        return a;
	      }
	      var elements = [];

	      // Define & Cache Initials & Units
	      a.elements.each(function (index, el) {
	        var initialFullValue;
	        var initialValue;
	        var unit;
	        var finalValue;
	        var finalFullValue;

	        if (!el.dom7AnimateInstance) { a.elements[index].dom7AnimateInstance = a; }

	        elements[index] = {
	          container: el,
	        };
	        Object.keys(props).forEach(function (prop) {
	          initialFullValue = win.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
	          initialValue = parseFloat(initialFullValue);
	          unit = initialFullValue.replace(initialValue, '');
	          finalValue = parseFloat(props[prop]);
	          finalFullValue = props[prop] + unit;
	          elements[index][prop] = {
	            initialFullValue: initialFullValue,
	            initialValue: initialValue,
	            unit: unit,
	            finalValue: finalValue,
	            finalFullValue: finalFullValue,
	            currentValue: initialValue,
	          };
	        });
	      });

	      var startTime = null;
	      var time;
	      var elementsDone = 0;
	      var propsDone = 0;
	      var done;
	      var began = false;

	      a.animating = true;

	      function render() {
	        time = new Date().getTime();
	        var progress;
	        var easeProgress;
	        // let el;
	        if (!began) {
	          began = true;
	          if (params.begin) { params.begin(els); }
	        }
	        if (startTime === null) {
	          startTime = time;
	        }
	        if (params.progress) {
	          // eslint-disable-next-line
	          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), ((startTime + params.duration) - time < 0 ? 0 : (startTime + params.duration) - time), startTime);
	        }

	        elements.forEach(function (element) {
	          var el = element;
	          if (done || el.done) { return; }
	          Object.keys(props).forEach(function (prop) {
	            if (done || el.done) { return; }
	            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
	            easeProgress = a.easingProgress(params.easing, progress);
	            var ref = el[prop];
	            var initialValue = ref.initialValue;
	            var finalValue = ref.finalValue;
	            var unit = ref.unit;
	            el[prop].currentValue = initialValue + (easeProgress * (finalValue - initialValue));
	            var currentValue = el[prop].currentValue;

	            if (
	              (finalValue > initialValue && currentValue >= finalValue) ||
	              (finalValue < initialValue && currentValue <= finalValue)) {
	              el.container.style[prop] = finalValue + unit;
	              propsDone += 1;
	              if (propsDone === Object.keys(props).length) {
	                el.done = true;
	                elementsDone += 1;
	              }
	              if (elementsDone === elements.length) {
	                done = true;
	              }
	            }
	            if (done) {
	              a.done(params.complete);
	              return;
	            }
	            el.container.style[prop] = currentValue + unit;
	          });
	        });
	        if (done) { return; }
	        // Then call
	        a.frameId = requestAnimationFrame$1(render);
	      }
	      a.frameId = requestAnimationFrame$1(render);
	      return a;
	    },
	  };

	  if (a.elements.length === 0) {
	    return els;
	  }

	  var animateInstance;
	  for (var i = 0; i < a.elements.length; i += 1) {
	    if (a.elements[i].dom7AnimateInstance) {
	      animateInstance = a.elements[i].dom7AnimateInstance;
	    } else { a.elements[i].dom7AnimateInstance = a; }
	  }
	  if (!animateInstance) {
	    animateInstance = a;
	  }

	  if (initialProps === 'stop') {
	    animateInstance.stop();
	  } else {
	    animateInstance.animate(a.props, a.params);
	  }

	  return els;
	}

	function stop() {
	  var els = this;
	  for (var i = 0; i < els.length; i += 1) {
	    if (els[i].dom7AnimateInstance) {
	      els[i].dom7AnimateInstance.stop();
	    }
	  }
	}

	var Animate = /*#__PURE__*/Object.freeze({
	  animate: animate,
	  stop: stop
	});

	var noTrigger = ('resize scroll').split(' ');
	function eventShortcut(name) {
	  var ref;

	  var args = [], len = arguments.length - 1;
	  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
	  if (typeof args[0] === 'undefined') {
	    for (var i = 0; i < this.length; i += 1) {
	      if (noTrigger.indexOf(name) < 0) {
	        if (name in this[i]) { this[i][name](); }
	        else {
	          $(this[i]).trigger(name);
	        }
	      }
	    }
	    return this;
	  }
	  return (ref = this).on.apply(ref, [ name ].concat( args ));
	}

	function click() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'click' ].concat( args ));
	}
	function blur() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'blur' ].concat( args ));
	}
	function focus() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'focus' ].concat( args ));
	}
	function focusin() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'focusin' ].concat( args ));
	}
	function focusout() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'focusout' ].concat( args ));
	}
	function keyup() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'keyup' ].concat( args ));
	}
	function keydown() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'keydown' ].concat( args ));
	}
	function keypress() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'keypress' ].concat( args ));
	}
	function submit() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'submit' ].concat( args ));
	}
	function change() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'change' ].concat( args ));
	}
	function mousedown() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'mousedown' ].concat( args ));
	}
	function mousemove() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'mousemove' ].concat( args ));
	}
	function mouseup() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'mouseup' ].concat( args ));
	}
	function mouseenter() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'mouseenter' ].concat( args ));
	}
	function mouseleave() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'mouseleave' ].concat( args ));
	}
	function mouseout() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'mouseout' ].concat( args ));
	}
	function mouseover() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'mouseover' ].concat( args ));
	}
	function touchstart() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'touchstart' ].concat( args ));
	}
	function touchend() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'touchend' ].concat( args ));
	}
	function touchmove() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'touchmove' ].concat( args ));
	}
	function resize() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'resize' ].concat( args ));
	}
	function scroll() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'scroll' ].concat( args ));
	}

	var eventShortcuts = /*#__PURE__*/Object.freeze({
	  click: click,
	  blur: blur,
	  focus: focus,
	  focusin: focusin,
	  focusout: focusout,
	  keyup: keyup,
	  keydown: keydown,
	  keypress: keypress,
	  submit: submit,
	  change: change,
	  mousedown: mousedown,
	  mousemove: mousemove,
	  mouseup: mouseup,
	  mouseenter: mouseenter,
	  mouseleave: mouseleave,
	  mouseout: mouseout,
	  mouseover: mouseover,
	  touchstart: touchstart,
	  touchend: touchend,
	  touchmove: touchmove,
	  resize: resize,
	  scroll: scroll
	});

	[Methods, Scroll, Animate, eventShortcuts].forEach(function (group) {
	  Object.keys(group).forEach(function (methodName) {
	    $.fn[methodName] = group[methodName];
	  });
	});

	/**
	 * https://github.com/gre/bezier-easing
	 * BezierEasing - use bezier curve for transition easing function
	 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
	 */

	/* eslint-disable */

	// These values are established by empiricism with tests (tradeoff: performance VS precision)
	var NEWTON_ITERATIONS = 4;
	var NEWTON_MIN_SLOPE = 0.001;
	var SUBDIVISION_PRECISION = 0.0000001;
	var SUBDIVISION_MAX_ITERATIONS = 10;

	var kSplineTableSize = 11;
	var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

	var float32ArraySupported = typeof Float32Array === 'function';

	function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
	function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
	function C (aA1)      { return 3.0 * aA1; }

	// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
	function calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }

	// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
	function getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }

	function binarySubdivide (aX, aA, aB, mX1, mX2) {
	  var currentX, currentT, i = 0;
	  do {
	    currentT = aA + (aB - aA) / 2.0;
	    currentX = calcBezier(currentT, mX1, mX2) - aX;
	    if (currentX > 0.0) {
	      aB = currentT;
	    } else {
	      aA = currentT;
	    }
	  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
	  return currentT;
	}

	function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
	 for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
	   var currentSlope = getSlope(aGuessT, mX1, mX2);
	   if (currentSlope === 0.0) {
	     return aGuessT;
	   }
	   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
	   aGuessT -= currentX / currentSlope;
	 }
	 return aGuessT;
	}

	function bezier (mX1, mY1, mX2, mY2) {
	  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
	    throw new Error('bezier x values must be in [0, 1] range');
	  }

	  // Precompute samples table
	  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
	  if (mX1 !== mY1 || mX2 !== mY2) {
	    for (var i = 0; i < kSplineTableSize; ++i) {
	      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
	    }
	  }

	  function getTForX (aX) {
	    var intervalStart = 0.0;
	    var currentSample = 1;
	    var lastSample = kSplineTableSize - 1;

	    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
	      intervalStart += kSampleStepSize;
	    }
	    --currentSample;

	    // Interpolate to provide an initial guess for t
	    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
	    var guessForT = intervalStart + dist * kSampleStepSize;

	    var initialSlope = getSlope(guessForT, mX1, mX2);
	    if (initialSlope >= NEWTON_MIN_SLOPE) {
	      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
	    } else if (initialSlope === 0.0) {
	      return guessForT;
	    } else {
	      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
	    }
	  }

	  return function BezierEasing (x) {
	    if (mX1 === mY1 && mX2 === mY2) {
	      return x; // linear
	    }
	    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
	    if (x === 0) {
	      return 0;
	    }
	    if (x === 1) {
	      return 1;
	    }
	    return calcBezier(getTForX(x), mY1, mY2);
	  };
	}

	/* eslint no-control-regex: "off" */

	// Remove Diacritics
	var defaultDiacriticsRemovalap = [
	  { base: 'A', letters: '\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F' },
	  { base: 'AA', letters: '\uA732' },
	  { base: 'AE', letters: '\u00C6\u01FC\u01E2' },
	  { base: 'AO', letters: '\uA734' },
	  { base: 'AU', letters: '\uA736' },
	  { base: 'AV', letters: '\uA738\uA73A' },
	  { base: 'AY', letters: '\uA73C' },
	  { base: 'B', letters: '\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181' },
	  { base: 'C', letters: '\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E' },
	  { base: 'D', letters: '\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779' },
	  { base: 'DZ', letters: '\u01F1\u01C4' },
	  { base: 'Dz', letters: '\u01F2\u01C5' },
	  { base: 'E', letters: '\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E' },
	  { base: 'F', letters: '\u0046\u24BB\uFF26\u1E1E\u0191\uA77B' },
	  { base: 'G', letters: '\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E' },
	  { base: 'H', letters: '\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D' },
	  { base: 'I', letters: '\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197' },
	  { base: 'J', letters: '\u004A\u24BF\uFF2A\u0134\u0248' },
	  { base: 'K', letters: '\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2' },
	  { base: 'L', letters: '\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780' },
	  { base: 'LJ', letters: '\u01C7' },
	  { base: 'Lj', letters: '\u01C8' },
	  { base: 'M', letters: '\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C' },
	  { base: 'N', letters: '\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4' },
	  { base: 'NJ', letters: '\u01CA' },
	  { base: 'Nj', letters: '\u01CB' },
	  { base: 'O', letters: '\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C' },
	  { base: 'OI', letters: '\u01A2' },
	  { base: 'OO', letters: '\uA74E' },
	  { base: 'OU', letters: '\u0222' },
	  { base: 'OE', letters: '\u008C\u0152' },
	  { base: 'oe', letters: '\u009C\u0153' },
	  { base: 'P', letters: '\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754' },
	  { base: 'Q', letters: '\u0051\u24C6\uFF31\uA756\uA758\u024A' },
	  { base: 'R', letters: '\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782' },
	  { base: 'S', letters: '\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784' },
	  { base: 'T', letters: '\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786' },
	  { base: 'TZ', letters: '\uA728' },
	  { base: 'U', letters: '\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244' },
	  { base: 'V', letters: '\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245' },
	  { base: 'VY', letters: '\uA760' },
	  { base: 'W', letters: '\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72' },
	  { base: 'X', letters: '\u0058\u24CD\uFF38\u1E8A\u1E8C' },
	  { base: 'Y', letters: '\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE' },
	  { base: 'Z', letters: '\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762' },
	  { base: 'a', letters: '\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250' },
	  { base: 'aa', letters: '\uA733' },
	  { base: 'ae', letters: '\u00E6\u01FD\u01E3' },
	  { base: 'ao', letters: '\uA735' },
	  { base: 'au', letters: '\uA737' },
	  { base: 'av', letters: '\uA739\uA73B' },
	  { base: 'ay', letters: '\uA73D' },
	  { base: 'b', letters: '\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253' },
	  { base: 'c', letters: '\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184' },
	  { base: 'd', letters: '\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A' },
	  { base: 'dz', letters: '\u01F3\u01C6' },
	  { base: 'e', letters: '\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD' },
	  { base: 'f', letters: '\u0066\u24D5\uFF46\u1E1F\u0192\uA77C' },
	  { base: 'g', letters: '\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F' },
	  { base: 'h', letters: '\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265' },
	  { base: 'hv', letters: '\u0195' },
	  { base: 'i', letters: '\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131' },
	  { base: 'j', letters: '\u006A\u24D9\uFF4A\u0135\u01F0\u0249' },
	  { base: 'k', letters: '\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3' },
	  { base: 'l', letters: '\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747' },
	  { base: 'lj', letters: '\u01C9' },
	  { base: 'm', letters: '\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F' },
	  { base: 'n', letters: '\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5' },
	  { base: 'nj', letters: '\u01CC' },
	  { base: 'o', letters: '\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275' },
	  { base: 'oi', letters: '\u01A3' },
	  { base: 'ou', letters: '\u0223' },
	  { base: 'oo', letters: '\uA74F' },
	  { base: 'p', letters: '\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755' },
	  { base: 'q', letters: '\u0071\u24E0\uFF51\u024B\uA757\uA759' },
	  { base: 'r', letters: '\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783' },
	  { base: 's', letters: '\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B' },
	  { base: 't', letters: '\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787' },
	  { base: 'tz', letters: '\uA729' },
	  { base: 'u', letters: '\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289' },
	  { base: 'v', letters: '\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C' },
	  { base: 'vy', letters: '\uA761' },
	  { base: 'w', letters: '\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73' },
	  { base: 'x', letters: '\u0078\u24E7\uFF58\u1E8B\u1E8D' },
	  { base: 'y', letters: '\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF' },
	  { base: 'z', letters: '\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763' } ];

	var diacriticsMap = {};
	for (var i = 0; i < defaultDiacriticsRemovalap.length; i += 1) {
	  var letters = defaultDiacriticsRemovalap[i].letters;
	  for (var j = 0; j < letters.length; j += 1) {
	    diacriticsMap[letters[j]] = defaultDiacriticsRemovalap[i].base;
	  }
	}

	var uniqueNumber = 1;

	var Utils = {
	  uniqueNumber: function uniqueNumber$1() {
	    uniqueNumber += 1;
	    return uniqueNumber;
	  },
	  id: function id(mask, map) {
	    if ( mask === void 0 ) mask = 'xxxxxxxxxx';
	    if ( map === void 0 ) map = '0123456789abcdef';

	    var length = map.length;
	    return mask.replace(/x/g, function () { return map[Math.floor((Math.random() * length))]; });
	  },
	  mdPreloaderContent: "\n    <span class=\"preloader-inner\">\n      <span class=\"preloader-inner-gap\"></span>\n      <span class=\"preloader-inner-left\">\n          <span class=\"preloader-inner-half-circle\"></span>\n      </span>\n      <span class=\"preloader-inner-right\">\n          <span class=\"preloader-inner-half-circle\"></span>\n      </span>\n    </span>\n  ".trim(),
	  iosPreloaderContent: ("\n    <span class=\"preloader-inner\">\n      " + ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(function () { return '<span class="preloader-inner-line"></span>'; }).join('')) + "\n    </span>\n  ").trim(),
	  auroraPreloaderContent: "\n    <span class=\"preloader-inner\">\n      <span class=\"preloader-inner-circle\"></span>\n    </span>\n  ",
	  eventNameToColonCase: function eventNameToColonCase(eventName) {
	    var hasColon;
	    return eventName.split('').map(function (char, index) {
	      if (char.match(/[A-Z]/) && index !== 0 && !hasColon) {
	        hasColon = true;
	        return (":" + (char.toLowerCase()));
	      }
	      return char.toLowerCase();
	    }).join('');
	  },
	  deleteProps: function deleteProps(obj) {
	    var object = obj;
	    Object.keys(object).forEach(function (key) {
	      try {
	        object[key] = null;
	      } catch (e) {
	        // no setter for object
	      }
	      try {
	        delete object[key];
	      } catch (e) {
	        // something got wrong
	      }
	    });
	  },
	  bezier: function bezier$1() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return bezier.apply(void 0, args);
	  },
	  nextTick: function nextTick(callback, delay) {
	    if ( delay === void 0 ) delay = 0;

	    return setTimeout(callback, delay);
	  },
	  nextFrame: function nextFrame(callback) {
	    return Utils.requestAnimationFrame(function () {
	      Utils.requestAnimationFrame(callback);
	    });
	  },
	  now: function now() {
	    return Date.now();
	  },
	  requestAnimationFrame: function requestAnimationFrame(callback) {
	    return win.requestAnimationFrame(callback);
	  },
	  cancelAnimationFrame: function cancelAnimationFrame(id) {
	    return win.cancelAnimationFrame(id);
	  },
	  removeDiacritics: function removeDiacritics(str) {
	    return str.replace(/[^\u0000-\u007E]/g, function (a) { return diacriticsMap[a] || a; });
	  },
	  parseUrlQuery: function parseUrlQuery(url) {
	    var query = {};
	    var urlToParse = url || win.location.href;
	    var i;
	    var params;
	    var param;
	    var length;
	    if (typeof urlToParse === 'string' && urlToParse.length) {
	      urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
	      params = urlToParse.split('&').filter(function (paramsPart) { return paramsPart !== ''; });
	      length = params.length;

	      for (i = 0; i < length; i += 1) {
	        param = params[i].replace(/#\S+/g, '').split('=');
	        query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param.slice(1).join('=')) || '';
	      }
	    }
	    return query;
	  },
	  getTranslate: function getTranslate(el, axis) {
	    if ( axis === void 0 ) axis = 'x';

	    var matrix;
	    var curTransform;
	    var transformMatrix;

	    var curStyle = win.getComputedStyle(el, null);

	    if (win.WebKitCSSMatrix) {
	      curTransform = curStyle.transform || curStyle.webkitTransform;
	      if (curTransform.split(',').length > 6) {
	        curTransform = curTransform.split(', ').map(function (a) { return a.replace(',', '.'); }).join(', ');
	      }
	      // Some old versions of Webkit choke when 'none' is passed; pass
	      // empty string instead in this case
	      transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
	    } else {
	      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
	      matrix = transformMatrix.toString().split(',');
	    }

	    if (axis === 'x') {
	      // Latest Chrome and webkits Fix
	      if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m41; }
	      // Crazy IE10 Matrix
	      else if (matrix.length === 16) { curTransform = parseFloat(matrix[12]); }
	      // Normal Browsers
	      else { curTransform = parseFloat(matrix[4]); }
	    }
	    if (axis === 'y') {
	      // Latest Chrome and webkits Fix
	      if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m42; }
	      // Crazy IE10 Matrix
	      else if (matrix.length === 16) { curTransform = parseFloat(matrix[13]); }
	      // Normal Browsers
	      else { curTransform = parseFloat(matrix[5]); }
	    }
	    return curTransform || 0;
	  },
	  serializeObject: function serializeObject(obj, parents) {
	    if ( parents === void 0 ) parents = [];

	    if (typeof obj === 'string') { return obj; }
	    var resultArray = [];
	    var separator = '&';
	    var newParents;
	    function varName(name) {
	      if (parents.length > 0) {
	        var parentParts = '';
	        for (var j = 0; j < parents.length; j += 1) {
	          if (j === 0) { parentParts += parents[j]; }
	          else { parentParts += "[" + (encodeURIComponent(parents[j])) + "]"; }
	        }
	        return (parentParts + "[" + (encodeURIComponent(name)) + "]");
	      }
	      return encodeURIComponent(name);
	    }
	    function varValue(value) {
	      return encodeURIComponent(value);
	    }
	    Object.keys(obj).forEach(function (prop) {
	      var toPush;
	      if (Array.isArray(obj[prop])) {
	        toPush = [];
	        for (var i = 0; i < obj[prop].length; i += 1) {
	          if (!Array.isArray(obj[prop][i]) && typeof obj[prop][i] === 'object') {
	            newParents = parents.slice();
	            newParents.push(prop);
	            newParents.push(String(i));
	            toPush.push(Utils.serializeObject(obj[prop][i], newParents));
	          } else {
	            toPush.push(((varName(prop)) + "[]=" + (varValue(obj[prop][i]))));
	          }
	        }
	        if (toPush.length > 0) { resultArray.push(toPush.join(separator)); }
	      } else if (obj[prop] === null || obj[prop] === '') {
	        resultArray.push(((varName(prop)) + "="));
	      } else if (typeof obj[prop] === 'object') {
	        // Object, convert to named array
	        newParents = parents.slice();
	        newParents.push(prop);
	        toPush = Utils.serializeObject(obj[prop], newParents);
	        if (toPush !== '') { resultArray.push(toPush); }
	      } else if (typeof obj[prop] !== 'undefined' && obj[prop] !== '') {
	        // Should be string or plain value
	        resultArray.push(((varName(prop)) + "=" + (varValue(obj[prop]))));
	      } else if (obj[prop] === '') { resultArray.push(varName(prop)); }
	    });
	    return resultArray.join(separator);
	  },
	  isObject: function isObject(o) {
	    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
	  },
	  merge: function merge() {
	    var args = [], len$1 = arguments.length;
	    while ( len$1-- ) args[ len$1 ] = arguments[ len$1 ];

	    var to = args[0];
	    args.splice(0, 1);
	    var from = args;

	    for (var i = 0; i < from.length; i += 1) {
	      var nextSource = args[i];
	      if (nextSource !== undefined && nextSource !== null) {
	        var keysArray = Object.keys(Object(nextSource));
	        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
	          var nextKey = keysArray[nextIndex];
	          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
	          if (desc !== undefined && desc.enumerable) {
	            to[nextKey] = nextSource[nextKey];
	          }
	        }
	      }
	    }
	    return to;
	  },
	  extend: function extend() {
	    var args = [], len$1 = arguments.length;
	    while ( len$1-- ) args[ len$1 ] = arguments[ len$1 ];

	    var deep = true;
	    var to;
	    var from;
	    if (typeof args[0] === 'boolean') {
	      deep = args[0];
	      to = args[1];
	      args.splice(0, 2);
	      from = args;
	    } else {
	      to = args[0];
	      args.splice(0, 1);
	      from = args;
	    }
	    for (var i = 0; i < from.length; i += 1) {
	      var nextSource = args[i];
	      if (nextSource !== undefined && nextSource !== null) {
	        var keysArray = Object.keys(Object(nextSource));
	        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
	          var nextKey = keysArray[nextIndex];
	          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
	          if (desc !== undefined && desc.enumerable) {
	            if (!deep) {
	              to[nextKey] = nextSource[nextKey];
	            } else if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
	              Utils.extend(to[nextKey], nextSource[nextKey]);
	            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
	              to[nextKey] = {};
	              Utils.extend(to[nextKey], nextSource[nextKey]);
	            } else {
	              to[nextKey] = nextSource[nextKey];
	            }
	          }
	        }
	      }
	    }
	    return to;
	  },
	  colorHexToRgb: function colorHexToRgb(hex) {
	    var h = hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (m, r, g, b) { return r + r + g + g + b + b; });
	    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);
	    return result
	      ? result.slice(1).map(function (n) { return parseInt(n, 16); })
	      : null;
	  },
	  colorRgbToHex: function colorRgbToHex(r, g, b) {
	    var result = [r, g, b].map(function (n) {
	      var hex = n.toString(16);
	      return hex.length === 1 ? ("0" + hex) : hex;
	    }).join('');
	    return ("#" + result);
	  },
	  colorRgbToHsl: function colorRgbToHsl(r, g, b) {
	    r /= 255; // eslint-disable-line
	    g /= 255; // eslint-disable-line
	    b /= 255; // eslint-disable-line
	    var max = Math.max(r, g, b);
	    var min = Math.min(r, g, b);
	    var d = max - min;
	    var h;
	    if (d === 0) { h = 0; }
	    else if (max === r) { h = ((g - b) / d) % 6; }
	    else if (max === g) { h = (b - r) / d + 2; }
	    else if (max === b) { h = (r - g) / d + 4; }
	    var l = (min + max) / 2;
	    var s = d === 0 ? 0 : d / (1 - Math.abs(2 * l - 1));
	    if (h < 0) { h = 360 / 60 + h; }
	    return [h * 60, s, l];
	  },
	  colorHslToRgb: function colorHslToRgb(h, s, l) {
	    var c = (1 - Math.abs(2 * l - 1)) * s;
	    var hp = h / 60;
	    var x = c * (1 - Math.abs((hp % 2) - 1));
	    var rgb1;
	    if (Number.isNaN(h) || typeof h === 'undefined') {
	      rgb1 = [0, 0, 0];
	    } else if (hp <= 1) { rgb1 = [c, x, 0]; }
	    else if (hp <= 2) { rgb1 = [x, c, 0]; }
	    else if (hp <= 3) { rgb1 = [0, c, x]; }
	    else if (hp <= 4) { rgb1 = [0, x, c]; }
	    else if (hp <= 5) { rgb1 = [x, 0, c]; }
	    else if (hp <= 6) { rgb1 = [c, 0, x]; }
	    var m = l - (c / 2);
	    return rgb1.map(function (n) { return Math.max(0, Math.min(255, Math.round(255 * (n + m)))); });
	  },
	  colorHsbToHsl: function colorHsbToHsl(h, s, b) {
	    var HSL = {
	      h: h,
	      s: 0,
	      l: 0,
	    };
	    var HSB = { h: h, s: s, b: b };

	    HSL.l = (2 - HSB.s) * HSB.b / 2;
	    HSL.s = HSL.l && HSL.l < 1 ? HSB.s * HSB.b / (HSL.l < 0.5 ? HSL.l * 2 : 2 - HSL.l * 2) : HSL.s;

	    return [HSL.h, HSL.s, HSL.l];
	  },
	  colorHslToHsb: function colorHslToHsb(h, s, l) {
	    var HSB = {
	      h: h,
	      s: 0,
	      b: 0,
	    };
	    var HSL = { h: h, s: s, l: l };

	    var t = HSL.s * (HSL.l < 0.5 ? HSL.l : 1 - HSL.l);
	    HSB.b = HSL.l + t;
	    HSB.s = HSL.l > 0 ? 2 * t / HSB.b : HSB.s;

	    return [HSB.h, HSB.s, HSB.b];
	  },
	  colorThemeCSSProperties: function colorThemeCSSProperties() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var hex;
	    var rgb;
	    if (args.length === 1) {
	      hex = args[0];
	      rgb = Utils.colorHexToRgb(hex);
	    } else if (args.length === 3) {
	      rgb = args;
	      hex = Utils.colorRgbToHex.apply(Utils, rgb);
	    }
	    if (!rgb) { return {}; }
	    var hsl = Utils.colorRgbToHsl.apply(Utils, rgb);
	    var hslShade = [hsl[0], hsl[1], Math.max(0, (hsl[2] - 0.08))];
	    var hslTint = [hsl[0], hsl[1], Math.max(0, (hsl[2] + 0.08))];
	    var shade = Utils.colorRgbToHex.apply(Utils, Utils.colorHslToRgb.apply(Utils, hslShade));
	    var tint = Utils.colorRgbToHex.apply(Utils, Utils.colorHslToRgb.apply(Utils, hslTint));
	    return {
	      '--f7-theme-color': hex,
	      '--f7-theme-color-rgb': rgb.join(', '),
	      '--f7-theme-color-shade': shade,
	      '--f7-theme-color-tint': tint,
	    };
	  },
	};

	var Device = (function Device() {
	  var platform = win.navigator.platform;
	  var ua = win.navigator.userAgent;

	  var device = {
	    ios: false,
	    android: false,
	    androidChrome: false,
	    desktop: false,
	    windowsPhone: false,
	    iphone: false,
	    iphoneX: false,
	    ipod: false,
	    ipad: false,
	    edge: false,
	    ie: false,
	    firefox: false,
	    macos: false,
	    windows: false,
	    cordova: !!(win.cordova || win.phonegap),
	    phonegap: !!(win.cordova || win.phonegap),
	    electron: false,
	  };

	  var screenWidth = win.screen.width;
	  var screenHeight = win.screen.height;

	  var windowsPhone = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/); // eslint-disable-line
	  var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
	  var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	  var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	  var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
	  var iphoneX = iphone && (
	    (screenWidth === 375 && screenHeight === 812) // X/XS
	    || (screenWidth === 414 && screenHeight === 896) // XR / XS Max
	  );
	  var ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
	  var edge = ua.indexOf('Edge/') >= 0;
	  var firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;
	  var macos = platform === 'MacIntel';
	  var windows = platform === 'Win32';
	  var electron = ua.toLowerCase().indexOf('electron') >= 0;

	  device.ie = ie;
	  device.edge = edge;
	  device.firefox = firefox;

	  // Windows
	  if (windowsPhone) {
	    device.os = 'windowsPhone';
	    device.osVersion = windowsPhone[2];
	    device.windowsPhone = true;
	  }
	  // Android
	  if (android && !windows) {
	    device.os = 'android';
	    device.osVersion = android[2];
	    device.android = true;
	    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
	  }
	  if (ipad || iphone || ipod) {
	    device.os = 'ios';
	    device.ios = true;
	  }
	  // iOS
	  if (iphone && !ipod) {
	    device.osVersion = iphone[2].replace(/_/g, '.');
	    device.iphone = true;
	    device.iphoneX = iphoneX;
	  }
	  if (ipad) {
	    device.osVersion = ipad[2].replace(/_/g, '.');
	    device.ipad = true;
	  }
	  if (ipod) {
	    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	    device.ipod = true;
	  }
	  // iOS 8+ changed UA
	  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
	    if (device.osVersion.split('.')[0] === '10') {
	      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
	    }
	  }

	  // Webview
	  device.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || win.navigator.standalone))
	    || (win.matchMedia && win.matchMedia('(display-mode: standalone)').matches);
	  device.webview = device.webView;
	  device.standalone = device.webView;

	  // Desktop
	  device.desktop = !(device.ios || device.android || device.windowsPhone) || electron;
	  if (device.desktop) {
	    device.electron = electron;
	    device.macos = macos;
	    device.windows = windows;
	  }

	  // Meta statusbar
	  var metaStatusbar = doc.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');

	  // Check for status bar and fullscreen app mode
	  device.needsStatusbarOverlay = function needsStatusbarOverlay() {
	    if (device.desktop) { return false; }
	    if (device.standalone && device.ios && metaStatusbar && metaStatusbar.content === 'black-translucent') {
	      return true;
	    }
	    if ((device.webView || (device.android && device.cordova)) && (win.innerWidth * win.innerHeight === win.screen.width * win.screen.height)) {
	      if (device.iphoneX && (win.orientation === 90 || win.orientation === -90)) {
	        return false;
	      }
	      return true;
	    }
	    return false;
	  };
	  device.statusbar = device.needsStatusbarOverlay();

	  // Pixel Ratio
	  device.pixelRatio = win.devicePixelRatio || 1;

	  // Color Scheme
	  var DARK = '(prefers-color-scheme: dark)';
	  var LIGHT = '(prefers-color-scheme: light)';
	  device.prefersColorScheme = function prefersColorTheme() {
	    var theme;
	    if (win.matchMedia && win.matchMedia(LIGHT).matches) {
	      theme = 'light';
	    }
	    if (win.matchMedia && win.matchMedia(DARK).matches) {
	      theme = 'dark';
	    }
	    return theme;
	  };

	  // Export object
	  return device;
	}());

	var EventsClass = function EventsClass(parents) {
	  if ( parents === void 0 ) parents = [];

	  var self = this;
	  self.eventsParents = parents;
	  self.eventsListeners = {};
	};

	EventsClass.prototype.on = function on (events, handler, priority) {
	  var self = this;
	  if (typeof handler !== 'function') { return self; }
	  var method = priority ? 'unshift' : 'push';
	  events.split(' ').forEach(function (event) {
	    if (!self.eventsListeners[event]) { self.eventsListeners[event] = []; }
	    self.eventsListeners[event][method](handler);
	  });
	  return self;
	};

	EventsClass.prototype.once = function once (events, handler, priority) {
	  var self = this;
	  if (typeof handler !== 'function') { return self; }
	  function onceHandler() {
	      var args = [], len = arguments.length;
	      while ( len-- ) args[ len ] = arguments[ len ];

	    handler.apply(self, args);
	    self.off(events, onceHandler);
	    if (onceHandler.f7proxy) {
	      delete onceHandler.f7proxy;
	    }
	  }
	  onceHandler.f7proxy = handler;
	  return self.on(events, onceHandler, priority);
	};

	EventsClass.prototype.off = function off (events, handler) {
	  var self = this;
	  if (!self.eventsListeners) { return self; }
	  events.split(' ').forEach(function (event) {
	    if (typeof handler === 'undefined') {
	      self.eventsListeners[event] = [];
	    } else if (self.eventsListeners[event]) {
	      self.eventsListeners[event].forEach(function (eventHandler, index) {
	        if (eventHandler === handler || (eventHandler.f7proxy && eventHandler.f7proxy === handler)) {
	          self.eventsListeners[event].splice(index, 1);
	        }
	      });
	    }
	  });
	  return self;
	};

	EventsClass.prototype.emit = function emit () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	  var self = this;
	  if (!self.eventsListeners) { return self; }
	  var events;
	  var data;
	  var context;
	  var eventsParents;
	  if (typeof args[0] === 'string' || Array.isArray(args[0])) {
	    events = args[0];
	    data = args.slice(1, args.length);
	    context = self;
	    eventsParents = self.eventsParents;
	  } else {
	    events = args[0].events;
	    data = args[0].data;
	    context = args[0].context || self;
	    eventsParents = args[0].local ? [] : args[0].parents || self.eventsParents;
	  }
	  var eventsArray = Array.isArray(events) ? events : events.split(' ');
	  var localEvents = eventsArray.map(function (eventName) { return eventName.replace('local::', ''); });
	  var parentEvents = eventsArray.filter(function (eventName) { return eventName.indexOf('local::') < 0; });

	  localEvents.forEach(function (event) {
	    if (self.eventsListeners && self.eventsListeners[event]) {
	      var handlers = [];
	      self.eventsListeners[event].forEach(function (eventHandler) {
	        handlers.push(eventHandler);
	      });
	      handlers.forEach(function (eventHandler) {
	        eventHandler.apply(context, data);
	      });
	    }
	  });
	  if (eventsParents && eventsParents.length > 0) {
	    eventsParents.forEach(function (eventsParent) {
	      eventsParent.emit.apply(eventsParent, [ parentEvents ].concat( data ));
	    });
	  }
	  return self;
	};

	var Framework7Class = /*@__PURE__*/(function (EventsClass) {
	  function Framework7Class(params, parents) {
	    if ( params === void 0 ) params = {};
	    if ( parents === void 0 ) parents = [];

	    EventsClass.call(this, parents);
	    var self = this;
	    self.params = params;

	    if (self.params && self.params.on) {
	      Object.keys(self.params.on).forEach(function (eventName) {
	        self.on(eventName, self.params.on[eventName]);
	      });
	    }
	  }

	  if ( EventsClass ) Framework7Class.__proto__ = EventsClass;
	  Framework7Class.prototype = Object.create( EventsClass && EventsClass.prototype );
	  Framework7Class.prototype.constructor = Framework7Class;

	  var staticAccessors = { components: { configurable: true } };

	  // eslint-disable-next-line
	  Framework7Class.prototype.useModuleParams = function useModuleParams (module, instanceParams) {
	    if (module.params) {
	      var originalParams = {};
	      Object.keys(module.params).forEach(function (paramKey) {
	        if (typeof instanceParams[paramKey] === 'undefined') { return; }
	        originalParams[paramKey] = Utils.extend({}, instanceParams[paramKey]);
	      });
	      Utils.extend(instanceParams, module.params);
	      Object.keys(originalParams).forEach(function (paramKey) {
	        Utils.extend(instanceParams[paramKey], originalParams[paramKey]);
	      });
	    }
	  };

	  Framework7Class.prototype.useModulesParams = function useModulesParams (instanceParams) {
	    var instance = this;
	    if (!instance.modules) { return; }
	    Object.keys(instance.modules).forEach(function (moduleName) {
	      var module = instance.modules[moduleName];
	      // Extend params
	      if (module.params) {
	        Utils.extend(instanceParams, module.params);
	      }
	    });
	  };

	  Framework7Class.prototype.useModule = function useModule (moduleName, moduleParams) {
	    if ( moduleName === void 0 ) moduleName = '';
	    if ( moduleParams === void 0 ) moduleParams = {};

	    var instance = this;
	    if (!instance.modules) { return; }
	    var module = typeof moduleName === 'string' ? instance.modules[moduleName] : moduleName;
	    if (!module) { return; }

	    // Extend instance methods and props
	    if (module.instance) {
	      Object.keys(module.instance).forEach(function (modulePropName) {
	        var moduleProp = module.instance[modulePropName];
	        if (typeof moduleProp === 'function') {
	          instance[modulePropName] = moduleProp.bind(instance);
	        } else {
	          instance[modulePropName] = moduleProp;
	        }
	      });
	    }
	    // Add event listeners
	    if (module.on && instance.on) {
	      Object.keys(module.on).forEach(function (moduleEventName) {
	        instance.on(moduleEventName, module.on[moduleEventName]);
	      });
	    }
	    // Add vnode hooks
	    if (module.vnode) {
	      if (!instance.vnodeHooks) { instance.vnodeHooks = {}; }
	      Object.keys(module.vnode).forEach(function (vnodeId) {
	        Object.keys(module.vnode[vnodeId]).forEach(function (hookName) {
	          var handler = module.vnode[vnodeId][hookName];
	          if (!instance.vnodeHooks[hookName]) { instance.vnodeHooks[hookName] = {}; }
	          if (!instance.vnodeHooks[hookName][vnodeId]) { instance.vnodeHooks[hookName][vnodeId] = []; }
	          instance.vnodeHooks[hookName][vnodeId].push(handler.bind(instance));
	        });
	      });
	    }
	    // Module create callback
	    if (module.create) {
	      module.create.bind(instance)(moduleParams);
	    }
	  };

	  Framework7Class.prototype.useModules = function useModules (modulesParams) {
	    if ( modulesParams === void 0 ) modulesParams = {};

	    var instance = this;
	    if (!instance.modules) { return; }
	    Object.keys(instance.modules).forEach(function (moduleName) {
	      var moduleParams = modulesParams[moduleName] || {};
	      instance.useModule(moduleName, moduleParams);
	    });
	  };

	  staticAccessors.components.set = function (components) {
	    var Class = this;
	    if (!Class.use) { return; }
	    Class.use(components);
	  };

	  Framework7Class.installModule = function installModule (module) {
	    var params = [], len = arguments.length - 1;
	    while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];

	    var Class = this;
	    if (!Class.prototype.modules) { Class.prototype.modules = {}; }
	    var name = module.name || (((Object.keys(Class.prototype.modules).length) + "_" + (Utils.now())));
	    Class.prototype.modules[name] = module;
	    // Prototype
	    if (module.proto) {
	      Object.keys(module.proto).forEach(function (key) {
	        Class.prototype[key] = module.proto[key];
	      });
	    }
	    // Class
	    if (module.static) {
	      Object.keys(module.static).forEach(function (key) {
	        Class[key] = module.static[key];
	      });
	    }
	    // Callback
	    if (module.install) {
	      module.install.apply(Class, params);
	    }
	    return Class;
	  };

	  Framework7Class.use = function use (module) {
	    var params = [], len = arguments.length - 1;
	    while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];

	    var Class = this;
	    if (Array.isArray(module)) {
	      module.forEach(function (m) { return Class.installModule(m); });
	      return Class;
	    }
	    return Class.installModule.apply(Class, [ module ].concat( params ));
	  };

	  Object.defineProperties( Framework7Class, staticAccessors );

	  return Framework7Class;
	}(EventsClass));

	function ConstructorMethods (parameters) {
	  if ( parameters === void 0 ) parameters = {};

	  var defaultSelector = parameters.defaultSelector;
	  var constructor = parameters.constructor;
	  var domProp = parameters.domProp;
	  var app = parameters.app;
	  var addMethods = parameters.addMethods;
	  var methods = {
	    create: function create() {
	      var args = [], len = arguments.length;
	      while ( len-- ) args[ len ] = arguments[ len ];

	      if (app) { return new (Function.prototype.bind.apply( constructor, [ null ].concat( [app], args) )); }
	      return new (Function.prototype.bind.apply( constructor, [ null ].concat( args) ));
	    },
	    get: function get(el) {
	      if ( el === void 0 ) el = defaultSelector;

	      if (el instanceof constructor) { return el; }
	      var $el = $(el);
	      if ($el.length === 0) { return undefined; }
	      return $el[0][domProp];
	    },
	    destroy: function destroy(el) {
	      var instance = methods.get(el);
	      if (instance && instance.destroy) { return instance.destroy(); }
	      return undefined;
	    },
	  };
	  if (addMethods && Array.isArray(addMethods)) {
	    addMethods.forEach(function (methodName) {
	      methods[methodName] = function (el) {
	        if ( el === void 0 ) el = defaultSelector;
	        var args = [], len = arguments.length - 1;
	        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	        var instance = methods.get(el);
	        if (instance && instance[methodName]) { return instance[methodName].apply(instance, args); }
	        return undefined;
	      };
	    });
	  }
	  return methods;
	}

	function ModalMethods (parameters) {
	  if ( parameters === void 0 ) parameters = {};

	  var defaultSelector = parameters.defaultSelector;
	  var constructor = parameters.constructor;
	  var app = parameters.app;
	  var methods = Utils.extend(
	    ConstructorMethods({
	      defaultSelector: defaultSelector,
	      constructor: constructor,
	      app: app,
	      domProp: 'f7Modal',
	    }),
	    {
	      open: function open(el, animate) {
	        var $el = $(el);
	        var instance = $el[0].f7Modal;
	        if (!instance) { instance = new constructor(app, { el: $el }); }
	        return instance.open(animate);
	      },
	      close: function close(el, animate) {
	        if ( el === void 0 ) el = defaultSelector;

	        var $el = $(el);
	        if ($el.length === 0) { return undefined; }
	        var instance = $el[0].f7Modal;
	        if (!instance) { instance = new constructor(app, { el: $el }); }
	        return instance.close(animate);
	      },
	    }
	  );
	  return methods;
	}

	var fetchedModules = [];
	function loadModule(moduleToLoad) {
	  var Framework7 = this;
	  return new Promise(function (resolve, reject) {
	    var app = Framework7.instance;
	    var modulePath;
	    var moduleObj;
	    var moduleFunc;
	    if (!moduleToLoad) {
	      reject(new Error('Framework7: Lazy module must be specified'));
	      return;
	    }

	    function install(module) {
	      Framework7.use(module);

	      if (app) {
	        app.useModuleParams(module, app.params);
	        app.useModule(module);
	      }
	    }

	    if (typeof moduleToLoad === 'string') {
	      var matchNamePattern = moduleToLoad.match(/([a-z0-9-]*)/i);
	      if (moduleToLoad.indexOf('.') < 0 && matchNamePattern && matchNamePattern[0].length === moduleToLoad.length) {
	        if (!app || (app && !app.params.lazyModulesPath)) {
	          reject(new Error('Framework7: "lazyModulesPath" app parameter must be specified to fetch module by name'));
	          return;
	        }
	        modulePath = (app.params.lazyModulesPath) + "/" + moduleToLoad + ".js";
	      } else {
	        modulePath = moduleToLoad;
	      }
	    } else if (typeof moduleToLoad === 'function') {
	      moduleFunc = moduleToLoad;
	    } else {
	      // considering F7-Plugin object
	      moduleObj = moduleToLoad;
	    }

	    if (moduleFunc) {
	      var module = moduleFunc(Framework7, false);
	      if (!module) {
	        reject(new Error('Framework7: Can\'t find Framework7 component in specified component function'));
	        return;
	      }
	      // Check if it was added
	      if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
	        resolve();
	        return;
	      }
	      // Install It
	      install(module);

	      resolve();
	    }
	    if (moduleObj) {
	      var module$1 = moduleObj;
	      if (!module$1) {
	        reject(new Error('Framework7: Can\'t find Framework7 component in specified component'));
	        return;
	      }
	      // Check if it was added
	      if (Framework7.prototype.modules && Framework7.prototype.modules[module$1.name]) {
	        resolve();
	        return;
	      }
	      // Install It
	      install(module$1);

	      resolve();
	    }
	    if (modulePath) {
	      if (fetchedModules.indexOf(modulePath) >= 0) {
	        resolve();
	        return;
	      }
	      fetchedModules.push(modulePath);
	      var scriptLoad = new Promise(function (resolveScript, rejectScript) {
	        Framework7.request.get(
	          modulePath,
	          function (scriptContent) {
	            var id = Utils.id();
	            var callbackLoadName = "f7_component_loader_callback_" + id;

	            var scriptEl = document.createElement('script');
	            scriptEl.innerHTML = "window." + callbackLoadName + " = function (Framework7, Framework7AutoInstallComponent) {return " + (scriptContent.trim()) + "}";
	            $('head').append(scriptEl);

	            var componentLoader = window[callbackLoadName];
	            delete window[callbackLoadName];
	            $(scriptEl).remove();

	            var module = componentLoader(Framework7, false);

	            if (!module) {
	              rejectScript(new Error(("Framework7: Can't find Framework7 component in " + modulePath + " file")));
	              return;
	            }

	            // Check if it was added
	            if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
	              resolveScript();
	              return;
	            }

	            // Install It
	            install(module);

	            resolveScript();
	          },
	          function (xhr, status) {
	            rejectScript(xhr, status);
	          }
	        );
	      });
	      var styleLoad = new Promise(function (resolveStyle) {
	        Framework7.request.get(
	          modulePath.replace('.js', app.rtl ? '.rtl.css' : '.css'),
	          function (styleContent) {
	            var styleEl = document.createElement('style');
	            styleEl.innerHTML = styleContent;
	            $('head').append(styleEl);

	            resolveStyle();
	          },
	          function () {
	            resolveStyle();
	          }
	        );
	      });

	      Promise.all([scriptLoad, styleLoad]).then(function () {
	        resolve();
	      }).catch(function (err) {
	        reject(err);
	      });
	    }
	  });
	}

	var Framework7 = /*@__PURE__*/(function (Framework7Class) {
	  function Framework7(params) {
	    Framework7Class.call(this, params);
	    if (Framework7.instance) {
	      throw new Error('Framework7 is already initialized and can\'t be initialized more than once');
	    }

	    var passedParams = Utils.extend({}, params);

	    // App Instance
	    var app = this;

	    Framework7.instance = app;

	    // Default
	    var defaults = {
	      version: '1.0.0',
	      id: 'io.framework7.testapp',
	      root: 'body',
	      theme: 'auto',
	      language: win.navigator.language,
	      routes: [],
	      name: 'Framework7',
	      lazyModulesPath: null,
	      initOnDeviceReady: true,
	      init: true,
	      autoDarkTheme: false,
	    };

	    // Extend defaults with modules params
	    app.useModulesParams(defaults);

	    // Extend defaults with passed params
	    app.params = Utils.extend(defaults, params);

	    var $rootEl = $(app.params.root);

	    Utils.extend(app, {
	      // App Id
	      id: app.params.id,
	      // App Name
	      name: app.params.name,
	      // App version
	      version: app.params.version,
	      // Routes
	      routes: app.params.routes,
	      // Lang
	      language: app.params.language,
	      // Root
	      root: $rootEl,
	      // RTL
	      rtl: $rootEl.css('direction') === 'rtl',
	      // Theme
	      theme: (function getTheme() {
	        if (app.params.theme === 'auto') {
	          if (Device.ios) { return 'ios'; }
	          if (Device.desktop && Device.electron) { return 'aurora'; }
	          return 'md';
	        }
	        return app.params.theme;
	      }()),
	      // Initially passed parameters
	      passedParams: passedParams,
	    });

	    // Save Root
	    if (app.root && app.root[0]) {
	      app.root[0].f7 = app;
	    }

	    // Install Modules
	    app.useModules();

	    // Init Data & Methods
	    app.initData();

	    // Auto Dark Theme
	    var DARK = '(prefers-color-scheme: dark)';
	    var LIGHT = '(prefers-color-scheme: light)';
	    app.mq = {};
	    if (win.matchMedia) {
	      app.mq.dark = win.matchMedia(DARK);
	      app.mq.light = win.matchMedia(LIGHT);
	    }
	    app.colorSchemeListener = function colorSchemeListener(ref) {
	      var matches = ref.matches;
	      var media = ref.media;

	      if (!matches) {
	        return;
	      }
	      var html = doc.querySelector('html');
	      if (media === DARK) {
	        html.classList.add('theme-dark');
	      } else if (media === LIGHT) {
	        html.classList.remove('theme-dark');
	      }
	    };
	    // Init
	    if (app.params.init) {
	      if (Device.cordova && app.params.initOnDeviceReady) {
	        $(doc).on('deviceready', function () {
	          app.init();
	        });
	      } else {
	        app.init();
	      }
	    }
	    // Return app instance
	    return app;
	  }

	  if ( Framework7Class ) Framework7.__proto__ = Framework7Class;
	  Framework7.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  Framework7.prototype.constructor = Framework7;

	  var prototypeAccessors = { $: { configurable: true },t7: { configurable: true } };
	  var staticAccessors = { Dom7: { configurable: true },$: { configurable: true },Template7: { configurable: true },Class: { configurable: true },Events: { configurable: true } };

	  Framework7.prototype.initData = function initData () {
	    var app = this;

	    // Data
	    app.data = {};
	    if (app.params.data && typeof app.params.data === 'function') {
	      Utils.extend(app.data, app.params.data.bind(app)());
	    } else if (app.params.data) {
	      Utils.extend(app.data, app.params.data);
	    }
	    // Methods
	    app.methods = {};
	    if (app.params.methods) {
	      Object.keys(app.params.methods).forEach(function (methodName) {
	        if (typeof app.params.methods[methodName] === 'function') {
	          app.methods[methodName] = app.params.methods[methodName].bind(app);
	        } else {
	          app.methods[methodName] = app.params.methods[methodName];
	        }
	      });
	    }
	  };

	  Framework7.prototype.enableAutoDarkTheme = function enableAutoDarkTheme () {
	    if (!win.matchMedia) { return; }
	    var app = this;
	    var html = doc.querySelector('html');
	    if (app.mq.dark && app.mq.light) {
	      app.mq.dark.addListener(app.colorSchemeListener);
	      app.mq.light.addListener(app.colorSchemeListener);
	    }
	    if (app.mq.dark && app.mq.dark.matches) {
	      html.classList.add('theme-dark');
	    } else if (app.mq.light && app.mq.light.matches) {
	      html.classList.remove('theme-dark');
	    }
	  };

	  Framework7.prototype.disableAutoDarkTheme = function disableAutoDarkTheme () {
	    if (!win.matchMedia) { return; }
	    var app = this;
	    if (app.mq.dark) { app.mq.dark.removeListener(app.colorSchemeListener); }
	    if (app.mq.light) { app.mq.light.removeListener(app.colorSchemeListener); }
	  };

	  Framework7.prototype.init = function init () {
	    var app = this;
	    if (app.initialized) { return app; }

	    app.root.addClass('framework7-initializing');

	    // RTL attr
	    if (app.rtl) {
	      $('html').attr('dir', 'rtl');
	    }

	    // Auto Dark Theme
	    if (app.params.autoDarkTheme) {
	      app.enableAutoDarkTheme();
	    }

	    // Root class
	    app.root.addClass('framework7-root');

	    // Theme class
	    $('html').removeClass('ios md').addClass(app.theme);

	    // Init class
	    Utils.nextFrame(function () {
	      app.root.removeClass('framework7-initializing');
	    });
	    // Emit, init other modules
	    app.initialized = true;
	    app.emit('init');

	    return app;
	  };

	  // eslint-disable-next-line
	  Framework7.prototype.loadModule = function loadModule () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return Framework7.loadModule.apply(Framework7, args);
	  };

	  // eslint-disable-next-line
	  Framework7.prototype.loadModules = function loadModules () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return Framework7.loadModules.apply(Framework7, args);
	  };

	  Framework7.prototype.getVnodeHooks = function getVnodeHooks (hook, id) {
	    var app = this;
	    if (!app.vnodeHooks || !app.vnodeHooks[hook]) { return []; }
	    return app.vnodeHooks[hook][id] || [];
	  };

	  // eslint-disable-next-line
	  prototypeAccessors.$.get = function () {
	    return $;
	  };
	  // eslint-disable-next-line
	  prototypeAccessors.t7.get = function () {
	    return Template7;
	  };

	  staticAccessors.Dom7.get = function () {
	    return $;
	  };

	  staticAccessors.$.get = function () {
	    return $;
	  };

	  staticAccessors.Template7.get = function () {
	    return Template7;
	  };

	  staticAccessors.Class.get = function () {
	    return Framework7Class;
	  };

	  staticAccessors.Events.get = function () {
	    return EventsClass;
	  };

	  Object.defineProperties( Framework7.prototype, prototypeAccessors );
	  Object.defineProperties( Framework7, staticAccessors );

	  return Framework7;
	}(Framework7Class));

	Framework7.ModalMethods = ModalMethods;
	Framework7.ConstructorMethods = ConstructorMethods;

	Framework7.loadModule = loadModule;
	Framework7.loadModules = function loadModules(modules) {
	  return Promise.all(modules.map(function (module) { return Framework7.loadModule(module); }));
	};

	var globals = {};
	var jsonpRequests = 0;

	function Request(requestOptions) {
	  var globalsNoCallbacks = Utils.extend({}, globals);
	  ('beforeCreate beforeOpen beforeSend error complete success statusCode').split(' ').forEach(function (callbackName) {
	    delete globalsNoCallbacks[callbackName];
	  });
	  var defaults = Utils.extend({
	    url: win.location.toString(),
	    method: 'GET',
	    data: false,
	    async: true,
	    cache: true,
	    user: '',
	    password: '',
	    headers: {},
	    xhrFields: {},
	    statusCode: {},
	    processData: true,
	    dataType: 'text',
	    contentType: 'application/x-www-form-urlencoded',
	    timeout: 0,
	  }, globalsNoCallbacks);

	  var options = Utils.extend({}, defaults, requestOptions);
	  var proceedRequest;

	  // Function to run XHR callbacks and events
	  function fireCallback(callbackName) {
	    var data = [], len = arguments.length - 1;
	    while ( len-- > 0 ) data[ len ] = arguments[ len + 1 ];

	    /*
	      Callbacks:
	      beforeCreate (options),
	      beforeOpen (xhr, options),
	      beforeSend (xhr, options),
	      error (xhr, status),
	      complete (xhr, stautus),
	      success (response, status, xhr),
	      statusCode ()
	    */
	    var globalCallbackValue;
	    var optionCallbackValue;
	    if (globals[callbackName]) {
	      globalCallbackValue = globals[callbackName].apply(globals, data);
	    }
	    if (options[callbackName]) {
	      optionCallbackValue = options[callbackName].apply(options, data);
	    }
	    if (typeof globalCallbackValue !== 'boolean') { globalCallbackValue = true; }
	    if (typeof optionCallbackValue !== 'boolean') { optionCallbackValue = true; }
	    return (globalCallbackValue && optionCallbackValue);
	  }

	  // Before create callback
	  proceedRequest = fireCallback('beforeCreate', options);
	  if (proceedRequest === false) { return undefined; }

	  // For jQuery guys
	  if (options.type) { options.method = options.type; }

	  // Parameters Prefix
	  var paramsPrefix = options.url.indexOf('?') >= 0 ? '&' : '?';

	  // UC method
	  var method = options.method.toUpperCase();

	  // Data to modify GET URL
	  if ((method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') && options.data) {
	    var stringData;
	    if (typeof options.data === 'string') {
	      // Should be key=value string
	      if (options.data.indexOf('?') >= 0) { stringData = options.data.split('?')[1]; }
	      else { stringData = options.data; }
	    } else {
	      // Should be key=value object
	      stringData = Utils.serializeObject(options.data);
	    }
	    if (stringData.length) {
	      options.url += paramsPrefix + stringData;
	      if (paramsPrefix === '?') { paramsPrefix = '&'; }
	    }
	  }

	  // JSONP
	  if (options.dataType === 'json' && options.url.indexOf('callback=') >= 0) {
	    var callbackName = "f7jsonp_" + (Date.now() + ((jsonpRequests += 1)));
	    var abortTimeout;
	    var callbackSplit = options.url.split('callback=');
	    var requestUrl = (callbackSplit[0]) + "callback=" + callbackName;
	    if (callbackSplit[1].indexOf('&') >= 0) {
	      var addVars = callbackSplit[1].split('&').filter(function (el) { return el.indexOf('=') > 0; }).join('&');
	      if (addVars.length > 0) { requestUrl += "&" + addVars; }
	    }

	    // Create script
	    var script = doc.createElement('script');
	    script.type = 'text/javascript';
	    script.onerror = function onerror() {
	      clearTimeout(abortTimeout);
	      fireCallback('error', null, 'scripterror');
	      fireCallback('complete', null, 'scripterror');
	    };
	    script.src = requestUrl;

	    // Handler
	    win[callbackName] = function jsonpCallback(data) {
	      clearTimeout(abortTimeout);
	      fireCallback('success', data);
	      script.parentNode.removeChild(script);
	      script = null;
	      delete win[callbackName];
	    };
	    doc.querySelector('head').appendChild(script);

	    if (options.timeout > 0) {
	      abortTimeout = setTimeout(function () {
	        script.parentNode.removeChild(script);
	        script = null;
	        fireCallback('error', null, 'timeout');
	      }, options.timeout);
	    }

	    return undefined;
	  }

	  // Cache for GET/HEAD requests
	  if (method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') {
	    if (options.cache === false) {
	      options.url += paramsPrefix + "_nocache" + (Date.now());
	    }
	  }

	  // Create XHR
	  var xhr = new XMLHttpRequest();

	  // Save Request URL
	  xhr.requestUrl = options.url;
	  xhr.requestParameters = options;

	  // Before open callback
	  proceedRequest = fireCallback('beforeOpen', xhr, options);
	  if (proceedRequest === false) { return xhr; }

	  // Open XHR
	  xhr.open(method, options.url, options.async, options.user, options.password);

	  // Create POST Data
	  var postData = null;

	  if ((method === 'POST' || method === 'PUT' || method === 'PATCH') && options.data) {
	    if (options.processData) {
	      var postDataInstances = [ArrayBuffer, Blob, Document, FormData];
	      // Post Data
	      if (postDataInstances.indexOf(options.data.constructor) >= 0) {
	        postData = options.data;
	      } else {
	        // POST Headers
	        var boundary = "---------------------------" + (Date.now().toString(16));

	        if (options.contentType === 'multipart/form-data') {
	          xhr.setRequestHeader('Content-Type', ("multipart/form-data; boundary=" + boundary));
	        } else {
	          xhr.setRequestHeader('Content-Type', options.contentType);
	        }
	        postData = '';
	        var data$1 = Utils.serializeObject(options.data);
	        if (options.contentType === 'multipart/form-data') {
	          data$1 = data$1.split('&');
	          var newData = [];
	          for (var i = 0; i < data$1.length; i += 1) {
	            newData.push(("Content-Disposition: form-data; name=\"" + (data$1[i].split('=')[0]) + "\"\r\n\r\n" + (data$1[i].split('=')[1]) + "\r\n"));
	          }
	          postData = "--" + boundary + "\r\n" + (newData.join(("--" + boundary + "\r\n"))) + "--" + boundary + "--\r\n";
	        } else if (options.contentType === 'application/json') {
	          postData = JSON.stringify(options.data);
	        } else {
	          postData = data$1;
	        }
	      }
	    } else {
	      postData = options.data;
	      xhr.setRequestHeader('Content-Type', options.contentType);
	    }
	  }
	  if (options.dataType === 'json' && (!options.headers || !options.headers.Accept)) {
	    xhr.setRequestHeader('Accept', 'application/json');
	  }

	  // Additional headers
	  if (options.headers) {
	    Object.keys(options.headers).forEach(function (headerName) {
	      xhr.setRequestHeader(headerName, options.headers[headerName]);
	    });
	  }

	  // Check for crossDomain
	  if (typeof options.crossDomain === 'undefined') {
	    // eslint-disable-next-line
	    options.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(options.url) && RegExp.$2 !== win.location.host;
	  }

	  if (!options.crossDomain) {
	    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
	  }

	  if (options.xhrFields) {
	    Utils.extend(xhr, options.xhrFields);
	  }

	  var xhrTimeout;

	  // Handle XHR
	  xhr.onload = function onload() {
	    if (xhrTimeout) { clearTimeout(xhrTimeout); }
	    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 0) {
	      var responseData;
	      if (options.dataType === 'json') {
	        var parseError;
	        try {
	          responseData = JSON.parse(xhr.responseText);
	        } catch (err) {
	          parseError = true;
	        }
	        if (!parseError) {
	          fireCallback('success', responseData, xhr.status, xhr);
	        } else {
	          fireCallback('error', xhr, 'parseerror');
	        }
	      } else {
	        responseData = xhr.responseType === 'text' || xhr.responseType === '' ? xhr.responseText : xhr.response;
	        fireCallback('success', responseData, xhr.status, xhr);
	      }
	    } else {
	      fireCallback('error', xhr, xhr.status);
	    }
	    if (options.statusCode) {
	      if (globals.statusCode && globals.statusCode[xhr.status]) { globals.statusCode[xhr.status](xhr); }
	      if (options.statusCode[xhr.status]) { options.statusCode[xhr.status](xhr); }
	    }
	    fireCallback('complete', xhr, xhr.status);
	  };

	  xhr.onerror = function onerror() {
	    if (xhrTimeout) { clearTimeout(xhrTimeout); }
	    fireCallback('error', xhr, xhr.status);
	    fireCallback('complete', xhr, 'error');
	  };

	  // Timeout
	  if (options.timeout > 0) {
	    xhr.onabort = function onabort() {
	      if (xhrTimeout) { clearTimeout(xhrTimeout); }
	    };
	    xhrTimeout = setTimeout(function () {
	      xhr.abort();
	      fireCallback('error', xhr, 'timeout');
	      fireCallback('complete', xhr, 'timeout');
	    }, options.timeout);
	  }

	  // Ajax start callback
	  proceedRequest = fireCallback('beforeSend', xhr, options);
	  if (proceedRequest === false) { return xhr; }

	  // Send XHR
	  xhr.send(postData);

	  // Return XHR object
	  return xhr;
	}
	function RequestShortcut(method) {
	  var assign, assign$1;

	  var args = [], len = arguments.length - 1;
	  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
	  var ref = [];
	  var url = ref[0];
	  var data = ref[1];
	  var success = ref[2];
	  var error = ref[3];
	  var dataType = ref[4];
	  if (typeof args[1] === 'function') {
	    (assign = args, url = assign[0], success = assign[1], error = assign[2], dataType = assign[3]);
	  } else {
	    (assign$1 = args, url = assign$1[0], data = assign$1[1], success = assign$1[2], error = assign$1[3], dataType = assign$1[4]);
	  }
	  [success, error].forEach(function (callback) {
	    if (typeof callback === 'string') {
	      dataType = callback;
	      if (callback === success) { success = undefined; }
	      else { error = undefined; }
	    }
	  });
	  dataType = dataType || (method === 'json' || method === 'postJSON' ? 'json' : undefined);
	  var requestOptions = {
	    url: url,
	    method: method === 'post' || method === 'postJSON' ? 'POST' : 'GET',
	    data: data,
	    success: success,
	    error: error,
	    dataType: dataType,
	  };
	  if (method === 'postJSON') {
	    Utils.extend(requestOptions, {
	      contentType: 'application/json',
	      processData: false,
	      crossDomain: true,
	      data: typeof data === 'string' ? data : JSON.stringify(data),
	    });
	  }
	  return Request(requestOptions);
	}
	function RequestShortcutPromise(method) {
	  var args = [], len = arguments.length - 1;
	  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	  var url = args[0];
	  var data = args[1];
	  var dataType = args[2];
	  return new Promise(function (resolve, reject) {
	    RequestShortcut(
	      method,
	      url,
	      data,
	      function (response) {
	        resolve(response);
	      },
	      function (xhr, status) {
	        reject(status);
	      },
	      dataType
	    );
	  });
	}
	Object.assign(Request, {
	  get: function () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return RequestShortcut.apply(void 0, [ 'get' ].concat( args ));
	},
	  post: function () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return RequestShortcut.apply(void 0, [ 'post' ].concat( args ));
	},
	  json: function () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return RequestShortcut.apply(void 0, [ 'json' ].concat( args ));
	},
	  getJSON: function () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return RequestShortcut.apply(void 0, [ 'json' ].concat( args ));
	},
	  postJSON: function () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return RequestShortcut.apply(void 0, [ 'postJSON' ].concat( args ));
	},
	});

	Request.promise = function requestPromise(requestOptions) {
	  return new Promise(function (resolve, reject) {
	    Request(Object.assign(requestOptions, {
	      success: function success(data) {
	        resolve(data);
	      },
	      error: function error(xhr, status) {
	        reject(status);
	      },
	    }));
	  });
	};
	Object.assign(Request.promise, {
	  get: function () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return RequestShortcutPromise.apply(void 0, [ 'get' ].concat( args ));
	},
	  post: function () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return RequestShortcutPromise.apply(void 0, [ 'post' ].concat( args ));
	},
	  json: function () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return RequestShortcutPromise.apply(void 0, [ 'json' ].concat( args ));
	},
	  getJSON: function () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return RequestShortcutPromise.apply(void 0, [ 'json' ].concat( args ));
	},
	  postJSON: function () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return RequestShortcutPromise.apply(void 0, [ 'postJSON' ].concat( args ));
	},
	});

	Request.setup = function setup(options) {
	  if (options.type && !options.method) {
	    Utils.extend(options, { method: options.type });
	  }
	  Utils.extend(globals, options);
	};

	var Support = (function Support() {
	  var testDiv = doc.createElement('div');

	  return {
	    touch: (function checkTouch() {
	      return !!((win.navigator.maxTouchPoints > 0) || ('ontouchstart' in win) || (win.DocumentTouch && doc instanceof win.DocumentTouch));
	    }()),

	    pointerEvents: !!(win.navigator.pointerEnabled || win.PointerEvent || ('maxTouchPoints' in win.navigator && win.navigator.maxTouchPoints > 0)),
	    prefixedPointerEvents: !!win.navigator.msPointerEnabled,

	    transition: (function checkTransition() {
	      var style = testDiv.style;
	      return ('transition' in style || 'webkitTransition' in style || 'MozTransition' in style);
	    }()),
	    transforms3d: (win.Modernizr && win.Modernizr.csstransforms3d === true) || (function checkTransforms3d() {
	      var style = testDiv.style;
	      return ('webkitPerspective' in style || 'MozPerspective' in style || 'OPerspective' in style || 'MsPerspective' in style || 'perspective' in style);
	    }()),

	    flexbox: (function checkFlexbox() {
	      var div = doc.createElement('div').style;
	      var styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
	      for (var i = 0; i < styles.length; i += 1) {
	        if (styles[i] in div) { return true; }
	      }
	      return false;
	    }()),

	    observer: (function checkObserver() {
	      return ('MutationObserver' in win || 'WebkitMutationObserver' in win);
	    }()),

	    passiveListener: (function checkPassiveListener() {
	      var supportsPassive = false;
	      try {
	        var opts = Object.defineProperty({}, 'passive', {
	          // eslint-disable-next-line
	          get: function get() {
	            supportsPassive = true;
	          },
	        });
	        win.addEventListener('testPassiveListener', null, opts);
	      } catch (e) {
	        // No support
	      }
	      return supportsPassive;
	    }()),

	    gestures: (function checkGestures() {
	      return 'ongesturestart' in win;
	    }()),

	    intersectionObserver: (function checkObserver() {
	      return ('IntersectionObserver' in win);
	    }()),
	  };
	}());

	var DeviceModule = {
	  name: 'device',
	  proto: {
	    device: Device,
	  },
	  static: {
	    device: Device,
	  },
	  on: {
	    init: function init() {
	      var classNames = [];
	      var html = doc.querySelector('html');
	      var metaStatusbar = doc.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
	      if (!html) { return; }
	      if (Device.standalone && Device.ios && metaStatusbar && metaStatusbar.content === 'black-translucent') {
	        classNames.push('device-full-viewport');
	      }

	      // Pixel Ratio
	      classNames.push(("device-pixel-ratio-" + (Math.floor(Device.pixelRatio))));
	      if (Device.pixelRatio >= 2) {
	        classNames.push('device-retina');
	      }
	      // OS classes
	      if (Device.os) {
	        classNames.push(
	          ("device-" + (Device.os)),
	          ("device-" + (Device.os) + "-" + (Device.osVersion.split('.')[0])),
	          ("device-" + (Device.os) + "-" + (Device.osVersion.replace(/\./g, '-')))
	        );
	        if (Device.os === 'ios') {
	          var major = parseInt(Device.osVersion.split('.')[0], 10);
	          for (var i = major - 1; i >= 6; i -= 1) {
	            classNames.push(("device-ios-gt-" + i));
	          }
	          if (Device.iphoneX) {
	            classNames.push('device-iphone-x');
	          }
	        }
	      } else if (Device.desktop) {
	        classNames.push('device-desktop');
	        if (Device.macos) { classNames.push('device-macos'); }
	        else if (Device.windows) { classNames.push('device-windows'); }
	      }
	      if (Device.cordova || Device.phonegap) {
	        classNames.push('device-cordova');
	      }

	      // Add html classes
	      classNames.forEach(function (className) {
	        html.classList.add(className);
	      });
	    },
	  },
	};

	var SupportModule = {
	  name: 'support',
	  proto: {
	    support: Support,
	  },
	  static: {
	    support: Support,
	  },
	  on: {
	    init: function init() {
	      var html = doc.querySelector('html');
	      if (!html) { return; }
	      var classNames = [];
	      // Add html classes
	      classNames.forEach(function (className) {
	        html.classList.add(className);
	      });
	    },
	  },
	};

	var UtilsModule = {
	  name: 'utils',
	  proto: {
	    utils: Utils,
	  },
	  static: {
	    utils: Utils,
	  },
	};

	var ResizeModule = {
	  name: 'resize',
	  instance: {
	    getSize: function getSize() {
	      var app = this;
	      if (!app.root[0]) { return { width: 0, height: 0, left: 0, top: 0 }; }
	      var offset = app.root.offset();
	      var ref = [app.root[0].offsetWidth, app.root[0].offsetHeight, offset.left, offset.top];
	      var width = ref[0];
	      var height = ref[1];
	      var left = ref[2];
	      var top = ref[3];
	      app.width = width;
	      app.height = height;
	      app.left = left;
	      app.top = top;
	      return { width: width, height: height, left: left, top: top };
	    },
	  },
	  on: {
	    init: function init() {
	      var app = this;

	      // Get Size
	      app.getSize();

	      // Emit resize
	      win.addEventListener('resize', function () {
	        app.emit('resize');
	      }, false);

	      // Emit orientationchange
	      win.addEventListener('orientationchange', function () {
	        app.emit('orientationchange');
	      });
	    },
	    orientationchange: function orientationchange() {
	      var app = this;
	      // Fix iPad weird body scroll
	      if (app.device.ipad) {
	        doc.body.scrollLeft = 0;
	        setTimeout(function () {
	          doc.body.scrollLeft = 0;
	        }, 0);
	      }
	    },
	    resize: function resize() {
	      var app = this;
	      app.getSize();
	    },
	  },
	};

	/* eslint no-param-reassign: "off" */

	var RequestModule = {
	  name: 'request',
	  proto: {
	    request: Request,
	  },
	  static: {
	    request: Request,
	  },
	};

	function initTouch() {
	  var app = this;
	  var params = app.params.touch;
	  var useRipple = params[((app.theme) + "TouchRipple")];

	  if (Device.ios && Device.webView) {
	    // Strange hack required for iOS 8 webview to work on inputs
	    win.addEventListener('touchstart', function () {});
	  }

	  var touchStartX;
	  var touchStartY;
	  var touchStartTime;
	  var targetElement;
	  var trackClick;
	  var activeSelection;
	  var scrollParent;
	  var lastClickTime;
	  var isMoved;
	  var tapHoldFired;
	  var tapHoldTimeout;
	  var preventClick;

	  var activableElement;
	  var activeTimeout;

	  var needsFastClick;
	  var needsFastClickTimeOut;

	  var rippleWave;
	  var rippleTarget;
	  var rippleTimeout;

	  function findActivableElement(el) {
	    var target = $(el);
	    var parents = target.parents(params.activeStateElements);
	    var activable;
	    if (target.is(params.activeStateElements)) {
	      activable = target;
	    }
	    if (parents.length > 0) {
	      activable = activable ? activable.add(parents) : parents;
	    }
	    if (activable && activable.length > 1) {
	      var newActivable = [];
	      var preventPropagation;
	      for (var i = 0; i < activable.length; i += 1) {
	        if (!preventPropagation) {
	          newActivable.push(activable[i]);
	          if (activable.eq(i).hasClass('prevent-active-state-propagation')
	            || activable.eq(i).hasClass('no-active-state-propagation')
	          ) {
	            preventPropagation = true;
	          }
	        }
	      }
	      activable = $(newActivable);
	    }
	    return activable || target;
	  }

	  function isInsideScrollableViewLight(el) {
	    var pageContent = el.parents('.page-content');
	    return pageContent.length > 0;
	  }
	  function isInsideScrollableView(el) {
	    var pageContent = el.parents('.page-content');

	    if (pageContent.length === 0) {
	      return false;
	    }

	    // This event handler covers the "tap to stop scrolling".
	    if (pageContent.prop('scrollHandlerSet') !== 'yes') {
	      pageContent.on('scroll', function () {
	        clearTimeout(activeTimeout);
	        clearTimeout(rippleTimeout);
	      });
	      pageContent.prop('scrollHandlerSet', 'yes');
	    }

	    return true;
	  }
	  function addActive() {
	    if (!activableElement) { return; }
	    activableElement.addClass('active-state');
	  }
	  function removeActive() {
	    if (!activableElement) { return; }
	    activableElement.removeClass('active-state');
	    activableElement = null;
	  }
	  function isFormElement(el) {
	    var nodes = ('input select textarea label').split(' ');
	    if (el.nodeName && nodes.indexOf(el.nodeName.toLowerCase()) >= 0) { return true; }
	    return false;
	  }
	  function androidNeedsBlur(el) {
	    var noBlur = ('button input textarea select').split(' ');
	    if (doc.activeElement && el !== doc.activeElement && doc.activeElement !== doc.body) {
	      if (noBlur.indexOf(el.nodeName.toLowerCase()) >= 0) {
	        return false;
	      }
	      return true;
	    }
	    return false;
	  }
	  function targetNeedsFastClick(el) {
	    /*
	    if (
	      Device.ios
	      &&
	      (
	        Device.osVersion.split('.')[0] > 9
	        ||
	        (Device.osVersion.split('.')[0] * 1 === 9 && Device.osVersion.split('.')[1] >= 1)
	      )
	    ) {
	      return false;
	    }
	    */
	    var $el = $(el);
	    if (el.nodeName.toLowerCase() === 'input' && (el.type === 'file' || el.type === 'range')) { return false; }
	    if (el.nodeName.toLowerCase() === 'select' && Device.android) { return false; }
	    if ($el.hasClass('no-fastclick') || $el.parents('.no-fastclick').length > 0) { return false; }
	    if (params.fastClicksExclude && $el.closest(params.fastClicksExclude).length > 0) { return false; }

	    return true;
	  }
	  function targetNeedsFocus(el) {
	    if (doc.activeElement === el) {
	      return false;
	    }
	    var tag = el.nodeName.toLowerCase();
	    var skipInputs = ('button checkbox file image radio submit').split(' ');
	    if (el.disabled || el.readOnly) { return false; }
	    if (tag === 'textarea') { return true; }
	    if (tag === 'select') {
	      if (Device.android) { return false; }
	      return true;
	    }
	    if (tag === 'input' && skipInputs.indexOf(el.type) < 0) { return true; }
	    return false;
	  }
	  function targetNeedsPrevent(el) {
	    var $el = $(el);
	    var prevent = true;
	    if ($el.is('label') || $el.parents('label').length > 0) {
	      if (Device.android) {
	        prevent = false;
	      } else if (Device.ios && $el.is('input')) {
	        prevent = true;
	      } else { prevent = false; }
	    }
	    return prevent;
	  }

	  // Ripple handlers
	  function findRippleElement(el) {
	    var rippleElements = params.touchRippleElements;
	    var $el = $(el);
	    if ($el.is(rippleElements)) {
	      if ($el.hasClass('no-ripple')) {
	        return false;
	      }
	      return $el;
	    }
	    if ($el.parents(rippleElements).length > 0) {
	      var rippleParent = $el.parents(rippleElements).eq(0);
	      if (rippleParent.hasClass('no-ripple')) {
	        return false;
	      }
	      return rippleParent;
	    }
	    return false;
	  }
	  function createRipple($el, x, y) {
	    if (!$el) { return; }
	    rippleWave = app.touchRipple.create($el, x, y);
	  }

	  function removeRipple() {
	    if (!rippleWave) { return; }
	    rippleWave.remove();
	    rippleWave = undefined;
	    rippleTarget = undefined;
	  }
	  function rippleTouchStart(el) {
	    rippleTarget = findRippleElement(el);
	    if (!rippleTarget || rippleTarget.length === 0) {
	      rippleTarget = undefined;
	      return;
	    }
	    var inScrollable = params.fastClicks
	      ? isInsideScrollableView(rippleTarget)
	      : isInsideScrollableViewLight(rippleTarget);

	    if (!inScrollable) {
	      removeRipple();
	      createRipple(rippleTarget, touchStartX, touchStartY);
	    } else {
	      clearTimeout(rippleTimeout);
	      rippleTimeout = setTimeout(function () {
	        removeRipple();
	        createRipple(rippleTarget, touchStartX, touchStartY);
	      }, 80);
	    }
	  }
	  function rippleTouchMove() {
	    clearTimeout(rippleTimeout);
	    removeRipple();
	  }
	  function rippleTouchEnd() {
	    if (!rippleWave && rippleTarget && !isMoved) {
	      clearTimeout(rippleTimeout);
	      createRipple(rippleTarget, touchStartX, touchStartY);
	      setTimeout(removeRipple, 0);
	    } else {
	      removeRipple();
	    }
	  }

	  // Mouse Handlers
	  function handleMouseDown(e) {
	    findActivableElement(e.target).addClass('active-state');
	    if ('which' in e && e.which === 3) {
	      setTimeout(function () {
	        $('.active-state').removeClass('active-state');
	      }, 0);
	    }
	    if (useRipple) {
	      touchStartX = e.pageX;
	      touchStartY = e.pageY;
	      rippleTouchStart(e.target, e.pageX, e.pageY);
	    }
	  }
	  function handleMouseMove() {
	    $('.active-state').removeClass('active-state');
	    if (useRipple) {
	      rippleTouchMove();
	    }
	  }
	  function handleMouseUp() {
	    $('.active-state').removeClass('active-state');
	    if (useRipple) {
	      rippleTouchEnd();
	    }
	  }

	  // Send Click
	  function sendClick(e) {
	    var touch = e.changedTouches[0];
	    var evt = doc.createEvent('MouseEvents');
	    var eventType = 'click';
	    if (Device.android && targetElement.nodeName.toLowerCase() === 'select') {
	      eventType = 'mousedown';
	    }
	    evt.initMouseEvent(eventType, true, true, win, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
	    evt.forwardedTouchEvent = true;

	    if (app.device.ios && win.navigator.standalone) {
	      // Fix the issue happens in iOS home screen apps where the wrong element is selected during a momentum scroll.
	      // Upon tapping, we give the scrolling time to stop, then we grab the element based where the user tapped.
	      setTimeout(function () {
	        targetElement = doc.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
	        if (targetElement) {
	          targetElement.dispatchEvent(evt);
	        }
	      }, 10);
	    } else {
	      targetElement.dispatchEvent(evt);
	    }
	  }

	  // Touch Handlers
	  function handleTouchStart(e) {
	    var this$1 = this;

	    isMoved = false;
	    tapHoldFired = false;
	    if (e.targetTouches.length > 1) {
	      if (activableElement) { removeActive(); }
	      return true;
	    }
	    if (e.touches.length > 1 && activableElement) {
	      removeActive();
	    }
	    if (params.tapHold) {
	      if (tapHoldTimeout) { clearTimeout(tapHoldTimeout); }
	      tapHoldTimeout = setTimeout(function () {
	        if (e && e.touches && e.touches.length > 1) { return; }
	        tapHoldFired = true;
	        e.preventDefault();
	        $(e.target).trigger('taphold');
	      }, params.tapHoldDelay);
	    }
	    if (needsFastClickTimeOut) { clearTimeout(needsFastClickTimeOut); }
	    needsFastClick = targetNeedsFastClick(e.target);

	    if (!needsFastClick) {
	      trackClick = false;
	      return true;
	    }
	    if (Device.ios || (Device.android && 'getSelection' in win)) {
	      var selection = win.getSelection();
	      if (
	        selection.rangeCount
	        && selection.focusNode !== doc.body
	        && (!selection.isCollapsed || doc.activeElement === selection.focusNode)
	      ) {
	        activeSelection = true;
	        return true;
	      }

	      activeSelection = false;
	    }
	    if (Device.android) {
	      if (androidNeedsBlur(e.target)) {
	        doc.activeElement.blur();
	      }
	    }

	    trackClick = true;
	    targetElement = e.target;
	    touchStartTime = (new Date()).getTime();
	    touchStartX = e.targetTouches[0].pageX;
	    touchStartY = e.targetTouches[0].pageY;

	    // Detect scroll parent
	    if (Device.ios) {
	      scrollParent = undefined;
	      $(targetElement).parents().each(function () {
	        var parent = this$1;
	        if (parent.scrollHeight > parent.offsetHeight && !scrollParent) {
	          scrollParent = parent;
	          scrollParent.f7ScrollTop = scrollParent.scrollTop;
	        }
	      });
	    }
	    if ((touchStartTime - lastClickTime) < params.fastClicksDelayBetweenClicks) {
	      e.preventDefault();
	    }

	    if (params.activeState) {
	      activableElement = findActivableElement(targetElement);
	      activeTimeout = setTimeout(addActive, 0);
	    }
	    if (useRipple) {
	      rippleTouchStart(targetElement, touchStartX, touchStartY);
	    }
	    return true;
	  }
	  function handleTouchMove(e) {
	    if (!trackClick) { return; }
	    var distance = params.fastClicksDistanceThreshold;
	    if (distance) {
	      var pageX = e.targetTouches[0].pageX;
	      var pageY = e.targetTouches[0].pageY;
	      if (Math.abs(pageX - touchStartX) > distance || Math.abs(pageY - touchStartY) > distance) {
	        isMoved = true;
	      }
	    } else {
	      isMoved = true;
	    }
	    if (isMoved) {
	      trackClick = false;
	      targetElement = null;
	      isMoved = true;
	      if (params.tapHold) {
	        clearTimeout(tapHoldTimeout);
	      }
	      if (params.activeState) {
	        clearTimeout(activeTimeout);
	        removeActive();
	      }
	      if (useRipple) {
	        rippleTouchMove();
	      }
	    }
	  }
	  function handleTouchEnd(e) {
	    clearTimeout(activeTimeout);
	    clearTimeout(tapHoldTimeout);

	    var touchEndTime = (new Date()).getTime();

	    if (!trackClick) {
	      if (!activeSelection && needsFastClick) {
	        if (!(Device.android && !e.cancelable) && e.cancelable) {
	          e.preventDefault();
	        }
	      }
	      if (params.activeState) { removeActive(); }
	      if (useRipple) {
	        rippleTouchEnd();
	      }
	      return true;
	    }

	    if (doc.activeElement === e.target) {
	      if (params.activeState) { removeActive(); }
	      if (useRipple) {
	        rippleTouchEnd();
	      }
	      return true;
	    }

	    if (!activeSelection) {
	      e.preventDefault();
	    }

	    if ((touchEndTime - lastClickTime) < params.fastClicksDelayBetweenClicks) {
	      setTimeout(removeActive, 0);
	      if (useRipple) {
	        rippleTouchEnd();
	      }
	      return true;
	    }

	    lastClickTime = touchEndTime;

	    trackClick = false;

	    if (Device.ios && scrollParent) {
	      if (scrollParent.scrollTop !== scrollParent.f7ScrollTop) {
	        return false;
	      }
	    }

	    // Add active-state here because, in a very fast tap, the timeout didn't
	    // have the chance to execute. Removing active-state in a timeout gives
	    // the chance to the animation execute.
	    if (params.activeState) {
	      addActive();
	      setTimeout(removeActive, 0);
	    }
	    // Remove Ripple
	    if (useRipple) {
	      rippleTouchEnd();
	    }

	    // Trigger focus when required
	    if (targetNeedsFocus(targetElement)) {
	      if (Device.ios && Device.webView) {
	        targetElement.focus();
	        return false;
	      }

	      targetElement.focus();
	    }

	    // Blur active elements
	    if (doc.activeElement && targetElement !== doc.activeElement && doc.activeElement !== doc.body && targetElement.nodeName.toLowerCase() !== 'label') {
	      doc.activeElement.blur();
	    }

	    // Send click
	    e.preventDefault();
	    if (params.tapHoldPreventClicks && tapHoldFired) {
	      return false;
	    }
	    sendClick(e);
	    return false;
	  }
	  function handleTouchCancel() {
	    trackClick = false;
	    targetElement = null;

	    // Remove Active State
	    clearTimeout(activeTimeout);
	    clearTimeout(tapHoldTimeout);
	    if (params.activeState) {
	      removeActive();
	    }

	    // Remove Ripple
	    if (useRipple) {
	      rippleTouchEnd();
	    }
	  }

	  function handleClick(e) {
	    var allowClick = false;
	    if (trackClick) {
	      targetElement = null;
	      trackClick = false;
	      return true;
	    }
	    if ((e.target.type === 'submit' && e.detail === 0) || e.target.type === 'file') {
	      return true;
	    }
	    if (!targetElement) {
	      if (!isFormElement(e.target)) {
	        allowClick = true;
	      }
	    }
	    if (!needsFastClick) {
	      allowClick = true;
	    }
	    if (doc.activeElement === targetElement) {
	      allowClick = true;
	    }
	    if (e.forwardedTouchEvent) {
	      allowClick = true;
	    }
	    if (!e.cancelable) {
	      allowClick = true;
	    }
	    if (params.tapHold && params.tapHoldPreventClicks && tapHoldFired) {
	      allowClick = false;
	    }
	    if (!allowClick) {
	      e.stopImmediatePropagation();
	      e.stopPropagation();
	      if (targetElement) {
	        if (targetNeedsPrevent(targetElement) || isMoved) {
	          e.preventDefault();
	        }
	      } else {
	        e.preventDefault();
	      }
	      targetElement = null;
	    }
	    needsFastClickTimeOut = setTimeout(function () {
	      needsFastClick = false;
	    }, (Device.ios || Device.androidChrome ? 100 : 400));

	    if (params.tapHold) {
	      tapHoldTimeout = setTimeout(function () {
	        tapHoldFired = false;
	      }, (Device.ios || Device.androidChrome ? 100 : 400));
	    }

	    return allowClick;
	  }

	  function handleTouchStartLight(e) {
	    isMoved = false;
	    tapHoldFired = false;
	    preventClick = false;
	    if (e.targetTouches.length > 1) {
	      if (activableElement) { removeActive(); }
	      return true;
	    }
	    if (e.touches.length > 1 && activableElement) {
	      removeActive();
	    }
	    if (params.tapHold) {
	      if (tapHoldTimeout) { clearTimeout(tapHoldTimeout); }
	      tapHoldTimeout = setTimeout(function () {
	        if (e && e.touches && e.touches.length > 1) { return; }
	        tapHoldFired = true;
	        e.preventDefault();
	        preventClick = true;
	        $(e.target).trigger('taphold');
	      }, params.tapHoldDelay);
	    }
	    targetElement = e.target;
	    touchStartX = e.targetTouches[0].pageX;
	    touchStartY = e.targetTouches[0].pageY;

	    if (params.activeState) {
	      activableElement = findActivableElement(targetElement);
	      if (!isInsideScrollableViewLight(activableElement)) {
	        addActive();
	      } else {
	        activeTimeout = setTimeout(addActive, 80);
	      }
	    }
	    if (useRipple) {
	      rippleTouchStart(targetElement, touchStartX, touchStartY);
	    }
	    return true;
	  }
	  function handleTouchMoveLight(e) {
	    var touch;
	    var distance;
	    if (e.type === 'touchmove') {
	      touch = e.targetTouches[0];
	      distance = params.touchClicksDistanceThreshold;
	      // if (touch && touch.touchType === 'stylus') {
	      //   distance = 5;
	      // } else {
	      //   distance = 3;
	      // }
	    }

	    if (distance && touch) {
	      var pageX = touch.pageX;
	      var pageY = touch.pageY;
	      if (Math.abs(pageX - touchStartX) > distance || Math.abs(pageY - touchStartY) > distance) {
	        isMoved = true;
	      }
	    } else {
	      isMoved = true;
	    }
	    if (isMoved) {
	      preventClick = true;
	      if (params.tapHold) {
	        clearTimeout(tapHoldTimeout);
	      }
	      if (params.activeState) {
	        clearTimeout(activeTimeout);
	        removeActive();
	      }
	      if (useRipple) {
	        rippleTouchMove();
	      }
	    }
	  }
	  function handleTouchEndLight(e) {
	    clearTimeout(activeTimeout);
	    clearTimeout(tapHoldTimeout);
	    if (doc.activeElement === e.target) {
	      if (params.activeState) { removeActive(); }
	      if (useRipple) {
	        rippleTouchEnd();
	      }
	      return true;
	    }
	    if (params.activeState) {
	      addActive();
	      setTimeout(removeActive, 0);
	    }
	    if (useRipple) {
	      rippleTouchEnd();
	    }
	    if ((params.tapHoldPreventClicks && tapHoldFired) || preventClick) {
	      if (e.cancelable) { e.preventDefault(); }
	      preventClick = true;
	      return false;
	    }
	    return true;
	  }
	  function handleClickLight(e) {
	    var localPreventClick = preventClick;
	    if (targetElement && e.target !== targetElement) {
	      localPreventClick = true;
	    }
	    if (params.tapHold && params.tapHoldPreventClicks && tapHoldFired) {
	      localPreventClick = true;
	    }
	    if (localPreventClick) {
	      e.stopImmediatePropagation();
	      e.stopPropagation();
	      e.preventDefault();
	    }

	    if (params.tapHold) {
	      tapHoldTimeout = setTimeout(
	        function () {
	          tapHoldFired = false;
	        },
	        (Device.ios || Device.androidChrome ? 100 : 400)
	      );
	    }
	    preventClick = false;
	    targetElement = null;

	    return !localPreventClick;
	  }

	  function emitAppTouchEvent(name, e) {
	    app.emit({
	      events: name,
	      data: [e],
	    });
	  }
	  function appClick(e) {
	    emitAppTouchEvent('click', e);
	  }
	  function appTouchStartActive(e) {
	    emitAppTouchEvent('touchstart touchstart:active', e);
	  }
	  function appTouchMoveActive(e) {
	    emitAppTouchEvent('touchmove touchmove:active', e);
	  }
	  function appTouchEndActive(e) {
	    emitAppTouchEvent('touchend touchend:active', e);
	  }
	  function appTouchStartPassive(e) {
	    emitAppTouchEvent('touchstart:passive', e);
	  }
	  function appTouchMovePassive(e) {
	    emitAppTouchEvent('touchmove:passive', e);
	  }
	  function appTouchEndPassive(e) {
	    emitAppTouchEvent('touchend:passive', e);
	  }

	  var passiveListener = Support.passiveListener ? { passive: true } : false;
	  var activeListener = Support.passiveListener ? { passive: false } : false;

	  doc.addEventListener('click', appClick, true);

	  if (Support.passiveListener) {
	    doc.addEventListener(app.touchEvents.start, appTouchStartActive, activeListener);
	    doc.addEventListener(app.touchEvents.move, appTouchMoveActive, activeListener);
	    doc.addEventListener(app.touchEvents.end, appTouchEndActive, activeListener);

	    doc.addEventListener(app.touchEvents.start, appTouchStartPassive, passiveListener);
	    doc.addEventListener(app.touchEvents.move, appTouchMovePassive, passiveListener);
	    doc.addEventListener(app.touchEvents.end, appTouchEndPassive, passiveListener);
	  } else {
	    doc.addEventListener(app.touchEvents.start, function (e) {
	      appTouchStartActive(e);
	      appTouchStartPassive(e);
	    }, false);
	    doc.addEventListener(app.touchEvents.move, function (e) {
	      appTouchMoveActive(e);
	      appTouchMovePassive(e);
	    }, false);
	    doc.addEventListener(app.touchEvents.end, function (e) {
	      appTouchEndActive(e);
	      appTouchEndPassive(e);
	    }, false);
	  }

	  if (Support.touch) {
	    if (params.fastClicks) {
	      app.on('click', handleClick);
	      app.on('touchstart', handleTouchStart);
	      app.on('touchmove', handleTouchMove);
	      app.on('touchend', handleTouchEnd);
	    } else {
	      app.on('click', handleClickLight);
	      app.on('touchstart', handleTouchStartLight);
	      app.on('touchmove', handleTouchMoveLight);
	      app.on('touchend', handleTouchEndLight);
	    }

	    doc.addEventListener('touchcancel', handleTouchCancel, { passive: true });
	  } else if (params.activeState) {
	    app.on('touchstart', handleMouseDown);
	    app.on('touchmove', handleMouseMove);
	    app.on('touchend', handleMouseUp);
	  }
	  doc.addEventListener('contextmenu', function (e) {
	    if (params.disableContextMenu && (Device.ios || Device.android || Device.cordova)) {
	      e.preventDefault();
	    }
	    if (useRipple) {
	      if (activableElement) { removeActive(); }
	      rippleTouchEnd();
	    }
	  });
	}

	var TouchModule = {
	  name: 'touch',
	  params: {
	    touch: {
	      // Fast clicks
	      fastClicks: false,
	      fastClicksDistanceThreshold: 10,
	      fastClicksDelayBetweenClicks: 50,
	      fastClicksExclude: '', // CSS selector
	      // Clicks
	      touchClicksDistanceThreshold: 5,
	      // ContextMenu
	      disableContextMenu: false,
	      // Tap Hold
	      tapHold: false,
	      tapHoldDelay: 750,
	      tapHoldPreventClicks: true,
	      // Active State
	      activeState: true,
	      activeStateElements: 'a, button, label, span, .actions-button, .stepper-button, .stepper-button-plus, .stepper-button-minus, .card-expandable, .menu-item, .link, .item-link',
	      mdTouchRipple: true,
	      iosTouchRipple: false,
	      auroraTouchRipple: false,
	      touchRippleElements: '.ripple, .link, .item-link, .list-button, .links-list a, .button, button, .input-clear-button, .dialog-button, .tab-link, .item-radio, .item-checkbox, .actions-button, .searchbar-disable-button, .fab a, .checkbox, .radio, .data-table .sortable-cell:not(.input-cell), .notification-close-button, .stepper-button, .stepper-button-minus, .stepper-button-plus, .menu-item-content',
	    },
	  },
	  instance: {
	    touchEvents: {
	      start: Support.touch ? 'touchstart' : 'mousedown',
	      move: Support.touch ? 'touchmove' : 'mousemove',
	      end: Support.touch ? 'touchend' : 'mouseup',
	    },
	  },
	  on: {
	    init: initTouch,
	  },
	};

	/**
	 * Expose `pathToRegexp`.
	 */
	var pathToRegexp_1 = pathToRegexp;
	var parse_1 = parse;
	var compile_1 = compile;
	var tokensToFunction_1 = tokensToFunction;
	var tokensToRegExp_1 = tokensToRegExp;

	/**
	 * Default configs.
	 */
	var DEFAULT_DELIMITER = '/';

	/**
	 * The main path matching regexp utility.
	 *
	 * @type {RegExp}
	 */
	var PATH_REGEXP = new RegExp([
	  // Match escaped characters that would otherwise appear in future matches.
	  // This allows the user to escape special characters that won't transform.
	  '(\\\\.)',
	  // Match Express-style parameters and un-named parameters with a prefix
	  // and optional suffixes. Matches appear as:
	  //
	  // ":test(\\d+)?" => ["test", "\d+", undefined, "?"]
	  // "(\\d+)"  => [undefined, undefined, "\d+", undefined]
	  '(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'
	].join('|'), 'g');

	/**
	 * Parse a string for the raw tokens.
	 *
	 * @param  {string}  str
	 * @param  {Object=} options
	 * @return {!Array}
	 */
	function parse (str, options) {
	  var tokens = [];
	  var key = 0;
	  var index = 0;
	  var path = '';
	  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;
	  var whitelist = (options && options.whitelist) || undefined;
	  var pathEscaped = false;
	  var res;

	  while ((res = PATH_REGEXP.exec(str)) !== null) {
	    var m = res[0];
	    var escaped = res[1];
	    var offset = res.index;
	    path += str.slice(index, offset);
	    index = offset + m.length;

	    // Ignore already escaped sequences.
	    if (escaped) {
	      path += escaped[1];
	      pathEscaped = true;
	      continue
	    }

	    var prev = '';
	    var name = res[2];
	    var capture = res[3];
	    var group = res[4];
	    var modifier = res[5];

	    if (!pathEscaped && path.length) {
	      var k = path.length - 1;
	      var c = path[k];
	      var matches = whitelist ? whitelist.indexOf(c) > -1 : true;

	      if (matches) {
	        prev = c;
	        path = path.slice(0, k);
	      }
	    }

	    // Push the current path onto the tokens.
	    if (path) {
	      tokens.push(path);
	      path = '';
	      pathEscaped = false;
	    }

	    var repeat = modifier === '+' || modifier === '*';
	    var optional = modifier === '?' || modifier === '*';
	    var pattern = capture || group;
	    var delimiter = prev || defaultDelimiter;

	    tokens.push({
	      name: name || key++,
	      prefix: prev,
	      delimiter: delimiter,
	      optional: optional,
	      repeat: repeat,
	      pattern: pattern
	        ? escapeGroup(pattern)
	        : '[^' + escapeString(delimiter === defaultDelimiter ? delimiter : (delimiter + defaultDelimiter)) + ']+?'
	    });
	  }

	  // Push any remaining characters.
	  if (path || index < str.length) {
	    tokens.push(path + str.substr(index));
	  }

	  return tokens
	}

	/**
	 * Compile a string to a template function for the path.
	 *
	 * @param  {string}             str
	 * @param  {Object=}            options
	 * @return {!function(Object=, Object=)}
	 */
	function compile (str, options) {
	  return tokensToFunction(parse(str, options))
	}

	/**
	 * Expose a method for transforming tokens into the path function.
	 */
	function tokensToFunction (tokens) {
	  // Compile all the tokens into regexps.
	  var matches = new Array(tokens.length);

	  // Compile all the patterns before compilation.
	  for (var i = 0; i < tokens.length; i++) {
	    if (typeof tokens[i] === 'object') {
	      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
	    }
	  }

	  return function (data, options) {
	    var path = '';
	    var encode = (options && options.encode) || encodeURIComponent;

	    for (var i = 0; i < tokens.length; i++) {
	      var token = tokens[i];

	      if (typeof token === 'string') {
	        path += token;
	        continue
	      }

	      var value = data ? data[token.name] : undefined;
	      var segment;

	      if (Array.isArray(value)) {
	        if (!token.repeat) {
	          throw new TypeError('Expected "' + token.name + '" to not repeat, but got array')
	        }

	        if (value.length === 0) {
	          if (token.optional) { continue }

	          throw new TypeError('Expected "' + token.name + '" to not be empty')
	        }

	        for (var j = 0; j < value.length; j++) {
	          segment = encode(value[j], token);

	          if (!matches[i].test(segment)) {
	            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '"')
	          }

	          path += (j === 0 ? token.prefix : token.delimiter) + segment;
	        }

	        continue
	      }

	      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
	        segment = encode(String(value), token);

	        if (!matches[i].test(segment)) {
	          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"')
	        }

	        path += token.prefix + segment;
	        continue
	      }

	      if (token.optional) { continue }

	      throw new TypeError('Expected "' + token.name + '" to be ' + (token.repeat ? 'an array' : 'a string'))
	    }

	    return path
	  }
	}

	/**
	 * Escape a regular expression string.
	 *
	 * @param  {string} str
	 * @return {string}
	 */
	function escapeString (str) {
	  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1')
	}

	/**
	 * Escape the capturing group by escaping special characters and meaning.
	 *
	 * @param  {string} group
	 * @return {string}
	 */
	function escapeGroup (group) {
	  return group.replace(/([=!:$/()])/g, '\\$1')
	}

	/**
	 * Get the flags for a regexp from the options.
	 *
	 * @param  {Object} options
	 * @return {string}
	 */
	function flags (options) {
	  return options && options.sensitive ? '' : 'i'
	}

	/**
	 * Pull out keys from a regexp.
	 *
	 * @param  {!RegExp} path
	 * @param  {Array=}  keys
	 * @return {!RegExp}
	 */
	function regexpToRegexp (path, keys) {
	  if (!keys) { return path }

	  // Use a negative lookahead to match only capturing groups.
	  var groups = path.source.match(/\((?!\?)/g);

	  if (groups) {
	    for (var i = 0; i < groups.length; i++) {
	      keys.push({
	        name: i,
	        prefix: null,
	        delimiter: null,
	        optional: false,
	        repeat: false,
	        pattern: null
	      });
	    }
	  }

	  return path
	}

	/**
	 * Transform an array into a regexp.
	 *
	 * @param  {!Array}  path
	 * @param  {Array=}  keys
	 * @param  {Object=} options
	 * @return {!RegExp}
	 */
	function arrayToRegexp (path, keys, options) {
	  var parts = [];

	  for (var i = 0; i < path.length; i++) {
	    parts.push(pathToRegexp(path[i], keys, options).source);
	  }

	  return new RegExp('(?:' + parts.join('|') + ')', flags(options))
	}

	/**
	 * Create a path regexp from string input.
	 *
	 * @param  {string}  path
	 * @param  {Array=}  keys
	 * @param  {Object=} options
	 * @return {!RegExp}
	 */
	function stringToRegexp (path, keys, options) {
	  return tokensToRegExp(parse(path, options), keys, options)
	}

	/**
	 * Expose a function for taking tokens and returning a RegExp.
	 *
	 * @param  {!Array}  tokens
	 * @param  {Array=}  keys
	 * @param  {Object=} options
	 * @return {!RegExp}
	 */
	function tokensToRegExp (tokens, keys, options) {
	  options = options || {};

	  var strict = options.strict;
	  var start = options.start !== false;
	  var end = options.end !== false;
	  var delimiter = options.delimiter || DEFAULT_DELIMITER;
	  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');
	  var route = start ? '^' : '';

	  // Iterate over the tokens and create our regexp string.
	  for (var i = 0; i < tokens.length; i++) {
	    var token = tokens[i];

	    if (typeof token === 'string') {
	      route += escapeString(token);
	    } else {
	      var capture = token.repeat
	        ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'
	        : token.pattern;

	      if (keys) { keys.push(token); }

	      if (token.optional) {
	        if (!token.prefix) {
	          route += '(' + capture + ')?';
	        } else {
	          route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?';
	        }
	      } else {
	        route += escapeString(token.prefix) + '(' + capture + ')';
	      }
	    }
	  }

	  if (end) {
	    if (!strict) { route += '(?:' + escapeString(delimiter) + ')?'; }

	    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';
	  } else {
	    var endToken = tokens[tokens.length - 1];
	    var isEndDelimited = typeof endToken === 'string'
	      ? endToken[endToken.length - 1] === delimiter
	      : endToken === undefined;

	    if (!strict) { route += '(?:' + escapeString(delimiter) + '(?=' + endsWith + '))?'; }
	    if (!isEndDelimited) { route += '(?=' + escapeString(delimiter) + '|' + endsWith + ')'; }
	  }

	  return new RegExp(route, flags(options))
	}

	/**
	 * Normalize the given path string, returning a regular expression.
	 *
	 * An empty array can be passed in for the keys, which will hold the
	 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
	 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
	 *
	 * @param  {(string|RegExp|Array)} path
	 * @param  {Array=}                keys
	 * @param  {Object=}               options
	 * @return {!RegExp}
	 */
	function pathToRegexp (path, keys, options) {
	  if (path instanceof RegExp) {
	    return regexpToRegexp(path, keys)
	  }

	  if (Array.isArray(path)) {
	    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)
	  }

	  return stringToRegexp(/** @type {string} */ (path), keys, options)
	}
	pathToRegexp_1.parse = parse_1;
	pathToRegexp_1.compile = compile_1;
	pathToRegexp_1.tokensToFunction = tokensToFunction_1;
	pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

	var History = {
	  queue: [],
	  clearQueue: function clearQueue() {
	    if (History.queue.length === 0) { return; }
	    var currentQueue = History.queue.shift();
	    currentQueue();
	  },
	  routerQueue: [],
	  clearRouterQueue: function clearRouterQueue() {
	    if (History.routerQueue.length === 0) { return; }
	    var currentQueue = History.routerQueue.pop();
	    var router = currentQueue.router;
	    var stateUrl = currentQueue.stateUrl;
	    var action = currentQueue.action;

	    var animate = router.params.animate;
	    if (router.params.pushStateAnimate === false) { animate = false; }

	    if (action === 'back') {
	      router.back({ animate: animate, pushState: false });
	    }
	    if (action === 'load') {
	      router.navigate(stateUrl, { animate: animate, pushState: false });
	    }
	  },
	  handle: function handle(e) {
	    if (History.blockPopstate) { return; }
	    var app = this;
	    // const mainView = app.views.main;
	    var state = e.state;
	    History.previousState = History.state;
	    History.state = state;

	    History.allowChange = true;
	    History.clearQueue();

	    state = History.state;
	    if (!state) { state = {}; }

	    app.views.forEach(function (view) {
	      var router = view.router;
	      var viewState = state[view.id];
	      if (!viewState && view.params.pushState) {
	        viewState = {
	          url: view.router.history[0],
	        };
	      }
	      if (!viewState) { return; }
	      var stateUrl = viewState.url || undefined;

	      var animate = router.params.animate;
	      if (router.params.pushStateAnimate === false) { animate = false; }

	      if (stateUrl !== router.url) {
	        if (router.history.indexOf(stateUrl) >= 0) {
	          // Go Back
	          if (router.allowPageChange) {
	            router.back({ animate: animate, pushState: false });
	          } else {
	            History.routerQueue.push({
	              action: 'back',
	              router: router,
	            });
	          }
	        } else if (router.allowPageChange) {
	          // Load page
	          router.navigate(stateUrl, { animate: animate, pushState: false });
	        } else {
	          History.routerQueue.unshift({
	            action: 'load',
	            stateUrl: stateUrl,
	            router: router,
	          });
	        }
	      }
	    });
	  },
	  initViewState: function initViewState(viewId, viewState) {
	    var obj;

	    var newState = Utils.extend({}, (History.state || {}), ( obj = {}, obj[viewId] = viewState, obj ));
	    History.state = newState;
	    win.history.replaceState(newState, '');
	  },
	  push: function push(viewId, viewState, url) {
	    var obj;

	    if (!History.allowChange) {
	      History.queue.push(function () {
	        History.push(viewId, viewState, url);
	      });
	      return;
	    }
	    History.previousState = History.state;
	    var newState = Utils.extend({}, (History.previousState || {}), ( obj = {}, obj[viewId] = viewState, obj ));
	    History.state = newState;
	    win.history.pushState(newState, '', url);
	  },
	  replace: function replace(viewId, viewState, url) {
	    var obj;

	    if (!History.allowChange) {
	      History.queue.push(function () {
	        History.replace(viewId, viewState, url);
	      });
	      return;
	    }
	    History.previousState = History.state;
	    var newState = Utils.extend({}, (History.previousState || {}), ( obj = {}, obj[viewId] = viewState, obj ));
	    History.state = newState;
	    win.history.replaceState(newState, '', url);
	  },
	  go: function go(index) {
	    History.allowChange = false;
	    win.history.go(index);
	  },
	  back: function back() {
	    History.allowChange = false;
	    win.history.back();
	  },
	  allowChange: true,
	  previousState: {},
	  state: win.history.state,
	  blockPopstate: true,
	  init: function init(app) {
	    $(win).on('load', function () {
	      setTimeout(function () {
	        History.blockPopstate = false;
	      }, 0);
	    });

	    if (doc.readyState && doc.readyState === 'complete') {
	      History.blockPopstate = false;
	    }

	    $(win).on('popstate', History.handle.bind(app));
	  },
	};

	function SwipeBack(r) {
	  var router = r;
	  var $el = router.$el;
	  var $navbarEl = router.$navbarEl;
	  var app = router.app;
	  var params = router.params;
	  var isTouched = false;
	  var isMoved = false;
	  var touchesStart = {};
	  var isScrolling;
	  var $currentPageEl = [];
	  var $previousPageEl = [];
	  var viewContainerWidth;
	  var touchesDiff;
	  var allowViewTouchMove = true;
	  var touchStartTime;
	  var $currentNavbarInnerEl = [];
	  var $previousNavbarInnerEl = [];
	  var dynamicNavbar;
	  var separateNavbar;
	  var $pageShadowEl;
	  var $pageOpacityEl;

	  var animatableNavEls;

	  var paramsSwipeBackAnimateShadow = params[((app.theme) + "SwipeBackAnimateShadow")];
	  var paramsSwipeBackAnimateOpacity = params[((app.theme) + "SwipeBackAnimateOpacity")];
	  var paramsSwipeBackActiveArea = params[((app.theme) + "SwipeBackActiveArea")];
	  var paramsSwipeBackThreshold = params[((app.theme) + "SwipeBackThreshold")];

	  var transformOrigin = app.rtl ? 'right center' : 'left center';

	  function animatableNavElements() {
	    var els = [];
	    var inverter = app.rtl ? -1 : 1;
	    var currentNavIsLarge = $currentNavbarInnerEl.hasClass('navbar-inner-large');
	    var previousNavIsLarge = $previousNavbarInnerEl.hasClass('navbar-inner-large');
	    var fromLarge = currentNavIsLarge && !$currentNavbarInnerEl.hasClass('navbar-inner-large-collapsed');
	    var toLarge = previousNavIsLarge && !$previousNavbarInnerEl.hasClass('navbar-inner-large-collapsed');
	    var $currentNavElements = $currentNavbarInnerEl.children('.left, .title, .right, .subnavbar, .fading, .title-large');
	    var $previousNavElements = $previousNavbarInnerEl.children('.left, .title, .right, .subnavbar, .fading, .title-large');
	    var activeNavBackIconText;
	    var previousNavBackIconText;

	    if (params.iosAnimateNavbarBackIcon) {
	      if ($currentNavbarInnerEl.hasClass('sliding')) {
	        activeNavBackIconText = $currentNavbarInnerEl.children('.left').find('.back .icon + span').eq(0);
	      } else {
	        activeNavBackIconText = $currentNavbarInnerEl.children('.left.sliding').find('.back .icon + span').eq(0);
	      }
	      if ($previousNavbarInnerEl.hasClass('sliding')) {
	        previousNavBackIconText = $previousNavbarInnerEl.children('.left').find('.back .icon + span').eq(0);
	      } else {
	        previousNavBackIconText = $previousNavbarInnerEl.children('.left.sliding').find('.back .icon + span').eq(0);
	      }
	      if (activeNavBackIconText.length) {
	        $previousNavElements.each(function (index, el) {
	          if (!$(el).hasClass('title')) { return; }
	          el.f7NavbarLeftOffset += activeNavBackIconText.prev('.icon')[0].offsetWidth;
	        });
	      }
	    }
	    $currentNavElements
	      .each(function (index, navEl) {
	        var $navEl = $(navEl);
	        var isSubnavbar = $navEl.hasClass('subnavbar');
	        var isLeft = $navEl.hasClass('left');
	        var isTitle = $navEl.hasClass('title');
	        if (!fromLarge && $navEl.hasClass('.title-large')) { return; }
	        var el = {
	          el: navEl,
	        };
	        if (fromLarge) {
	          if (isTitle) { return; }
	          if ($navEl.hasClass('title-large')) {
	            if (!separateNavbar) { return; }
	            if (toLarge) {
	              if (els.indexOf(el) < 0) { els.push(el); }
	              el.overflow = 'visible';
	              el.transform = 'translateX(100%)';
	              $navEl.find('.title-large-text, .title-large-inner').each(function (subIndex, subNavEl) {
	                els.push({
	                  el: subNavEl,
	                  transform: function (progress) { return ("translateX(" + (-100 + progress * 100 * inverter) + "%)"); },
	                });
	              });
	            } else {
	              if (els.indexOf(el) < 0) { els.push(el); }
	              el.overflow = 'hidden';
	              el.transform = function (progress) { return ("translateY(calc(" + (-progress) + " * var(--f7-navbar-large-title-height)))"); };
	              $navEl.find('.title-large-text, .title-large-inner').each(function (subIndex, subNavEl) {
	                els.push({
	                  el: subNavEl,
	                  transform: function (progress) { return ("translateX(" + (progress * 100 * inverter) + "%) translateY(calc(" + progress + " * var(--f7-navbar-large-title-height)))"); },
	                });
	              });
	            }
	            return;
	          }
	        }
	        if (toLarge) {
	          if (!fromLarge) {
	            if ($navEl.hasClass('title-large')) {
	              if (!separateNavbar) { return; }
	              if (els.indexOf(el) < 0) { els.push(el); }
	              el.opacity = 0;
	            }
	          }
	          if (isLeft && separateNavbar) {
	            if (els.indexOf(el) < 0) { els.push(el); }
	            el.opacity = function (progress) { return (1 - (Math.pow( progress, 0.33 ))); };
	            $navEl.find('.back span').each(function (subIndex, subNavEl) {
	              els.push({
	                el: subNavEl,
	                'transform-origin': transformOrigin,
	                transform: function (progress) { return ("translateY(calc(var(--f7-navbar-height) * " + progress + ")) scale(" + (1 + (1 * progress)) + ")"); },
	              });
	            });
	            return;
	          }
	        }
	        if ($navEl.hasClass('title-large')) { return; }
	        var isSliding = $navEl.hasClass('sliding') || $currentNavbarInnerEl.hasClass('sliding');
	        if (els.indexOf(el) < 0) { els.push(el); }
	        if (!isSubnavbar || (isSubnavbar && !isSliding)) {
	          el.opacity = function (progress) { return (1 - (Math.pow( progress, 0.33 ))); };
	        }
	        if (isSliding) {
	          var transformTarget = el;
	          if (isLeft && activeNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
	            var textEl = { el: activeNavBackIconText[0] };
	            transformTarget = textEl;
	            els.push(textEl);
	          }
	          transformTarget.transform = function (progress) {
	            var activeNavTranslate = progress * transformTarget.el.f7NavbarRightOffset;
	            if (Device.pixelRatio === 1) { activeNavTranslate = Math.round(activeNavTranslate); }
	            if (isSubnavbar && currentNavIsLarge && separateNavbar) {
	              return ("translate3d(" + activeNavTranslate + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)");
	            }
	            return ("translate3d(" + activeNavTranslate + "px,0,0)");
	          };
	        }
	      });
	    $previousNavElements
	      .each(function (index, navEl) {
	        var $navEl = $(navEl);
	        var isSubnavbar = $navEl.hasClass('subnavbar');
	        var isLeft = $navEl.hasClass('left');
	        var isTitle = $navEl.hasClass('title');
	        var el = {
	          el: navEl,
	        };
	        if (toLarge) {
	          if (isTitle) { return; }
	          if (els.indexOf(el) < 0) { els.push(el); }

	          if ($navEl.hasClass('title-large')) {
	            if (!separateNavbar) { return; }
	            if (fromLarge) {
	              el.opacity = 1;
	              el.overflow = 'visible';
	              el.transform = 'translateY(0)';
	              $navEl.find('.title-large-text').each(function (subIndex, subNavEl) {
	                els.push({
	                  el: subNavEl,
	                  'transform-origin': transformOrigin,
	                  opacity: function (progress) { return (Math.pow( progress, 3 )); },
	                  transform: function (progress) { return ("translateY(calc(" + (-1 + progress * 1) + " * var(--f7-navbar-large-title-height))) scale(" + (0.5 + progress * 0.5) + ")"); },
	                });
	              });
	            } else {
	              el.transform = function (progress) { return ("translateY(calc(" + (progress - 1) + " * var(--f7-navbar-large-title-height)))"); };
	              el.opacity = 1;
	              el.overflow = 'hidden';
	              $navEl.find('.title-large-text').each(function (subIndex, subNavEl) {
	                els.push({
	                  el: subNavEl,
	                  'transform-origin': transformOrigin,
	                  opacity: function (progress) { return (Math.pow( progress, 3 )); },
	                  transform: function (progress) { return ("scale(" + (0.5 + progress * 0.5) + ")"); },
	                });
	              });
	            }
	            $navEl.find('.title-large-inner').each(function (subIndex, subNavEl) {
	              els.push({
	                el: subNavEl,
	                'transform-origin': transformOrigin,
	                opacity: function (progress) { return (Math.pow( progress, 3 )); },
	                transform: function (progress) { return ("translateX(" + (-100 * (1 - progress) * inverter) + "%)"); },
	              });
	            });
	            return;
	          }
	        }
	        if ($navEl.hasClass('title-large')) { return; }
	        var isSliding = $navEl.hasClass('sliding') || $previousNavbarInnerEl.hasClass('sliding');
	        if (els.indexOf(el) < 0) { els.push(el); }
	        if (!isSubnavbar || (isSubnavbar && !isSliding)) {
	          el.opacity = function (progress) { return (Math.pow( progress, 3 )); };
	        }
	        if (isSliding) {
	          var transformTarget = el;
	          if (isLeft && previousNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
	            var textEl = { el: previousNavBackIconText[0] };
	            transformTarget = textEl;
	            els.push(textEl);
	          }
	          transformTarget.transform = function (progress) {
	            var previousNavTranslate = transformTarget.el.f7NavbarLeftOffset * (1 - progress);
	            if (Device.pixelRatio === 1) { previousNavTranslate = Math.round(previousNavTranslate); }
	            if (isSubnavbar && previousNavIsLarge && separateNavbar) {
	              return ("translate3d(" + previousNavTranslate + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)");
	            }
	            return ("translate3d(" + previousNavTranslate + "px,0,0)");
	          };
	        }
	      });
	    return els;
	  }

	  function setAnimatableNavElements(ref) {
	    if ( ref === void 0 ) ref = {};
	    var progress = ref.progress;
	    var reset = ref.reset;
	    var transition = ref.transition;

	    var styles = ['overflow', 'transform', 'transform-origin', 'opacity'];
	    for (var i = 0; i < animatableNavEls.length; i += 1) {
	      var el = animatableNavEls[i];
	      if (el && el.el) {
	        if (transition === true) { el.el.classList.add('navbar-page-transitioning'); }
	        if (transition === false) { el.el.classList.remove('navbar-page-transitioning'); }
	        for (var j = 0; j < styles.length; j += 1) {
	          var styleProp = styles[j];
	          if (el[styleProp]) {
	            if (reset) {
	              el.el.style[styleProp] = '';
	            } else if (typeof el[styleProp] === 'function') {
	              el.el.style[styleProp] = el[styleProp](progress);
	            } else {
	              el.el.style[styleProp] = el[styleProp];
	            }
	          }
	        }
	      }
	    }
	  }

	  function handleTouchStart(e) {
	    var swipeBackEnabled = params[((app.theme) + "SwipeBack")];
	    if (!allowViewTouchMove || !swipeBackEnabled || isTouched || (app.swipeout && app.swipeout.el) || !router.allowPageChange) { return; }
	    if ($(e.target).closest('.range-slider, .calendar-months').length > 0) { return; }
	    if ($(e.target).closest('.page-master, .page-master-detail').length > 0 && params.masterDetailBreakpoint > 0 && app.width >= params.masterDetailBreakpoint) { return; }
	    isMoved = false;
	    isTouched = true;
	    isScrolling = undefined;
	    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	    touchStartTime = Utils.now();
	    dynamicNavbar = router.dynamicNavbar;
	    separateNavbar = router.separateNavbar;
	  }
	  function handleTouchMove(e) {
	    if (!isTouched) { return; }
	    var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	    var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	    if (typeof isScrolling === 'undefined') {
	      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x)) || (pageX < touchesStart.x && !app.rtl) || (pageX > touchesStart.x && app.rtl);
	    }
	    if (isScrolling || e.f7PreventSwipeBack || app.preventSwipeBack) {
	      isTouched = false;
	      return;
	    }
	    if (!isMoved) {
	      // Calc values during first move fired
	      var cancel = false;
	      var target = $(e.target);

	      var swipeout = target.closest('.swipeout');
	      if (swipeout.length > 0) {
	        if (!app.rtl && swipeout.find('.swipeout-actions-left').length > 0) { cancel = true; }
	        if (app.rtl && swipeout.find('.swipeout-actions-right').length > 0) { cancel = true; }
	      }

	      $currentPageEl = target.closest('.page');
	      if ($currentPageEl.hasClass('no-swipeback') || target.closest('.no-swipeback, .card-opened').length > 0) { cancel = true; }
	      $previousPageEl = $el.find('.page-previous:not(.stacked)');
	      if ($previousPageEl.length > 1) {
	        $previousPageEl = $previousPageEl.eq($previousPageEl.length - 1);
	      }
	      var notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
	      viewContainerWidth = $el.width();
	      if (app.rtl) {
	        notFromBorder = touchesStart.x < ($el.offset().left - $el[0].scrollLeft) + (viewContainerWidth - paramsSwipeBackActiveArea);
	      } else {
	        notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
	      }
	      if (notFromBorder) { cancel = true; }
	      if ($previousPageEl.length === 0 || $currentPageEl.length === 0) { cancel = true; }
	      if (cancel) {
	        isTouched = false;
	        return;
	      }

	      if (paramsSwipeBackAnimateShadow) {
	        $pageShadowEl = $currentPageEl.find('.page-shadow-effect');
	        if ($pageShadowEl.length === 0) {
	          $pageShadowEl = $('<div class="page-shadow-effect"></div>');
	          $currentPageEl.append($pageShadowEl);
	        }
	      }
	      if (paramsSwipeBackAnimateOpacity) {
	        $pageOpacityEl = $previousPageEl.find('.page-opacity-effect');
	        if ($pageOpacityEl.length === 0) {
	          $pageOpacityEl = $('<div class="page-opacity-effect"></div>');
	          $previousPageEl.append($pageOpacityEl);
	        }
	      }

	      if (dynamicNavbar) {
	        if (separateNavbar) {
	          $currentNavbarInnerEl = $navbarEl.find('.navbar-current:not(.stacked)');
	          $previousNavbarInnerEl = $navbarEl.find('.navbar-previous:not(.stacked)');
	        } else {
	          $currentNavbarInnerEl = $currentPageEl.children('.navbar').children('.navbar-inner');
	          $previousNavbarInnerEl = $previousPageEl.children('.navbar').children('.navbar-inner');
	        }
	        if ($previousNavbarInnerEl.length > 1) {
	          $previousNavbarInnerEl = $previousNavbarInnerEl.eq($previousNavbarInnerEl.length - 1);
	        }

	        animatableNavEls = animatableNavElements($previousNavbarInnerEl, $currentNavbarInnerEl);
	      }

	      // Close/Hide Any Picker
	      if ($('.sheet.modal-in').length > 0 && app.sheet) {
	        app.sheet.close($('.sheet.modal-in'));
	      }
	    }
	    e.f7PreventPanelSwipe = true;
	    isMoved = true;
	    app.preventSwipePanelBySwipeBack = true;
	    e.preventDefault();

	    // RTL inverter
	    var inverter = app.rtl ? -1 : 1;

	    // Touches diff
	    touchesDiff = (pageX - touchesStart.x - paramsSwipeBackThreshold) * inverter;
	    if (touchesDiff < 0) { touchesDiff = 0; }
	    var percentage = Math.min(Math.max(touchesDiff / viewContainerWidth, 0), 1);

	    // Swipe Back Callback
	    var callbackData = {
	      percentage: percentage,
	      progress: percentage,
	      currentPageEl: $currentPageEl[0],
	      previousPageEl: $previousPageEl[0],
	      currentNavbarEl: $currentNavbarInnerEl[0],
	      previousNavbarEl: $previousNavbarInnerEl[0],
	    };
	    $el.trigger('swipeback:move', callbackData);
	    router.emit('swipebackMove', callbackData);

	    // Transform pages
	    var currentPageTranslate = touchesDiff * inverter;
	    var previousPageTranslate = ((touchesDiff / 5) - (viewContainerWidth / 5)) * inverter;
	    if (!app.rtl) {
	      currentPageTranslate = Math.min(currentPageTranslate, viewContainerWidth);
	      previousPageTranslate = Math.min(previousPageTranslate, 0);
	    } else {
	      currentPageTranslate = Math.max(currentPageTranslate, -viewContainerWidth);
	      previousPageTranslate = Math.max(previousPageTranslate, 0);
	    }
	    if (Device.pixelRatio === 1) {
	      currentPageTranslate = Math.round(currentPageTranslate);
	      previousPageTranslate = Math.round(previousPageTranslate);
	    }

	    router.swipeBackActive = true;
	    $([$currentPageEl[0], $previousPageEl[0]]).addClass('page-swipeback-active');

	    $currentPageEl.transform(("translate3d(" + currentPageTranslate + "px,0,0)"));
	    if (paramsSwipeBackAnimateShadow) { $pageShadowEl[0].style.opacity = 1 - (1 * percentage); }

	    if (app.theme === 'ios') {
	      $previousPageEl.transform(("translate3d(" + previousPageTranslate + "px,0,0)"));
	    }
	    if (paramsSwipeBackAnimateOpacity) { $pageShadowEl[0].style.opacity = 1 - (1 * percentage); }

	    // Dynamic Navbars Animation
	    if (!dynamicNavbar) { return; }

	    setAnimatableNavElements({ progress: percentage });
	  }
	  function handleTouchEnd() {
	    app.preventSwipePanelBySwipeBack = false;
	    if (!isTouched || !isMoved) {
	      isTouched = false;
	      isMoved = false;
	      return;
	    }
	    isTouched = false;
	    isMoved = false;
	    router.swipeBackActive = false;
	    $([$currentPageEl[0], $previousPageEl[0]]).removeClass('page-swipeback-active');
	    if (touchesDiff === 0) {
	      $([$currentPageEl[0], $previousPageEl[0]]).transform('');
	      if ($pageShadowEl && $pageShadowEl.length > 0) { $pageShadowEl.remove(); }
	      if ($pageOpacityEl && $pageOpacityEl.length > 0) { $pageOpacityEl.remove(); }
	      if (dynamicNavbar) {
	        setAnimatableNavElements({ reset: true });
	      }
	      return;
	    }
	    var timeDiff = Utils.now() - touchStartTime;
	    var pageChanged = false;
	    // Swipe back to previous page
	    if (
	      (timeDiff < 300 && touchesDiff > 10)
	      || (timeDiff >= 300 && touchesDiff > viewContainerWidth / 2)
	    ) {
	      $currentPageEl.removeClass('page-current').addClass(("page-next" + (app.theme !== 'ios' ? ' page-next-on-right' : '')));
	      $previousPageEl.removeClass('page-previous').addClass('page-current').removeAttr('aria-hidden');
	      if ($pageShadowEl) { $pageShadowEl[0].style.opacity = ''; }
	      if ($pageOpacityEl) { $pageOpacityEl[0].style.opacity = ''; }
	      if (dynamicNavbar) {
	        $currentNavbarInnerEl.removeClass('navbar-current').addClass('navbar-next');
	        $previousNavbarInnerEl.removeClass('navbar-previous').addClass('navbar-current').removeAttr('aria-hidden');
	      }
	      pageChanged = true;
	    }
	    // Reset custom styles
	    // Add transitioning class for transition-duration
	    $([$currentPageEl[0], $previousPageEl[0]]).addClass('page-transitioning page-transitioning-swipeback').transform('');

	    if (dynamicNavbar) {
	      setAnimatableNavElements({ progress: pageChanged ? 1 : 0, transition: true });
	    }
	    allowViewTouchMove = false;
	    router.allowPageChange = false;

	    // Swipe Back Callback
	    var callbackData = {
	      currentPageEl: $currentPageEl[0],
	      previousPageEl: $previousPageEl[0],
	      currentNavbarEl: $currentNavbarInnerEl[0],
	      previousNavbarEl: $previousNavbarInnerEl[0],
	    };

	    if (pageChanged) {
	      // Update Route
	      router.currentRoute = $previousPageEl[0].f7Page.route;
	      router.currentPage = $previousPageEl[0];

	      // Page before animation callback
	      router.pageCallback('beforeOut', $currentPageEl, $currentNavbarInnerEl, 'current', 'next', { route: $currentPageEl[0].f7Page.route, swipeBack: true });
	      router.pageCallback('beforeIn', $previousPageEl, $previousNavbarInnerEl, 'previous', 'current', { route: $previousPageEl[0].f7Page.route, swipeBack: true }, $currentPageEl[0]);

	      $el.trigger('swipeback:beforechange', callbackData);
	      router.emit('swipebackBeforeChange', callbackData);
	    } else {
	      $el.trigger('swipeback:beforereset', callbackData);
	      router.emit('swipebackBeforeReset', callbackData);
	    }

	    $currentPageEl.transitionEnd(function () {
	      $([$currentPageEl[0], $previousPageEl[0]]).removeClass('page-transitioning page-transitioning-swipeback');
	      if (dynamicNavbar) {
	        setAnimatableNavElements({ reset: true, transition: false });
	      }
	      allowViewTouchMove = true;
	      router.allowPageChange = true;
	      if (pageChanged) {
	        // Update History
	        if (router.history.length === 1) {
	          router.history.unshift(router.url);
	        }
	        router.history.pop();
	        router.saveHistory();

	        // Update push state
	        if (params.pushState) {
	          History.back();
	        }

	        // Page after animation callback
	        router.pageCallback('afterOut', $currentPageEl, $currentNavbarInnerEl, 'current', 'next', { route: $currentPageEl[0].f7Page.route, swipeBack: true });
	        router.pageCallback('afterIn', $previousPageEl, $previousNavbarInnerEl, 'previous', 'current', { route: $previousPageEl[0].f7Page.route, swipeBack: true });

	        // Remove Old Page
	        if (params.stackPages && router.initialPages.indexOf($currentPageEl[0]) >= 0) {
	          $currentPageEl.addClass('stacked');
	          if (separateNavbar) {
	            $currentNavbarInnerEl.addClass('stacked');
	          }
	        } else {
	          router.pageCallback('beforeRemove', $currentPageEl, $currentNavbarInnerEl, 'next', { swipeBack: true });
	          router.removePage($currentPageEl);
	          if (separateNavbar) {
	            router.removeNavbar($currentNavbarInnerEl);
	          }
	        }

	        $el.trigger('swipeback:afterchange', callbackData);
	        router.emit('swipebackAfterChange', callbackData);

	        router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

	        if (params.preloadPreviousPage) {
	          router.back(router.history[router.history.length - 2], { preload: true });
	        }
	      } else {
	        $el.trigger('swipeback:afterreset', callbackData);
	        router.emit('swipebackAfterReset', callbackData);
	      }
	      if ($pageShadowEl && $pageShadowEl.length > 0) { $pageShadowEl.remove(); }
	      if ($pageOpacityEl && $pageOpacityEl.length > 0) { $pageOpacityEl.remove(); }
	    });
	  }

	  function attachEvents() {
	    var passiveListener = (app.touchEvents.start === 'touchstart' && Support.passiveListener) ? { passive: true, capture: false } : false;
	    $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
	    app.on('touchmove:active', handleTouchMove);
	    app.on('touchend:passive', handleTouchEnd);
	  }
	  function detachEvents() {
	    var passiveListener = (app.touchEvents.start === 'touchstart' && Support.passiveListener) ? { passive: true, capture: false } : false;
	    $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
	    app.off('touchmove:active', handleTouchMove);
	    app.off('touchend:passive', handleTouchEnd);
	  }

	  attachEvents();

	  router.on('routerDestroy', detachEvents);
	}

	function redirect (direction, route, options) {
	  var router = this;
	  var redirect = route.route.redirect;
	  if (options.initial && router.params.pushState) {
	    options.replaceState = true; // eslint-disable-line
	    options.history = true; // eslint-disable-line
	  }
	  function redirectResolve(redirectUrl, redirectOptions) {
	    if ( redirectOptions === void 0 ) redirectOptions = {};

	    router.allowPageChange = true;
	    router[direction](redirectUrl, Utils.extend({}, options, redirectOptions));
	  }
	  function redirectReject() {
	    router.allowPageChange = true;
	  }
	  if (typeof redirect === 'function') {
	    router.allowPageChange = false;
	    var redirectUrl = redirect.call(router, route, redirectResolve, redirectReject);
	    if (redirectUrl && typeof redirectUrl === 'string') {
	      router.allowPageChange = true;
	      return router[direction](redirectUrl, options);
	    }
	    return router;
	  }
	  return router[direction](redirect, options);
	}

	function processQueue(router, routerQueue, routeQueue, to, from, resolve, reject) {
	  var queue = [];

	  if (Array.isArray(routeQueue)) {
	    queue.push.apply(queue, routeQueue);
	  } else if (routeQueue && typeof routeQueue === 'function') {
	    queue.push(routeQueue);
	  }
	  if (routerQueue) {
	    if (Array.isArray(routerQueue)) {
	      queue.push.apply(queue, routerQueue);
	    } else {
	      queue.push(routerQueue);
	    }
	  }

	  function next() {
	    if (queue.length === 0) {
	      resolve();
	      return;
	    }
	    var queueItem = queue.shift();

	    queueItem.call(
	      router,
	      to,
	      from,
	      function () {
	        next();
	      },
	      function () {
	        reject();
	      }
	    );
	  }
	  next();
	}

	function processRouteQueue (to, from, resolve, reject) {
	  var router = this;
	  function enterNextRoute() {
	    if (to && to.route && (router.params.routesBeforeEnter || to.route.beforeEnter)) {
	      router.allowPageChange = false;
	      processQueue(
	        router,
	        router.params.routesBeforeEnter,
	        to.route.beforeEnter,
	        to,
	        from,
	        function () {
	          router.allowPageChange = true;
	          resolve();
	        },
	        function () {
	          reject();
	        }
	      );
	    } else {
	      resolve();
	    }
	  }
	  function leaveCurrentRoute() {
	    if (from && from.route && (router.params.routesBeforeLeave || from.route.beforeLeave)) {
	      router.allowPageChange = false;
	      processQueue(
	        router,
	        router.params.routesBeforeLeave,
	        from.route.beforeLeave,
	        to,
	        from,
	        function () {
	          router.allowPageChange = true;
	          enterNextRoute();
	        },
	        function () {
	          reject();
	        }
	      );
	    } else {
	      enterNextRoute();
	    }
	  }
	  leaveCurrentRoute();
	}

	function appRouterCheck (router, method) {
	  if (!router.view) {
	    throw new Error(("Framework7: it is not allowed to use router methods on global app router. Use router methods only on related View, e.g. app.views.main.router." + method + "(...)"));
	  }
	}

	function refreshPage() {
	  var router = this;
	  appRouterCheck(router, 'refreshPage');
	  return router.navigate(router.currentRoute.url, {
	    ignoreCache: true,
	    reloadCurrent: true,
	  });
	}

	function forward(el, forwardOptions) {
	  if ( forwardOptions === void 0 ) forwardOptions = {};

	  var router = this;
	  var $el = $(el);
	  var app = router.app;
	  var view = router.view;
	  var options = Utils.extend(false, {
	    animate: router.params.animate,
	    pushState: true,
	    replaceState: false,
	    history: true,
	    reloadCurrent: router.params.reloadPages,
	    reloadPrevious: false,
	    reloadAll: false,
	    clearPreviousHistory: false,
	    reloadDetail: router.params.reloadDetail,
	    on: {},
	  }, forwardOptions);

	  var masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
	  var isMaster = masterDetailEnabled && options.route && options.route.route && options.route.route.master === true;
	  var masterPageEl;
	  var otherDetailPageEl;

	  var currentRouteIsModal = router.currentRoute.modal;
	  var modalType;
	  if (!currentRouteIsModal) {
	    ('popup popover sheet loginScreen actions customModal panel').split(' ').forEach(function (modalLoadProp) {
	      if (router.currentRoute && router.currentRoute.route && router.currentRoute.route[modalLoadProp]) {
	        currentRouteIsModal = true;
	        modalType = modalLoadProp;
	      }
	    });
	  }

	  if (currentRouteIsModal) {
	    var modalToClose = router.currentRoute.modal
	                         || router.currentRoute.route.modalInstance
	                         || app[modalType].get();
	    var previousUrl = router.history[router.history.length - 2];
	    var previousRoute = router.findMatchingRoute(previousUrl);
	    if (!previousRoute && previousUrl) {
	      previousRoute = {
	        url: previousUrl,
	        path: previousUrl.split('?')[0],
	        query: Utils.parseUrlQuery(previousUrl),
	        route: {
	          path: previousUrl.split('?')[0],
	          url: previousUrl,
	        },
	      };
	    }

	    router.modalRemove(modalToClose);
	  }

	  var dynamicNavbar = router.dynamicNavbar;
	  var separateNavbar = router.separateNavbar;

	  var $viewEl = router.$el;
	  var $newPage = $el;
	  var reload = options.reloadPrevious || options.reloadCurrent || options.reloadAll;
	  var $oldPage;

	  var $navbarEl;
	  var $newNavbarInner;
	  var $oldNavbarInner;

	  router.allowPageChange = false;
	  if ($newPage.length === 0) {
	    router.allowPageChange = true;
	    return router;
	  }

	  if ($newPage.length) {
	    // Remove theme elements
	    router.removeThemeElements($newPage);
	  }

	  if (dynamicNavbar) {
	    $newNavbarInner = $newPage.children('.navbar').children('.navbar-inner');
	    if (separateNavbar) {
	      $navbarEl = router.$navbarEl;
	      if ($newNavbarInner.length > 0) {
	        $newPage.children('.navbar').remove();
	      }
	      if ($newNavbarInner.length === 0 && $newPage[0] && $newPage[0].f7Page) {
	        // Try from pageData
	        $newNavbarInner = $newPage[0].f7Page.$navbarEl;
	      }
	    }
	  }

	  // Save Keep Alive Cache
	  if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
	    options.route.route.keepAliveData = {
	      pageEl: $el[0],
	    };
	  }

	  // Pages In View
	  var $pagesInView = $viewEl
	    .children('.page:not(.stacked)')
	    .filter(function (index, pageInView) { return pageInView !== $newPage[0]; });

	  // Navbars In View
	  var $navbarsInView;
	  if (separateNavbar) {
	    $navbarsInView = $navbarEl
	      .children('.navbar-inner:not(.stacked)')
	      .filter(function (index, navbarInView) { return navbarInView !== $newNavbarInner[0]; });
	  }

	  // Exit when reload previous and only 1 page in view so nothing ro reload
	  if (options.reloadPrevious && $pagesInView.length < 2) {
	    router.allowPageChange = true;
	    return router;
	  }

	  // Find Detail' master page
	  var isDetail;
	  var reloadDetail;
	  if (masterDetailEnabled && !options.reloadAll) {
	    for (var i = 0; i < $pagesInView.length; i += 1) {
	      if (!masterPageEl
	        && $pagesInView[i].classList.contains('page-master')
	      ) {
	        masterPageEl = $pagesInView[i];
	        continue; // eslint-disable-line
	      }
	    }
	    isDetail = !isMaster && masterPageEl;

	    if (isDetail) {
	      // Find Other Detail
	      if (masterPageEl) {
	        for (var i$1 = 0; i$1 < $pagesInView.length; i$1 += 1) {
	          if ($pagesInView[i$1].classList.contains('page-master-detail')
	          ) {
	            otherDetailPageEl = $pagesInView[i$1];
	            continue; // eslint-disable-line
	          }
	        }
	      }
	    }
	    reloadDetail = isDetail && options.reloadDetail && app.width >= router.params.masterDetailBreakpoint && masterPageEl;
	  }

	  // New Page
	  var newPagePosition = 'next';
	  if (options.reloadCurrent || options.reloadAll || reloadDetail) {
	    newPagePosition = 'current';
	  } else if (options.reloadPrevious) {
	    newPagePosition = 'previous';
	  }
	  $newPage
	    .removeClass('page-previous page-current page-next')
	    .addClass(("page-" + newPagePosition + (isMaster ? ' page-master' : '') + (isDetail ? ' page-master-detail' : '')))
	    .removeClass('stacked')
	    .trigger('page:unstack')
	    .trigger('page:position', { position: newPagePosition });
	  if (isMaster || isDetail) {
	    $newPage.trigger('page:role', { role: isMaster ? 'master' : 'detail' });
	  }


	  if (dynamicNavbar && $newNavbarInner.length) {
	    $newNavbarInner
	      .removeClass('navbar-previous navbar-current navbar-next')
	      .addClass(("navbar-" + newPagePosition + (isMaster ? ' navbar-master' : '') + (isDetail ? ' navbar-master-detail' : '')))
	      .removeClass('stacked');
	  }

	  // Find Old Page
	  if (options.reloadCurrent || reloadDetail) {
	    $oldPage = $pagesInView.eq($pagesInView.length - 1);
	    if (separateNavbar) {
	      // $oldNavbarInner = $navbarsInView.eq($pagesInView.length - 1);
	      $oldNavbarInner = $(app.navbar.getElByPage($oldPage));
	    }
	  } else if (options.reloadPrevious) {
	    $oldPage = $pagesInView.eq($pagesInView.length - 2);
	    if (separateNavbar) {
	      // $oldNavbarInner = $navbarsInView.eq($pagesInView.length - 2);
	      $oldNavbarInner = $(app.navbar.getElByPage($oldPage));
	    }
	  } else if (options.reloadAll) {
	    $oldPage = $pagesInView.filter(function (index, pageEl) { return pageEl !== $newPage[0]; });
	    if (separateNavbar) {
	      $oldNavbarInner = $navbarsInView.filter(function (index, navbarEl) { return navbarEl !== $newNavbarInner[0]; });
	    }
	  } else {
	    if ($pagesInView.length > 1) {
	      var i$2 = 0;
	      for (i$2 = 0; i$2 < $pagesInView.length - 1; i$2 += 1) {
	        if (masterPageEl
	          && $pagesInView[i$2] === masterPageEl
	        ) {
	          $pagesInView.eq(i$2).addClass('page-master-stacked');
	          $pagesInView.eq(i$2).trigger('page:masterstack');
	          if (separateNavbar) {
	            $(app.navbar.getElByPage(masterPageEl)).addClass('navbar-master-stacked');
	          }
	          continue; // eslint-disable-line
	        }
	        var oldNavbarInnerEl = app.navbar.getElByPage($pagesInView.eq(i$2));
	        if (router.params.stackPages) {
	          $pagesInView.eq(i$2).addClass('stacked');
	          $pagesInView.eq(i$2).trigger('page:stack');
	          if (separateNavbar) {
	            $(oldNavbarInnerEl).addClass('stacked');
	          }
	        } else {
	          // Page remove event
	          router.pageCallback('beforeRemove', $pagesInView[i$2], $navbarsInView && $navbarsInView[i$2], 'previous', undefined, options);
	          router.removePage($pagesInView[i$2]);
	          if (separateNavbar && oldNavbarInnerEl) {
	            router.removeNavbar(oldNavbarInnerEl);
	          }
	        }
	      }
	    }
	    $oldPage = $viewEl
	      .children('.page:not(.stacked)')
	      .filter(function (index, page) { return page !== $newPage[0]; });
	    if (separateNavbar) {
	      $oldNavbarInner = $navbarEl
	        .children('.navbar-inner:not(.stacked)')
	        .filter(function (index, navbarInner) { return navbarInner !== $newNavbarInner[0]; });
	    }
	  }

	  if (dynamicNavbar && !separateNavbar) {
	    $oldNavbarInner = $oldPage.children('.navbar').children('.navbar-inner');
	  }
	  if (isDetail && !options.reloadAll) {
	    if ($oldPage.length > 1 || reloadDetail) {
	      $oldPage = $oldPage.filter(function (pageIndex, pageEl) { return !pageEl.classList.contains('page-master'); });
	    }
	    if ($oldNavbarInner && ($oldNavbarInner.length > 1 || reloadDetail)) {
	      $oldNavbarInner = $oldNavbarInner.filter(function (navbarIndex, navbarEl) { return !navbarEl.classList.contains('navbar-master'); });
	    }
	  }

	  // Push State
	  if (router.params.pushState && (options.pushState || options.replaceState) && !options.reloadPrevious) {
	    var pushStateRoot = router.params.pushStateRoot || '';
	    History[options.reloadCurrent || (reloadDetail && otherDetailPageEl) || options.reloadAll || options.replaceState ? 'replace' : 'push'](
	      view.id,
	      {
	        url: options.route.url,
	      },
	      pushStateRoot + router.params.pushStateSeparator + options.route.url
	    );
	  }

	  if (!options.reloadPrevious) {
	    // Current Page & Navbar
	    router.currentPageEl = $newPage[0];
	    if (dynamicNavbar && $newNavbarInner.length) {
	      router.currentNavbarEl = $newNavbarInner[0];
	    } else {
	      delete router.currentNavbarEl;
	    }

	    // Current Route
	    router.currentRoute = options.route;
	  }

	  // Update router history
	  var url = options.route.url;

	  if (options.history) {
	    if (((options.reloadCurrent || (reloadDetail && otherDetailPageEl)) && router.history.length) > 0 || options.replaceState) {
	      router.history[router.history.length - (options.reloadPrevious ? 2 : 1)] = url;
	    } else if (options.reloadPrevious) {
	      router.history[router.history.length - 2] = url;
	    } else if (options.reloadAll) {
	      router.history = [url];
	    } else {
	      router.history.push(url);
	    }
	  }
	  router.saveHistory();

	  // Insert new page and navbar
	  var newPageInDom = $newPage.parents(doc).length > 0;
	  var f7Component = $newPage[0].f7Component;
	  if (options.reloadPrevious) {
	    if (f7Component && !newPageInDom) {
	      f7Component.$mount(function (componentEl) {
	        $(componentEl).insertBefore($oldPage);
	      });
	    } else {
	      $newPage.insertBefore($oldPage);
	    }
	    if (separateNavbar && $newNavbarInner.length) {
	      if ($newNavbarInner.children('.title-large').length) {
	        $newNavbarInner.addClass('navbar-inner-large');
	      }
	      if ($oldNavbarInner.length) {
	        $newNavbarInner.insertBefore($oldNavbarInner);
	      } else {
	        if (!router.$navbarEl.parents(doc).length) {
	          router.$el.prepend(router.$navbarEl);
	        }
	        $navbarEl.append($newNavbarInner);
	      }
	    }
	  } else {
	    if ($oldPage.next('.page')[0] !== $newPage[0]) {
	      if (f7Component && !newPageInDom) {
	        f7Component.$mount(function (componentEl) {
	          $viewEl.append(componentEl);
	        });
	      } else {
	        $viewEl.append($newPage[0]);
	      }
	    }
	    if (separateNavbar && $newNavbarInner.length) {
	      if ($newNavbarInner.children('.title-large').length) {
	        $newNavbarInner.addClass('navbar-inner-large');
	      }
	      if (!router.$navbarEl.parents(doc).length) {
	        router.$el.prepend(router.$navbarEl);
	      }
	      $navbarEl.append($newNavbarInner[0]);
	    }
	  }
	  if (!newPageInDom) {
	    router.pageCallback('mounted', $newPage, $newNavbarInner, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);
	  } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
	    $newPage[0].f7PageMounted = true;
	    router.pageCallback('mounted', $newPage, $newNavbarInner, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);
	  }

	  // Remove old page
	  if ((options.reloadCurrent || reloadDetail) && $oldPage.length > 0) {
	    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
	      $oldPage.addClass('stacked');
	      $oldPage.trigger('page:stack');
	      if (separateNavbar) {
	        $oldNavbarInner.addClass('stacked');
	      }
	    } else {
	      // Page remove event
	      router.pageCallback('beforeOut', $oldPage, $oldNavbarInner, 'current', undefined, options);
	      router.pageCallback('afterOut', $oldPage, $oldNavbarInner, 'current', undefined, options);
	      router.pageCallback('beforeRemove', $oldPage, $oldNavbarInner, 'current', undefined, options);
	      router.removePage($oldPage);
	      if (separateNavbar && $oldNavbarInner && $oldNavbarInner.length) {
	        router.removeNavbar($oldNavbarInner);
	      }
	    }
	  } else if (options.reloadAll) {
	    $oldPage.each(function (index, pageEl) {
	      var $oldPageEl = $(pageEl);
	      var $oldNavbarInnerEl = $(app.navbar.getElByPage($oldPageEl));
	      if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
	        $oldPageEl.addClass('stacked');
	        $oldPageEl.trigger('page:stack');
	        if (separateNavbar) {
	          $oldNavbarInnerEl.addClass('stacked');
	        }
	      } else {
	        // Page remove event
	        if ($oldPageEl.hasClass('page-current')) {
	          router.pageCallback('beforeOut', $oldPage, $oldNavbarInner, 'current', undefined, options);
	          router.pageCallback('afterOut', $oldPage, $oldNavbarInner, 'current', undefined, options);
	        }
	        router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarInner && $oldNavbarInner.eq(index), 'previous', undefined, options);
	        router.removePage($oldPageEl);
	        if (separateNavbar && $oldNavbarInnerEl.length) {
	          router.removeNavbar($oldNavbarInnerEl);
	        }
	      }
	    });
	  } else if (options.reloadPrevious) {
	    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
	      $oldPage.addClass('stacked');
	      $oldPage.trigger('page:stack');
	      if (separateNavbar) {
	        $oldNavbarInner.addClass('stacked');
	      }
	    } else {
	      // Page remove event
	      router.pageCallback('beforeRemove', $oldPage, $oldNavbarInner, 'previous', undefined, options);
	      router.removePage($oldPage);
	      if (separateNavbar && $oldNavbarInner && $oldNavbarInner.length) {
	        router.removeNavbar($oldNavbarInner);
	      }
	    }
	  }

	  // Load Tab
	  if (options.route.route.tab) {
	    router.tabLoad(options.route.route.tab, Utils.extend({}, options, {
	      history: false,
	      pushState: false,
	    }));
	  }

	  // Page init and before init events
	  router.pageCallback('init', $newPage, $newNavbarInner, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);

	  if (options.reloadCurrent || options.reloadAll || reloadDetail) {
	    router.allowPageChange = true;
	    router.pageCallback('beforeIn', $newPage, $newNavbarInner, newPagePosition, 'current', options);
	    $newPage.removeAttr('aria-hidden');
	    if (dynamicNavbar && $newNavbarInner) {
	      $newNavbarInner.removeAttr('aria-hidden');
	    }
	    router.pageCallback('afterIn', $newPage, $newNavbarInner, newPagePosition, 'current', options);
	    if (options.reloadCurrent && options.clearPreviousHistory) { router.clearPreviousHistory(); }
	    if (reloadDetail) {
	      masterPageEl.classList.add('page-previous');
	      masterPageEl.classList.remove('page-current');
	      $(masterPageEl).trigger('page:position', { position: 'previous' });
	      if (masterPageEl.f7Page && masterPageEl.f7Page.navbarEl) {
	        masterPageEl.f7Page.navbarEl.classList.add('navbar-previous');
	        masterPageEl.f7Page.navbarEl.classList.remove('navbar-current');
	      }
	    }
	    return router;
	  }
	  if (options.reloadPrevious) {
	    router.allowPageChange = true;
	    return router;
	  }

	  // Before animation event
	  router.pageCallback('beforeOut', $oldPage, $oldNavbarInner, 'current', 'previous', options);
	  router.pageCallback('beforeIn', $newPage, $newNavbarInner, 'next', 'current', options);

	  // Animation
	  function afterAnimation() {
	    var pageClasses = 'page-previous page-current page-next';
	    var navbarClasses = 'navbar-previous navbar-current navbar-next';
	    $newPage.removeClass(pageClasses).addClass('page-current').removeAttr('aria-hidden').trigger('page:position', { position: 'current' });
	    $oldPage.removeClass(pageClasses).addClass('page-previous').trigger('page:position', { position: 'previous' });
	    if (!$oldPage.hasClass('page-master')) {
	      $oldPage.attr('aria-hidden', 'true');
	    }
	    if (dynamicNavbar) {
	      $newNavbarInner.removeClass(navbarClasses).addClass('navbar-current').removeAttr('aria-hidden');
	      $oldNavbarInner.removeClass(navbarClasses).addClass('navbar-previous');
	      if (!$oldNavbarInner.hasClass('navbar-master')) {
	        $oldNavbarInner.attr('aria-hidden', 'true');
	      }
	    }
	    // After animation event
	    router.allowPageChange = true;
	    router.pageCallback('afterOut', $oldPage, $oldNavbarInner, 'current', 'previous', options);
	    router.pageCallback('afterIn', $newPage, $newNavbarInner, 'next', 'current', options);

	    var keepOldPage = (router.params.preloadPreviousPage || router.params[((app.theme) + "SwipeBack")]) && !isMaster;
	    if (!keepOldPage) {
	      if ($newPage.hasClass('smart-select-page') || $newPage.hasClass('photo-browser-page') || $newPage.hasClass('autocomplete-page') || $newPage.hasClass('color-picker-page')) {
	        keepOldPage = true;
	      }
	    }
	    if (!keepOldPage) {
	      if (router.params.stackPages) {
	        $oldPage.addClass('stacked');
	        $oldPage.trigger('page:stack');
	        if (separateNavbar) {
	          $oldNavbarInner.addClass('stacked');
	        }
	      } else if (!($newPage.attr('data-name') && $newPage.attr('data-name') === 'smart-select-page')) {
	        // Remove event
	        router.pageCallback('beforeRemove', $oldPage, $oldNavbarInner, 'previous', undefined, options);
	        router.removePage($oldPage);
	        if (separateNavbar && $oldNavbarInner.length) {
	          router.removeNavbar($oldNavbarInner);
	        }
	      }
	    }
	    if (options.clearPreviousHistory) { router.clearPreviousHistory(); }
	    router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

	    if (router.params.pushState) {
	      History.clearRouterQueue();
	    }
	  }
	  function setPositionClasses() {
	    var pageClasses = 'page-previous page-current page-next';
	    var navbarClasses = 'navbar-previous navbar-current navbar-next';
	    $oldPage.removeClass(pageClasses).addClass('page-current').removeAttr('aria-hidden').trigger('page:position', { position: 'current' });
	    $newPage.removeClass(pageClasses).addClass('page-next').removeAttr('aria-hidden').trigger('page:position', { position: 'next' });
	    if (dynamicNavbar) {
	      $oldNavbarInner.removeClass(navbarClasses).addClass('navbar-current').removeAttr('aria-hidden');
	      $newNavbarInner.removeClass(navbarClasses).addClass('navbar-next').removeAttr('aria-hidden');
	    }
	  }
	  if (options.animate && !(isMaster && app.width >= router.params.masterDetailBreakpoint)) {
	    var delay = router.params[((router.app.theme) + "PageLoadDelay")];
	    if (delay) {
	      setTimeout(function () {
	        setPositionClasses();
	        router.animate($oldPage, $newPage, $oldNavbarInner, $newNavbarInner, 'forward', function () {
	          afterAnimation();
	        });
	      }, delay);
	    } else {
	      setPositionClasses();
	      router.animate($oldPage, $newPage, $oldNavbarInner, $newNavbarInner, 'forward', function () {
	        afterAnimation();
	      });
	    }
	  } else {
	    afterAnimation();
	  }
	  return router;
	}
	function load(loadParams, loadOptions, ignorePageChange) {
	  if ( loadParams === void 0 ) loadParams = {};
	  if ( loadOptions === void 0 ) loadOptions = {};

	  var router = this;
	  if (!router.allowPageChange && !ignorePageChange) { return router; }
	  var params = loadParams;
	  var options = loadOptions;
	  var url = params.url;
	  var content = params.content;
	  var el = params.el;
	  var pageName = params.pageName;
	  var template = params.template;
	  var templateUrl = params.templateUrl;
	  var component = params.component;
	  var componentUrl = params.componentUrl;

	  if (!options.reloadCurrent
	    && options.route
	    && options.route.route
	    && options.route.route.parentPath
	    && router.currentRoute.route
	    && router.currentRoute.route.parentPath === options.route.route.parentPath) {
	    // Do something nested
	    if (options.route.url === router.url) {
	      router.allowPageChange = true;
	      return false;
	    }
	    // Check for same params
	    var sameParams = Object.keys(options.route.params).length === Object.keys(router.currentRoute.params).length;
	    if (sameParams) {
	      // Check for equal params name
	      Object.keys(options.route.params).forEach(function (paramName) {
	        if (
	          !(paramName in router.currentRoute.params)
	          || (router.currentRoute.params[paramName] !== options.route.params[paramName])
	        ) {
	          sameParams = false;
	        }
	      });
	    }
	    if (sameParams) {
	      if (options.route.route.tab) {
	        return router.tabLoad(options.route.route.tab, options);
	      }
	      return false;
	    }
	    if (!sameParams
	      && options.route.route.tab
	      && router.currentRoute.route.tab
	      && router.currentRoute.parentPath === options.route.parentPath
	    ) {
	      return router.tabLoad(options.route.route.tab, options);
	    }
	  }

	  if (
	    options.route
	    && options.route.url
	    && router.url === options.route.url
	    && !(options.reloadCurrent || options.reloadPrevious)
	    && !router.params.allowDuplicateUrls
	  ) {
	    router.allowPageChange = true;
	    return false;
	  }

	  if (!options.route && url) {
	    options.route = router.parseRouteUrl(url);
	    Utils.extend(options.route, { route: { url: url, path: url } });
	  }

	  // Component Callbacks
	  function resolve(pageEl, newOptions) {
	    return router.forward(pageEl, Utils.extend(options, newOptions));
	  }
	  function reject() {
	    router.allowPageChange = true;
	    return router;
	  }

	  if (url || templateUrl || componentUrl) {
	    router.allowPageChange = false;
	  }

	  // Proceed
	  if (content) {
	    router.forward(router.getPageEl(content), options);
	  } else if (template || templateUrl) {
	    // Parse template and send page element
	    try {
	      router.pageTemplateLoader(template, templateUrl, options, resolve, reject);
	    } catch (err) {
	      router.allowPageChange = true;
	      throw err;
	    }
	  } else if (el) {
	    // Load page from specified HTMLElement or by page name in pages container
	    router.forward(router.getPageEl(el), options);
	  } else if (pageName) {
	    // Load page by page name in pages container
	    router.forward(router.$el.children((".page[data-name=\"" + pageName + "\"]")).eq(0), options);
	  } else if (component || componentUrl) {
	    // Load from component (F7/Vue/React/...)
	    try {
	      router.pageComponentLoader(router.el, component, componentUrl, options, resolve, reject);
	    } catch (err) {
	      router.allowPageChange = true;
	      throw err;
	    }
	  } else if (url) {
	    // Load using XHR
	    if (router.xhr) {
	      router.xhr.abort();
	      router.xhr = false;
	    }
	    router.xhrRequest(url, options)
	      .then(function (pageContent) {
	        router.forward(router.getPageEl(pageContent), options);
	      })
	      .catch(function () {
	        router.allowPageChange = true;
	      });
	  }
	  return router;
	}
	function navigate(navigateParams, navigateOptions) {
	  if ( navigateOptions === void 0 ) navigateOptions = {};

	  var router = this;
	  if (router.swipeBackActive) { return router; }
	  var url;
	  var createRoute;
	  var name;
	  var query;
	  var params;
	  var route;
	  if (typeof navigateParams === 'string') {
	    url = navigateParams;
	  } else {
	    url = navigateParams.url;
	    createRoute = navigateParams.route;
	    name = navigateParams.name;
	    query = navigateParams.query;
	    params = navigateParams.params;
	  }
	  if (name) {
	    // find route by name
	    route = router.findRouteByKey('name', name);
	    if (!route) {
	      throw new Error(("Framework7: route with name \"" + name + "\" not found"));
	    }
	    url = router.constructRouteUrl(route, { params: params, query: query });
	    if (url) {
	      return router.navigate(url, navigateOptions);
	    }
	    throw new Error(("Framework7: can't construct URL for route with name \"" + name + "\""));
	  }
	  var app = router.app;
	  appRouterCheck(router, 'navigate');
	  if (url === '#' || url === '') {
	    return router;
	  }

	  var navigateUrl = url.replace('./', '');
	  if (navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
	    var currentPath = router.currentRoute.parentPath || router.currentRoute.path;
	    navigateUrl = ((currentPath ? (currentPath + "/") : '/') + navigateUrl)
	      .replace('///', '/')
	      .replace('//', '/');
	  }
	  if (createRoute) {
	    route = Utils.extend(router.parseRouteUrl(navigateUrl), {
	      route: Utils.extend({}, createRoute),
	    });
	  } else {
	    route = router.findMatchingRoute(navigateUrl);
	  }

	  if (!route) {
	    return router;
	  }

	  if (route.route.redirect) {
	    return redirect.call(router, 'navigate', route, navigateOptions);
	  }


	  var options = {};
	  if (route.route.options) {
	    Utils.extend(options, route.route.options, navigateOptions);
	  } else {
	    Utils.extend(options, navigateOptions);
	  }
	  options.route = route;

	  if (options && options.context) {
	    route.context = options.context;
	    options.route.context = options.context;
	  }

	  function resolve() {
	    var routerLoaded = false;
	    ('popup popover sheet loginScreen actions customModal panel').split(' ').forEach(function (modalLoadProp) {
	      if (route.route[modalLoadProp] && !routerLoaded) {
	        routerLoaded = true;
	        router.modalLoad(modalLoadProp, route, options);
	      }
	    });
	    if (route.route.keepAlive && route.route.keepAliveData) {
	      router.load({ el: route.route.keepAliveData.pageEl }, options, false);
	      routerLoaded = true;
	    }
	    ('url content component pageName el componentUrl template templateUrl').split(' ').forEach(function (pageLoadProp) {
	      var obj;

	      if (route.route[pageLoadProp] && !routerLoaded) {
	        routerLoaded = true;
	        router.load(( obj = {}, obj[pageLoadProp] = route.route[pageLoadProp], obj ), options, false);
	      }
	    });
	    if (routerLoaded) { return; }
	    // Async
	    function asyncResolve(resolveParams, resolveOptions) {
	      router.allowPageChange = false;
	      var resolvedAsModal = false;
	      if (resolveOptions && resolveOptions.context) {
	        if (!route.context) { route.context = resolveOptions.context; }
	        else { route.context = Utils.extend({}, route.context, resolveOptions.context); }
	        options.route.context = route.context;
	      }
	      ('popup popover sheet loginScreen actions customModal panel').split(' ').forEach(function (modalLoadProp) {
	        if (resolveParams[modalLoadProp]) {
	          resolvedAsModal = true;
	          var modalRoute = Utils.extend({}, route, { route: resolveParams });
	          router.allowPageChange = true;
	          router.modalLoad(modalLoadProp, modalRoute, Utils.extend(options, resolveOptions));
	        }
	      });
	      if (resolvedAsModal) { return; }
	      router.load(resolveParams, Utils.extend(options, resolveOptions), true);
	    }
	    function asyncReject() {
	      router.allowPageChange = true;
	    }
	    if (route.route.async) {
	      router.allowPageChange = false;

	      route.route.async.call(router, options.route, router.currentRoute, asyncResolve, asyncReject);
	    }
	  }
	  function reject() {
	    router.allowPageChange = true;
	  }

	  if (router.params.masterDetailBreakpoint > 0 && route.route.masterRoute) {
	    // load detail route
	    var preloadMaster = true;
	    if (router.currentRoute && router.currentRoute.route) {
	      if (router.currentRoute.route.master && (router.currentRoute.route === route.route.masterRoute || router.currentRoute.route.path === route.route.masterRoute.path)) {
	        preloadMaster = false;
	      }
	      if (router.currentRoute.route.masterRoute && ((router.currentRoute.route.masterRoute === route.route.masterRoute) || (router.currentRoute.route.masterRoute.path === route.route.masterRoute.path))) {
	        preloadMaster = false;
	      }
	    }
	    if (preloadMaster) {
	      router.navigate(route.route.masterRoute.path, {
	        animate: false,
	        reloadAll: navigateOptions.reloadAll,
	        reloadCurrent: navigateOptions.reloadCurrent,
	        reloadPrevious: navigateOptions.reloadPrevious,
	        once: {
	          pageAfterIn: function pageAfterIn() {
	            router.navigate(navigateParams, Utils.extend({}, navigateOptions, {
	              animate: false,
	              reloadAll: false,
	              reloadCurrent: false,
	              reloadPrevious: false,
	            }));
	          },
	        },
	      });
	      return router;
	    }
	  }

	  processRouteQueue.call(
	    router,
	    route,
	    router.currentRoute,
	    function () {
	      if (route.route.modules) {
	        app
	          .loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules])
	          .then(function () {
	            resolve();
	          })
	          .catch(function () {
	            reject();
	          });
	      } else {
	        resolve();
	      }
	    },
	    function () {
	      reject();
	    }
	  );

	  // Return Router
	  return router;
	}

	function tabLoad(tabRoute, loadOptions) {
	  if ( loadOptions === void 0 ) loadOptions = {};

	  var router = this;
	  var options = Utils.extend({
	    animate: router.params.animate,
	    pushState: true,
	    history: true,
	    parentPageEl: null,
	    preload: false,
	    on: {},
	  }, loadOptions);

	  var currentRoute;
	  var previousRoute;
	  if (options.route) {
	    // Set Route
	    if (!options.preload && options.route !== router.currentRoute) {
	      previousRoute = router.previousRoute;
	      router.currentRoute = options.route;
	    }
	    if (options.preload) {
	      currentRoute = options.route;
	      previousRoute = router.currentRoute;
	    } else {
	      currentRoute = router.currentRoute;
	      if (!previousRoute) { previousRoute = router.previousRoute; }
	    }

	    // Update Browser History
	    if (router.params.pushState && options.pushState && !options.reloadPrevious) {
	      History.replace(
	        router.view.id,
	        {
	          url: options.route.url,
	        },
	        (router.params.pushStateRoot || '') + router.params.pushStateSeparator + options.route.url
	      );
	    }

	    // Update Router History
	    if (options.history) {
	      router.history[Math.max(router.history.length - 1, 0)] = options.route.url;
	      router.saveHistory();
	    }
	  }

	  // Show Tab
	  var $parentPageEl = $(options.parentPageEl || router.currentPageEl);
	  var tabEl;
	  if ($parentPageEl.length && $parentPageEl.find(("#" + (tabRoute.id))).length) {
	    tabEl = $parentPageEl.find(("#" + (tabRoute.id))).eq(0);
	  } else if (router.view.selector) {
	    tabEl = (router.view.selector) + " #" + (tabRoute.id);
	  } else {
	    tabEl = "#" + (tabRoute.id);
	  }
	  var tabShowResult = router.app.tab.show({
	    tabEl: tabEl,
	    animate: options.animate,
	    tabRoute: options.route,
	  });

	  var $newTabEl = tabShowResult.$newTabEl;
	  var $oldTabEl = tabShowResult.$oldTabEl;
	  var animated = tabShowResult.animated;
	  var onTabsChanged = tabShowResult.onTabsChanged;

	  if ($newTabEl && $newTabEl.parents('.page').length > 0 && options.route) {
	    var tabParentPageData = $newTabEl.parents('.page')[0].f7Page;
	    if (tabParentPageData && options.route) {
	      tabParentPageData.route = options.route;
	    }
	  }

	  // Tab Content Loaded
	  function onTabLoaded(contentEl) {
	    // Remove theme elements
	    router.removeThemeElements($newTabEl);

	    var tabEventTarget = $newTabEl;
	    if (typeof contentEl !== 'string') { tabEventTarget = $(contentEl); }

	    tabEventTarget.trigger('tab:init tab:mounted', tabRoute);
	    router.emit('tabInit tabMounted', $newTabEl[0], tabRoute);

	    if ($oldTabEl && $oldTabEl.length) {
	      if (animated) {
	        onTabsChanged(function () {
	          router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
	          if (router.params.unloadTabContent) {
	            router.tabRemove($oldTabEl, $newTabEl, tabRoute);
	          }
	        });
	      } else {
	        router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
	        if (router.params.unloadTabContent) {
	          router.tabRemove($oldTabEl, $newTabEl, tabRoute);
	        }
	      }
	    }
	  }

	  if ($newTabEl[0].f7RouterTabLoaded) {
	    if (!$oldTabEl || !$oldTabEl.length) { return router; }
	    if (animated) {
	      onTabsChanged(function () {
	        router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
	      });
	    } else {
	      router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
	    }
	    return router;
	  }

	  // Load Tab Content
	  function loadTab(loadTabParams, loadTabOptions) {
	    // Load Tab Props
	    var url = loadTabParams.url;
	    var content = loadTabParams.content;
	    var el = loadTabParams.el;
	    var template = loadTabParams.template;
	    var templateUrl = loadTabParams.templateUrl;
	    var component = loadTabParams.component;
	    var componentUrl = loadTabParams.componentUrl;
	    // Component/Template Callbacks
	    function resolve(contentEl) {
	      router.allowPageChange = true;
	      if (!contentEl) { return; }
	      if (typeof contentEl === 'string') {
	        $newTabEl.html(contentEl);
	      } else {
	        $newTabEl.html('');
	        if (contentEl.f7Component) {
	          contentEl.f7Component.$mount(function (componentEl) {
	            $newTabEl.append(componentEl);
	          });
	        } else {
	          $newTabEl.append(contentEl);
	        }
	      }
	      $newTabEl[0].f7RouterTabLoaded = true;
	      onTabLoaded(contentEl);
	    }
	    function reject() {
	      router.allowPageChange = true;
	      return router;
	    }

	    if (content) {
	      resolve(content);
	    } else if (template || templateUrl) {
	      try {
	        router.tabTemplateLoader(template, templateUrl, loadTabOptions, resolve, reject);
	      } catch (err) {
	        router.allowPageChange = true;
	        throw err;
	      }
	    } else if (el) {
	      resolve(el);
	    } else if (component || componentUrl) {
	      // Load from component (F7/Vue/React/...)
	      try {
	        router.tabComponentLoader($newTabEl[0], component, componentUrl, loadTabOptions, resolve, reject);
	      } catch (err) {
	        router.allowPageChange = true;
	        throw err;
	      }
	    } else if (url) {
	      // Load using XHR
	      if (router.xhr) {
	        router.xhr.abort();
	        router.xhr = false;
	      }
	      router.xhrRequest(url, loadTabOptions)
	        .then(function (tabContent) {
	          resolve(tabContent);
	        })
	        .catch(function () {
	          router.allowPageChange = true;
	        });
	    }
	  }

	  var hasContentLoadProp;
	  ('url content component el componentUrl template templateUrl').split(' ').forEach(function (tabLoadProp) {
	    var obj;

	    if (tabRoute[tabLoadProp]) {
	      hasContentLoadProp = true;
	      loadTab(( obj = {}, obj[tabLoadProp] = tabRoute[tabLoadProp], obj ), options);
	    }
	  });

	  // Async
	  function asyncResolve(resolveParams, resolveOptions) {
	    loadTab(resolveParams, Utils.extend(options, resolveOptions));
	  }
	  function asyncReject() {
	    router.allowPageChange = true;
	  }
	  if (tabRoute.async) {
	    tabRoute.async.call(router, currentRoute, previousRoute, asyncResolve, asyncReject);
	  } else if (!hasContentLoadProp) {
	    router.allowPageChange = true;
	  }

	  return router;
	}
	function tabRemove($oldTabEl, $newTabEl, tabRoute) {
	  var router = this;

	  var hasTabComponentChild;
	  if ($oldTabEl[0]) {
	    $oldTabEl[0].f7RouterTabLoaded = false;
	    delete $oldTabEl[0].f7RouterTabLoaded;
	  }
	  $oldTabEl.children().each(function (index, tabChild) {
	    if (tabChild.f7Component) {
	      hasTabComponentChild = true;
	      $(tabChild).trigger('tab:beforeremove', tabRoute);
	      tabChild.f7Component.$destroy();
	    }
	  });
	  if (!hasTabComponentChild) {
	    $oldTabEl.trigger('tab:beforeremove', tabRoute);
	  }
	  router.emit('tabBeforeRemove', $oldTabEl[0], $newTabEl[0], tabRoute);
	  router.removeTabContent($oldTabEl[0], tabRoute);
	}

	function modalLoad(modalType, route, loadOptions) {
	  if ( loadOptions === void 0 ) loadOptions = {};

	  var router = this;
	  var app = router.app;
	  var isPanel = modalType === 'panel';
	  var modalOrPanel = isPanel ? 'panel' : 'modal';

	  var options = Utils.extend({
	    animate: router.params.animate,
	    pushState: true,
	    history: true,
	    on: {},
	  }, loadOptions);

	  var modalParams = Utils.extend({}, route.route[modalType]);
	  var modalRoute = route.route;

	  function onModalLoaded() {
	    // Create Modal
	    var modal = app[modalType].create(modalParams);
	    modalRoute.modalInstance = modal;

	    var hasEl = modal.el;

	    function closeOnSwipeBack() {
	      modal.close();
	    }
	    modal.on((modalOrPanel + "Open"), function () {
	      if (!hasEl) {
	        // Remove theme elements
	        router.removeThemeElements(modal.el);

	        // Emit events
	        modal.$el.trigger(((modalType.toLowerCase()) + ":init " + (modalType.toLowerCase()) + ":mounted"), route, modal);
	        router.emit(((!isPanel ? 'modalInit' : '') + " " + modalType + "Init " + modalType + "Mounted"), modal.el, route, modal);
	      }
	      router.once('swipeBackMove', closeOnSwipeBack);
	    });
	    modal.on((modalOrPanel + "Close"), function () {
	      router.off('swipeBackMove', closeOnSwipeBack);
	      if (!modal.closeByRouter) {
	        router.back();
	      }
	    });

	    modal.on((modalOrPanel + "Closed"), function () {
	      modal.$el.trigger(((modalType.toLowerCase()) + ":beforeremove"), route, modal);
	      modal.emit(("" + (!isPanel ? 'modalBeforeRemove ' : '') + modalType + "BeforeRemove"), modal.el, route, modal);
	      var modalComponent = modal.el.f7Component;
	      if (modalComponent) {
	        modalComponent.$destroy();
	      }
	      Utils.nextTick(function () {
	        if (modalComponent || modalParams.component) {
	          router.removeModal(modal.el);
	        }
	        modal.destroy();
	        delete modal.route;
	        delete modalRoute.modalInstance;
	      });
	    });

	    if (options.route) {
	      // Update Browser History
	      if (router.params.pushState && options.pushState) {
	        History.push(
	          router.view.id,
	          {
	            url: options.route.url,
	            modal: modalType,
	          },
	          (router.params.pushStateRoot || '') + router.params.pushStateSeparator + options.route.url
	        );
	      }

	      // Set Route
	      if (options.route !== router.currentRoute) {
	        modal.route = Utils.extend(options.route, { modal: modal });
	        router.currentRoute = modal.route;
	      }

	      // Update Router History
	      if (options.history) {
	        router.history.push(options.route.url);
	        router.saveHistory();
	      }
	    }

	    if (hasEl) {
	      // Remove theme elements
	      router.removeThemeElements(modal.el);

	      // Emit events
	      modal.$el.trigger(((modalType.toLowerCase()) + ":init " + (modalType.toLowerCase()) + ":mounted"), route, modal);
	      router.emit((modalOrPanel + "Init " + modalType + "Init " + modalType + "Mounted"), modal.el, route, modal);
	    }

	    // Open
	    modal.open();
	  }

	  // Load Modal Content
	  function loadModal(loadModalParams, loadModalOptions) {
	    // Load Modal Props
	    var url = loadModalParams.url;
	    var content = loadModalParams.content;
	    var template = loadModalParams.template;
	    var templateUrl = loadModalParams.templateUrl;
	    var component = loadModalParams.component;
	    var componentUrl = loadModalParams.componentUrl;

	    // Component/Template Callbacks
	    function resolve(contentEl) {
	      if (contentEl) {
	        if (typeof contentEl === 'string') {
	          modalParams.content = contentEl;
	        } else if (contentEl.f7Component) {
	          contentEl.f7Component.$mount(function (componentEl) {
	            modalParams.el = componentEl;
	            app.root.append(componentEl);
	          });
	        } else {
	          modalParams.el = contentEl;
	        }
	        onModalLoaded();
	      }
	    }
	    function reject() {
	      router.allowPageChange = true;
	      return router;
	    }

	    if (content) {
	      resolve(content);
	    } else if (template || templateUrl) {
	      try {
	        router.modalTemplateLoader(template, templateUrl, loadModalOptions, resolve, reject);
	      } catch (err) {
	        router.allowPageChange = true;
	        throw err;
	      }
	    } else if (component || componentUrl) {
	      // Load from component (F7/Vue/React/...)
	      try {
	        router.modalComponentLoader(app.root[0], component, componentUrl, loadModalOptions, resolve, reject);
	      } catch (err) {
	        router.allowPageChange = true;
	        throw err;
	      }
	    } else if (url) {
	      // Load using XHR
	      if (router.xhr) {
	        router.xhr.abort();
	        router.xhr = false;
	      }
	      router.xhrRequest(url, loadModalOptions)
	        .then(function (modalContent) {
	          modalParams.content = modalContent;
	          onModalLoaded();
	        })
	        .catch(function () {
	          router.allowPageChange = true;
	        });
	    } else {
	      onModalLoaded();
	    }
	  }

	  var foundLoadProp;
	  ('url content component el componentUrl template templateUrl').split(' ').forEach(function (modalLoadProp) {
	    var obj;

	    if (modalParams[modalLoadProp] && !foundLoadProp) {
	      foundLoadProp = true;
	      loadModal(( obj = {}, obj[modalLoadProp] = modalParams[modalLoadProp], obj ), options);
	    }
	  });
	  if (!foundLoadProp && modalType === 'actions') {
	    onModalLoaded();
	  }

	  // Async
	  function asyncResolve(resolveParams, resolveOptions) {
	    loadModal(resolveParams, Utils.extend(options, resolveOptions));
	  }
	  function asyncReject() {
	    router.allowPageChange = true;
	  }
	  if (modalParams.async) {
	    modalParams.async.call(router, options.route, router.currentRoute, asyncResolve, asyncReject);
	  }
	  return router;
	}
	function modalRemove(modal) {
	  Utils.extend(modal, { closeByRouter: true });
	  modal.close();
	}

	function backward(el, backwardOptions) {
	  var router = this;
	  var $el = $(el);
	  var app = router.app;
	  var view = router.view;

	  var options = Utils.extend({
	    animate: router.params.animate,
	    pushState: true,
	  }, backwardOptions);

	  var masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
	  var isMaster = masterDetailEnabled && options.route && options.route.route && options.route.route.master === true;
	  var masterPageEl;

	  var dynamicNavbar = router.dynamicNavbar;
	  var separateNavbar = router.separateNavbar;

	  var $newPage = $el;
	  var $oldPage = router.$el.children('.page-current');
	  var currentIsMaster = masterDetailEnabled && $oldPage.hasClass('page-master');

	  if ($newPage.length) {
	    // Remove theme elements
	    router.removeThemeElements($newPage);
	  }

	  var $navbarEl;
	  var $newNavbarInner;
	  var $oldNavbarInner;

	  if (dynamicNavbar) {
	    $newNavbarInner = $newPage.children('.navbar').children('.navbar-inner');
	    if (separateNavbar) {
	      $navbarEl = router.$navbarEl;
	      if ($newNavbarInner.length > 0) {
	        $newPage.children('.navbar').remove();
	      }
	      if ($newNavbarInner.length === 0 && $newPage[0] && $newPage[0].f7Page) {
	        // Try from pageData
	        $newNavbarInner = $newPage[0].f7Page.$navbarEl;
	      }
	      $oldNavbarInner = $navbarEl.find('.navbar-current');
	    } else {
	      $oldNavbarInner = $oldPage.children('.navbar').children('.navbar-inner');
	    }
	  }

	  router.allowPageChange = false;
	  if ($newPage.length === 0 || $oldPage.length === 0) {
	    router.allowPageChange = true;
	    return router;
	  }

	  // Remove theme elements
	  router.removeThemeElements($newPage);

	  // Save Keep Alive Cache
	  if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
	    options.route.route.keepAliveData = {
	      pageEl: $el[0],
	    };
	  }

	  // Pages In View
	  var isDetail;
	  if (masterDetailEnabled) {
	    var $pagesInView = router.$el
	      .children('.page:not(.stacked)')
	      .filter(function (index, pageInView) { return pageInView !== $newPage[0]; });

	    // Find Detail' master page
	    for (var i = 0; i < $pagesInView.length; i += 1) {
	      if (!masterPageEl
	        && $pagesInView[i].classList.contains('page-master')
	      ) {
	        masterPageEl = $pagesInView[i];
	        continue; // eslint-disable-line
	      }
	    }

	    isDetail = !isMaster
	      && masterPageEl
	      && (router.history.indexOf(options.route.url) > router.history.indexOf(masterPageEl.f7Page.route.url));
	  }


	  // New Page
	  $newPage
	    .addClass(("page-previous" + (isMaster ? ' page-master' : '') + (isDetail ? ' page-master-detail' : '')))
	    .removeClass('stacked')
	    .removeAttr('aria-hidden')
	    .trigger('page:unstack')
	    .trigger('page:position', { position: 'previous' });
	  if (isMaster || isDetail) {
	    $newPage.trigger('page:role', { role: isMaster ? 'master' : 'detail' });
	  }

	  if (dynamicNavbar && $newNavbarInner.length > 0) {
	    $newNavbarInner
	      .addClass(("navbar-previous" + (isMaster ? ' navbar-master' : '') + (isDetail ? ' navbar-master-detail' : '')))
	      .removeClass('stacked')
	      .removeAttr('aria-hidden');
	  }

	  // Remove previous page in case of "forced"
	  var backIndex;
	  if (options.force) {
	    if ($oldPage.prev('.page-previous:not(.stacked)').length > 0 || $oldPage.prev('.page-previous').length === 0) {
	      if (router.history.indexOf(options.route.url) >= 0) {
	        backIndex = router.history.length - router.history.indexOf(options.route.url) - 1;
	        router.history = router.history.slice(0, router.history.indexOf(options.route.url) + 2);
	        view.history = router.history;
	      } else if (router.history[[router.history.length - 2]]) {
	        router.history[router.history.length - 2] = options.route.url;
	      } else {
	        router.history.unshift(router.url);
	      }

	      if (backIndex && router.params.stackPages) {
	        $oldPage.prevAll('.page-previous').each(function (index, pageToRemove) {
	          var $pageToRemove = $(pageToRemove);
	          var $navbarToRemove;
	          if (separateNavbar) {
	            // $navbarToRemove = $oldNavbarInner.prevAll('.navbar-previous').eq(index);
	            $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
	          }
	          if ($pageToRemove[0] !== $newPage[0] && $pageToRemove.index() > $newPage.index()) {
	            if (router.initialPages.indexOf($pageToRemove[0]) >= 0) {
	              $pageToRemove.addClass('stacked');
	              $pageToRemove.trigger('page:stack');
	              if (separateNavbar) {
	                $navbarToRemove.addClass('stacked');
	              }
	            } else {
	              router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);
	              router.removePage($pageToRemove);
	              if (separateNavbar && $navbarToRemove.length > 0) {
	                router.removeNavbar($navbarToRemove);
	              }
	            }
	          }
	        });
	      } else {
	        var $pageToRemove = $oldPage.prev('.page-previous:not(.stacked)');
	        var $navbarToRemove;
	        if (separateNavbar) {
	          // $navbarToRemove = $oldNavbarInner.prev('.navbar-inner:not(.stacked)');
	          $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
	        }
	        if (router.params.stackPages && router.initialPages.indexOf($pageToRemove[0]) >= 0) {
	          $pageToRemove.addClass('stacked');
	          $pageToRemove.trigger('page:stack');
	          $navbarToRemove.addClass('stacked');
	        } else if ($pageToRemove.length > 0) {
	          router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);
	          router.removePage($pageToRemove);
	          if (separateNavbar && $navbarToRemove.length) {
	            router.removeNavbar($navbarToRemove);
	          }
	        }
	      }
	    }
	  }

	  // Insert new page
	  var newPageInDom = $newPage.parents(doc).length > 0;
	  var f7Component = $newPage[0].f7Component;

	  function insertPage() {
	    if ($newPage.next($oldPage).length === 0) {
	      if (!newPageInDom && f7Component) {
	        f7Component.$mount(function (componentEl) {
	          $(componentEl).insertBefore($oldPage);
	        });
	      } else {
	        $newPage.insertBefore($oldPage);
	      }
	    }
	    if (separateNavbar && $newNavbarInner.length) {
	      if ($newNavbarInner.children('.title-large').length) {
	        $newNavbarInner.addClass('navbar-inner-large');
	      }
	      $newNavbarInner.insertBefore($oldNavbarInner);
	      if ($oldNavbarInner.length > 0) {
	        $newNavbarInner.insertBefore($oldNavbarInner);
	      } else {
	        if (!router.$navbarEl.parents(doc).length) {
	          router.$el.prepend(router.$navbarEl);
	        }
	        $navbarEl.append($newNavbarInner);
	      }
	    }
	    if (!newPageInDom) {
	      router.pageCallback('mounted', $newPage, $newNavbarInner, 'previous', 'current', options, $oldPage);
	    } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
	      $newPage[0].f7PageMounted = true;
	      router.pageCallback('mounted', $newPage, $newNavbarInner, 'previous', 'current', options, $oldPage);
	    }
	  }

	  if (options.preload) {
	    // Insert Page
	    insertPage();
	    // Tab route
	    if (options.route.route.tab) {
	      router.tabLoad(options.route.route.tab, Utils.extend({}, options, {
	        history: false,
	        pushState: false,
	        preload: true,
	      }));
	    }
	    if (isMaster) {
	      $newPage
	        .removeClass('page-master-stacked')
	        .trigger('page:masterunstack');
	      if (separateNavbar) {
	        $(app.navbar.getElByPage($newPage)).removeClass('navbar-master-stacked');
	      }
	    }
	    // Page init and before init events
	    router.pageCallback('init', $newPage, $newNavbarInner, 'previous', 'current', options, $oldPage);
	    var $previousPages = $newPage.prevAll('.page-previous:not(.stacked):not(.page-master)');
	    if ($previousPages.length > 0) {
	      $previousPages.each(function (index, pageToRemove) {
	        var $pageToRemove = $(pageToRemove);
	        var $navbarToRemove;
	        if (separateNavbar) {
	          // $navbarToRemove = $newNavbarInner.prevAll('.navbar-previous:not(.stacked)').eq(index);
	          $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
	        }
	        if (router.params.stackPages && router.initialPages.indexOf(pageToRemove) >= 0) {
	          $pageToRemove.addClass('stacked');
	          $pageToRemove.trigger('page:stack');
	          if (separateNavbar) {
	            $navbarToRemove.addClass('stacked');
	          }
	        } else {
	          router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined);
	          router.removePage($pageToRemove);
	          if (separateNavbar && $navbarToRemove.length) {
	            router.removeNavbar($navbarToRemove);
	          }
	        }
	      });
	    }
	    router.allowPageChange = true;
	    return router;
	  }

	  // History State
	  if (!(Device.ie || Device.edge || (Device.firefox && !Device.ios))) {
	    if (router.params.pushState && options.pushState) {
	      if (backIndex) { History.go(-backIndex); }
	      else { History.back(); }
	    }
	  }

	  // Update History
	  if (router.history.length === 1) {
	    router.history.unshift(router.url);
	  }
	  router.history.pop();
	  router.saveHistory();

	  // Current Page & Navbar
	  router.currentPageEl = $newPage[0];
	  if (dynamicNavbar && $newNavbarInner.length) {
	    router.currentNavbarEl = $newNavbarInner[0];
	  } else {
	    delete router.currentNavbarEl;
	  }

	  // Current Route
	  router.currentRoute = options.route;

	  // History State
	  if (Device.ie || Device.edge || (Device.firefox && !Device.ios)) {
	    if (router.params.pushState && options.pushState) {
	      if (backIndex) { History.go(-backIndex); }
	      else { History.back(); }
	    }
	  }

	  // Insert Page
	  insertPage();

	  // Load Tab
	  if (options.route.route.tab) {
	    router.tabLoad(options.route.route.tab, Utils.extend({}, options, {
	      history: false,
	      pushState: false,
	    }));
	  }

	  // Page init and before init events
	  router.pageCallback('init', $newPage, $newNavbarInner, 'previous', 'current', options, $oldPage);

	  // Before animation callback
	  router.pageCallback('beforeOut', $oldPage, $oldNavbarInner, 'current', 'next', options);
	  router.pageCallback('beforeIn', $newPage, $newNavbarInner, 'previous', 'current', options);

	  // Animation
	  function afterAnimation() {
	    // Set classes
	    var pageClasses = 'page-previous page-current page-next';
	    var navbarClasses = 'navbar-previous navbar-current navbar-next';
	    $newPage.removeClass(pageClasses).addClass('page-current').removeAttr('aria-hidden').trigger('page:position', { position: 'current' });
	    $oldPage.removeClass(pageClasses).addClass('page-next').attr('aria-hidden', 'true').trigger('page:position', { position: 'next' });
	    if (dynamicNavbar) {
	      $newNavbarInner.removeClass(navbarClasses).addClass('navbar-current').removeAttr('aria-hidden');
	      $oldNavbarInner.removeClass(navbarClasses).addClass('navbar-next').attr('aria-hidden', 'true');
	    }

	    // After animation event
	    router.pageCallback('afterOut', $oldPage, $oldNavbarInner, 'current', 'next', options);
	    router.pageCallback('afterIn', $newPage, $newNavbarInner, 'previous', 'current', options);

	    // Remove Old Page
	    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
	      $oldPage.addClass('stacked');
	      $oldPage.trigger('page:stack');
	      if (separateNavbar) {
	        $oldNavbarInner.addClass('stacked');
	      }
	    } else {
	      router.pageCallback('beforeRemove', $oldPage, $oldNavbarInner, 'next', undefined, options);
	      router.removePage($oldPage);
	      if (separateNavbar && $oldNavbarInner.length) {
	        router.removeNavbar($oldNavbarInner);
	      }
	    }

	    router.allowPageChange = true;
	    router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

	    // Preload previous page
	    var preloadPreviousPage = router.params.preloadPreviousPage || router.params[((app.theme) + "SwipeBack")];
	    if (preloadPreviousPage && router.history[router.history.length - 2] && !isMaster) {
	      router.back(router.history[router.history.length - 2], { preload: true });
	    }
	    if (router.params.pushState) {
	      History.clearRouterQueue();
	    }
	  }

	  function setPositionClasses() {
	    var pageClasses = 'page-previous page-current page-next';
	    var navbarClasses = 'navbar-previous navbar-current navbar-next';
	    $oldPage.removeClass(pageClasses).addClass('page-current').trigger('page:position', { position: 'current' });
	    $newPage.removeClass(pageClasses).addClass('page-previous').removeAttr('aria-hidden').trigger('page:position', { position: 'previous' });
	    if (dynamicNavbar) {
	      $oldNavbarInner.removeClass(navbarClasses).addClass('navbar-current');
	      $newNavbarInner.removeClass(navbarClasses).addClass('navbar-previous').removeAttr('aria-hidden');
	    }
	  }

	  if (options.animate && !(currentIsMaster && app.width >= router.params.masterDetailBreakpoint)) {
	    setPositionClasses();
	    router.animate($oldPage, $newPage, $oldNavbarInner, $newNavbarInner, 'backward', function () {
	      afterAnimation();
	    });
	  } else {
	    afterAnimation();
	  }

	  return router;
	}
	function loadBack(backParams, backOptions, ignorePageChange) {
	  var router = this;

	  if (!router.allowPageChange && !ignorePageChange) { return router; }
	  var params = backParams;
	  var options = backOptions;
	  var url = params.url;
	  var content = params.content;
	  var el = params.el;
	  var pageName = params.pageName;
	  var template = params.template;
	  var templateUrl = params.templateUrl;
	  var component = params.component;
	  var componentUrl = params.componentUrl;

	  if (
	    options.route.url
	    && router.url === options.route.url
	    && !(options.reloadCurrent || options.reloadPrevious)
	    && !router.params.allowDuplicateUrls
	  ) {
	    return false;
	  }

	  if (!options.route && url) {
	    options.route = router.parseRouteUrl(url);
	  }

	  // Component Callbacks
	  function resolve(pageEl, newOptions) {
	    return router.backward(pageEl, Utils.extend(options, newOptions));
	  }
	  function reject() {
	    router.allowPageChange = true;
	    return router;
	  }

	  if (url || templateUrl || componentUrl) {
	    router.allowPageChange = false;
	  }

	  // Proceed
	  if (content) {
	    router.backward(router.getPageEl(content), options);
	  } else if (template || templateUrl) {
	    // Parse template and send page element
	    try {
	      router.pageTemplateLoader(template, templateUrl, options, resolve, reject);
	    } catch (err) {
	      router.allowPageChange = true;
	      throw err;
	    }
	  } else if (el) {
	    // Load page from specified HTMLElement or by page name in pages container
	    router.backward(router.getPageEl(el), options);
	  } else if (pageName) {
	    // Load page by page name in pages container
	    router.backward(router.$el.children((".page[data-name=\"" + pageName + "\"]")).eq(0), options);
	  } else if (component || componentUrl) {
	    // Load from component (F7/Vue/React/...)
	    try {
	      router.pageComponentLoader(router.el, component, componentUrl, options, resolve, reject);
	    } catch (err) {
	      router.allowPageChange = true;
	      throw err;
	    }
	  } else if (url) {
	    // Load using XHR
	    if (router.xhr) {
	      router.xhr.abort();
	      router.xhr = false;
	    }
	    router.xhrRequest(url, options)
	      .then(function (pageContent) {
	        router.backward(router.getPageEl(pageContent), options);
	      })
	      .catch(function () {
	        router.allowPageChange = true;
	      });
	  }
	  return router;
	}
	function back() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var router = this;
	  if (router.swipeBackActive) { return router; }
	  var navigateUrl;
	  var navigateOptions;
	  var route;
	  if (typeof args[0] === 'object') {
	    navigateOptions = args[0] || {};
	  } else {
	    navigateUrl = args[0];
	    navigateOptions = args[1] || {};
	  }

	  var name = navigateOptions.name;
	  var params = navigateOptions.params;
	  var query = navigateOptions.query;
	  if (name) {
	    // find route by name
	    route = router.findRouteByKey('name', name);
	    if (!route) {
	      throw new Error(("Framework7: route with name \"" + name + "\" not found"));
	    }
	    navigateUrl = router.constructRouteUrl(route, { params: params, query: query });
	    if (navigateUrl) {
	      return router.back(navigateUrl, Utils.extend({}, navigateOptions, {
	        name: null,
	        params: null,
	        query: null,
	      }));
	    }
	    throw new Error(("Framework7: can't construct URL for route with name \"" + name + "\""));
	  }

	  var app = router.app;
	  appRouterCheck(router, 'back');

	  var currentRouteIsModal = router.currentRoute.modal;
	  var modalType;
	  if (!currentRouteIsModal) {
	    ('popup popover sheet loginScreen actions customModal panel').split(' ').forEach(function (modalLoadProp) {
	      if (router.currentRoute.route[modalLoadProp]) {
	        currentRouteIsModal = true;
	        modalType = modalLoadProp;
	      }
	    });
	  }
	  if (currentRouteIsModal) {
	    var modalToClose = router.currentRoute.modal
	                         || router.currentRoute.route.modalInstance
	                         || app[modalType].get();
	    var previousUrl = router.history[router.history.length - 2];
	    var previousRoute;
	    // check if previous route is modal too
	    if (modalToClose && modalToClose.$el) {
	      var prevOpenedModals = modalToClose.$el.prevAll('.modal-in');
	      if (prevOpenedModals.length && prevOpenedModals[0].f7Modal) {
	        previousRoute = prevOpenedModals[0].f7Modal.route;
	      }
	    }
	    if (!previousRoute) {
	      previousRoute = router.findMatchingRoute(previousUrl);
	    }

	    if (!previousRoute && previousUrl) {
	      previousRoute = {
	        url: previousUrl,
	        path: previousUrl.split('?')[0],
	        query: Utils.parseUrlQuery(previousUrl),
	        route: {
	          path: previousUrl.split('?')[0],
	          url: previousUrl,
	        },
	      };
	    }
	    if (!navigateUrl || navigateUrl.replace(/[# ]/g, '').trim().length === 0) {
	      if (!previousRoute || !modalToClose) {
	        return router;
	      }
	    }
	    var forceOtherUrl = navigateOptions.force && previousRoute && navigateUrl;
	    if (previousRoute && modalToClose) {
	      if (router.params.pushState && navigateOptions.pushState !== false) {
	        History.back();
	      }
	      router.currentRoute = previousRoute;
	      router.history.pop();
	      router.saveHistory();
	      router.modalRemove(modalToClose);
	      if (forceOtherUrl) {
	        router.navigate(navigateUrl, { reloadCurrent: true });
	      }
	    } else if (modalToClose) {
	      router.modalRemove(modalToClose);
	      if (navigateUrl) {
	        router.navigate(navigateUrl, { reloadCurrent: true });
	      }
	    }
	    return router;
	  }
	  var $previousPage = router.$el.children('.page-current').prevAll('.page-previous:not(.page-master)').eq(0);

	  var skipMaster;
	  if (router.params.masterDetailBreakpoint > 0) {
	    var $previousMaster = router.$el.children('.page-current').prevAll('.page-master').eq(0);
	    if ($previousMaster.length) {
	      var expectedPreviousPageUrl = router.history[router.history.length - 2];
	      var expectedPreviousPageRoute = router.findMatchingRoute(expectedPreviousPageUrl);
	      if (expectedPreviousPageRoute && expectedPreviousPageRoute.route === $previousMaster[0].f7Page.route.route) {
	        $previousPage = $previousMaster;
	        if (!navigateOptions.preload) {
	          skipMaster = app.width >= router.params.masterDetailBreakpoint;
	        }
	      }
	    }
	  }
	  if (!navigateOptions.force && $previousPage.length && !skipMaster) {
	    if (router.params.pushState
	      && $previousPage[0].f7Page
	      && router.history[router.history.length - 2] !== $previousPage[0].f7Page.route.url
	    ) {
	      router.back(
	        router.history[router.history.length - 2],
	        Utils.extend(navigateOptions, { force: true })
	      );
	      return router;
	    }
	    var previousPageRoute = $previousPage[0].f7Page.route;

	    processRouteQueue.call(
	      router,
	      previousPageRoute,
	      router.currentRoute,
	      function () {
	        router.loadBack({ el: $previousPage }, Utils.extend(navigateOptions, {
	          route: previousPageRoute,
	        }));
	      },
	      function () {}
	    );

	    return router;
	  }

	  // Navigate URL
	  if (navigateUrl === '#') {
	    navigateUrl = undefined;
	  }
	  if (navigateUrl && navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
	    navigateUrl = ((router.path || '/') + navigateUrl).replace('//', '/');
	  }
	  if (!navigateUrl && router.history.length > 1) {
	    navigateUrl = router.history[router.history.length - 2];
	  }
	  if (skipMaster && !navigateOptions.force && router.history[router.history.length - 3]) {
	    return router.back(router.history[router.history.length - 3], Utils.extend({}, navigateOptions || {}, {
	      force: true,
	      animate: false,
	    }));
	  }
	  if (skipMaster && !navigateOptions.force) {
	    return router;
	  }

	  // Find route to load
	  route = router.findMatchingRoute(navigateUrl);
	  if (!route) {
	    if (navigateUrl) {
	      route = {
	        url: navigateUrl,
	        path: navigateUrl.split('?')[0],
	        query: Utils.parseUrlQuery(navigateUrl),
	        route: {
	          path: navigateUrl.split('?')[0],
	          url: navigateUrl,
	        },
	      };
	    }
	  }
	  if (!route) {
	    return router;
	  }

	  if (route.route.redirect) {
	    return redirect.call(router, 'back', route, navigateOptions);
	  }

	  var options = {};
	  if (route.route.options) {
	    Utils.extend(options, route.route.options, navigateOptions);
	  } else {
	    Utils.extend(options, navigateOptions);
	  }
	  options.route = route;

	  if (options && options.context) {
	    route.context = options.context;
	    options.route.context = options.context;
	  }

	  var backForceLoaded;
	  if (options.force && router.params.stackPages) {
	    router.$el.children('.page-previous.stacked').each(function (index, pageEl) {
	      if (pageEl.f7Page && pageEl.f7Page.route && pageEl.f7Page.route.url === route.url) {
	        backForceLoaded = true;
	        router.loadBack({ el: pageEl }, options);
	      }
	    });
	    if (backForceLoaded) {
	      return router;
	    }
	  }
	  function resolve() {
	    var routerLoaded = false;
	    if (route.route.keepAlive && route.route.keepAliveData) {
	      router.loadBack({ el: route.route.keepAliveData.pageEl }, options);
	      routerLoaded = true;
	    }
	    ('url content component pageName el componentUrl template templateUrl').split(' ').forEach(function (pageLoadProp) {
	      var obj;

	      if (route.route[pageLoadProp] && !routerLoaded) {
	        routerLoaded = true;
	        router.loadBack(( obj = {}, obj[pageLoadProp] = route.route[pageLoadProp], obj ), options);
	      }
	    });
	    if (routerLoaded) { return; }
	    // Async
	    function asyncResolve(resolveParams, resolveOptions) {
	      router.allowPageChange = false;
	      if (resolveOptions && resolveOptions.context) {
	        if (!route.context) { route.context = resolveOptions.context; }
	        else { route.context = Utils.extend({}, route.context, resolveOptions.context); }
	        options.route.context = route.context;
	      }
	      router.loadBack(resolveParams, Utils.extend(options, resolveOptions), true);
	    }
	    function asyncReject() {
	      router.allowPageChange = true;
	    }
	    if (route.route.async) {
	      router.allowPageChange = false;

	      route.route.async.call(router, route, router.currentRoute, asyncResolve, asyncReject);
	    }
	  }
	  function reject() {
	    router.allowPageChange = true;
	  }

	  if (options.preload) {
	    resolve();
	  } else {
	    processRouteQueue.call(
	      router,
	      route,
	      router.currentRoute,
	      function () {
	        if (route.route.modules) {
	          app
	            .loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules])
	            .then(function () {
	              resolve();
	            })
	            .catch(function () {
	              reject();
	            });
	        } else {
	          resolve();
	        }
	      },
	      function () {
	        reject();
	      }
	    );
	  }

	  // Return Router
	  return router;
	}

	function clearPreviousPages() {
	  var router = this;
	  appRouterCheck(router, 'clearPreviousPages');
	  var app = router.app;
	  var separateNavbar = router.separateNavbar;

	  var $pagesToRemove = router.$el
	    .children('.page')
	    .filter(function (index, pageInView) {
	      if (router.currentRoute && (router.currentRoute.modal || router.currentRoute.panel)) { return true; }
	      return pageInView !== router.currentPageEl;
	    });

	  $pagesToRemove.each(function (index, pageEl) {
	    var $oldPageEl = $(pageEl);
	    var $oldNavbarInnerEl = $(app.navbar.getElByPage($oldPageEl));
	    if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
	      $oldPageEl.addClass('stacked');
	      if (separateNavbar) {
	        $oldNavbarInnerEl.addClass('stacked');
	      }
	    } else {
	      // Page remove event
	      router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarInnerEl, 'previous', undefined, {});
	      router.removePage($oldPageEl);
	      if (separateNavbar && $oldNavbarInnerEl.length) {
	        router.removeNavbar($oldNavbarInnerEl);
	      }
	    }
	  });
	}

	function clearPreviousHistory() {
	  var router = this;
	  appRouterCheck(router, 'clearPreviousHistory');
	  var url = router.history[router.history.length - 1];

	  router.clearPreviousPages();

	  router.history = [url];
	  router.view.history = [url];
	  router.saveHistory();
	}

	var Router = /*@__PURE__*/(function (Framework7Class) {
	  function Router(app, view) {
	    Framework7Class.call(this, {}, [typeof view === 'undefined' ? app : view]);
	    var router = this;

	    // Is App Router
	    router.isAppRouter = typeof view === 'undefined';

	    if (router.isAppRouter) {
	      // App Router
	      Utils.extend(false, router, {
	        app: app,
	        params: app.params.view,
	        routes: app.routes || [],
	        cache: app.cache,
	      });
	    } else {
	      // View Router
	      Utils.extend(false, router, {
	        app: app,
	        view: view,
	        viewId: view.id,
	        params: view.params,
	        routes: view.routes,
	        $el: view.$el,
	        el: view.el,
	        $navbarEl: view.$navbarEl,
	        navbarEl: view.navbarEl,
	        history: view.history,
	        scrollHistory: view.scrollHistory,
	        cache: app.cache,
	        dynamicNavbar: app.theme === 'ios' && view.params.iosDynamicNavbar,
	        separateNavbar: app.theme === 'ios' && view.params.iosDynamicNavbar && view.params.iosSeparateDynamicNavbar,
	        initialPages: [],
	        initialNavbars: [],
	      });
	    }

	    // Install Modules
	    router.useModules();

	    // Temporary Dom
	    router.tempDom = doc.createElement('div');

	    // AllowPageChage
	    router.allowPageChange = true;

	    // Current Route
	    var currentRoute = {};
	    var previousRoute = {};
	    Object.defineProperty(router, 'currentRoute', {
	      enumerable: true,
	      configurable: true,
	      set: function set(newRoute) {
	        if ( newRoute === void 0 ) newRoute = {};

	        previousRoute = Utils.extend({}, currentRoute);
	        currentRoute = newRoute;
	        if (!currentRoute) { return; }
	        router.url = currentRoute.url;
	        router.emit('routeChange', newRoute, previousRoute, router);
	      },
	      get: function get() {
	        return currentRoute;
	      },
	    });
	    Object.defineProperty(router, 'previousRoute', {
	      enumerable: true,
	      configurable: true,
	      get: function get() {
	        return previousRoute;
	      },
	      set: function set(newRoute) {
	        previousRoute = newRoute;
	      },
	    });

	    return router;
	  }

	  if ( Framework7Class ) Router.__proto__ = Framework7Class;
	  Router.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  Router.prototype.constructor = Router;

	  Router.prototype.animatableNavElements = function animatableNavElements (newNavbarInner, oldNavbarInner, toLarge, fromLarge, direction) {
	    var router = this;
	    var dynamicNavbar = router.dynamicNavbar;
	    var separateNavbar = router.separateNavbar;
	    var animateIcon = router.params.iosAnimateNavbarBackIcon;

	    var newNavEls;
	    var oldNavEls;
	    function animatableNavEl($el, navbarInner) {
	      var isSliding = $el.hasClass('sliding') || navbarInner.hasClass('sliding');
	      var isSubnavbar = $el.hasClass('subnavbar');
	      var needsOpacityTransition = isSliding ? !isSubnavbar : true;
	      var $iconEl = $el.find('.back .icon');
	      var isIconLabel;
	      if (isSliding && animateIcon && $el.hasClass('left') && $iconEl.length > 0 && $iconEl.next('span').length) {
	        $el = $iconEl.next('span'); // eslint-disable-line
	        isIconLabel = true;
	      }
	      return {
	        $el: $el,
	        isIconLabel: isIconLabel,
	        leftOffset: $el[0].f7NavbarLeftOffset,
	        rightOffset: $el[0].f7NavbarRightOffset,
	        isSliding: isSliding,
	        isSubnavbar: isSubnavbar,
	        needsOpacityTransition: needsOpacityTransition,
	      };
	    }
	    if (dynamicNavbar) {
	      newNavEls = [];
	      oldNavEls = [];
	      newNavbarInner.children('.left, .right, .title, .subnavbar').each(function (index, navEl) {
	        var $navEl = $(navEl);
	        if ($navEl.hasClass('left') && fromLarge && direction === 'forward' && separateNavbar) { return; }
	        if ($navEl.hasClass('title') && toLarge) { return; }
	        newNavEls.push(animatableNavEl($navEl, newNavbarInner));
	      });
	      if (!(oldNavbarInner.hasClass('navbar-master') && router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint)) {
	        oldNavbarInner.children('.left, .right, .title, .subnavbar').each(function (index, navEl) {
	          var $navEl = $(navEl);
	          if ($navEl.hasClass('left') && toLarge && !fromLarge && direction === 'forward' && separateNavbar) { return; }
	          if ($navEl.hasClass('left') && toLarge && direction === 'backward' && separateNavbar) { return; }
	          if ($navEl.hasClass('title') && fromLarge) {
	            return;
	          }
	          oldNavEls.push(animatableNavEl($navEl, oldNavbarInner));
	        });
	      }
	      [oldNavEls, newNavEls].forEach(function (navEls) {
	        navEls.forEach(function (navEl) {
	          var n = navEl;
	          var isSliding = navEl.isSliding;
	          var $el = navEl.$el;
	          var otherEls = navEls === oldNavEls ? newNavEls : oldNavEls;
	          if (!(isSliding && $el.hasClass('title') && otherEls)) { return; }
	          otherEls.forEach(function (otherNavEl) {
	            if (otherNavEl.isIconLabel) {
	              var iconTextEl = otherNavEl.$el[0];
	              n.leftOffset += iconTextEl ? (iconTextEl.offsetLeft || 0) : 0;
	            }
	          });
	        });
	      });
	    }

	    return { newNavEls: newNavEls, oldNavEls: oldNavEls };
	  };

	  Router.prototype.animate = function animate (oldPage, newPage, oldNavbarInner, newNavbarInner, direction, callback) {
	    var router = this;
	    if (router.params.animateCustom) {
	      router.params.animateCustom.apply(router, [oldPage, newPage, oldNavbarInner, newNavbarInner, direction, callback]);
	      return;
	    }
	    var dynamicNavbar = router.dynamicNavbar;
	    var ios = router.app.theme === 'ios';
	    // Router Animation class
	    var routerTransitionClass = "router-transition-" + direction + " router-transition";

	    var newNavEls;
	    var oldNavEls;

	    var fromLarge;
	    var toLarge;

	    var oldIsLarge;
	    var newIsLarge;

	    if (ios && dynamicNavbar) {
	      oldIsLarge = oldNavbarInner && oldNavbarInner.hasClass('navbar-inner-large');
	      newIsLarge = newNavbarInner && newNavbarInner.hasClass('navbar-inner-large');
	      fromLarge = oldIsLarge && !oldNavbarInner.hasClass('navbar-inner-large-collapsed');
	      toLarge = newIsLarge && !newNavbarInner.hasClass('navbar-inner-large-collapsed');
	      var navEls = router.animatableNavElements(newNavbarInner, oldNavbarInner, toLarge, fromLarge, direction);
	      newNavEls = navEls.newNavEls;
	      oldNavEls = navEls.oldNavEls;
	    }

	    function animateNavbars(progress) {
	      if (!(ios && dynamicNavbar)) { return; }
	      if (progress === 1) {
	        if (toLarge) {
	          newNavbarInner.addClass('router-navbar-transition-to-large');
	          oldNavbarInner.addClass('router-navbar-transition-to-large');
	        }
	        if (fromLarge) {
	          newNavbarInner.addClass('router-navbar-transition-from-large');
	          oldNavbarInner.addClass('router-navbar-transition-from-large');
	        }
	      }
	      newNavEls.forEach(function (navEl) {
	        var $el = navEl.$el;
	        var offset = direction === 'forward' ? navEl.rightOffset : navEl.leftOffset;
	        if (navEl.isSliding) {
	          if (navEl.isSubnavbar && newIsLarge) {
	            $el[0].style.setProperty('transform', ("translate3d(" + (offset * (1 - progress)) + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)"), 'important');
	          } else {
	            $el.transform(("translate3d(" + (offset * (1 - progress)) + "px,0,0)"));
	          }
	        }
	      });
	      oldNavEls.forEach(function (navEl) {
	        var $el = navEl.$el;
	        var offset = direction === 'forward' ? navEl.leftOffset : navEl.rightOffset;
	        if (navEl.isSliding) {
	          if (navEl.isSubnavbar && oldIsLarge) {
	            $el.transform(("translate3d(" + (offset * (progress)) + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)"));
	          } else {
	            $el.transform(("translate3d(" + (offset * (progress)) + "px,0,0)"));
	          }
	        }
	      });
	    }

	    // AnimationEnd Callback
	    function onDone() {
	      if (router.dynamicNavbar) {
	        if (newNavbarInner) {
	          newNavbarInner.removeClass('router-navbar-transition-to-large router-navbar-transition-from-large');
	          newNavbarInner.addClass('navbar-no-title-large-transition');
	          Utils.nextFrame(function () {
	            newNavbarInner.removeClass('navbar-no-title-large-transition');
	          });
	        }
	        if (oldNavbarInner) {
	          oldNavbarInner.removeClass('router-navbar-transition-to-large router-navbar-transition-from-large');
	        }
	        if (newNavbarInner.hasClass('sliding')) {
	          newNavbarInner.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
	        } else {
	          newNavbarInner.find('.sliding').transform('');
	        }
	        if (oldNavbarInner.hasClass('sliding')) {
	          oldNavbarInner.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
	        } else {
	          oldNavbarInner.find('.sliding').transform('');
	        }
	      }
	      router.$el.removeClass(routerTransitionClass);
	      if (callback) { callback(); }
	    }

	    (direction === 'forward' ? newPage : oldPage).animationEnd(function () {
	      onDone();
	    });

	    // Animate
	    if (dynamicNavbar) {
	      // Prepare Navbars
	      animateNavbars(0);
	      Utils.nextFrame(function () {
	        // Add class, start animation
	        animateNavbars(1);
	        router.$el.addClass(routerTransitionClass);
	      });
	    } else {
	      // Add class, start animation
	      router.$el.addClass(routerTransitionClass);
	    }
	  };

	  Router.prototype.removeModal = function removeModal (modalEl) {
	    var router = this;
	    router.removeEl(modalEl);
	  };
	  // eslint-disable-next-line
	  Router.prototype.removeTabContent = function removeTabContent (tabEl) {
	    var $tabEl = $(tabEl);
	    $tabEl.html('');
	  };

	  Router.prototype.removeNavbar = function removeNavbar (el) {
	    var router = this;
	    router.removeEl(el);
	  };

	  Router.prototype.removePage = function removePage (el) {
	    var $el = $(el);
	    var f7Page = $el && $el[0] && $el[0].f7Page;
	    var router = this;
	    if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
	      $el.remove();
	      return;
	    }
	    router.removeEl(el);
	  };

	  Router.prototype.removeEl = function removeEl (el) {
	    if (!el) { return; }
	    var router = this;
	    var $el = $(el);
	    if ($el.length === 0) { return; }
	    $el.find('.tab').each(function (tabIndex, tabEl) {
	      $(tabEl).children().each(function (index, tabChild) {
	        if (tabChild.f7Component) {
	          $(tabChild).trigger('tab:beforeremove');
	          tabChild.f7Component.$destroy();
	        }
	      });
	    });
	    if ($el[0].f7Component && $el[0].f7Component.$destroy) {
	      $el[0].f7Component.$destroy();
	    }
	    if (!router.params.removeElements) {
	      return;
	    }
	    if (router.params.removeElementsWithTimeout) {
	      setTimeout(function () {
	        $el.remove();
	      }, router.params.removeElementsTimeout);
	    } else {
	      $el.remove();
	    }
	  };

	  Router.prototype.getPageEl = function getPageEl (content) {
	    var router = this;
	    if (typeof content === 'string') {
	      router.tempDom.innerHTML = content;
	    } else {
	      if ($(content).hasClass('page')) {
	        return content;
	      }
	      router.tempDom.innerHTML = '';
	      $(router.tempDom).append(content);
	    }

	    return router.findElement('.page', router.tempDom);
	  };

	  Router.prototype.findElement = function findElement (stringSelector, container, notStacked) {
	    var router = this;
	    var view = router.view;
	    var app = router.app;

	    // Modals Selector
	    var modalsSelector = '.popup, .dialog, .popover, .actions-modal, .sheet-modal, .login-screen, .page';

	    var $container = $(container);
	    var selector = stringSelector;
	    if (notStacked) { selector += ':not(.stacked)'; }

	    var found = $container
	      .find(selector)
	      .filter(function (index, el) { return $(el).parents(modalsSelector).length === 0; });

	    if (found.length > 1) {
	      if (typeof view.selector === 'string') {
	        // Search in related view
	        found = $container.find(((view.selector) + " " + selector));
	      }
	      if (found.length > 1) {
	        // Search in main view
	        found = $container.find(("." + (app.params.viewMainClass) + " " + selector));
	      }
	    }
	    if (found.length === 1) { return found; }

	    // Try to find not stacked
	    if (!notStacked) { found = router.findElement(selector, $container, true); }
	    if (found && found.length === 1) { return found; }
	    if (found && found.length > 1) { return $(found[0]); }
	    return undefined;
	  };

	  Router.prototype.flattenRoutes = function flattenRoutes (routes) {
	    if ( routes === void 0 ) routes = this.routes;

	    var router = this;
	    var flattenedRoutes = [];
	    routes.forEach(function (route) {
	      var hasTabRoutes = false;
	      if ('tabs' in route && route.tabs) {
	        var mergedPathsRoutes = route.tabs.map(function (tabRoute) {
	          var tRoute = Utils.extend({}, route, {
	            path: (((route.path) + "/" + (tabRoute.path))).replace('///', '/').replace('//', '/'),
	            parentPath: route.path,
	            tab: tabRoute,
	          });
	          delete tRoute.tabs;
	          delete tRoute.routes;
	          return tRoute;
	        });
	        hasTabRoutes = true;
	        flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(mergedPathsRoutes));
	      }
	      if ('detailRoutes' in route) {
	        var mergedPathsRoutes$1 = route.detailRoutes.map(function (detailRoute) {
	          var dRoute = Utils.extend({}, detailRoute);
	          dRoute.masterRoute = route;
	          dRoute.masterRoutePath = route.path;
	          return dRoute;
	        });
	        flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(mergedPathsRoutes$1));
	      }
	      if ('routes' in route) {
	        var mergedPathsRoutes$2 = route.routes.map(function (childRoute) {
	          var cRoute = Utils.extend({}, childRoute);
	          cRoute.path = (((route.path) + "/" + (cRoute.path))).replace('///', '/').replace('//', '/');
	          return cRoute;
	        });
	        if (hasTabRoutes) {
	          flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(mergedPathsRoutes$2));
	        } else {
	          flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(mergedPathsRoutes$2));
	        }
	      }
	      if (!('routes' in route) && !('tabs' in route && route.tabs) && !('detailRoutes' in route)) {
	        flattenedRoutes.push(route);
	      }
	    });
	    return flattenedRoutes;
	  };

	  // eslint-disable-next-line
	  Router.prototype.parseRouteUrl = function parseRouteUrl (url) {
	    if (!url) { return {}; }
	    var query = Utils.parseUrlQuery(url);
	    var hash = url.split('#')[1];
	    var params = {};
	    var path = url.split('#')[0].split('?')[0];
	    return {
	      query: query,
	      hash: hash,
	      params: params,
	      url: url,
	      path: path,
	    };
	  };

	  // eslint-disable-next-line
	  Router.prototype.constructRouteUrl = function constructRouteUrl (route, ref) {
	    if ( ref === void 0 ) ref = {};
	    var params = ref.params;
	    var query = ref.query;

	    var path = route.path;
	    var toUrl = pathToRegexp_1.compile(path);
	    var url;
	    try {
	      url = toUrl(params || {});
	    } catch (error) {
	      throw new Error(("Framework7: error constructing route URL from passed params:\nRoute: " + path + "\n" + (error.toString())));
	    }

	    if (query) {
	      if (typeof query === 'string') { url += "?" + query; }
	      else { url += "?" + (Utils.serializeObject(query)); }
	    }

	    return url;
	  };

	  Router.prototype.findTabRoute = function findTabRoute (tabEl) {
	    var router = this;
	    var $tabEl = $(tabEl);
	    var parentPath = router.currentRoute.route.parentPath;
	    var tabId = $tabEl.attr('id');
	    var flattenedRoutes = router.flattenRoutes(router.routes);
	    var foundTabRoute;
	    flattenedRoutes.forEach(function (route) {
	      if (
	        route.parentPath === parentPath
	        && route.tab
	        && route.tab.id === tabId
	      ) {
	        foundTabRoute = route;
	      }
	    });
	    return foundTabRoute;
	  };

	  Router.prototype.findRouteByKey = function findRouteByKey (key, value) {
	    var router = this;
	    var routes = router.routes;
	    var flattenedRoutes = router.flattenRoutes(routes);
	    var matchingRoute;

	    flattenedRoutes.forEach(function (route) {
	      if (matchingRoute) { return; }
	      if (route[key] === value) {
	        matchingRoute = route;
	      }
	    });
	    return matchingRoute;
	  };

	  Router.prototype.findMatchingRoute = function findMatchingRoute (url) {
	    if (!url) { return undefined; }
	    var router = this;
	    var routes = router.routes;
	    var flattenedRoutes = router.flattenRoutes(routes);
	    var ref = router.parseRouteUrl(url);
	    var path = ref.path;
	    var query = ref.query;
	    var hash = ref.hash;
	    var params = ref.params;
	    var matchingRoute;
	    flattenedRoutes.forEach(function (route) {
	      if (matchingRoute) { return; }
	      var keys = [];

	      var pathsToMatch = [route.path];
	      if (route.alias) {
	        if (typeof route.alias === 'string') { pathsToMatch.push(route.alias); }
	        else if (Array.isArray(route.alias)) {
	          route.alias.forEach(function (aliasPath) {
	            pathsToMatch.push(aliasPath);
	          });
	        }
	      }

	      var matched;
	      pathsToMatch.forEach(function (pathToMatch) {
	        if (matched) { return; }
	        matched = pathToRegexp_1(pathToMatch, keys).exec(path);
	      });

	      if (matched) {
	        keys.forEach(function (keyObj, index) {
	          if (typeof keyObj.name === 'number') { return; }
	          var paramValue = matched[index + 1];
	          params[keyObj.name] = paramValue;
	        });

	        var parentPath;
	        if (route.parentPath) {
	          parentPath = path.split('/').slice(0, route.parentPath.split('/').length - 1).join('/');
	        }

	        matchingRoute = {
	          query: query,
	          hash: hash,
	          params: params,
	          url: url,
	          path: path,
	          parentPath: parentPath,
	          route: route,
	          name: route.name,
	        };
	      }
	    });
	    return matchingRoute;
	  };

	  // eslint-disable-next-line
	  Router.prototype.replaceRequestUrlParams = function replaceRequestUrlParams (url, options) {
	    if ( url === void 0 ) url = '';
	    if ( options === void 0 ) options = {};

	    var compiledUrl = url;
	    if (typeof compiledUrl === 'string'
	      && compiledUrl.indexOf('{{') >= 0
	      && options
	      && options.route
	      && options.route.params
	      && Object.keys(options.route.params).length
	    ) {
	      Object.keys(options.route.params).forEach(function (paramName) {
	        var regExp = new RegExp(("{{" + paramName + "}}"), 'g');
	        compiledUrl = compiledUrl.replace(regExp, options.route.params[paramName] || '');
	      });
	    }
	    return compiledUrl;
	  };

	  Router.prototype.removeFromXhrCache = function removeFromXhrCache (url) {
	    var router = this;
	    var xhrCache = router.cache.xhr;
	    var index = false;
	    for (var i = 0; i < xhrCache.length; i += 1) {
	      if (xhrCache[i].url === url) { index = i; }
	    }
	    if (index !== false) { xhrCache.splice(index, 1); }
	  };

	  Router.prototype.xhrRequest = function xhrRequest (requestUrl, options) {
	    var router = this;
	    var params = router.params;
	    var ignoreCache = options.ignoreCache;
	    var url = requestUrl;

	    var hasQuery = url.indexOf('?') >= 0;
	    if (params.passRouteQueryToRequest
	      && options
	      && options.route
	      && options.route.query
	      && Object.keys(options.route.query).length
	    ) {
	      url += "" + (hasQuery ? '&' : '?') + (Utils.serializeObject(options.route.query));
	      hasQuery = true;
	    }

	    if (params.passRouteParamsToRequest
	      && options
	      && options.route
	      && options.route.params
	      && Object.keys(options.route.params).length
	    ) {
	      url += "" + (hasQuery ? '&' : '?') + (Utils.serializeObject(options.route.params));
	      hasQuery = true;
	    }

	    if (url.indexOf('{{') >= 0) {
	      url = router.replaceRequestUrlParams(url, options);
	    }
	    // should we ignore get params or not
	    if (params.xhrCacheIgnoreGetParameters && url.indexOf('?') >= 0) {
	      url = url.split('?')[0];
	    }
	    return new Promise(function (resolve, reject) {
	      if (params.xhrCache && !ignoreCache && url.indexOf('nocache') < 0 && params.xhrCacheIgnore.indexOf(url) < 0) {
	        for (var i = 0; i < router.cache.xhr.length; i += 1) {
	          var cachedUrl = router.cache.xhr[i];
	          if (cachedUrl.url === url) {
	            // Check expiration
	            if (Utils.now() - cachedUrl.time < params.xhrCacheDuration) {
	              // Load from cache
	              resolve(cachedUrl.content);
	              return;
	            }
	          }
	        }
	      }
	      router.xhr = router.app.request({
	        url: url,
	        method: 'GET',
	        beforeSend: function beforeSend(xhr) {
	          router.emit('routerAjaxStart', xhr, options);
	        },
	        complete: function complete(xhr, status) {
	          router.emit('routerAjaxComplete', xhr);
	          if ((status !== 'error' && status !== 'timeout' && (xhr.status >= 200 && xhr.status < 300)) || xhr.status === 0) {
	            if (params.xhrCache && xhr.responseText !== '') {
	              router.removeFromXhrCache(url);
	              router.cache.xhr.push({
	                url: url,
	                time: Utils.now(),
	                content: xhr.responseText,
	              });
	            }
	            router.emit('routerAjaxSuccess', xhr, options);
	            resolve(xhr.responseText);
	          } else {
	            router.emit('routerAjaxError', xhr, options);
	            reject(xhr);
	          }
	        },
	        error: function error(xhr) {
	          router.emit('routerAjaxError', xhr, options);
	          reject(xhr);
	        },
	      });
	    });
	  };

	  // Remove theme elements
	  Router.prototype.removeThemeElements = function removeThemeElements (el) {
	    var router = this;
	    var theme = router.app.theme;
	    var toRemove;
	    if (theme === 'ios') {
	      toRemove = '.md-only, .aurora-only, .if-md, .if-aurora, .if-not-ios, .not-ios';
	    } else if (theme === 'md') {
	      toRemove = '.ios-only, .aurora-only, .if-ios, .if-aurora, .if-not-md, .not-md';
	    } else if (theme === 'aurora') {
	      toRemove = '.ios-only, .md-only, .if-ios, .if-md, .if-not-aurora, .not-aurora';
	    }
	    $(el).find(toRemove).remove();
	  };

	  Router.prototype.getPageData = function getPageData (pageEl, navbarEl, from, to, route, pageFromEl) {
	    if ( route === void 0 ) route = {};

	    var router = this;
	    var $pageEl = $(pageEl).eq(0);
	    var $navbarEl = $(navbarEl).eq(0);
	    var currentPage = $pageEl[0].f7Page || {};
	    var direction;
	    var pageFrom;
	    if ((from === 'next' && to === 'current') || (from === 'current' && to === 'previous')) { direction = 'forward'; }
	    if ((from === 'current' && to === 'next') || (from === 'previous' && to === 'current')) { direction = 'backward'; }
	    if (currentPage && !currentPage.fromPage) {
	      var $pageFromEl = $(pageFromEl);
	      if ($pageFromEl.length) {
	        pageFrom = $pageFromEl[0].f7Page;
	      }
	    }
	    pageFrom = currentPage.pageFrom || pageFrom;
	    if (pageFrom && pageFrom.pageFrom) {
	      pageFrom.pageFrom = null;
	    }
	    var page = {
	      app: router.app,
	      view: router.view,
	      router: router,
	      $el: $pageEl,
	      el: $pageEl[0],
	      $pageEl: $pageEl,
	      pageEl: $pageEl[0],
	      $navbarEl: $navbarEl,
	      navbarEl: $navbarEl[0],
	      name: $pageEl.attr('data-name'),
	      position: from,
	      from: from,
	      to: to,
	      direction: direction,
	      route: currentPage.route ? currentPage.route : route,
	      pageFrom: pageFrom,
	    };

	    $pageEl[0].f7Page = page;
	    return page;
	  };

	  // Callbacks
	  Router.prototype.pageCallback = function pageCallback (callback, pageEl, navbarEl, from, to, options, pageFromEl) {
	    if ( options === void 0 ) options = {};

	    if (!pageEl) { return; }
	    var router = this;
	    var $pageEl = $(pageEl);
	    if (!$pageEl.length) { return; }
	    var $navbarEl = $(navbarEl);
	    var route = options.route;
	    var restoreScrollTopOnBack = router.params.restoreScrollTopOnBack
	      && !(
	        router.params.masterDetailBreakpoint > 0
	        && $pageEl.hasClass('page-master')
	        && router.app.width >= router.params.masterDetailBreakpoint
	      );
	    var keepAlive = $pageEl[0].f7Page && $pageEl[0].f7Page.route && $pageEl[0].f7Page.route.route && $pageEl[0].f7Page.route.route.keepAlive;

	    if (callback === 'beforeRemove' && keepAlive) {
	      callback = 'beforeUnmount'; // eslint-disable-line
	    }

	    var camelName = "page" + (callback[0].toUpperCase() + callback.slice(1, callback.length));
	    var colonName = "page:" + (callback.toLowerCase());

	    var page = {};
	    if (callback === 'beforeRemove' && $pageEl[0].f7Page) {
	      page = Utils.extend($pageEl[0].f7Page, { from: from, to: to, position: from });
	    } else {
	      page = router.getPageData($pageEl[0], $navbarEl[0], from, to, route, pageFromEl);
	    }
	    page.swipeBack = !!options.swipeBack;

	    var ref = options.route ? options.route.route : {};
	    var on = ref.on; if ( on === void 0 ) on = {};
	    var once = ref.once; if ( once === void 0 ) once = {};
	    if (options.on) {
	      Utils.extend(on, options.on);
	    }
	    if (options.once) {
	      Utils.extend(once, options.once);
	    }

	    function attachEvents() {
	      if ($pageEl[0].f7RouteEventsAttached) { return; }
	      $pageEl[0].f7RouteEventsAttached = true;
	      if (on && Object.keys(on).length > 0) {
	        $pageEl[0].f7RouteEventsOn = on;
	        Object.keys(on).forEach(function (eventName) {
	          on[eventName] = on[eventName].bind(router);
	          $pageEl.on(Utils.eventNameToColonCase(eventName), on[eventName]);
	        });
	      }
	      if (once && Object.keys(once).length > 0) {
	        $pageEl[0].f7RouteEventsOnce = once;
	        Object.keys(once).forEach(function (eventName) {
	          once[eventName] = once[eventName].bind(router);
	          $pageEl.once(Utils.eventNameToColonCase(eventName), once[eventName]);
	        });
	      }
	    }

	    function detachEvents() {
	      if (!$pageEl[0].f7RouteEventsAttached) { return; }
	      if ($pageEl[0].f7RouteEventsOn) {
	        Object.keys($pageEl[0].f7RouteEventsOn).forEach(function (eventName) {
	          $pageEl.off(Utils.eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOn[eventName]);
	        });
	      }
	      if ($pageEl[0].f7RouteEventsOnce) {
	        Object.keys($pageEl[0].f7RouteEventsOnce).forEach(function (eventName) {
	          $pageEl.off(Utils.eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOnce[eventName]);
	        });
	      }
	      $pageEl[0].f7RouteEventsAttached = null;
	      $pageEl[0].f7RouteEventsOn = null;
	      $pageEl[0].f7RouteEventsOnce = null;
	      delete $pageEl[0].f7RouteEventsAttached;
	      delete $pageEl[0].f7RouteEventsOn;
	      delete $pageEl[0].f7RouteEventsOnce;
	    }

	    if (callback === 'mounted') {
	      attachEvents();
	    }
	    if (callback === 'init') {
	      if (restoreScrollTopOnBack && (from === 'previous' || !from) && to === 'current' && router.scrollHistory[page.route.url] && !$pageEl.hasClass('no-restore-scroll')) {
	        var $pageContent = $pageEl.find('.page-content');
	        if ($pageContent.length > 0) {
	          // eslint-disable-next-line
	          $pageContent = $pageContent.filter(function (pageContentIndex, pageContentEl) {
	            return (
	              $(pageContentEl).parents('.tab:not(.tab-active)').length === 0
	              && !$(pageContentEl).is('.tab:not(.tab-active)')
	            );
	          });
	        }
	        $pageContent.scrollTop(router.scrollHistory[page.route.url]);
	      }
	      attachEvents();
	      if ($pageEl[0].f7PageInitialized) {
	        $pageEl.trigger('page:reinit', page);
	        router.emit('pageReinit', page);
	        return;
	      }
	      $pageEl[0].f7PageInitialized = true;
	    }
	    if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'previous') {
	      // Save scroll position
	      var $pageContent$1 = $pageEl.find('.page-content');
	      if ($pageContent$1.length > 0) {
	        // eslint-disable-next-line
	        $pageContent$1 = $pageContent$1.filter(function (pageContentIndex, pageContentEl) {
	          return (
	            $(pageContentEl).parents('.tab:not(.tab-active)').length === 0
	            && !$(pageContentEl).is('.tab:not(.tab-active)')
	          );
	        });
	      }
	      router.scrollHistory[page.route.url] = $pageContent$1.scrollTop();
	    }
	    if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'next') {
	      // Delete scroll position
	      delete router.scrollHistory[page.route.url];
	    }

	    $pageEl.trigger(colonName, page);
	    router.emit(camelName, page);

	    if (callback === 'beforeRemove' || callback === 'beforeUnmount') {
	      detachEvents();
	      if (!keepAlive) {
	        if ($pageEl[0].f7Page && $pageEl[0].f7Page.navbarEl) {
	          delete $pageEl[0].f7Page.navbarEl.f7Page;
	        }
	        $pageEl[0].f7Page = null;
	      }
	    }
	  };

	  Router.prototype.saveHistory = function saveHistory () {
	    var router = this;
	    router.view.history = router.history;
	    if (router.params.pushState) {
	      win.localStorage[("f7router-" + (router.view.id) + "-history")] = JSON.stringify(router.history);
	    }
	  };

	  Router.prototype.restoreHistory = function restoreHistory () {
	    var router = this;
	    if (router.params.pushState && win.localStorage[("f7router-" + (router.view.id) + "-history")]) {
	      router.history = JSON.parse(win.localStorage[("f7router-" + (router.view.id) + "-history")]);
	      router.view.history = router.history;
	    }
	  };

	  Router.prototype.clearHistory = function clearHistory () {
	    var router = this;
	    router.history = [];
	    if (router.view) { router.view.history = []; }
	    router.saveHistory();
	  };

	  Router.prototype.updateCurrentUrl = function updateCurrentUrl (newUrl) {
	    var router = this;
	    appRouterCheck(router, 'updateCurrentUrl');
	    // Update history
	    if (router.history.length) {
	      router.history[router.history.length - 1] = newUrl;
	    } else {
	      router.history.push(newUrl);
	    }

	    // Update current route params
	    var ref = router.parseRouteUrl(newUrl);
	    var query = ref.query;
	    var hash = ref.hash;
	    var params = ref.params;
	    var url = ref.url;
	    var path = ref.path;
	    if (router.currentRoute) {
	      Utils.extend(router.currentRoute, {
	        query: query,
	        hash: hash,
	        params: params,
	        url: url,
	        path: path,
	      });
	    }

	    if (router.params.pushState) {
	      var pushStateRoot = router.params.pushStateRoot || '';
	      History.replace(
	        router.view.id,
	        {
	          url: newUrl,
	        },
	        pushStateRoot + router.params.pushStateSeparator + newUrl
	      );
	    }

	    // Save History
	    router.saveHistory();

	    router.emit('routeUrlUpdate', router.currentRoute, router);
	  };

	  Router.prototype.init = function init () {
	    var router = this;
	    var app = router.app;
	    var view = router.view;

	    // Init Swipeback
	    {
	      if (
	        (view && router.params.iosSwipeBack && app.theme === 'ios')
	        || (view && router.params.mdSwipeBack && app.theme === 'md')
	        || (view && router.params.auroraSwipeBack && app.theme === 'aurora')
	      ) {
	        SwipeBack(router);
	      }
	    }

	    // Dynamic not separated navbbar
	    if (router.dynamicNavbar && !router.separateNavbar) {
	      router.$el.addClass('router-dynamic-navbar-inside');
	    }

	    var initUrl = router.params.url;
	    var documentUrl = doc.location.href.split(doc.location.origin)[1];
	    var historyRestored;
	    var ref = router.params;
	    var pushState = ref.pushState;
	    var pushStateOnLoad = ref.pushStateOnLoad;
	    var pushStateSeparator = ref.pushStateSeparator;
	    var pushStateAnimateOnLoad = ref.pushStateAnimateOnLoad;
	    var ref$1 = router.params;
	    var pushStateRoot = ref$1.pushStateRoot;
	    if (win.cordova && pushState && !pushStateSeparator && !pushStateRoot && doc.location.pathname.indexOf('index.html')) {
	      // eslint-disable-next-line
	      console.warn('Framework7: wrong or not complete pushState configuration, trying to guess pushStateRoot');
	      pushStateRoot = doc.location.pathname.split('index.html')[0];
	    }
	    if (!pushState || !pushStateOnLoad) {
	      if (!initUrl) {
	        initUrl = documentUrl;
	      }
	      if (doc.location.search && initUrl.indexOf('?') < 0) {
	        initUrl += doc.location.search;
	      }
	      if (doc.location.hash && initUrl.indexOf('#') < 0) {
	        initUrl += doc.location.hash;
	      }
	    } else {
	      if (pushStateRoot && documentUrl.indexOf(pushStateRoot) >= 0) {
	        documentUrl = documentUrl.split(pushStateRoot)[1];
	        if (documentUrl === '') { documentUrl = '/'; }
	      }
	      if (pushStateSeparator.length > 0 && documentUrl.indexOf(pushStateSeparator) >= 0) {
	        initUrl = documentUrl.split(pushStateSeparator)[1];
	      } else {
	        initUrl = documentUrl;
	      }
	      router.restoreHistory();
	      if (router.history.indexOf(initUrl) >= 0) {
	        router.history = router.history.slice(0, router.history.indexOf(initUrl) + 1);
	      } else if (router.params.url === initUrl) {
	        router.history = [initUrl];
	      } else if (History.state && History.state[view.id] && History.state[view.id].url === router.history[router.history.length - 1]) {
	        initUrl = router.history[router.history.length - 1];
	      } else {
	        router.history = [documentUrl.split(pushStateSeparator)[0] || '/', initUrl];
	      }
	      if (router.history.length > 1) {
	        historyRestored = true;
	      } else {
	        router.history = [];
	      }
	      router.saveHistory();
	    }
	    var currentRoute;
	    if (router.history.length > 1) {
	      // Will load page
	      currentRoute = router.findMatchingRoute(router.history[0]);
	      if (!currentRoute) {
	        currentRoute = Utils.extend(router.parseRouteUrl(router.history[0]), {
	          route: {
	            url: router.history[0],
	            path: router.history[0].split('?')[0],
	          },
	        });
	      }
	    } else {
	      // Don't load page
	      currentRoute = router.findMatchingRoute(initUrl);
	      if (!currentRoute) {
	        currentRoute = Utils.extend(router.parseRouteUrl(initUrl), {
	          route: {
	            url: initUrl,
	            path: initUrl.split('?')[0],
	          },
	        });
	      }
	    }

	    if (router.params.stackPages) {
	      router.$el.children('.page').each(function (index, pageEl) {
	        var $pageEl = $(pageEl);
	        router.initialPages.push($pageEl[0]);
	        if (router.separateNavbar && $pageEl.children('.navbar').length > 0) {
	          router.initialNavbars.push($pageEl.children('.navbar').find('.navbar-inner')[0]);
	        }
	      });
	    }

	    if (router.$el.children('.page:not(.stacked)').length === 0 && initUrl) {
	      // No pages presented in DOM, reload new page
	      router.navigate(initUrl, {
	        initial: true,
	        reloadCurrent: true,
	        pushState: false,
	      });
	    } else {
	      // Init current DOM page
	      var hasTabRoute;
	      router.currentRoute = currentRoute;
	      router.$el.children('.page:not(.stacked)').each(function (index, pageEl) {
	        var $pageEl = $(pageEl);
	        var $navbarInnerEl;
	        $pageEl.addClass('page-current');
	        if (router.separateNavbar) {
	          $navbarInnerEl = $pageEl.children('.navbar').children('.navbar-inner');
	          if ($navbarInnerEl.length > 0) {
	            if (!router.$navbarEl.parents(doc).length) {
	              router.$el.prepend(router.$navbarEl);
	            }
	            $navbarInnerEl.addClass('navbar-current');
	            router.$navbarEl.append($navbarInnerEl);
	            if ($navbarInnerEl.children('.title-large').length) {
	              $navbarInnerEl.addClass('navbar-inner-large');
	            }
	            $pageEl.children('.navbar').remove();
	          } else {
	            router.$navbarEl.addClass('navbar-hidden');
	            if ($navbarInnerEl.children('.title-large').length) {
	              router.$navbarEl.addClass('navbar-hidden navbar-large-hidden');
	            }
	          }
	        }
	        if (router.currentRoute && router.currentRoute.route && router.currentRoute.route.master && router.params.masterDetailBreakpoint > 0) {
	          $pageEl.addClass('page-master');
	          $pageEl.trigger('page:role', { role: 'master' });
	          if ($navbarInnerEl && $navbarInnerEl.length) {
	            $navbarInnerEl.addClass('navbar-master');
	          }
	        }
	        var initOptions = {
	          route: router.currentRoute,
	        };
	        if (router.currentRoute && router.currentRoute.route && router.currentRoute.route.options) {
	          Utils.extend(initOptions, router.currentRoute.route.options);
	        }
	        router.currentPageEl = $pageEl[0];
	        if (router.separateNavbar && $navbarInnerEl.length) {
	          router.currentNavbarEl = $navbarInnerEl[0];
	        }
	        router.removeThemeElements($pageEl);
	        if (router.separateNavbar && $navbarInnerEl.length) {
	          router.removeThemeElements($navbarInnerEl);
	        }
	        if (initOptions.route.route.tab) {
	          hasTabRoute = true;
	          router.tabLoad(initOptions.route.route.tab, Utils.extend({}, initOptions));
	        }
	        router.pageCallback('init', $pageEl, $navbarInnerEl, 'current', undefined, initOptions);
	      });
	      if (historyRestored) {
	        router.navigate(initUrl, {
	          initial: true,
	          pushState: false,
	          history: false,
	          animate: pushStateAnimateOnLoad,
	          once: {
	            pageAfterIn: function pageAfterIn() {
	              var preloadPreviousPage = router.params.preloadPreviousPage || router.params[((app.theme) + "SwipeBack")];
	              if (preloadPreviousPage && router.history.length > 2) {
	                router.back({ preload: true });
	              }
	            },
	          },
	        });
	      }
	      if (!historyRestored && !hasTabRoute) {
	        router.history.push(initUrl);
	        router.saveHistory();
	      }
	    }
	    if (initUrl && pushState && pushStateOnLoad && (!History.state || !History.state[view.id])) {
	      History.initViewState(view.id, {
	        url: initUrl,
	      });
	    }
	    router.emit('local::init routerInit', router);
	  };

	  Router.prototype.destroy = function destroy () {
	    var router = this;

	    router.emit('local::destroy routerDestroy', router);

	    // Delete props & methods
	    Object.keys(router).forEach(function (routerProp) {
	      router[routerProp] = null;
	      delete router[routerProp];
	    });

	    router = null;
	  };

	  return Router;
	}(Framework7Class));

	// Load
	Router.prototype.forward = forward;
	Router.prototype.load = load;
	Router.prototype.navigate = navigate;
	Router.prototype.refreshPage = refreshPage;
	// Tab
	Router.prototype.tabLoad = tabLoad;
	Router.prototype.tabRemove = tabRemove;
	// Modal
	Router.prototype.modalLoad = modalLoad;
	Router.prototype.modalRemove = modalRemove;
	// Back
	Router.prototype.backward = backward;
	Router.prototype.loadBack = loadBack;
	Router.prototype.back = back;
	// Clear previoius pages from the DOM
	Router.prototype.clearPreviousPages = clearPreviousPages;
	// Clear history
	Router.prototype.clearPreviousHistory = clearPreviousHistory;

	var RouterModule = {
	  name: 'router',
	  static: {
	    Router: Router,
	  },
	  instance: {
	    cache: {
	      xhr: [],
	      templates: [],
	      components: [],
	    },
	  },
	  create: function create() {
	    var instance = this;
	    if (instance.app) {
	      // View Router
	      if (instance.params.router) {
	        instance.router = new Router(instance.app, instance);
	      }
	    } else {
	      // App Router
	      instance.router = new Router(instance);
	    }
	  },
	};

	var View = /*@__PURE__*/(function (Framework7Class) {
	  function View(appInstance, el, viewParams) {
	    if ( viewParams === void 0 ) viewParams = {};

	    Framework7Class.call(this, viewParams, [appInstance]);

	    var app = appInstance;
	    var $el = $(el);
	    var view = this;

	    var defaults = {
	      routes: [],
	      routesAdd: [],
	    };

	    // Default View params
	    view.params = Utils.extend(defaults, app.params.view, viewParams);

	    // Routes
	    if (view.params.routes.length > 0) {
	      view.routes = view.params.routes;
	    } else {
	      view.routes = [].concat(app.routes, view.params.routesAdd);
	    }

	    // Selector
	    var selector;
	    if (typeof el === 'string') { selector = el; }
	    else {
	      // Supposed to be HTMLElement or Dom7
	      selector = ($el.attr('id') ? ("#" + ($el.attr('id'))) : '') + ($el.attr('class') ? ("." + ($el.attr('class').replace(/ /g, '.').replace('.active', ''))) : '');
	    }

	    // DynamicNavbar
	    var $navbarEl;
	    if (app.theme === 'ios' && view.params.iosDynamicNavbar && view.params.iosSeparateDynamicNavbar) {
	      $navbarEl = $el.children('.navbar').eq(0);
	      if ($navbarEl.length === 0) {
	        $navbarEl = $('<div class="navbar"></div>');
	      }
	    }

	    // View Props
	    Utils.extend(false, view, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      name: view.params.name,
	      main: view.params.main || $el.hasClass('view-main'),
	      $navbarEl: $navbarEl,
	      navbarEl: $navbarEl ? $navbarEl[0] : undefined,
	      selector: selector,
	      history: [],
	      scrollHistory: {},
	    });

	    // Save in DOM
	    $el[0].f7View = view;

	    // Install Modules
	    view.useModules();

	    // Add to app
	    app.views.push(view);
	    if (view.main) {
	      app.views.main = view;
	    }
	    if (view.name) {
	      app.views[view.name] = view;
	    }

	    // Index
	    view.index = app.views.indexOf(view);

	    // View ID
	    var viewId;
	    if (view.name) {
	      viewId = "view_" + (view.name);
	    } else if (view.main) {
	      viewId = 'view_main';
	    } else {
	      viewId = "view_" + (view.index);
	    }
	    view.id = viewId;

	    // Init View
	    if (app.initialized) {
	      view.init();
	    } else {
	      app.on('init', function () {
	        view.init();
	      });
	    }

	    return view;
	  }

	  if ( Framework7Class ) View.__proto__ = Framework7Class;
	  View.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  View.prototype.constructor = View;

	  View.prototype.destroy = function destroy () {
	    var view = this;
	    var app = view.app;

	    view.$el.trigger('view:beforedestroy', view);
	    view.emit('local::beforeDestroy viewBeforeDestroy', view);

	    app.off('resize', view.checkmasterDetailBreakpoint);

	    if (view.main) {
	      app.views.main = null;
	      delete app.views.main;
	    } else if (view.name) {
	      app.views[view.name] = null;
	      delete app.views[view.name];
	    }
	    view.$el[0].f7View = null;
	    delete view.$el[0].f7View;

	    app.views.splice(app.views.indexOf(view), 1);

	    // Destroy Router
	    if (view.params.router && view.router) {
	      view.router.destroy();
	    }

	    view.emit('local::destroy viewDestroy', view);

	    // Delete props & methods
	    Object.keys(view).forEach(function (viewProp) {
	      view[viewProp] = null;
	      delete view[viewProp];
	    });

	    view = null;
	  };

	  View.prototype.checkmasterDetailBreakpoint = function checkmasterDetailBreakpoint () {
	    var view = this;
	    var app = view.app;
	    var wasMasterDetail = view.$el.hasClass('view-master-detail');
	    if (app.width >= view.params.masterDetailBreakpoint) {
	      view.$el.addClass('view-master-detail');
	      if (!wasMasterDetail) {
	        view.emit('local::masterDetailBreakpoint viewMasterDetailBreakpoint');
	        view.$el.trigger('view:masterDetailBreakpoint', view);
	      }
	    } else {
	      view.$el.removeClass('view-master-detail');
	      if (wasMasterDetail) {
	        view.emit('local::masterDetailBreakpoint viewMasterDetailBreakpoint');
	        view.$el.trigger('view:masterDetailBreakpoint', view);
	      }
	    }
	  };

	  View.prototype.initMasterDetail = function initMasterDetail () {
	    var view = this;
	    var app = view.app;
	    view.checkmasterDetailBreakpoint = view.checkmasterDetailBreakpoint.bind(view);
	    view.checkmasterDetailBreakpoint();
	    app.on('resize', view.checkmasterDetailBreakpoint);
	  };

	  View.prototype.init = function init () {
	    var view = this;
	    if (view.params.router) {
	      if (view.params.masterDetailBreakpoint > 0) {
	        view.initMasterDetail();
	      }
	      view.router.init();
	      view.$el.trigger('view:init', view);
	      view.emit('local::init viewInit', view);
	    }
	  };

	  return View;
	}(Framework7Class));

	// Use Router
	View.use(RouterModule);

	function initClicks(app) {
	  function handleClicks(e) {
	    var $clickedEl = $(e.target);
	    var $clickedLinkEl = $clickedEl.closest('a');
	    var isLink = $clickedLinkEl.length > 0;
	    var url = isLink && $clickedLinkEl.attr('href');
	    var isTabLink = isLink && $clickedLinkEl.hasClass('tab-link') && ($clickedLinkEl.attr('data-tab') || (url && url.indexOf('#') === 0));

	    // Check if link is external
	    if (isLink) {
	      // eslint-disable-next-line
	      if ($clickedLinkEl.is(app.params.clicks.externalLinks) || (url && url.indexOf('javascript:') >= 0)) {
	        var target = $clickedLinkEl.attr('target');
	        if (
	          url
	          && win.cordova
	          && win.cordova.InAppBrowser
	          && (target === '_system' || target === '_blank')
	        ) {
	          e.preventDefault();
	          win.cordova.InAppBrowser.open(url, target);
	        }
	        return;
	      }
	    }

	    // Modules Clicks
	    Object.keys(app.modules).forEach(function (moduleName) {
	      var moduleClicks = app.modules[moduleName].clicks;
	      if (!moduleClicks) { return; }
	      if (e.preventF7Router) { return; }
	      Object.keys(moduleClicks).forEach(function (clickSelector) {
	        var matchingClickedElement = $clickedEl.closest(clickSelector).eq(0);
	        if (matchingClickedElement.length > 0) {
	          moduleClicks[clickSelector].call(app, matchingClickedElement, matchingClickedElement.dataset(), e);
	        }
	      });
	    });

	    // Load Page
	    var clickedLinkData = {};
	    if (isLink) {
	      e.preventDefault();
	      clickedLinkData = $clickedLinkEl.dataset();
	    }

	    // Prevent Router
	    if (e.preventF7Router) { return; }
	    if ($clickedLinkEl.hasClass('prevent-router') || $clickedLinkEl.hasClass('router-prevent')) { return; }

	    var validUrl = url && url.length > 0 && url !== '#' && !isTabLink;
	    if (validUrl || $clickedLinkEl.hasClass('back')) {
	      var view;
	      if (clickedLinkData.view) {
	        view = $(clickedLinkData.view)[0].f7View;
	      } else {
	        view = $clickedEl.parents('.view')[0] && $clickedEl.parents('.view')[0].f7View;
	        if (!$clickedLinkEl.hasClass('back') && view && view.params.linksView) {
	          if (typeof view.params.linksView === 'string') { view = $(view.params.linksView)[0].f7View; }
	          else if (view.params.linksView instanceof View) { view = view.params.linksView; }
	        }
	      }
	      if (!view) {
	        if (app.views.main) { view = app.views.main; }
	      }
	      if (!view || !view.router) { return; }
	      if (clickedLinkData.context && typeof clickedLinkData.context === 'string') {
	        try {
	          clickedLinkData.context = JSON.parse(clickedLinkData.context);
	        } catch (err) {
	          // something wrong there
	        }
	      }
	      if ($clickedLinkEl[0].f7RouteProps) {
	        clickedLinkData.props = $clickedLinkEl[0].f7RouteProps;
	      }
	      if ($clickedLinkEl.hasClass('back')) { view.router.back(url, clickedLinkData); }
	      else { view.router.navigate(url, clickedLinkData); }
	    }
	  }

	  app.on('click', handleClicks);

	  // TODO: check if need this in iOS
	  // Prevent scrolling on overlays
	  // function preventScrolling(e) {
	  //   e.preventDefault();
	  // }
	  // if (Support.touch && !Device.android) {
	  //   const activeListener = Support.passiveListener ? { passive: false, capture: false } : false;
	  //   $(document).on((app.params.touch.fastClicks ? 'touchstart' : 'touchmove'), '.panel-backdrop, .dialog-backdrop, .preloader-backdrop, .popup-backdrop, .searchbar-backdrop', preventScrolling, activeListener);
	  // }
	}
	var ClicksModule = {
	  name: 'clicks',
	  params: {
	    clicks: {
	      // External Links
	      externalLinks: '.external',
	    },
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      initClicks(app);
	    },
	  },
	};

	var RouterTemplateLoaderModule = {
	  name: 'routerTemplateLoader',
	  proto: {
	    templateLoader: function templateLoader(template, templateUrl, options, resolve, reject) {
	      var router = this;
	      function compile(t) {
	        var compiledHtml;
	        var context;
	        try {
	          context = options.context || {};
	          if (typeof context === 'function') { context = context.call(router); }
	          else if (typeof context === 'string') {
	            try {
	              context = JSON.parse(context);
	            } catch (err) {
	              reject();
	              throw (err);
	            }
	          }
	          if (typeof t === 'function') {
	            compiledHtml = t(context);
	          } else {
	            compiledHtml = Template7.compile(t)(Utils.extend({}, context || {}, {
	              $app: router.app,
	              $root: Utils.extend({}, router.app.data, router.app.methods),
	              $route: options.route,
	              $f7route: options.route,
	              $router: router,
	              $f7router: router,
	              $theme: {
	                ios: router.app.theme === 'ios',
	                md: router.app.theme === 'md',
	                aurora: router.app.theme === 'aurora',
	              },
	            }));
	          }
	        } catch (err) {
	          reject();
	          throw (err);
	        }
	        resolve(compiledHtml, { context: context });
	      }
	      if (templateUrl) {
	        // Load via XHR
	        if (router.xhr) {
	          router.xhr.abort();
	          router.xhr = false;
	        }
	        router
	          .xhrRequest(templateUrl, options)
	          .then(function (templateContent) {
	            compile(templateContent);
	          })
	          .catch(function () {
	            reject();
	          });
	      } else {
	        compile(template);
	      }
	    },

	    modalTemplateLoader: function modalTemplateLoader(template, templateUrl, options, resolve, reject) {
	      var router = this;
	      return router.templateLoader(template, templateUrl, options, function (html) {
	        resolve(html);
	      }, reject);
	    },

	    tabTemplateLoader: function tabTemplateLoader(template, templateUrl, options, resolve, reject) {
	      var router = this;
	      return router.templateLoader(template, templateUrl, options, function (html) {
	        resolve(html);
	      }, reject);
	    },

	    pageTemplateLoader: function pageTemplateLoader(template, templateUrl, options, resolve, reject) {
	      var router = this;
	      return router.templateLoader(template, templateUrl, options, function (html, newOptions) {
	        if ( newOptions === void 0 ) newOptions = {};

	        resolve(router.getPageEl(html), newOptions);
	      }, reject);
	    },
	  },
	};

	var RouterComponentLoaderModule = {
	  name: 'routerComponentLoader',
	  proto: {
	    componentLoader: function componentLoader(component, componentUrl, options, resolve, reject) {
	      if ( options === void 0 ) options = {};

	      var router = this;
	      var app = router.app;
	      var url = typeof component === 'string' ? component : componentUrl;
	      var compiledUrl = router.replaceRequestUrlParams(url, options);
	      function compile(componentOptions) {
	        var context = options.context || {};
	        if (typeof context === 'function') { context = context.call(router); }
	        else if (typeof context === 'string') {
	          try {
	            context = JSON.parse(context);
	          } catch (err) {
	            reject();
	            throw (err);
	          }
	        }
	        var extendContext = Utils.merge(
	          {},
	          context,
	          {
	            $route: options.route,
	            $f7route: options.route,
	            $router: router,
	            $f7router: router,
	            $theme: {
	              ios: app.theme === 'ios',
	              md: app.theme === 'md',
	              aurora: app.theme === 'aurora',
	            },
	          }
	        );
	        var createdComponent = app.component.create(componentOptions, extendContext);
	        resolve(createdComponent.el);
	      }
	      var cachedComponent;
	      if (compiledUrl) {
	        router.cache.components.forEach(function (cached) {
	          if (cached.url === compiledUrl) { cachedComponent = cached.component; }
	        });
	      }
	      if (compiledUrl && cachedComponent) {
	        compile(cachedComponent);
	      } else if (compiledUrl && !cachedComponent) {
	        // Load via XHR
	        if (router.xhr) {
	          router.xhr.abort();
	          router.xhr = false;
	        }
	        router
	          .xhrRequest(url, options)
	          .then(function (loadedComponent) {
	            var parsedComponent = app.component.parse(loadedComponent);
	            router.cache.components.push({
	              url: compiledUrl,
	              component: parsedComponent,
	            });
	            compile(parsedComponent);
	          })
	          .catch(function (err) {
	            reject();
	            throw (err);
	          });
	      } else {
	        compile(component);
	      }
	    },

	    modalComponentLoader: function modalComponentLoader(rootEl, component, componentUrl, options, resolve, reject) {
	      var router = this;
	      router.componentLoader(component, componentUrl, options, function (el) {
	        resolve(el);
	      }, reject);
	    },

	    tabComponentLoader: function tabComponentLoader(tabEl, component, componentUrl, options, resolve, reject) {
	      var router = this;
	      router.componentLoader(component, componentUrl, options, function (el) {
	        resolve(el);
	      }, reject);
	    },

	    pageComponentLoader: function pageComponentLoader(routerEl, component, componentUrl, options, resolve, reject) {
	      var router = this;
	      router.componentLoader(component, componentUrl, options, function (el, newOptions) {
	        if ( newOptions === void 0 ) newOptions = {};

	        resolve(el, newOptions);
	      }, reject);
	    },
	  },
	};

	var HistoryModule = {
	  name: 'history',
	  static: {
	    history: History,
	  },
	  on: {
	    init: function init() {
	      History.init(this);
	    },
	  },
	};

	var keyPrefix = 'f7storage-';
	var Storage = {
	  get: function get(key) {
	    return new Promise(function (resolve, reject) {
	      try {
	        var value = JSON.parse(win.localStorage.getItem(("" + keyPrefix + key)));
	        resolve(value);
	      } catch (e) {
	        reject(e);
	      }
	    });
	  },
	  set: function set(key, value) {
	    return new Promise(function (resolve, reject) {
	      try {
	        win.localStorage.setItem(("" + keyPrefix + key), JSON.stringify(value));
	        resolve();
	      } catch (e) {
	        reject(e);
	      }
	    });
	  },
	  remove: function remove(key) {
	    return new Promise(function (resolve, reject) {
	      try {
	        win.localStorage.removeItem(("" + keyPrefix + key));
	        resolve();
	      } catch (e) {
	        reject(e);
	      }
	    });
	  },
	  clear: function clear() {

	  },
	  length: function length() {

	  },
	  keys: function keys() {
	    return new Promise(function (resolve, reject) {
	      try {
	        var keys = Object.keys(win.localStorage)
	          .filter(function (keyName) { return keyName.indexOf(keyPrefix) === 0; })
	          .map(function (keyName) { return keyName.replace(keyPrefix, ''); });
	        resolve(keys);
	      } catch (e) {
	        reject(e);
	      }
	    });
	  },
	  forEach: function forEach(callback) {
	    return new Promise(function (resolve, reject) {
	      try {
	        Object.keys(win.localStorage)
	          .filter(function (keyName) { return keyName.indexOf(keyPrefix) === 0; })
	          .forEach(function (keyName, index) {
	            var key = keyName.replace(keyPrefix, '');
	            Storage.get(key).then(function (value) {
	              callback(key, value, index);
	            });
	          });
	        resolve();
	      } catch (e) {
	        reject(e);
	      }
	    });
	  },
	};

	var StorageModule = {
	  name: 'storage',
	  static: {
	    Storage: Storage,
	    storage: Storage,
	  },
	};

	function vnode(sel, data, children, text, elm) {
	    var key = data === undefined ? undefined : data.key;
	    return { sel: sel, data: data, children: children,
	        text: text, elm: elm, key: key };
	}

	var array = Array.isArray;
	function primitive(s) {
	    return typeof s === 'string' || typeof s === 'number';
	}

	function addNS(data, children, sel) {
	    data.ns = 'http://www.w3.org/2000/svg';
	    if (sel !== 'foreignObject' && children !== undefined) {
	        for (var i = 0; i < children.length; ++i) {
	            var childData = children[i].data;
	            if (childData !== undefined) {
	                addNS(childData, children[i].children, children[i].sel);
	            }
	        }
	    }
	}
	function h(sel, b, c) {
	    var data = {}, children, text, i;
	    if (c !== undefined) {
	        data = b;
	        if (array(c)) {
	            children = c;
	        }
	        else if (primitive(c)) {
	            text = c;
	        }
	        else if (c && c.sel) {
	            children = [c];
	        }
	    }
	    else if (b !== undefined) {
	        if (array(b)) {
	            children = b;
	        }
	        else if (primitive(b)) {
	            text = b;
	        }
	        else if (b && b.sel) {
	            children = [b];
	        }
	        else {
	            data = b;
	        }
	    }
	    if (array(children)) {
	        for (i = 0; i < children.length; ++i) {
	            if (primitive(children[i]))
	                { children[i] = vnode(undefined, undefined, undefined, children[i], undefined); }
	        }
	    }
	    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&
	        (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {
	        addNS(data, children, sel);
	    }
	    return vnode(sel, data, children, text, undefined);
	}

	/* eslint no-use-before-define: "off" */

	var selfClosing = 'area base br col command embed hr img input keygen link menuitem meta param source track wbr'.split(' ');
	var propsAttrs = 'hidden checked disabled readonly selected autocomplete autofocus autoplay required multiple value indeterminate'.split(' ');
	var booleanProps = 'hidden checked disabled readonly selected autocomplete autofocus autoplay required multiple readOnly indeterminate'.split(' ');
	var tempDom = doc.createElement('div');

	function getHooks(data, app, initial, isRoot) {
	  var hooks = {};
	  if (!data || !data.attrs || !data.attrs.class) { return hooks; }
	  var classNames = data.attrs.class;
	  var insert = [];
	  var destroy = [];
	  var update = [];
	  var postpatch = [];
	  classNames.split(' ').forEach(function (className) {
	    if (!initial) {
	      insert.push.apply(insert, app.getVnodeHooks('insert', className));
	    }
	    destroy.push.apply(destroy, app.getVnodeHooks('destroy', className));
	    update.push.apply(update, app.getVnodeHooks('update', className));
	    postpatch.push.apply(postpatch, app.getVnodeHooks('postpatch', className));
	  });

	  if (isRoot && !initial) {
	    postpatch.push(function (oldVnode, vnode) {
	      var vn = vnode || oldVnode;
	      if (!vn) { return; }
	      if (vn.data && vn.data.context && vn.data.context.$options.updated) {
	        vn.data.context.$options.updated();
	      }
	    });
	  }
	  if (insert.length === 0 && destroy.length === 0 && update.length === 0 && postpatch.length === 0) {
	    return hooks;
	  }
	  if (insert.length) {
	    hooks.insert = function (vnode) {
	      insert.forEach(function (f) { return f(vnode); });
	    };
	  }
	  if (destroy.length) {
	    hooks.destroy = function (vnode) {
	      destroy.forEach(function (f) { return f(vnode); });
	    };
	  }
	  if (update.length) {
	    hooks.update = function (oldVnode, vnode) {
	      update.forEach(function (f) { return f(oldVnode, vnode); });
	    };
	  }
	  if (postpatch.length) {
	    hooks.postpatch = function (oldVnode, vnode) {
	      postpatch.forEach(function (f) { return f(oldVnode, vnode); });
	    };
	  }

	  return hooks;
	}
	function getEventHandler(handlerString, context, ref) {
	  if ( ref === void 0 ) ref = {};
	  var stop = ref.stop;
	  var prevent = ref.prevent;
	  var once = ref.once;

	  var fired = false;
	  var methodName;
	  var method;
	  var customArgs = [];
	  var needMethodBind = true;

	  if (handlerString.indexOf('(') < 0) {
	    methodName = handlerString;
	  } else {
	    methodName = handlerString.split('(')[0];
	  }
	  if (methodName.indexOf('.') >= 0) {
	    methodName.split('.').forEach(function (path, pathIndex) {
	      if (pathIndex === 0 && path === 'this') { return; }
	      if (pathIndex === 0 && path === 'window') {
	        // eslint-disable-next-line
	        method = win;
	        needMethodBind = false;
	        return;
	      }
	      if (!method) { method = context; }
	      if (method[path]) { method = method[path]; }
	      else {
	        throw new Error(("Framework7: Component doesn't have method \"" + (methodName.split('.').slice(0, pathIndex + 1).join('.')) + "\""));
	      }
	    });
	  } else {
	    if (!context[methodName]) {
	      throw new Error(("Framework7: Component doesn't have method \"" + methodName + "\""));
	    }
	    method = context[methodName];
	  }
	  if (needMethodBind) {
	    method = method.bind(context);
	  }

	  function handler() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var e = args[0];
	    if (once && fired) { return; }
	    if (stop) { e.stopPropagation(); }
	    if (prevent) { e.preventDefault(); }
	    fired = true;

	    if (handlerString.indexOf('(') < 0) {
	      customArgs = args;
	    } else {
	      var handlerArguments = handlerString
	        .split('(')[1]
	        .split(')')[0]
	        .replace(/'[^']*'|"[^"]*"/g, function (a) { return a.replace(/,/g, '<_comma_>'); })
	        .split(',')
	        .map(function (a) { return a.replace(/<_comma_>/g, ','); });
	      handlerArguments.forEach(function (argument) {
	        var arg = argument.trim();
	        // eslint-disable-next-line
	        if (!isNaN(arg)) { arg = parseFloat(arg); }
	        else if (arg === 'true') { arg = true; }
	        else if (arg === 'false') { arg = false; }
	        else if (arg === 'null') { arg = null; }
	        else if (arg === 'undefined') { arg = undefined; }
	        else if (arg[0] === '"') { arg = arg.replace(/"/g, ''); }
	        else if (arg[0] === '\'') { arg = arg.replace(/'/g, ''); }
	        else if (arg.indexOf('.') > 0) {
	          var deepArg;
	          arg.split('.').forEach(function (path) {
	            if (!deepArg) { deepArg = context; }
	            deepArg = deepArg[path];
	          });
	          arg = deepArg;
	        } else {
	          arg = context[arg];
	        }
	        customArgs.push(arg);
	      });
	    }

	    method.apply(void 0, customArgs);
	  }

	  return handler;
	}

	function getData(el, context, app, initial, isRoot) {
	  var data = {
	    context: context,
	  };
	  var attributes = el.attributes;
	  Array.prototype.forEach.call(attributes, function (attr) {
	    var attrName = attr.name;
	    var attrValue = attr.value;
	    if (propsAttrs.indexOf(attrName) >= 0) {
	      // Props
	      if (!data.props) { data.props = {}; }
	      if (attrName === 'readonly') {
	        attrName = 'readOnly';
	      }
	      if (booleanProps.indexOf(attrName) >= 0) {
	        // eslint-disable-next-line
	        data.props[attrName] = attrValue === false ? false : true;
	      } else {
	        data.props[attrName] = attrValue;
	      }
	    } else if (attrName === 'key') {
	      // Key
	      data.key = attrValue;
	    } else if (attrName.indexOf('@') === 0) {
	      // Events
	      if (!data.on) { data.on = {}; }
	      var eventName = attrName.substr(1);
	      var stop = false;
	      var prevent = false;
	      var once = false;
	      if (eventName.indexOf('.') >= 0) {
	        eventName.split('.').forEach(function (eventNamePart, eventNameIndex) {
	          if (eventNameIndex === 0) { eventName = eventNamePart; }
	          else {
	            if (eventNamePart === 'stop') { stop = true; }
	            if (eventNamePart === 'prevent') { prevent = true; }
	            if (eventNamePart === 'once') { once = true; }
	          }
	        });
	      }
	      data.on[eventName] = getEventHandler(attrValue, context, { stop: stop, prevent: prevent, once: once });
	    } else if (attrName === 'style') {
	      // Style
	      if (attrValue.indexOf('{') >= 0 && attrValue.indexOf('}') >= 0) {
	        try {
	          data.style = JSON.parse(attrValue);
	        } catch (e) {
	          if (!data.attrs) { data.attrs = {}; }
	          data.attrs.style = attrValue;
	        }
	      } else {
	        if (!data.attrs) { data.attrs = {}; }
	        data.attrs.style = attrValue;
	      }
	    } else {
	      // Rest of attribures
	      if (!data.attrs) { data.attrs = {}; }
	      data.attrs[attrName] = attrValue;

	      // ID -> Key
	      if (attrName === 'id' && !data.key && !isRoot) {
	        data.key = attrValue;
	      }
	    }
	  });
	  var hooks = getHooks(data, app, initial, isRoot);
	  hooks.prepatch = function (oldVnode, vnode) {
	    if (!oldVnode || !vnode) { return; }
	    if (oldVnode && oldVnode.data && oldVnode.data.props) {
	      Object.keys(oldVnode.data.props).forEach(function (key) {
	        if (booleanProps.indexOf(key) < 0) { return; }
	        if (!vnode.data) { vnode.data = {}; }
	        if (!vnode.data.props) { vnode.data.props = {}; }
	        if (oldVnode.data.props[key] === true && !(key in vnode.data.props)) {
	          vnode.data.props[key] = false;
	        }
	      });
	    }
	  };
	  if (hooks) {
	    data.hook = hooks;
	  }
	  return data;
	}

	function getChildren(el, context, app, initial) {
	  var children = [];
	  var nodes = el.childNodes;
	  for (var i = 0; i < nodes.length; i += 1) {
	    var childNode = nodes[i];
	    var child = elementToVNode(childNode, context, app, initial);
	    if (child) {
	      children.push(child);
	    }
	  }
	  return children;
	}

	function elementToVNode(el, context, app, initial, isRoot) {
	  if (el.nodeType === 1) {
	    // element (statement adds inline SVG compatibility)
	    var tagName = (el instanceof win.SVGElement) ? el.nodeName : el.nodeName.toLowerCase();
	    return h(
	      tagName,
	      getData(el, context, app, initial, isRoot),
	      selfClosing.indexOf(tagName) >= 0 ? [] : getChildren(el, context, app, initial)
	    );
	  }
	  if (el.nodeType === 3) {
	    // text
	    return el.textContent;
	  }
	  return null;
	}

	function vdom (html, context, app, initial) {
	  if ( html === void 0 ) html = '';

	  // Save to temp dom
	  tempDom.innerHTML = html.trim();

	  // Parse DOM
	  var rootEl;
	  for (var i = 0; i < tempDom.childNodes.length; i += 1) {
	    if (!rootEl && tempDom.childNodes[i].nodeType === 1) {
	      rootEl = tempDom.childNodes[i];
	    }
	  }
	  var result = elementToVNode(rootEl, context, app, initial, true);

	  // Clean
	  tempDom.innerHTML = '';

	  return result;
	}

	function createElement(tagName) {
	    return document.createElement(tagName);
	}
	function createElementNS(namespaceURI, qualifiedName) {
	    return document.createElementNS(namespaceURI, qualifiedName);
	}
	function createTextNode(text) {
	    return document.createTextNode(text);
	}
	function createComment(text) {
	    return document.createComment(text);
	}
	function insertBefore$1(parentNode, newNode, referenceNode) {
	    parentNode.insertBefore(newNode, referenceNode);
	}
	function removeChild(node, child) {
	    if (!node) { return; }
	    node.removeChild(child);
	}
	function appendChild(node, child) {
	    node.appendChild(child);
	}
	function parentNode(node) {
	    return node.parentNode;
	}
	function nextSibling(node) {
	    return node.nextSibling;
	}
	function tagName(elm) {
	    return elm.tagName;
	}
	function setTextContent(node, text) {
	    node.textContent = text;
	}
	function getTextContent(node) {
	    return node.textContent;
	}
	function isElement(node) {
	    return node.nodeType === 1;
	}
	function isText(node) {
	    return node.nodeType === 3;
	}
	function isComment(node) {
	    return node.nodeType === 8;
	}
	var htmlDomApi = {
	    createElement: createElement,
	    createElementNS: createElementNS,
	    createTextNode: createTextNode,
	    createComment: createComment,
	    insertBefore: insertBefore$1,
	    removeChild: removeChild,
	    appendChild: appendChild,
	    parentNode: parentNode,
	    nextSibling: nextSibling,
	    tagName: tagName,
	    setTextContent: setTextContent,
	    getTextContent: getTextContent,
	    isElement: isElement,
	    isText: isText,
	    isComment: isComment,
	};

	function isUndef(s) { return s === undefined; }
	function isDef(s) { return s !== undefined; }
	var emptyNode = vnode('', {}, [], undefined, undefined);
	function sameVnode(vnode1, vnode2) {
	    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
	}
	function isVnode(vnode) {
	    return vnode.sel !== undefined;
	}
	function createKeyToOldIdx(children, beginIdx, endIdx) {
	    var i, map = {}, key, ch;
	    for (i = beginIdx; i <= endIdx; ++i) {
	        ch = children[i];
	        if (ch != null) {
	            key = ch.key;
	            if (key !== undefined)
	                { map[key] = i; }
	        }
	    }
	    return map;
	}
	var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];
	function init(modules, domApi) {
	    var i, j, cbs = {};
	    var api = domApi !== undefined ? domApi : htmlDomApi;
	    for (i = 0; i < hooks.length; ++i) {
	        cbs[hooks[i]] = [];
	        for (j = 0; j < modules.length; ++j) {
	            var hook = modules[j][hooks[i]];
	            if (hook !== undefined) {
	                cbs[hooks[i]].push(hook);
	            }
	        }
	    }
	    function emptyNodeAt(elm) {
	        var id = elm.id ? '#' + elm.id : '';
	        var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';
	        return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
	    }
	    function createRmCb(childElm, listeners) {
	        return function rmCb() {
	            if (--listeners === 0) {
	                var parent_1 = api.parentNode(childElm);
	                api.removeChild(parent_1, childElm);
	            }
	        };
	    }
	    function createElm(vnode, insertedVnodeQueue) {
	        var i, data = vnode.data;
	        if (data !== undefined) {
	            if (isDef(i = data.hook) && isDef(i = i.init)) {
	                i(vnode);
	                data = vnode.data;
	            }
	        }
	        var children = vnode.children, sel = vnode.sel;
	        if (sel === '!') {
	            if (isUndef(vnode.text)) {
	                vnode.text = '';
	            }
	            vnode.elm = api.createComment(vnode.text);
	        }
	        else if (sel !== undefined) {
	            // Parse selector
	            var hashIdx = sel.indexOf('#');
	            var dotIdx = sel.indexOf('.', hashIdx);
	            var hash = hashIdx > 0 ? hashIdx : sel.length;
	            var dot = dotIdx > 0 ? dotIdx : sel.length;
	            var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
	            var elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag)
	                : api.createElement(tag);
	            if (hash < dot)
	                { elm.setAttribute('id', sel.slice(hash + 1, dot)); }
	            if (dotIdx > 0)
	                { elm.setAttribute('class', sel.slice(dot + 1).replace(/\./g, ' ')); }
	            for (i = 0; i < cbs.create.length; ++i)
	                { cbs.create[i](emptyNode, vnode); }
	            if (array(children)) {
	                for (i = 0; i < children.length; ++i) {
	                    var ch = children[i];
	                    if (ch != null) {
	                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));
	                    }
	                }
	            }
	            else if (primitive(vnode.text)) {
	                api.appendChild(elm, api.createTextNode(vnode.text));
	            }
	            i = vnode.data.hook; // Reuse variable
	            if (isDef(i)) {
	                if (i.create)
	                    { i.create(emptyNode, vnode); }
	                if (i.insert)
	                    { insertedVnodeQueue.push(vnode); }
	            }
	        }
	        else {
	            vnode.elm = api.createTextNode(vnode.text);
	        }
	        return vnode.elm;
	    }
	    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
	        for (; startIdx <= endIdx; ++startIdx) {
	            var ch = vnodes[startIdx];
	            if (ch != null) {
	                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
	            }
	        }
	    }
	    function invokeDestroyHook(vnode) {
	        var i, j, data = vnode.data;
	        if (data !== undefined) {
	            if (isDef(i = data.hook) && isDef(i = i.destroy))
	                { i(vnode); }
	            for (i = 0; i < cbs.destroy.length; ++i)
	                { cbs.destroy[i](vnode); }
	            if (vnode.children !== undefined) {
	                for (j = 0; j < vnode.children.length; ++j) {
	                    i = vnode.children[j];
	                    if (i != null && typeof i !== "string") {
	                        invokeDestroyHook(i);
	                    }
	                }
	            }
	        }
	    }
	    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
	        for (; startIdx <= endIdx; ++startIdx) {
	            var i_1 = void 0, listeners = void 0, rm = void 0, ch = vnodes[startIdx];
	            if (ch != null) {
	                if (isDef(ch.sel)) {
	                    invokeDestroyHook(ch);
	                    listeners = cbs.remove.length + 1;
	                    rm = createRmCb(ch.elm, listeners);
	                    for (i_1 = 0; i_1 < cbs.remove.length; ++i_1)
	                        { cbs.remove[i_1](ch, rm); }
	                    if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {
	                        i_1(ch, rm);
	                    }
	                    else {
	                        rm();
	                    }
	                }
	                else {
	                    api.removeChild(parentElm, ch.elm);
	                }
	            }
	        }
	    }
	    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
	        var oldStartIdx = 0, newStartIdx = 0;
	        var oldEndIdx = oldCh.length - 1;
	        var oldStartVnode = oldCh[0];
	        var oldEndVnode = oldCh[oldEndIdx];
	        var newEndIdx = newCh.length - 1;
	        var newStartVnode = newCh[0];
	        var newEndVnode = newCh[newEndIdx];
	        var oldKeyToIdx;
	        var idxInOld;
	        var elmToMove;
	        var before;
	        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
	            if (oldStartVnode == null) {
	                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
	            }
	            else if (oldEndVnode == null) {
	                oldEndVnode = oldCh[--oldEndIdx];
	            }
	            else if (newStartVnode == null) {
	                newStartVnode = newCh[++newStartIdx];
	            }
	            else if (newEndVnode == null) {
	                newEndVnode = newCh[--newEndIdx];
	            }
	            else if (sameVnode(oldStartVnode, newStartVnode)) {
	                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
	                oldStartVnode = oldCh[++oldStartIdx];
	                newStartVnode = newCh[++newStartIdx];
	            }
	            else if (sameVnode(oldEndVnode, newEndVnode)) {
	                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
	                oldEndVnode = oldCh[--oldEndIdx];
	                newEndVnode = newCh[--newEndIdx];
	            }
	            else if (sameVnode(oldStartVnode, newEndVnode)) {
	                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
	                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
	                oldStartVnode = oldCh[++oldStartIdx];
	                newEndVnode = newCh[--newEndIdx];
	            }
	            else if (sameVnode(oldEndVnode, newStartVnode)) {
	                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
	                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
	                oldEndVnode = oldCh[--oldEndIdx];
	                newStartVnode = newCh[++newStartIdx];
	            }
	            else {
	                if (oldKeyToIdx === undefined) {
	                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
	                }
	                idxInOld = oldKeyToIdx[newStartVnode.key];
	                if (isUndef(idxInOld)) {
	                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
	                    newStartVnode = newCh[++newStartIdx];
	                }
	                else {
	                    elmToMove = oldCh[idxInOld];
	                    if (elmToMove.sel !== newStartVnode.sel) {
	                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
	                    }
	                    else {
	                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
	                        oldCh[idxInOld] = undefined;
	                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
	                    }
	                    newStartVnode = newCh[++newStartIdx];
	                }
	            }
	        }
	        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
	            if (oldStartIdx > oldEndIdx) {
	                before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
	                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
	            }
	            else {
	                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
	            }
	        }
	    }
	    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
	        var i, hook;
	        if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
	            i(oldVnode, vnode);
	        }
	        var elm = vnode.elm = oldVnode.elm;
	        var oldCh = oldVnode.children;
	        var ch = vnode.children;
	        if (oldVnode === vnode)
	            { return; }
	        if (vnode.data !== undefined) {
	            for (i = 0; i < cbs.update.length; ++i)
	                { cbs.update[i](oldVnode, vnode); }
	            i = vnode.data.hook;
	            if (isDef(i) && isDef(i = i.update))
	                { i(oldVnode, vnode); }
	        }
	        if (isUndef(vnode.text)) {
	            if (isDef(oldCh) && isDef(ch)) {
	                if (oldCh !== ch)
	                    { updateChildren(elm, oldCh, ch, insertedVnodeQueue); }
	            }
	            else if (isDef(ch)) {
	                if (isDef(oldVnode.text))
	                    { api.setTextContent(elm, ''); }
	                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
	            }
	            else if (isDef(oldCh)) {
	                removeVnodes(elm, oldCh, 0, oldCh.length - 1);
	            }
	            else if (isDef(oldVnode.text)) {
	                api.setTextContent(elm, '');
	            }
	        }
	        else if (oldVnode.text !== vnode.text) {
	            api.setTextContent(elm, vnode.text);
	        }
	        if (isDef(hook) && isDef(i = hook.postpatch)) {
	            i(oldVnode, vnode);
	        }
	    }
	    return function patch(oldVnode, vnode) {
	        var i, elm, parent;
	        var insertedVnodeQueue = [];
	        for (i = 0; i < cbs.pre.length; ++i)
	            { cbs.pre[i](); }
	        if (!isVnode(oldVnode)) {
	            oldVnode = emptyNodeAt(oldVnode);
	        }
	        if (sameVnode(oldVnode, vnode)) {
	            patchVnode(oldVnode, vnode, insertedVnodeQueue);
	        }
	        else {
	            elm = oldVnode.elm;
	            parent = api.parentNode(elm);
	            createElm(vnode, insertedVnodeQueue);
	            if (parent !== null) {
	                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
	                removeVnodes(parent, [oldVnode], 0, 0);
	            }
	        }
	        for (i = 0; i < insertedVnodeQueue.length; ++i) {
	            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
	        }
	        for (i = 0; i < cbs.post.length; ++i)
	            { cbs.post[i](); }
	        return vnode;
	    };
	}

	var xlinkNS = 'http://www.w3.org/1999/xlink';
	var xmlNS = 'http://www.w3.org/XML/1998/namespace';
	var colonChar = 58;
	var xChar = 120;
	function updateAttrs(oldVnode, vnode) {
	    var key, elm = vnode.elm, oldAttrs = oldVnode.data.attrs, attrs = vnode.data.attrs;
	    if (!oldAttrs && !attrs)
	        { return; }
	    if (oldAttrs === attrs)
	        { return; }
	    oldAttrs = oldAttrs || {};
	    attrs = attrs || {};
	    // update modified attributes, add new attributes
	    for (key in attrs) {
	        var cur = attrs[key];
	        var old = oldAttrs[key];
	        if (old !== cur) {
	            if (cur === true) {
	                elm.setAttribute(key, "");
	            }
	            else if (cur === false) {
	                elm.removeAttribute(key);
	            }
	            else {
	                if (key.charCodeAt(0) !== xChar) {
	                    elm.setAttribute(key, cur);
	                }
	                else if (key.charCodeAt(3) === colonChar) {
	                    // Assume xml namespace
	                    elm.setAttributeNS(xmlNS, key, cur);
	                }
	                else if (key.charCodeAt(5) === colonChar) {
	                    // Assume xlink namespace
	                    elm.setAttributeNS(xlinkNS, key, cur);
	                }
	                else {
	                    elm.setAttribute(key, cur);
	                }
	            }
	        }
	    }
	    // remove removed attributes
	    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
	    // the other option is to remove all attributes with value == undefined
	    for (key in oldAttrs) {
	        if (!(key in attrs)) {
	            elm.removeAttribute(key);
	        }
	    }
	}
	var attributesModule = { create: updateAttrs, update: updateAttrs };

	function updateProps(oldVnode, vnode) {
	    var key, cur, old, elm = vnode.elm, oldProps = oldVnode.data.props, props = vnode.data.props;
	    if (!oldProps && !props)
	        { return; }
	    if (oldProps === props)
	        { return; }
	    oldProps = oldProps || {};
	    props = props || {};
	    for (key in oldProps) {
	        if (!props[key]) {
	            delete elm[key];
	        }
	    }
	    for (key in props) {
	        cur = props[key];
	        old = oldProps[key];
	        if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
	            elm[key] = cur;
	        }
	    }
	}
	var propsModule = { create: updateProps, update: updateProps };

	var raf = (typeof window !== 'undefined' && window.requestAnimationFrame) || setTimeout;
	var nextFrame = function (fn) { raf(function () { raf(fn); }); };
	function setNextFrame(obj, prop, val) {
	    nextFrame(function () { obj[prop] = val; });
	}
	function updateStyle(oldVnode, vnode) {
	    var cur, name, elm = vnode.elm, oldStyle = oldVnode.data.style, style = vnode.data.style;
	    if (!oldStyle && !style)
	        { return; }
	    if (oldStyle === style)
	        { return; }
	    oldStyle = oldStyle || {};
	    style = style || {};
	    var oldHasDel = 'delayed' in oldStyle;
	    for (name in oldStyle) {
	        if (!style[name]) {
	            if (name[0] === '-' && name[1] === '-') {
	                elm.style.removeProperty(name);
	            }
	            else {
	                elm.style[name] = '';
	            }
	        }
	    }
	    for (name in style) {
	        cur = style[name];
	        if (name === 'delayed' && style.delayed) {
	            for (var name2 in style.delayed) {
	                cur = style.delayed[name2];
	                if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
	                    setNextFrame(elm.style, name2, cur);
	                }
	            }
	        }
	        else if (name !== 'remove' && cur !== oldStyle[name]) {
	            if (name[0] === '-' && name[1] === '-') {
	                elm.style.setProperty(name, cur);
	            }
	            else {
	                elm.style[name] = cur;
	            }
	        }
	    }
	}
	function applyDestroyStyle(vnode) {
	    var style, name, elm = vnode.elm, s = vnode.data.style;
	    if (!s || !(style = s.destroy))
	        { return; }
	    for (name in style) {
	        elm.style[name] = style[name];
	    }
	}
	function applyRemoveStyle(vnode, rm) {
	    var s = vnode.data.style;
	    if (!s || !s.remove) {
	        rm();
	        return;
	    }
	    var name, elm = vnode.elm, i = 0, compStyle, style = s.remove, amount = 0, applied = [];
	    for (name in style) {
	        applied.push(name);
	        elm.style[name] = style[name];
	    }
	    compStyle = getComputedStyle(elm);
	    var props = compStyle['transition-property'].split(', ');
	    for (; i < props.length; ++i) {
	        if (applied.indexOf(props[i]) !== -1)
	            { amount++; }
	    }
	    elm.addEventListener('transitionend', function (ev) {
	        if (ev.target === elm)
	            { --amount; }
	        if (amount === 0)
	            { rm(); }
	    });
	}
	var styleModule = {
	    create: updateStyle,
	    update: updateStyle,
	    destroy: applyDestroyStyle,
	    remove: applyRemoveStyle
	};

	function invokeHandler(handler, event, args) {
	  if (typeof handler === 'function') {
	    // call function handler
	    handler.apply(void 0, [ event ].concat( args ));
	  }
	}
	function handleEvent(event, args, vnode) {
	  var name = event.type;
	  var on = vnode.data.on;
	  // call event handler(s) if exists
	  if (on && on[name]) {
	    invokeHandler(on[name], event, args, vnode);
	  }
	}
	function createListener() {
	  return function handler(event) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    handleEvent(event, args, handler.vnode);
	  };
	}
	function updateEvents(oldVnode, vnode) {
	  var oldOn = oldVnode.data.on;
	  var oldListener = oldVnode.listener;
	  var oldElm = oldVnode.elm;
	  var on = vnode && vnode.data.on;
	  var elm = (vnode && vnode.elm);
	  // optimization for reused immutable handlers
	  if (oldOn === on) {
	    return;
	  }
	  // remove existing listeners which no longer used
	  if (oldOn && oldListener) {
	    // if element changed or deleted we remove all existing listeners unconditionally
	    if (!on) {
	      Object.keys(oldOn).forEach(function (name) {
	        $(oldElm).off(name, oldListener);
	      });
	    } else {
	      Object.keys(oldOn).forEach(function (name) {
	        if (!on[name]) {
	          $(oldElm).off(name, oldListener);
	        }
	      });
	    }
	  }
	  // add new listeners which has not already attached
	  if (on) {
	    // reuse existing listener or create new
	    var listener = oldVnode.listener || createListener();
	    vnode.listener = listener;
	    // update vnode for listener
	    listener.vnode = vnode;
	    // if element changed or added we add all needed listeners unconditionally
	    if (!oldOn) {
	      Object.keys(on).forEach(function (name) {
	        $(elm).on(name, listener);
	      });
	    } else {
	      Object.keys(on).forEach(function (name) {
	        if (!oldOn[name]) {
	          $(elm).on(name, listener);
	        }
	      });
	    }
	  }
	}

	var eventListenersModule = {
	  create: updateEvents,
	  update: updateEvents,
	  destroy: updateEvents,
	};

	/* eslint import/no-named-as-default: off */

	var patch = init([
	  attributesModule,
	  propsModule,
	  styleModule,
	  eventListenersModule ]);

	var Framework7Component = function Framework7Component(app, options, extendContext) {
	  if ( extendContext === void 0 ) extendContext = {};

	  var id = Utils.id();
	  var self = Utils.merge(
	    this,
	    extendContext,
	    {
	      $: $,
	      $$: $,
	      $dom7: $,
	      $app: app,
	      $f7: app,
	      $options: Utils.extend({ id: id }, options),
	      $id: options.id || id,
	    }
	  );
	  var $options = self.$options;

	  // Root data and methods
	  Object.defineProperty(self, '$root', {
	    enumerable: true,
	    configurable: true,
	    get: function get() {
	      var root = Utils.merge({}, app.data, app.methods);
	      if (win && win.Proxy) {
	        root = new win.Proxy(root, {
	          set: function set(target, name, val) {
	            app.data[name] = val;
	          },
	          deleteProperty: function deleteProperty(target, name) {
	            delete app.data[name];
	            delete app.methods[name];
	          },
	          has: function has(target, name) {
	            return (name in app.data || name in app.methods);
	          },
	        });
	      }
	      return root;
	    },
	    set: function set() {},
	  });

	  // Apply context
	  ('beforeCreate created beforeMount mounted beforeDestroy destroyed updated').split(' ').forEach(function (cycleKey) {
	    if ($options[cycleKey]) { $options[cycleKey] = $options[cycleKey].bind(self); }
	  });

	  if ($options.data) {
	    $options.data = $options.data.bind(self);
	    // Data
	    Utils.extend(self, $options.data());
	  }
	  if ($options.render) { $options.render = $options.render.bind(self); }
	  if ($options.methods) {
	    Object.keys($options.methods).forEach(function (methodName) {
	      self[methodName] = $options.methods[methodName].bind(self);
	    });
	  }

	  // Bind Events
	  if ($options.on) {
	    Object.keys($options.on).forEach(function (eventName) {
	      $options.on[eventName] = $options.on[eventName].bind(self);
	    });
	  }
	  if ($options.once) {
	    Object.keys($options.once).forEach(function (eventName) {
	      $options.once[eventName] = $options.once[eventName].bind(self);
	    });
	  }

	  // Before create hook
	  if ($options.beforeCreate) { $options.beforeCreate(); }

	  // Render
	  var html = self.$render();

	  // Make Dom
	  if (html && typeof html === 'string') {
	    html = html.trim();
	    self.$vnode = vdom(html, self, app, true);
	    self.el = doc.createElement('div');
	    patch(self.el, self.$vnode);
	  } else if (html) {
	    self.el = html;
	  }
	  self.$el = $(self.el);

	  // Set styles scope ID
	  if ($options.style) {
	    self.$styleEl = doc.createElement('style');
	    self.$styleEl.innerHTML = $options.style;
	    if ($options.styleScoped) {
	      self.el.setAttribute(("data-f7-" + ($options.id)), '');
	    }
	  }

	  self.$attachEvents();

	  // Created callback
	  if ($options.created) { $options.created(); }

	  // Store component instance
	  self.el.f7Component = self;

	  return self;
	};

	Framework7Component.prototype.$attachEvents = function $attachEvents () {
	  var self = this;
	  var $options = self.$options;
	    var $el = self.$el;
	  if ($options.on) {
	    Object.keys($options.on).forEach(function (eventName) {
	      $el.on(Utils.eventNameToColonCase(eventName), $options.on[eventName]);
	    });
	  }
	  if ($options.once) {
	    Object.keys($options.once).forEach(function (eventName) {
	      $el.once(Utils.eventNameToColonCase(eventName), $options.once[eventName]);
	    });
	  }
	};

	Framework7Component.prototype.$detachEvents = function $detachEvents () {
	  var self = this;
	  var $options = self.$options;
	    var $el = self.$el;
	  if ($options.on) {
	    Object.keys($options.on).forEach(function (eventName) {
	      $el.off(Utils.eventNameToColonCase(eventName), $options.on[eventName]);
	    });
	  }
	  if ($options.once) {
	    Object.keys($options.once).forEach(function (eventName) {
	      $el.off(Utils.eventNameToColonCase(eventName), $options.once[eventName]);
	    });
	  }
	};

	Framework7Component.prototype.$render = function $render () {
	  var self = this;
	  var $options = self.$options;
	  var html = '';
	  if ($options.render) {
	    html = $options.render();
	  } else if ($options.template) {
	    if (typeof $options.template === 'string') {
	      try {
	        html = Template7.compile($options.template)(self);
	      } catch (err) {
	        throw err;
	      }
	    } else {
	      // Supposed to be function
	      html = $options.template(self);
	    }
	  }
	  return html;
	};

	Framework7Component.prototype.$forceUpdate = function $forceUpdate () {
	  var self = this;
	  var html = self.$render();

	  // Make Dom
	  if (html && typeof html === 'string') {
	    html = html.trim();
	    var newVNode = vdom(html, self, self.$app);
	    self.$vnode = patch(self.$vnode, newVNode);
	  }
	};

	Framework7Component.prototype.$setState = function $setState (mergeState) {
	  var self = this;
	  Utils.merge(self, mergeState);
	  self.$forceUpdate();
	};

	Framework7Component.prototype.$mount = function $mount (mountMethod) {
	  var self = this;
	  if (self.$options.beforeMount) { self.$options.beforeMount(); }
	  if (self.$styleEl) { $('head').append(self.$styleEl); }
	  if (mountMethod) { mountMethod(self.el); }
	  if (self.$options.mounted) { self.$options.mounted(); }
	};

	Framework7Component.prototype.$destroy = function $destroy () {
	  var self = this;
	  if (self.$options.beforeDestroy) { self.$options.beforeDestroy(); }
	  if (self.$styleEl) { $(self.$styleEl).remove(); }
	  self.$detachEvents();
	  if (self.$options.destroyed) { self.$options.destroyed(); }
	  // Delete component instance
	  if (self.el && self.el.f7Component) {
	    self.el.f7Component = null;
	    delete self.el.f7Component;
	  }
	  // Patch with empty node
	  if (self.$vnode) {
	    self.$vnode = patch(self.$vnode, { sel: self.$vnode.sel, data: {} });
	  }
	  Utils.deleteProps(self);
	};

	function parseComponent(componentString) {
	  var id = Utils.id();
	  var callbackCreateName = "f7_component_create_callback_" + id;
	  var callbackRenderName = "f7_component_render_callback_" + id;

	  // Template
	  var template;
	  var hasTemplate = componentString.match(/<template([ ]?)([a-z0-9-]*)>/);
	  var templateType = hasTemplate[2] || 't7';
	  if (hasTemplate) {
	    template = componentString
	      .split(/<template[ ]?[a-z0-9-]*>/)
	      .filter(function (item, index) { return index > 0; })
	      .join('<template>')
	      .split('</template>')
	      .filter(function (item, index, arr) { return index < arr.length - 1; })
	      .join('</template>')
	      .replace(/{{#raw}}([ \n]*)<template/g, '{{#raw}}<template')
	      .replace(/\/template>([ \n]*){{\/raw}}/g, '/template>{{/raw}}')
	      .replace(/([ \n])<template/g, '$1{{#raw}}<template')
	      .replace(/\/template>([ \n])/g, '/template>{{/raw}}$1');
	  }

	  // Parse Styles
	  var style = null;
	  var styleScoped = false;

	  if (componentString.indexOf('<style>') >= 0) {
	    style = componentString.split('<style>')[1].split('</style>')[0];
	  } else if (componentString.indexOf('<style scoped>') >= 0) {
	    styleScoped = true;
	    style = componentString.split('<style scoped>')[1].split('</style>')[0];
	    style = style.split('\n').map(function (line) {
	      var trimmedLine = line.trim();
	      if (trimmedLine.indexOf('@') === 0) { return line; }
	      if (line.indexOf('{') >= 0) {
	        if (line.indexOf('{{this}}') >= 0) {
	          return line.replace('{{this}}', ("[data-f7-" + id + "]"));
	        }
	        return ("[data-f7-" + id + "] " + (line.trim()));
	      }
	      return line;
	    }).join('\n');
	  }

	  // Parse Script
	  var scriptContent;
	  var scriptEl;
	  if (componentString.indexOf('<script>') >= 0) {
	    var scripts = componentString.split('<script>');
	    scriptContent = scripts[scripts.length - 1].split('</script>')[0].trim();
	  } else {
	    scriptContent = 'return {}';
	  }
	  if (!scriptContent || !scriptContent.trim()) { scriptContent = 'return {}'; }

	  scriptContent = "window." + callbackCreateName + " = function () {" + scriptContent + "}";

	  // Insert Script El
	  scriptEl = doc.createElement('script');
	  scriptEl.innerHTML = scriptContent;
	  $('head').append(scriptEl);

	  var component = win[callbackCreateName]();

	  // Remove Script El
	  $(scriptEl).remove();
	  win[callbackCreateName] = null;
	  delete win[callbackCreateName];

	  // Assign Template
	  if (!component.template && !component.render) {
	    component.template = template;
	    component.templateType = templateType;
	  }
	  if (component.template) {
	    if (component.templateType === 't7') {
	      component.template = Template7.compile(component.template);
	    }
	    if (component.templateType === 'es') {
	      var renderContent = "window." + callbackRenderName + " = function () {\n        return function render() {\n          return `" + (component.template) + "`;\n        }\n      }";
	      scriptEl = doc.createElement('script');
	      scriptEl.innerHTML = renderContent;
	      $('head').append(scriptEl);

	      component.render = win[callbackRenderName]();

	      // Remove Script El
	      $(scriptEl).remove();
	      win[callbackRenderName] = null;
	      delete win[callbackRenderName];
	    }
	  }

	  // Assign Style
	  if (style) {
	    component.style = style;
	    component.styleScoped = styleScoped;
	  }

	  // Component ID
	  component.id = id;
	  return component;
	}

	var ComponentModule = {
	  name: 'component',
	  create: function create() {
	    var app = this;
	    app.component = {
	      parse: function parse(componentString) {
	        return parseComponent(componentString);
	      },
	      create: function create(options, extendContext) {
	        return new Framework7Component(app, options, extendContext);
	      },
	    };
	  },
	};

	var SW = {
	  registrations: [],
	  register: function register(path, scope) {
	    var app = this;
	    if (!('serviceWorker' in window.navigator) || !app.serviceWorker.container) {
	      return new Promise(function (resolve, reject) {
	        reject(new Error('Service worker is not supported'));
	      });
	    }
	    return new Promise(function (resolve, reject) {
	      app.serviceWorker.container.register(path, (scope ? { scope: scope } : {}))
	        .then(function (reg) {
	          SW.registrations.push(reg);
	          app.emit('serviceWorkerRegisterSuccess', reg);
	          resolve(reg);
	        }).catch(function (error) {
	          app.emit('serviceWorkerRegisterError', error);
	          reject(error);
	        });
	    });
	  },
	  unregister: function unregister(registration) {
	    var app = this;
	    if (!('serviceWorker' in window.navigator) || !app.serviceWorker.container) {
	      return new Promise(function (resolve, reject) {
	        reject(new Error('Service worker is not supported'));
	      });
	    }
	    var registrations;
	    if (!registration) { registrations = SW.registrations; }
	    else if (Array.isArray(registration)) { registrations = registration; }
	    else { registrations = [registration]; }
	    return Promise.all(registrations.map(function (reg) { return new Promise(function (resolve, reject) {
	      reg.unregister()
	        .then(function () {
	          if (SW.registrations.indexOf(reg) >= 0) {
	            SW.registrations.splice(SW.registrations.indexOf(reg), 1);
	          }
	          app.emit('serviceWorkerUnregisterSuccess', reg);
	          resolve();
	        })
	        .catch(function (error) {
	          app.emit('serviceWorkerUnregisterError', reg, error);
	          reject(error);
	        });
	    }); }));
	  },
	};

	var ServiceWorkerModule = {
	  name: 'sw',
	  params: {
	    serviceWorker: {
	      path: undefined,
	      scope: undefined,
	    },
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      serviceWorker: {
	        container: ('serviceWorker' in window.navigator) ? window.navigator.serviceWorker : undefined,
	        registrations: SW.registrations,
	        register: SW.register.bind(app),
	        unregister: SW.unregister.bind(app),
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      if (!('serviceWorker' in window.navigator)) { return; }
	      var app = this;
	      if (!app.serviceWorker.container) { return; }
	      var paths = app.params.serviceWorker.path;
	      var scope = app.params.serviceWorker.scope;
	      if (!paths || (Array.isArray(paths) && !paths.length)) { return; }
	      var toRegister = Array.isArray(paths) ? paths : [paths];
	      toRegister.forEach(function (path) {
	        app.serviceWorker.register(path, scope);
	      });
	    },
	  },
	};

	var Statusbar = {
	  hide: function hide() {
	    $('html').removeClass('with-statusbar');
	    if (Device.cordova && win.StatusBar) {
	      win.StatusBar.hide();
	    }
	  },
	  show: function show() {
	    if (Device.cordova && win.StatusBar) {
	      win.StatusBar.show();
	      Utils.nextTick(function () {
	        if (Device.needsStatusbarOverlay()) {
	          $('html').addClass('with-statusbar');
	        }
	      });
	      return;
	    }
	    $('html').addClass('with-statusbar');
	  },
	  onClick: function onClick() {
	    var app = this;
	    var pageContent;
	    if ($('.popup.modal-in').length > 0) {
	      // Check for opened popup
	      pageContent = $('.popup.modal-in').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
	    } else if ($('.panel.panel-active').length > 0) {
	      // Check for opened panel
	      pageContent = $('.panel.panel-active').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
	    } else if ($('.views > .view.tab-active').length > 0) {
	      // View in tab bar app layout
	      pageContent = $('.views > .view.tab-active').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
	    } else if ($('.views').length > 0) {
	      pageContent = $('.views').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
	    } else {
	      pageContent = app.root.children('.view').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
	    }

	    if (pageContent && pageContent.length > 0) {
	      // Check for tab
	      if (pageContent.hasClass('tab')) {
	        pageContent = pageContent.parent('.tabs').children('.page-content.tab-active');
	      }
	      if (pageContent.length > 0) { pageContent.scrollTop(0, 300); }
	    }
	  },
	  setTextColor: function setTextColor(color) {
	    if (Device.cordova && win.StatusBar) {
	      if (color === 'white') {
	        win.StatusBar.styleLightContent();
	      } else {
	        win.StatusBar.styleDefault();
	      }
	    }
	  },
	  setIosTextColor: function setIosTextColor(color) {
	    if (!Device.ios) { return; }
	    Statusbar.setTextColor(color);
	  },
	  setBackgroundColor: function setBackgroundColor(color) {
	    $('.statusbar').css('background-color', color);
	    if (Device.cordova && win.StatusBar) {
	      win.StatusBar.backgroundColorByHexString(color);
	    }
	  },
	  isVisible: function isVisible() {
	    if (Device.cordova && win.StatusBar) {
	      return win.StatusBar.isVisible;
	    }
	    return false;
	  },
	  overlaysWebView: function overlaysWebView(overlays) {
	    if ( overlays === void 0 ) overlays = true;

	    if (Device.cordova && win.StatusBar) {
	      win.StatusBar.overlaysWebView(overlays);
	      if (overlays) {
	        $('html').addClass('with-statusbar');
	      } else {
	        $('html').removeClass('with-statusbar');
	      }
	    }
	  },
	  checkOverlay: function checkOverlay() {
	    if (Device.needsStatusbarOverlay()) {
	      $('html').addClass('with-statusbar');
	    } else {
	      $('html').removeClass('with-statusbar');
	    }
	  },
	  init: function init() {
	    var app = this;
	    var params = app.params.statusbar;
	    if (!params.enabled) { return; }

	    if (params.overlay === 'auto') {
	      if (Device.needsStatusbarOverlay()) {
	        $('html').addClass('with-statusbar');
	      } else {
	        $('html').removeClass('with-statusbar');
	      }

	      if (Device.ios && (Device.cordova || Device.webView)) {
	        if (win.orientation === 0) {
	          app.once('resize', function () {
	            Statusbar.checkOverlay();
	          });
	        }

	        $(doc).on('resume', function () {
	          Statusbar.checkOverlay();
	        }, false);

	        app.on(Device.ios ? 'orientationchange' : 'orientationchange resize', function () {
	          Statusbar.checkOverlay();
	        });
	      }
	    } else if (params.overlay === true) {
	      $('html').addClass('with-statusbar');
	    } else if (params.overlay === false) {
	      $('html').removeClass('with-statusbar');
	    }

	    if (Device.cordova && win.StatusBar) {
	      if (params.scrollTopOnClick) {
	        $(win).on('statusTap', Statusbar.onClick.bind(app));
	      }
	      if (Device.ios) {
	        if (params.iosOverlaysWebView) {
	          win.StatusBar.overlaysWebView(true);
	        } else {
	          win.StatusBar.overlaysWebView(false);
	        }
	        if (params.iosTextColor === 'white') {
	          win.StatusBar.styleLightContent();
	        } else {
	          win.StatusBar.styleDefault();
	        }
	      }
	      if (Device.android) {
	        if (params.androidOverlaysWebView) {
	          win.StatusBar.overlaysWebView(true);
	        } else {
	          win.StatusBar.overlaysWebView(false);
	        }
	        if (params.androidTextColor === 'white') {
	          win.StatusBar.styleLightContent();
	        } else {
	          win.StatusBar.styleDefault();
	        }
	      }
	    }
	    if (params.iosBackgroundColor && Device.ios) {
	      Statusbar.setBackgroundColor(params.iosBackgroundColor);
	    }
	    if ((params.materialBackgroundColor || params.androidBackgroundColor) && Device.android) {
	      Statusbar.setBackgroundColor(params.materialBackgroundColor || params.androidBackgroundColor);
	    }
	  },
	};

	var Statusbar$1 = {
	  name: 'statusbar',
	  params: {
	    statusbar: {
	      enabled: true,
	      overlay: 'auto',
	      scrollTopOnClick: true,

	      iosOverlaysWebView: true,
	      iosTextColor: 'black',
	      iosBackgroundColor: null,

	      androidOverlaysWebView: false,
	      androidTextColor: 'black',
	      androidBackgroundColor: null,
	    },
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      statusbar: {
	        checkOverlay: Statusbar.checkOverlay,
	        hide: Statusbar.hide,
	        show: Statusbar.show,
	        overlaysWebView: Statusbar.overlaysWebView,
	        setTextColor: Statusbar.setTextColor,
	        setBackgroundColor: Statusbar.setBackgroundColor,
	        isVisible: Statusbar.isVisible,
	        init: Statusbar.init.bind(app),
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      Statusbar.init.call(app);
	    },
	  },
	  clicks: {
	    '.statusbar': function onStatusbarClick() {
	      var app = this;
	      if (!app.params.statusbar.enabled) { return; }
	      if (!app.params.statusbar.scrollTopOnClick) { return; }
	      Statusbar.onClick.call(app);
	    },
	  },
	};

	function getCurrentView(app) {
	  var popoverView = $('.popover.modal-in .view');
	  var popupView = $('.popup.modal-in .view');
	  var panelView = $('.panel.panel-active .view');
	  var appViews = $('.views');
	  if (appViews.length === 0) { appViews = app.root; }
	  // Find active view as tab
	  var appView = appViews.children('.view');
	  // Propably in tabs or split view
	  if (appView.length > 1) {
	    if (appView.hasClass('tab')) {
	      // Tabs
	      appView = appViews.children('.view.tab-active');
	    }
	  }
	  if (popoverView.length > 0 && popoverView[0].f7View) { return popoverView[0].f7View; }
	  if (popupView.length > 0 && popupView[0].f7View) { return popupView[0].f7View; }
	  if (panelView.length > 0 && panelView[0].f7View) { return panelView[0].f7View; }
	  if (appView.length > 0) {
	    if (appView.length === 1 && appView[0].f7View) { return appView[0].f7View; }
	    if (appView.length > 1) {
	      return app.views.main;
	    }
	  }
	  return undefined;
	}

	var View$1 = {
	  name: 'view',
	  params: {
	    view: {
	      name: undefined,
	      main: false,
	      router: true,
	      linksView: null,
	      stackPages: false,
	      xhrCache: true,
	      xhrCacheIgnore: [],
	      xhrCacheIgnoreGetParameters: false,
	      xhrCacheDuration: 1000 * 60 * 10, // Ten minutes
	      preloadPreviousPage: true,
	      allowDuplicateUrls: false,
	      reloadPages: false,
	      reloadDetail: false,
	      masterDetailBreakpoint: 0,
	      removeElements: true,
	      removeElementsWithTimeout: false,
	      removeElementsTimeout: 0,
	      restoreScrollTopOnBack: true,
	      unloadTabContent: true,
	      passRouteQueryToRequest: true,
	      passRouteParamsToRequest: false,
	      // Swipe Back
	      iosSwipeBack: true,
	      iosSwipeBackAnimateShadow: true,
	      iosSwipeBackAnimateOpacity: true,
	      iosSwipeBackActiveArea: 30,
	      iosSwipeBackThreshold: 0,
	      mdSwipeBack: false,
	      mdSwipeBackAnimateShadow: true,
	      mdSwipeBackAnimateOpacity: false,
	      mdSwipeBackActiveArea: 30,
	      mdSwipeBackThreshold: 0,
	      auroraSwipeBack: false,
	      auroraSwipeBackAnimateShadow: false,
	      auroraSwipeBackAnimateOpacity: true,
	      auroraSwipeBackActiveArea: 30,
	      auroraSwipeBackThreshold: 0,
	      // Push State
	      pushState: false,
	      pushStateRoot: undefined,
	      pushStateAnimate: true,
	      pushStateAnimateOnLoad: false,
	      pushStateSeparator: '#!',
	      pushStateOnLoad: true,
	      // Animate Pages
	      animate: true,
	      // iOS Dynamic Navbar
	      iosDynamicNavbar: true,
	      iosSeparateDynamicNavbar: true,
	      // Animate iOS Navbar Back Icon
	      iosAnimateNavbarBackIcon: true,
	      // Delays
	      iosPageLoadDelay: 0,
	      mdPageLoadDelay: 0,
	      auroraPageLoadDelay: 0,
	      // Routes hooks
	      routesBeforeEnter: null,
	      routesBeforeLeave: null,
	    },
	  },
	  static: {
	    View: View,
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      views: Utils.extend([], {
	        create: function create(el, params) {
	          return new View(app, el, params);
	        },
	        get: function get(viewEl) {
	          var $viewEl = $(viewEl);
	          if ($viewEl.length && $viewEl[0].f7View) { return $viewEl[0].f7View; }
	          return undefined;
	        },
	      }),
	    });
	    Object.defineProperty(app.views, 'current', {
	      enumerable: true,
	      configurable: true,
	      get: function get() {
	        return getCurrentView(app);
	      },
	    });
	    // Alias
	    app.view = app.views;
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      $('.view-init').each(function (index, viewEl) {
	        if (viewEl.f7View) { return; }
	        var viewParams = $(viewEl).dataset();
	        app.views.create(viewEl, viewParams);
	      });
	    },
	    modalOpen: function modalOpen(modal) {
	      var app = this;
	      modal.$el.find('.view-init').each(function (index, viewEl) {
	        if (viewEl.f7View) { return; }
	        var viewParams = $(viewEl).dataset();
	        app.views.create(viewEl, viewParams);
	      });
	    },
	    modalBeforeDestroy: function modalBeforeDestroy(modal) {
	      if (!modal || !modal.$el) { return; }
	      modal.$el.find('.view-init').each(function (index, viewEl) {
	        var view = viewEl.f7View;
	        if (!view) { return; }
	        view.destroy();
	      });
	    },
	  },
	};

	var Navbar = {
	  size: function size(el) {
	    var app = this;
	    if (app.theme !== 'ios' && !app.params.navbar[((app.theme) + "CenterTitle")]) {
	      return;
	    }
	    var $el = $(el);
	    if ($el.hasClass('navbar')) {
	      $el = $el.children('.navbar-inner').each(function (index, navbarEl) {
	        app.navbar.size(navbarEl);
	      });
	      return;
	    }

	    if (
	      $el.hasClass('stacked')
	      || $el.parents('.stacked').length > 0
	      || $el.parents('.tab:not(.tab-active)').length > 0
	      || $el.parents('.popup:not(.modal-in)').length > 0
	    ) {
	      return;
	    }

	    if (app.theme !== 'ios' && app.params.navbar[((app.theme) + "CenterTitle")]) {
	      $el.addClass('navbar-inner-centered-title');
	    }
	    if (app.theme === 'ios' && !app.params.navbar.iosCenterTitle) {
	      $el.addClass('navbar-inner-left-title');
	    }

	    var $viewEl = $el.parents('.view').eq(0);
	    var left = app.rtl ? $el.children('.right') : $el.children('.left');
	    var right = app.rtl ? $el.children('.left') : $el.children('.right');
	    var title = $el.children('.title');
	    var subnavbar = $el.children('.subnavbar');
	    var noLeft = left.length === 0;
	    var noRight = right.length === 0;
	    var leftWidth = noLeft ? 0 : left.outerWidth(true);
	    var rightWidth = noRight ? 0 : right.outerWidth(true);
	    var titleWidth = title.outerWidth(true);
	    var navbarStyles = $el.styles();
	    var navbarWidth = $el[0].offsetWidth;
	    var navbarInnerWidth = navbarWidth - parseInt(navbarStyles.paddingLeft, 10) - parseInt(navbarStyles.paddingRight, 10);
	    var isPrevious = $el.hasClass('navbar-previous');
	    var sliding = $el.hasClass('sliding');

	    var router;
	    var dynamicNavbar;
	    var separateNavbar;
	    var separateNavbarRightOffset = 0;
	    var separateNavbarLeftOffset = 0;

	    if ($viewEl.length > 0 && $viewEl[0].f7View) {
	      router = $viewEl[0].f7View.router;
	      dynamicNavbar = router && router.dynamicNavbar;
	      separateNavbar = router && router.separateNavbar;
	      if (!separateNavbar) {
	        separateNavbarRightOffset = navbarWidth;
	        separateNavbarLeftOffset = navbarWidth / 5;
	      }
	    }

	    var currLeft;
	    var diff;
	    if (noRight) {
	      currLeft = navbarInnerWidth - titleWidth;
	    }
	    if (noLeft) {
	      currLeft = 0;
	    }
	    if (!noLeft && !noRight) {
	      currLeft = ((navbarInnerWidth - rightWidth - titleWidth) + leftWidth) / 2;
	    }
	    var requiredLeft = (navbarInnerWidth - titleWidth) / 2;
	    if (navbarInnerWidth - leftWidth - rightWidth > titleWidth) {
	      if (requiredLeft < leftWidth) {
	        requiredLeft = leftWidth;
	      }
	      if (requiredLeft + titleWidth > navbarInnerWidth - rightWidth) {
	        requiredLeft = navbarInnerWidth - rightWidth - titleWidth;
	      }
	      diff = requiredLeft - currLeft;
	    } else {
	      diff = 0;
	    }

	    // RTL inverter
	    var inverter = app.rtl ? -1 : 1;

	    if (dynamicNavbar && app.theme === 'ios') {
	      if (title.hasClass('sliding') || (title.length > 0 && sliding)) {
	        var titleLeftOffset = (-(currLeft + diff) * inverter) + separateNavbarLeftOffset;
	        var titleRightOffset = ((navbarInnerWidth - currLeft - diff - titleWidth) * inverter) - separateNavbarRightOffset;

	        if (isPrevious) {
	          if (router && router.params.iosAnimateNavbarBackIcon) {
	            var activeNavbarBackLink = $el.parent().find('.navbar-current').children('.left.sliding').find('.back .icon ~ span');
	            if (activeNavbarBackLink.length > 0) {
	              titleLeftOffset += activeNavbarBackLink[0].offsetLeft;
	            }
	          }
	        }
	        title[0].f7NavbarLeftOffset = titleLeftOffset;
	        title[0].f7NavbarRightOffset = titleRightOffset;
	      }
	      if (!noLeft && (left.hasClass('sliding') || sliding)) {
	        if (app.rtl) {
	          left[0].f7NavbarLeftOffset = (-(navbarInnerWidth - left[0].offsetWidth) / 2) * inverter;
	          left[0].f7NavbarRightOffset = leftWidth * inverter;
	        } else {
	          left[0].f7NavbarLeftOffset = -leftWidth + separateNavbarLeftOffset;
	          left[0].f7NavbarRightOffset = ((navbarInnerWidth - left[0].offsetWidth) / 2) - separateNavbarRightOffset;
	          if (router && router.params.iosAnimateNavbarBackIcon && left.find('.back .icon').length > 0) {
	            if (left.find('.back .icon ~ span').length) {
	              var leftOffset = left[0].f7NavbarLeftOffset;
	              var rightOffset = left[0].f7NavbarRightOffset;
	              left[0].f7NavbarLeftOffset = 0;
	              left[0].f7NavbarRightOffset = 0;
	              left.find('.back .icon ~ span')[0].f7NavbarLeftOffset = leftOffset;
	              left.find('.back .icon ~ span')[0].f7NavbarRightOffset = rightOffset - left.find('.back .icon')[0].offsetWidth;
	            }
	          }
	        }
	      }
	      if (!noRight && (right.hasClass('sliding') || sliding)) {
	        if (app.rtl) {
	          right[0].f7NavbarLeftOffset = -rightWidth * inverter;
	          right[0].f7NavbarRightOffset = ((navbarInnerWidth - right[0].offsetWidth) / 2) * inverter;
	        } else {
	          right[0].f7NavbarLeftOffset = (-(navbarInnerWidth - right[0].offsetWidth) / 2) + separateNavbarLeftOffset;
	          right[0].f7NavbarRightOffset = rightWidth - separateNavbarRightOffset;
	        }
	      }
	      if (subnavbar.length && (subnavbar.hasClass('sliding') || sliding)) {
	        subnavbar[0].f7NavbarLeftOffset = app.rtl ? subnavbar[0].offsetWidth : (-subnavbar[0].offsetWidth + separateNavbarLeftOffset);
	        subnavbar[0].f7NavbarRightOffset = (-subnavbar[0].f7NavbarLeftOffset - separateNavbarRightOffset) + separateNavbarLeftOffset;
	      }
	    }

	    // Center title
	    if (app.params.navbar[((app.theme) + "CenterTitle")]) {
	      var titleLeft = diff;
	      if (app.rtl && noLeft && noRight && title.length > 0) { titleLeft = -titleLeft; }
	      title.css({ left: (titleLeft + "px") });
	    }
	  },
	  hide: function hide(el, animate) {
	    if ( animate === void 0 ) animate = true;

	    var app = this;
	    var $el = $(el);
	    if ($el.hasClass('navbar-inner')) { $el = $el.parents('.navbar'); }
	    if (!$el.length) { return; }
	    if ($el.hasClass('navbar-hidden')) { return; }
	    var className = "navbar-hidden" + (animate ? ' navbar-transitioning' : '');
	    var currentIsLarge = app.theme === 'ios'
	      ? $el.find('.navbar-current .title-large').length
	      : $el.find('.title-large').length;
	    if (currentIsLarge) {
	      className += ' navbar-large-hidden';
	    }
	    $el.transitionEnd(function () {
	      $el.removeClass('navbar-transitioning');
	    });
	    $el.addClass(className);
	    $el.trigger('navbar:hide');
	    app.emit('navbarHide', $el[0]);
	  },
	  show: function show(el, animate) {
	    if ( el === void 0 ) el = '.navbar-hidden';
	    if ( animate === void 0 ) animate = true;

	    var app = this;
	    var $el = $(el);
	    if ($el.hasClass('navbar-inner')) { $el = $el.parents('.navbar'); }
	    if (!$el.length) { return; }
	    if (!$el.hasClass('navbar-hidden')) { return; }
	    if (animate) {
	      $el.addClass('navbar-transitioning');
	      $el.transitionEnd(function () {
	        $el.removeClass('navbar-transitioning');
	      });
	    }
	    $el.removeClass('navbar-hidden navbar-large-hidden');
	    $el.trigger('navbar:show');
	    app.emit('navbarShow', $el[0]);
	  },
	  getElByPage: function getElByPage(page) {
	    var $pageEl;
	    var $navbarInnerEl;
	    var pageData;
	    if (page.$navbarEl || page.$el) {
	      pageData = page;
	      $pageEl = page.$el;
	    } else {
	      $pageEl = $(page);
	      if ($pageEl.length > 0) { pageData = $pageEl[0].f7Page; }
	    }
	    if (pageData && pageData.$navbarEl && pageData.$navbarEl.length > 0) {
	      $navbarInnerEl = pageData.$navbarEl;
	    } else if ($pageEl) {
	      $navbarInnerEl = $pageEl.children('.navbar').children('.navbar-inner');
	    }
	    if (!$navbarInnerEl || ($navbarInnerEl && $navbarInnerEl.length === 0)) { return undefined; }
	    return $navbarInnerEl[0];
	  },
	  getPageByEl: function getPageByEl(navbarInnerEl) {
	    var $navbarInnerEl = $(navbarInnerEl);
	    if ($navbarInnerEl.hasClass('navbar')) {
	      $navbarInnerEl = $navbarInnerEl.find('.navbar-inner');
	      if ($navbarInnerEl.length > 1) { return undefined; }
	    }
	    if ($navbarInnerEl.parents('.page').length) {
	      return $navbarInnerEl.parents('.page')[0];
	    }
	    var pageEl;
	    $navbarInnerEl.parents('.view').find('.page').each(function (index, el) {
	      if (el && el.f7Page && el.f7Page.navbarEl && $navbarInnerEl[0] === el.f7Page.navbarEl) {
	        pageEl = el;
	      }
	    });
	    return pageEl;
	  },

	  collapseLargeTitle: function collapseLargeTitle(navbarInnerEl) {
	    var app = this;
	    var $navbarInnerEl = $(navbarInnerEl);
	    if ($navbarInnerEl.hasClass('navbar')) {
	      $navbarInnerEl = $navbarInnerEl.find('.navbar-inner-large');
	      if ($navbarInnerEl.length > 1) {
	        $navbarInnerEl = $(navbarInnerEl).find('.navbar-inner-large.navbar-current');
	      }
	      if ($navbarInnerEl.length > 1 || !$navbarInnerEl.length) {
	        return;
	      }
	    }
	    var $pageEl = $(app.navbar.getPageByEl($navbarInnerEl));
	    $navbarInnerEl.addClass('navbar-inner-large-collapsed');
	    $pageEl.eq(0).addClass('page-with-navbar-large-collapsed').trigger('page:navbarlargecollapsed');
	    var $navbarEl = $navbarInnerEl.parents('.navbar');
	    if (app.theme === 'md' || app.theme === 'aurora') {
	      $navbarEl.addClass('navbar-large-collapsed');
	    }
	    $navbarEl.trigger('navbar:collapse');
	    app.emit('navbarCollapse', $navbarEl[0]);
	  },
	  expandLargeTitle: function expandLargeTitle(navbarInnerEl) {
	    var app = this;
	    var $navbarInnerEl = $(navbarInnerEl);
	    if ($navbarInnerEl.hasClass('navbar')) {
	      $navbarInnerEl = $navbarInnerEl.find('.navbar-inner-large');
	      if ($navbarInnerEl.length > 1) {
	        $navbarInnerEl = $(navbarInnerEl).find('.navbar-inner-large.navbar-current');
	      }
	      if ($navbarInnerEl.length > 1 || !$navbarInnerEl.length) {
	        return;
	      }
	    }
	    var $pageEl = $(app.navbar.getPageByEl($navbarInnerEl));
	    $navbarInnerEl.removeClass('navbar-inner-large-collapsed');
	    $pageEl.eq(0).removeClass('page-with-navbar-large-collapsed').trigger('page:navbarlargeexpanded');
	    var $navbarEl = $navbarInnerEl.parents('.navbar');
	    if (app.theme === 'md' || app.theme === 'aurora') {
	      $navbarEl.removeClass('navbar-large-collapsed');
	    }
	    $navbarEl.trigger('navbar:expand');
	    app.emit('navbarExpand', $navbarEl[0]);
	  },
	  toggleLargeTitle: function toggleLargeTitle(navbarInnerEl) {
	    var app = this;
	    var $navbarInnerEl = $(navbarInnerEl);
	    if ($navbarInnerEl.hasClass('navbar')) {
	      $navbarInnerEl = $navbarInnerEl.find('.navbar-inner-large');
	      if ($navbarInnerEl.length > 1) {
	        $navbarInnerEl = $(navbarInnerEl).find('.navbar-inner-large.navbar-current');
	      }
	      if ($navbarInnerEl.length > 1 || !$navbarInnerEl.length) {
	        return;
	      }
	    }
	    if ($navbarInnerEl.hasClass('navbar-inner-large-collapsed')) {
	      app.navbar.expandLargeTitle($navbarInnerEl);
	    } else {
	      app.navbar.collapseLargeTitle($navbarInnerEl);
	    }
	  },
	  initNavbarOnScroll: function initNavbarOnScroll(pageEl, navbarInnerEl, needHide, needCollapse) {
	    var app = this;
	    var $pageEl = $(pageEl);
	    var $navbarInnerEl = $(navbarInnerEl);
	    var $navbarEl = app.theme === 'md' || app.theme === 'aurora'
	      ? $navbarInnerEl.parents('.navbar')
	      : $(navbarInnerEl || app.navbar.getElByPage(pageEl)).closest('.navbar');
	    var isLarge = $navbarInnerEl.find('.title-large').length || $navbarInnerEl.hasClass('.navbar-inner-large');
	    var navbarHideHeight = 44;
	    var snapPageScrollToLargeTitle = app.params.navbar.snapPageScrollToLargeTitle;

	    var previousScrollTop;
	    var currentScrollTop;

	    var scrollHeight;
	    var offsetHeight;
	    var reachEnd;
	    var action;
	    var navbarHidden;

	    var navbarCollapsed;
	    var navbarTitleLargeHeight;
	    if (needCollapse || (needHide && isLarge)) {
	      navbarTitleLargeHeight = $navbarInnerEl.css('--f7-navbar-large-title-height');
	      if (navbarTitleLargeHeight && navbarTitleLargeHeight.indexOf('px') >= 0) {
	        navbarTitleLargeHeight = parseInt(navbarTitleLargeHeight, 10);
	        if (Number.isNaN(navbarTitleLargeHeight)) {
	          if (app.theme === 'ios') { navbarTitleLargeHeight = 52; }
	          else if (app.theme === 'md') { navbarTitleLargeHeight = 48; }
	          else if (app.theme === 'aurora') { navbarTitleLargeHeight = 38; }
	        }
	      } else { // eslint-disable-next-line
	        if (app.theme === 'ios') { navbarTitleLargeHeight = 52; }
	        else if (app.theme === 'md') { navbarTitleLargeHeight = 48; }
	        else if (app.theme === 'aurora') { navbarTitleLargeHeight = 38; }
	      }
	    }
	    if (needHide && isLarge) {
	      navbarHideHeight += navbarTitleLargeHeight;
	    }

	    var scrollChanged;
	    var scrollContent;
	    var scrollTimeoutId;
	    var touchEndTimeoutId;
	    var touchSnapTimeout = 70;
	    var desktopSnapTimeout = 300;

	    function snapLargeNavbar() {
	      var inSearchbarExpanded = $navbarInnerEl.hasClass('with-searchbar-expandable-enabled');
	      if (inSearchbarExpanded) { return; }
	      if (!scrollContent || currentScrollTop < 0) { return; }
	      if (currentScrollTop >= navbarTitleLargeHeight / 2 && currentScrollTop < navbarTitleLargeHeight) {
	        $(scrollContent).scrollTop(navbarTitleLargeHeight, 100);
	      } else if (currentScrollTop < navbarTitleLargeHeight) {
	        $(scrollContent).scrollTop(0, 200);
	      }
	    }

	    function handleLargeNavbarCollapse() {
	      var collapseProgress = Math.min(Math.max((currentScrollTop / navbarTitleLargeHeight), 0), 1);
	      var inSearchbarExpanded = $navbarInnerEl.hasClass('with-searchbar-expandable-enabled');
	      if (inSearchbarExpanded) { return; }
	      navbarCollapsed = $navbarInnerEl.hasClass('navbar-inner-large-collapsed');
	      if (collapseProgress === 0 && navbarCollapsed) {
	        app.navbar.expandLargeTitle($navbarInnerEl[0]);
	        $navbarInnerEl[0].style.removeProperty('--f7-navbar-large-collapse-progress');
	        $pageEl[0].style.removeProperty('--f7-navbar-large-collapse-progress');
	        $navbarInnerEl[0].style.overflow = '';
	        if (app.theme === 'md' || app.theme === 'aurora') {
	          $navbarEl[0].style.removeProperty('--f7-navbar-large-collapse-progress');
	        }
	      } else if (collapseProgress === 1 && !navbarCollapsed) {
	        app.navbar.collapseLargeTitle($navbarInnerEl[0]);
	        $navbarInnerEl[0].style.removeProperty('--f7-navbar-large-collapse-progress');
	        $navbarInnerEl[0].style.overflow = '';
	        $pageEl[0].style.removeProperty('--f7-navbar-large-collapse-progress');
	        if (app.theme === 'md' || app.theme === 'aurora') {
	          $navbarEl[0].style.removeProperty('--f7-navbar-large-collapse-progress');
	        }
	      } else if ((collapseProgress === 1 && navbarCollapsed) || (collapseProgress === 0 && !navbarCollapsed)) {
	        $navbarInnerEl[0].style.removeProperty('--f7-navbar-large-collapse-progress');
	        $navbarInnerEl[0].style.overflow = '';
	        $pageEl[0].style.removeProperty('--f7-navbar-large-collapse-progress');
	        if (app.theme === 'md' || app.theme === 'aurora') {
	          $navbarEl[0].style.removeProperty('--f7-navbar-large-collapse-progress');
	        }
	      } else {
	        $navbarInnerEl[0].style.setProperty('--f7-navbar-large-collapse-progress', collapseProgress);
	        $navbarInnerEl[0].style.overflow = 'visible';
	        $pageEl[0].style.setProperty('--f7-navbar-large-collapse-progress', collapseProgress);
	        if (app.theme === 'md' || app.theme === 'aurora') {
	          $navbarEl[0].style.setProperty('--f7-navbar-large-collapse-progress', collapseProgress);
	        }
	      }

	      if (snapPageScrollToLargeTitle) {
	        if (!Support.touch) {
	          clearTimeout(scrollTimeoutId);
	          scrollTimeoutId = setTimeout(function () {
	            snapLargeNavbar();
	          }, desktopSnapTimeout);
	        } else if (touchEndTimeoutId) {
	          clearTimeout(touchEndTimeoutId);
	          touchEndTimeoutId = null;
	          touchEndTimeoutId = setTimeout(function () {
	            snapLargeNavbar();
	            clearTimeout(touchEndTimeoutId);
	            touchEndTimeoutId = null;
	          }, touchSnapTimeout);
	        }
	      }
	    }

	    function handleTitleHideShow() {
	      scrollHeight = scrollContent.scrollHeight;
	      offsetHeight = scrollContent.offsetHeight;
	      reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
	      navbarHidden = $navbarEl.hasClass('navbar-hidden');

	      if (reachEnd) {
	        if (app.params.navbar.showOnPageScrollEnd) {
	          action = 'show';
	        }
	      } else if (previousScrollTop > currentScrollTop) {
	        if (app.params.navbar.showOnPageScrollTop || currentScrollTop <= navbarHideHeight) {
	          action = 'show';
	        } else {
	          action = 'hide';
	        }
	      } else if (currentScrollTop > navbarHideHeight) {
	        action = 'hide';
	      } else {
	        action = 'show';
	      }

	      if (action === 'show' && navbarHidden) {
	        app.navbar.show($navbarEl);
	        navbarHidden = false;
	      } else if (action === 'hide' && !navbarHidden) {
	        app.navbar.hide($navbarEl);
	        navbarHidden = true;
	      }
	      previousScrollTop = currentScrollTop;
	    }

	    function handleScroll() {
	      scrollContent = this;
	      currentScrollTop = scrollContent.scrollTop;
	      scrollChanged = currentScrollTop;

	      if (needCollapse) {
	        handleLargeNavbarCollapse();
	      }
	      if ($pageEl.hasClass('page-previous')) { return; }
	      if (needHide) {
	        handleTitleHideShow();
	      }
	    }
	    function handeTouchStart() {
	      scrollChanged = false;
	    }
	    function handleTouchEnd() {
	      clearTimeout(touchEndTimeoutId);
	      touchEndTimeoutId = null;
	      touchEndTimeoutId = setTimeout(function () {
	        if (scrollChanged !== false) {
	          snapLargeNavbar();
	          clearTimeout(touchEndTimeoutId);
	          touchEndTimeoutId = null;
	        }
	      }, touchSnapTimeout);
	    }
	    $pageEl.on('scroll', '.page-content', handleScroll, true);
	    if (Support.touch && needCollapse && snapPageScrollToLargeTitle) {
	      app.on('touchstart:passive', handeTouchStart);
	      app.on('touchend:passive', handleTouchEnd);
	    }
	    if (needCollapse) {
	      $pageEl.find('.page-content').each(function (pageContentIndex, pageContentEl) {
	        if (pageContentEl.scrollTop > 0) { handleScroll.call(pageContentEl); }
	      });
	    }
	    $pageEl[0].f7DetachNavbarScrollHandlers = function f7DetachNavbarScrollHandlers() {
	      delete $pageEl[0].f7DetachNavbarScrollHandlers;
	      $pageEl.off('scroll', '.page-content', handleScroll, true);
	      if (Support.touch && needCollapse && snapPageScrollToLargeTitle) {
	        app.off('touchstart:passive', handeTouchStart);
	        app.off('touchend:passive', handleTouchEnd);
	      }
	    };
	  },
	};
	var Navbar$1 = {
	  name: 'navbar',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      navbar: {
	        size: Navbar.size.bind(app),
	        hide: Navbar.hide.bind(app),
	        show: Navbar.show.bind(app),
	        getElByPage: Navbar.getElByPage.bind(app),
	        getPageByEl: Navbar.getPageByEl.bind(app),
	        collapseLargeTitle: Navbar.collapseLargeTitle.bind(app),
	        expandLargeTitle: Navbar.expandLargeTitle.bind(app),
	        toggleLargeTitle: Navbar.toggleLargeTitle.bind(app),
	        initNavbarOnScroll: Navbar.initNavbarOnScroll.bind(app),
	      },
	    });
	  },
	  params: {
	    navbar: {
	      scrollTopOnTitleClick: true,
	      iosCenterTitle: true,
	      mdCenterTitle: false,
	      auroraCenterTitle: true,
	      hideOnPageScroll: false,
	      showOnPageScrollEnd: true,
	      showOnPageScrollTop: true,
	      collapseLargeTitleOnScroll: true,
	      snapPageScrollToLargeTitle: true,
	    },
	  },
	  on: {
	    'panelBreakpoint panelResize resize viewMasterDetailBreakpoint': function onResize() {
	      var app = this;
	      $('.navbar').each(function (index, navbarEl) {
	        app.navbar.size(navbarEl);
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      if (page.$el[0].f7DetachNavbarScrollHandlers) {
	        page.$el[0].f7DetachNavbarScrollHandlers();
	      }
	    },
	    pageBeforeIn: function pageBeforeIn(page) {
	      var app = this;
	      if (app.theme !== 'ios') { return; }
	      var $navbarEl;
	      var view = page.$el.parents('.view')[0].f7View;
	      var navbarInnerEl = app.navbar.getElByPage(page);
	      if (!navbarInnerEl) {
	        $navbarEl = page.$el.parents('.view').children('.navbar');
	      } else {
	        $navbarEl = $(navbarInnerEl).parents('.navbar');
	      }
	      if (page.$el.hasClass('no-navbar') || (view.router.dynamicNavbar && !navbarInnerEl)) {
	        var animate = !!(page.pageFrom && page.router.history.length > 0);
	        app.navbar.hide($navbarEl, animate);
	      } else {
	        app.navbar.show($navbarEl);
	      }
	    },
	    pageReinit: function pageReinit(page) {
	      var app = this;
	      var $navbarInnerEl = $(app.navbar.getElByPage(page));
	      if (!$navbarInnerEl || $navbarInnerEl.length === 0) { return; }
	      app.navbar.size($navbarInnerEl);
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      var $navbarInnerEl = $(app.navbar.getElByPage(page));
	      if (!$navbarInnerEl || $navbarInnerEl.length === 0) { return; }

	      // Size
	      app.navbar.size($navbarInnerEl);

	      // Need Collapse On Scroll
	      var needCollapseOnScrollHandler;
	      if ($navbarInnerEl.children('.title-large').length > 0) {
	        $navbarInnerEl.addClass('navbar-inner-large');
	      }
	      if ($navbarInnerEl.hasClass('navbar-inner-large')) {
	        if (app.params.navbar.collapseLargeTitleOnScroll) { needCollapseOnScrollHandler = true; }
	        if (app.theme === 'md' || app.theme === 'aurora') {
	          $navbarInnerEl.parents('.navbar').addClass('navbar-large');
	        }
	        page.$el.addClass('page-with-navbar-large');
	      }

	      // Need Hide On Scroll
	      var needHideOnScrollHandler;
	      if (
	        app.params.navbar.hideOnPageScroll
	        || page.$el.find('.hide-navbar-on-scroll').length
	        || page.$el.hasClass('hide-navbar-on-scroll')
	        || page.$el.find('.hide-bars-on-scroll').length
	        || page.$el.hasClass('hide-bars-on-scroll')
	      ) {
	        if (
	          page.$el.find('.keep-navbar-on-scroll').length
	          || page.$el.hasClass('keep-navbar-on-scroll')
	          || page.$el.find('.keep-bars-on-scroll').length
	          || page.$el.hasClass('keep-bars-on-scroll')
	        ) {
	          needHideOnScrollHandler = false;
	        } else {
	          needHideOnScrollHandler = true;
	        }
	      }

	      if (needCollapseOnScrollHandler || needHideOnScrollHandler) {
	        app.navbar.initNavbarOnScroll(page.el, $navbarInnerEl[0], needHideOnScrollHandler, needCollapseOnScrollHandler);
	      }
	    },
	    modalOpen: function modalOpen(modal) {
	      var app = this;
	      if (!app.params.navbar[((app.theme) + "CenterTitle")]) {
	        return;
	      }
	      modal.$el.find('.navbar:not(.navbar-previous):not(.stacked)').each(function (index, navbarEl) {
	        app.navbar.size(navbarEl);
	      });
	    },
	    panelOpen: function panelOpen(panel) {
	      var app = this;
	      if (!app.params.navbar[((app.theme) + "CenterTitle")]) {
	        return;
	      }
	      panel.$el.find('.navbar:not(.navbar-previous):not(.stacked)').each(function (index, navbarEl) {
	        app.navbar.size(navbarEl);
	      });
	    },
	    panelSwipeOpen: function panelSwipeOpen(panel) {
	      var app = this;
	      if (!app.params.navbar[((app.theme) + "CenterTitle")]) {
	        return;
	      }
	      panel.$el.find('.navbar:not(.navbar-previous):not(.stacked)').each(function (index, navbarEl) {
	        app.navbar.size(navbarEl);
	      });
	    },
	    tabShow: function tabShow(tabEl) {
	      var app = this;
	      if (!app.params.navbar[((app.theme) + "CenterTitle")]) {
	        return;
	      }
	      $(tabEl).find('.navbar:not(.navbar-previous):not(.stacked)').each(function (index, navbarEl) {
	        app.navbar.size(navbarEl);
	      });
	    },
	  },
	  clicks: {
	    '.navbar .title': function onTitleClick($clickedEl) {
	      var app = this;
	      if (!app.params.navbar.scrollTopOnTitleClick) { return; }
	      if ($clickedEl.closest('a').length > 0) {
	        return;
	      }
	      var pageContent;
	      // Find active page
	      var navbar = $clickedEl.parents('.navbar');

	      // Static Layout
	      pageContent = navbar.parents('.page-content');

	      if (pageContent.length === 0) {
	        // Fixed Layout
	        if (navbar.parents('.page').length > 0) {
	          pageContent = navbar.parents('.page').find('.page-content');
	        }
	        // Through Layout
	        if (pageContent.length === 0) {
	          if (navbar.nextAll('.page-current:not(.stacked)').length > 0) {
	            pageContent = navbar.nextAll('.page-current:not(.stacked)').find('.page-content');
	          }
	        }
	      }
	      if (pageContent && pageContent.length > 0) {
	        // Check for tab
	        if (pageContent.hasClass('tab')) {
	          pageContent = pageContent.parent('.tabs').children('.page-content.tab-active');
	        }
	        if (pageContent.length > 0) { pageContent.scrollTop(0, 300); }
	      }
	    },
	  },
	  vnode: {
	    'navbar-inner': {
	      postpatch: function postpatch(vnode) {
	        var app = this;
	        if (!app.params.navbar[((app.theme) + "CenterTitle")]) {
	          return;
	        }
	        app.navbar.size(vnode.elm);
	      },
	    },
	  },
	};

	var Toolbar = {
	  setHighlight: function setHighlight(tabbarEl) {
	    var app = this;
	    if (app.theme !== 'md') { return; }

	    var $tabbarEl = $(tabbarEl);

	    if ($tabbarEl.length === 0 || !($tabbarEl.hasClass('tabbar') || $tabbarEl.hasClass('tabbar-labels'))) { return; }

	    var $highlightEl = $tabbarEl.find('.tab-link-highlight');
	    var tabLinksCount = $tabbarEl.find('.tab-link').length;
	    if (tabLinksCount === 0) {
	      $highlightEl.remove();
	      return;
	    }

	    if ($highlightEl.length === 0) {
	      $tabbarEl.children('.toolbar-inner').append('<span class="tab-link-highlight"></span>');
	      $highlightEl = $tabbarEl.find('.tab-link-highlight');
	    } else if ($highlightEl.next().length) {
	      $tabbarEl.children('.toolbar-inner').append($highlightEl);
	    }

	    var $activeLink = $tabbarEl.find('.tab-link-active');
	    var highlightWidth;
	    var highlightTranslate;

	    if ($tabbarEl.hasClass('tabbar-scrollable') && $activeLink && $activeLink[0]) {
	      highlightWidth = ($activeLink[0].offsetWidth) + "px";
	      highlightTranslate = ($activeLink[0].offsetLeft) + "px";
	    } else {
	      var activeIndex = $activeLink.index();
	      highlightWidth = (100 / tabLinksCount) + "%";
	      highlightTranslate = ((app.rtl ? -activeIndex : activeIndex) * 100) + "%";
	    }

	    Utils.nextFrame(function () {
	      $highlightEl
	        .css('width', highlightWidth)
	        .transform(("translate3d(" + highlightTranslate + ",0,0)"));
	    });
	  },
	  init: function init(tabbarEl) {
	    var app = this;
	    app.toolbar.setHighlight(tabbarEl);
	  },
	  hide: function hide(el, animate) {
	    if ( animate === void 0 ) animate = true;

	    var $el = $(el);
	    if ($el.hasClass('toolbar-hidden')) { return; }
	    var className = "toolbar-hidden" + (animate ? ' toolbar-transitioning' : '');
	    $el.transitionEnd(function () {
	      $el.removeClass('toolbar-transitioning');
	    });
	    $el.addClass(className);
	  },
	  show: function show(el, animate) {
	    if ( animate === void 0 ) animate = true;

	    var $el = $(el);
	    if (!$el.hasClass('toolbar-hidden')) { return; }
	    if (animate) {
	      $el.addClass('toolbar-transitioning');
	      $el.transitionEnd(function () {
	        $el.removeClass('toolbar-transitioning');
	      });
	    }
	    $el.removeClass('toolbar-hidden');
	  },
	  initHideToolbarOnScroll: function initHideToolbarOnScroll(pageEl) {
	    var app = this;
	    var $pageEl = $(pageEl);
	    var $toolbarEl = $pageEl.parents('.view').children('.toolbar');
	    if ($toolbarEl.length === 0) {
	      $toolbarEl = $pageEl.find('.toolbar');
	    }
	    if ($toolbarEl.length === 0) {
	      $toolbarEl = $pageEl.parents('.views').children('.tabbar, .tabbar-labels');
	    }
	    if ($toolbarEl.length === 0) {
	      return;
	    }

	    var previousScrollTop;
	    var currentScrollTop;

	    var scrollHeight;
	    var offsetHeight;
	    var reachEnd;
	    var action;
	    var toolbarHidden;
	    function handleScroll() {
	      var scrollContent = this;
	      if ($pageEl.hasClass('page-previous')) { return; }
	      currentScrollTop = scrollContent.scrollTop;
	      scrollHeight = scrollContent.scrollHeight;
	      offsetHeight = scrollContent.offsetHeight;
	      reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
	      toolbarHidden = $toolbarEl.hasClass('toolbar-hidden');

	      if (reachEnd) {
	        if (app.params.toolbar.showOnPageScrollEnd) {
	          action = 'show';
	        }
	      } else if (previousScrollTop > currentScrollTop) {
	        if (app.params.toolbar.showOnPageScrollTop || currentScrollTop <= 44) {
	          action = 'show';
	        } else {
	          action = 'hide';
	        }
	      } else if (currentScrollTop > 44) {
	        action = 'hide';
	      } else {
	        action = 'show';
	      }

	      if (action === 'show' && toolbarHidden) {
	        app.toolbar.show($toolbarEl);
	        toolbarHidden = false;
	      } else if (action === 'hide' && !toolbarHidden) {
	        app.toolbar.hide($toolbarEl);
	        toolbarHidden = true;
	      }

	      previousScrollTop = currentScrollTop;
	    }
	    $pageEl.on('scroll', '.page-content', handleScroll, true);
	    $pageEl[0].f7ScrollToolbarHandler = handleScroll;
	  },
	};
	var Toolbar$1 = {
	  name: 'toolbar',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      toolbar: {
	        hide: Toolbar.hide.bind(app),
	        show: Toolbar.show.bind(app),
	        setHighlight: Toolbar.setHighlight.bind(app),
	        initHideToolbarOnScroll: Toolbar.initHideToolbarOnScroll.bind(app),
	        init: Toolbar.init.bind(app),
	      },
	    });
	  },
	  params: {
	    toolbar: {
	      hideOnPageScroll: false,
	      showOnPageScrollEnd: true,
	      showOnPageScrollTop: true,
	    },
	  },
	  on: {
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      if (page.$el[0].f7ScrollToolbarHandler) {
	        page.$el.off('scroll', '.page-content', page.$el[0].f7ScrollToolbarHandler, true);
	      }
	    },
	    pageBeforeIn: function pageBeforeIn(page) {
	      var app = this;
	      var $toolbarEl = page.$el.parents('.view').children('.toolbar');
	      if ($toolbarEl.length === 0) {
	        $toolbarEl = page.$el.parents('.views').children('.tabbar, .tabbar-labels');
	      }
	      if ($toolbarEl.length === 0) {
	        $toolbarEl = page.$el.find('.toolbar');
	      }
	      if ($toolbarEl.length === 0) {
	        return;
	      }
	      if (page.$el.hasClass('no-toolbar')) {
	        app.toolbar.hide($toolbarEl);
	      } else {
	        app.toolbar.show($toolbarEl);
	      }
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.tabbar, .tabbar-labels').each(function (index, tabbarEl) {
	        app.toolbar.init(tabbarEl);
	      });
	      if (
	        app.params.toolbar.hideOnPageScroll
	        || page.$el.find('.hide-toolbar-on-scroll').length
	        || page.$el.hasClass('hide-toolbar-on-scroll')
	        || page.$el.find('.hide-bars-on-scroll').length
	        || page.$el.hasClass('hide-bars-on-scroll')
	      ) {
	        if (
	          page.$el.find('.keep-toolbar-on-scroll').length
	          || page.$el.hasClass('keep-toolbar-on-scroll')
	          || page.$el.find('.keep-bars-on-scroll').length
	          || page.$el.hasClass('keep-bars-on-scroll')
	        ) {
	          return;
	        }
	        app.toolbar.initHideToolbarOnScroll(page.el);
	      }
	    },
	    init: function init() {
	      var app = this;
	      app.root.find('.tabbar, .tabbar-labels').each(function (index, tabbarEl) {
	        app.toolbar.init(tabbarEl);
	      });
	    },
	  },
	};

	var Subnavbar = {
	  name: 'subnavbar',
	  on: {
	    pageInit: function pageInit(page) {
	      if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find('.subnavbar').length) {
	        page.$el.addClass('page-with-subnavbar');
	      }
	      if (page.$el.find('.subnavbar').length) {
	        page.$el.addClass('page-with-subnavbar');
	      }
	    },
	  },
	};

	var TouchRipple = function TouchRipple($el, x, y) {
	  var ripple = this;
	  if (!$el) { return undefined; }
	  var box = $el[0].getBoundingClientRect();
	  var center = {
	    x: x - box.left,
	    y: y - box.top,
	  };
	  var width = box.width;
	  var height = box.height;
	  var diameter = Math.max((Math.pow( ((Math.pow( height, 2 )) + (Math.pow( width, 2 ))), 0.5 )), 48);

	  ripple.$rippleWaveEl = $(("<div class=\"ripple-wave\" style=\"width: " + diameter + "px; height: " + diameter + "px; margin-top:-" + (diameter / 2) + "px; margin-left:-" + (diameter / 2) + "px; left:" + (center.x) + "px; top:" + (center.y) + "px;\"></div>"));

	  $el.prepend(ripple.$rippleWaveEl);

	  ripple.rippleTransform = "translate3d(" + (-center.x + (width / 2)) + "px, " + (-center.y + (height / 2)) + "px, 0) scale(1)";

	  Utils.nextFrame(function () {
	    if (!ripple || !ripple.$rippleWaveEl) { return; }
	    ripple.$rippleWaveEl.transform(ripple.rippleTransform);
	  });

	  return ripple;
	};

	TouchRipple.prototype.destroy = function destroy () {
	  var ripple = this;
	  if (ripple.$rippleWaveEl) {
	    ripple.$rippleWaveEl.remove();
	  }
	  Object.keys(ripple).forEach(function (key) {
	    ripple[key] = null;
	    delete ripple[key];
	  });
	  ripple = null;
	};

	TouchRipple.prototype.remove = function remove () {
	  var ripple = this;
	  if (ripple.removing) { return; }
	  var $rippleWaveEl = this.$rippleWaveEl;
	  var rippleTransform = this.rippleTransform;
	  var removeTimeout = Utils.nextTick(function () {
	    ripple.destroy();
	  }, 400);
	  ripple.removing = true;
	  $rippleWaveEl
	    .addClass('ripple-wave-fill')
	    .transform(rippleTransform.replace('scale(1)', 'scale(1.01)'))
	    .transitionEnd(function () {
	      clearTimeout(removeTimeout);
	      Utils.nextFrame(function () {
	        $rippleWaveEl
	          .addClass('ripple-wave-out')
	          .transform(rippleTransform.replace('scale(1)', 'scale(1.01)'));

	        removeTimeout = Utils.nextTick(function () {
	          ripple.destroy();
	        }, 700);

	        $rippleWaveEl.transitionEnd(function () {
	          clearTimeout(removeTimeout);
	          ripple.destroy();
	        });
	      });
	    });
	};

	var TouchRipple$1 = {
	  name: 'touch-ripple',
	  static: {
	    TouchRipple: TouchRipple,
	  },
	  create: function create() {
	    var app = this;
	    app.touchRipple = {
	      create: function create() {
	        var args = [], len = arguments.length;
	        while ( len-- ) args[ len ] = arguments[ len ];

	        return new (Function.prototype.bind.apply( TouchRipple, [ null ].concat( args) ));
	      },
	    };
	  },
	};

	var openedModals = [];
	var dialogsQueue = [];
	function clearDialogsQueue() {
	  if (dialogsQueue.length === 0) { return; }
	  var dialog = dialogsQueue.shift();
	  dialog.open();
	}
	var Modal = /*@__PURE__*/(function (Framework7Class) {
	  function Modal(app, params) {
	    Framework7Class.call(this, params, [app]);

	    var modal = this;

	    var defaults = {};

	    // Extend defaults with modules params
	    modal.useModulesParams(defaults);

	    modal.params = Utils.extend(defaults, params);
	    modal.opened = false;

	    // Install Modules
	    modal.useModules();

	    return this;
	  }

	  if ( Framework7Class ) Modal.__proto__ = Framework7Class;
	  Modal.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  Modal.prototype.constructor = Modal;

	  Modal.prototype.onOpen = function onOpen () {
	    var modal = this;
	    modal.opened = true;
	    openedModals.push(modal);
	    $('html').addClass(("with-modal-" + (modal.type.toLowerCase())));
	    modal.$el.trigger(("modal:open " + (modal.type.toLowerCase()) + ":open"), modal);
	    modal.emit(("local::open modalOpen " + (modal.type) + "Open"), modal);
	  };

	  Modal.prototype.onOpened = function onOpened () {
	    var modal = this;
	    modal.$el.trigger(("modal:opened " + (modal.type.toLowerCase()) + ":opened"), modal);
	    modal.emit(("local::opened modalOpened " + (modal.type) + "Opened"), modal);
	  };

	  Modal.prototype.onClose = function onClose () {
	    var modal = this;
	    modal.opened = false;
	    if (!modal.type || !modal.$el) { return; }
	    openedModals.splice(openedModals.indexOf(modal), 1);
	    $('html').removeClass(("with-modal-" + (modal.type.toLowerCase())));
	    modal.$el.trigger(("modal:close " + (modal.type.toLowerCase()) + ":close"), modal);
	    modal.emit(("local::close modalClose " + (modal.type) + "Close"), modal);
	  };

	  Modal.prototype.onClosed = function onClosed () {
	    var modal = this;
	    if (!modal.type || !modal.$el) { return; }
	    modal.$el.removeClass('modal-out');
	    modal.$el.hide();
	    modal.$el.trigger(("modal:closed " + (modal.type.toLowerCase()) + ":closed"), modal);
	    modal.emit(("local::closed modalClosed " + (modal.type) + "Closed"), modal);
	  };

	  Modal.prototype.open = function open (animateModal) {
	    var modal = this;
	    var app = modal.app;
	    var $el = modal.$el;
	    var $backdropEl = modal.$backdropEl;
	    var type = modal.type;
	    var animate = true;
	    if (typeof animateModal !== 'undefined') { animate = animateModal; }
	    else if (typeof modal.params.animate !== 'undefined') {
	      animate = modal.params.animate;
	    }

	    if (!$el || $el.hasClass('modal-in')) {
	      return modal;
	    }

	    if (type === 'dialog' && app.params.modal.queueDialogs) {
	      var pushToQueue;
	      if ($('.dialog.modal-in').length > 0) {
	        pushToQueue = true;
	      } else if (openedModals.length > 0) {
	        openedModals.forEach(function (openedModal) {
	          if (openedModal.type === 'dialog') { pushToQueue = true; }
	        });
	      }
	      if (pushToQueue) {
	        dialogsQueue.push(modal);
	        return modal;
	      }
	    }

	    var $modalParentEl = $el.parent();
	    var wasInDom = $el.parents(doc).length > 0;
	    if (app.params.modal.moveToRoot && !$modalParentEl.is(app.root)) {
	      app.root.append($el);
	      modal.once((type + "Closed"), function () {
	        if (wasInDom) {
	          $modalParentEl.append($el);
	        } else {
	          $el.remove();
	        }
	      });
	    }
	    // Show Modal
	    $el.show();

	    /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
	    modal._clientLeft = $el[0].clientLeft;

	    // Modal
	    function transitionEnd() {
	      if ($el.hasClass('modal-out')) {
	        modal.onClosed();
	      } else if ($el.hasClass('modal-in')) {
	        modal.onOpened();
	      }
	    }
	    if (animate) {
	      if ($backdropEl) {
	        $backdropEl.removeClass('not-animated');
	        $backdropEl.addClass('backdrop-in');
	      }
	      $el
	        .animationEnd(function () {
	          transitionEnd();
	        });
	      $el
	        .transitionEnd(function () {
	          transitionEnd();
	        });
	      $el
	        .removeClass('modal-out not-animated')
	        .addClass('modal-in');
	      modal.onOpen();
	    } else {
	      if ($backdropEl) {
	        $backdropEl.addClass('backdrop-in not-animated');
	      }
	      $el.removeClass('modal-out').addClass('modal-in not-animated');
	      modal.onOpen();
	      modal.onOpened();
	    }

	    return modal;
	  };

	  Modal.prototype.close = function close (animateModal) {
	    var modal = this;
	    var $el = modal.$el;
	    var $backdropEl = modal.$backdropEl;

	    var animate = true;
	    if (typeof animateModal !== 'undefined') { animate = animateModal; }
	    else if (typeof modal.params.animate !== 'undefined') {
	      animate = modal.params.animate;
	    }

	    if (!$el || !$el.hasClass('modal-in')) {
	      return modal;
	    }

	    // backdrop
	    if ($backdropEl) {
	      var needToHideBackdrop = true;
	      if (modal.type === 'popup') {
	        modal.$el.prevAll('.popup.modal-in').each(function (index, popupEl) {
	          var popupInstance = popupEl.f7Modal;
	          if (!popupInstance) { return; }
	          if (
	            popupInstance.params.closeByBackdropClick
	            && popupInstance.params.backdrop
	            && popupInstance.backdropEl === modal.backdropEl
	          ) {
	            needToHideBackdrop = false;
	          }
	        });
	      }
	      if (needToHideBackdrop) {
	        $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
	        $backdropEl.removeClass('backdrop-in');
	      }
	    }

	    // Modal
	    $el[animate ? 'removeClass' : 'addClass']('not-animated');
	    function transitionEnd() {
	      if ($el.hasClass('modal-out')) {
	        modal.onClosed();
	      } else if ($el.hasClass('modal-in')) {
	        modal.onOpened();
	      }
	    }
	    if (animate) {
	      $el
	        .animationEnd(function () {
	          transitionEnd();
	        });
	      $el
	        .transitionEnd(function () {
	          transitionEnd();
	        });
	      $el
	        .removeClass('modal-in')
	        .addClass('modal-out');
	      // Emit close
	      modal.onClose();
	    } else {
	      $el
	        .addClass('not-animated')
	        .removeClass('modal-in')
	        .addClass('modal-out');
	      // Emit close
	      modal.onClose();
	      modal.onClosed();
	    }

	    if (modal.type === 'dialog') {
	      clearDialogsQueue();
	    }

	    return modal;
	  };

	  Modal.prototype.destroy = function destroy () {
	    var modal = this;
	    if (modal.destroyed) { return; }
	    modal.emit(("local::beforeDestroy modalBeforeDestroy " + (modal.type) + "BeforeDestroy"), modal);
	    if (modal.$el) {
	      modal.$el.trigger(("modal:beforedestroy " + (modal.type.toLowerCase()) + ":beforedestroy"), modal);
	      if (modal.$el.length && modal.$el[0].f7Modal) {
	        delete modal.$el[0].f7Modal;
	      }
	    }
	    Utils.deleteProps(modal);
	    modal.destroyed = true;
	  };

	  return Modal;
	}(Framework7Class));

	var CustomModal = /*@__PURE__*/(function (Modal) {
	  function CustomModal(app, params) {
	    var extendedParams = Utils.extend({
	      backdrop: true,
	      closeByBackdropClick: true,
	      on: {},
	    }, params);

	    // Extends with open/close Modal methods;
	    Modal.call(this, extendedParams, app);

	    var customModal = this;

	    customModal.params = extendedParams;

	    // Find Element
	    var $el;
	    if (!customModal.params.el) {
	      $el = $(customModal.params.content);
	    } else {
	      $el = $(customModal.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el.length === 0) {
	      return customModal.destroy();
	    }
	    var $backdropEl;
	    if (customModal.params.backdrop) {
	      $backdropEl = app.root.children('.custom-modal-backdrop');
	      if ($backdropEl.length === 0) {
	        $backdropEl = $('<div class="custom-modal-backdrop"></div>');
	        app.root.append($backdropEl);
	      }
	    }

	    function handleClick(e) {
	      if (!customModal || customModal.destroyed) { return; }
	      if ($backdropEl && e.target === $backdropEl[0]) {
	        customModal.close();
	      }
	    }

	    customModal.on('customModalOpened', function () {
	      if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
	        app.on('click', handleClick);
	      }
	    });
	    customModal.on('customModalClose', function () {
	      if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
	        app.off('click', handleClick);
	      }
	    });

	    Utils.extend(customModal, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl && $backdropEl[0],
	      type: 'customModal',
	    });

	    $el[0].f7Modal = customModal;

	    return customModal;
	  }

	  if ( Modal ) CustomModal.__proto__ = Modal;
	  CustomModal.prototype = Object.create( Modal && Modal.prototype );
	  CustomModal.prototype.constructor = CustomModal;

	  return CustomModal;
	}(Modal));

	var Modal$1 = {
	  name: 'modal',
	  static: {
	    Modal: Modal,
	    CustomModal: CustomModal,
	  },
	  create: function create() {
	    var app = this;
	    app.customModal = {
	      create: function create(params) {
	        return new CustomModal(app, params);
	      },
	    };
	  },
	  params: {
	    modal: {
	      moveToRoot: true,
	      queueDialogs: true,
	    },
	  },
	};

	var Appbar = {
	  name: 'appbar',
	};

	var Dialog = /*@__PURE__*/(function (Modal) {
	  function Dialog(app, params) {
	    var extendedParams = Utils.extend({
	      title: app.params.dialog.title,
	      text: undefined,
	      content: '',
	      buttons: [],
	      verticalButtons: false,
	      onClick: undefined,
	      cssClass: undefined,
	      destroyOnClose: false,
	      on: {},
	    }, params);
	    if (typeof extendedParams.closeByBackdropClick === 'undefined') {
	      extendedParams.closeByBackdropClick = app.params.dialog.closeByBackdropClick;
	    }

	    // Extends with open/close Modal methods;
	    Modal.call(this, extendedParams, app);

	    var dialog = this;

	    var title = extendedParams.title;
	    var text = extendedParams.text;
	    var content = extendedParams.content;
	    var buttons = extendedParams.buttons;
	    var verticalButtons = extendedParams.verticalButtons;
	    var cssClass = extendedParams.cssClass;

	    dialog.params = extendedParams;

	    // Find Element
	    var $el;
	    if (!dialog.params.el) {
	      var dialogClasses = ['dialog'];
	      if (buttons.length === 0) { dialogClasses.push('dialog-no-buttons'); }
	      if (buttons.length > 0) { dialogClasses.push(("dialog-buttons-" + (buttons.length))); }
	      if (verticalButtons) { dialogClasses.push('dialog-buttons-vertical'); }
	      if (cssClass) { dialogClasses.push(cssClass); }

	      var buttonsHTML = '';
	      if (buttons.length > 0) {
	        buttonsHTML = "\n          <div class=\"dialog-buttons\">\n            " + (buttons.map(function (button) { return ("\n              <span class=\"dialog-button" + (button.bold ? ' dialog-button-bold' : '') + (button.color ? (" color-" + (button.color)) : '') + (button.cssClass ? (" " + (button.cssClass)) : '') + "\">" + (button.text) + "</span>\n            "); }).join('')) + "\n          </div>\n        ";
	      }

	      var dialogHtml = "\n        <div class=\"" + (dialogClasses.join(' ')) + "\">\n          <div class=\"dialog-inner\">\n            " + (title ? ("<div class=\"dialog-title\">" + title + "</div>") : '') + "\n            " + (text ? ("<div class=\"dialog-text\">" + text + "</div>") : '') + "\n            " + content + "\n          </div>\n          " + buttonsHTML + "\n        </div>\n      ";
	      $el = $(dialogHtml);
	    } else {
	      $el = $(dialog.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el.length === 0) {
	      return dialog.destroy();
	    }

	    var $backdropEl = app.root.children('.dialog-backdrop');
	    if ($backdropEl.length === 0) {
	      $backdropEl = $('<div class="dialog-backdrop"></div>');
	      app.root.append($backdropEl);
	    }

	    // Assign events
	    function buttonOnClick(e) {
	      var buttonEl = this;
	      var index = $(buttonEl).index();
	      var button = buttons[index];
	      if (button.onClick) { button.onClick(dialog, e); }
	      if (dialog.params.onClick) { dialog.params.onClick(dialog, index); }
	      if (button.close !== false) { dialog.close(); }
	    }
	    var addKeyboardHander;
	    function onKeyDown(e) {
	      var keyCode = e.keyCode;
	      buttons.forEach(function (button, index) {
	        if (button.keyCodes && button.keyCodes.indexOf(keyCode) >= 0) {
	          if (doc.activeElement) { doc.activeElement.blur(); }
	          if (button.onClick) { button.onClick(dialog, e); }
	          if (dialog.params.onClick) { dialog.params.onClick(dialog, index); }
	          if (button.close !== false) { dialog.close(); }
	        }
	      });
	    }
	    if (buttons && buttons.length > 0) {
	      dialog.on('open', function () {
	        $el.find('.dialog-button').each(function (index, buttonEl) {
	          var button = buttons[index];
	          if (button.keyCodes) { addKeyboardHander = true; }
	          $(buttonEl).on('click', buttonOnClick);
	        });
	        if (
	          addKeyboardHander
	          && !app.device.ios
	          && !app.device.android
	          && !app.device.cordova
	        ) {
	          $(doc).on('keydown', onKeyDown);
	        }
	      });
	      dialog.on('close', function () {
	        $el.find('.dialog-button').each(function (index, buttonEl) {
	          $(buttonEl).off('click', buttonOnClick);
	        });
	        if (
	          addKeyboardHander
	          && !app.device.ios
	          && !app.device.android
	          && !app.device.cordova
	        ) {
	          $(doc).off('keydown', onKeyDown);
	        }
	        addKeyboardHander = false;
	      });
	    }
	    Utils.extend(dialog, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl[0],
	      type: 'dialog',
	      setProgress: function setProgress(progress, duration) {
	        app.progressbar.set($el.find('.progressbar'), progress, duration);
	        return dialog;
	      },
	      setText: function setText(newText) {
	        var $textEl = $el.find('.dialog-text');
	        if ($textEl.length === 0) {
	          $textEl = $('<div class="dialog-text"></div>');
	          if (typeof title !== 'undefined') {
	            $textEl.insertAfter($el.find('.dialog-title'));
	          } else {
	            $el.find('.dialog-inner').prepend($textEl);
	          }
	        }
	        $textEl.html(newText);
	        dialog.params.text = newText;
	        return dialog;
	      },
	      setTitle: function setTitle(newTitle) {
	        var $titleEl = $el.find('.dialog-title');
	        if ($titleEl.length === 0) {
	          $titleEl = $('<div class="dialog-title"></div>');
	          $el.find('.dialog-inner').prepend($titleEl);
	        }
	        $titleEl.html(newTitle);
	        dialog.params.title = newTitle;
	        return dialog;
	      },
	    });

	    function handleClick(e) {
	      var target = e.target;
	      var $target = $(target);
	      if ($target.closest(dialog.el).length === 0) {
	        if (
	          dialog.params.closeByBackdropClick
	          && dialog.backdropEl
	          && dialog.backdropEl === target
	        ) {
	          dialog.close();
	        }
	      }
	    }

	    dialog.on('opened', function () {
	      if (dialog.params.closeByBackdropClick) {
	        app.on('click', handleClick);
	      }
	    });
	    dialog.on('close', function () {
	      if (dialog.params.closeByBackdropClick) {
	        app.off('click', handleClick);
	      }
	    });

	    $el[0].f7Modal = dialog;

	    if (dialog.params.destroyOnClose) {
	      dialog.once('closed', function () {
	        setTimeout(function () {
	          dialog.destroy();
	        }, 0);
	      });
	    }

	    return dialog;
	  }

	  if ( Modal ) Dialog.__proto__ = Modal;
	  Dialog.prototype = Object.create( Modal && Modal.prototype );
	  Dialog.prototype.constructor = Dialog;

	  return Dialog;
	}(Modal));

	var Dialog$1 = {
	  name: 'dialog',
	  params: {
	    dialog: {
	      title: undefined,
	      buttonOk: 'OK',
	      buttonCancel: 'Cancel',
	      usernamePlaceholder: 'Username',
	      passwordPlaceholder: 'Password',
	      preloaderTitle: 'Loading... ',
	      progressTitle: 'Loading... ',
	      closeByBackdropClick: false,
	      destroyPredefinedDialogs: true,
	      keyboardActions: true,
	    },
	  },
	  static: {
	    Dialog: Dialog,
	  },
	  create: function create() {
	    var app = this;
	    function defaultDialogTitle() {
	      return app.params.dialog.title || app.name;
	    }
	    var destroyOnClose = app.params.dialog.destroyPredefinedDialogs;
	    var keyboardActions = app.params.dialog.keyboardActions;
	    app.dialog = Utils.extend(
	      ModalMethods({
	        app: app,
	        constructor: Dialog,
	        defaultSelector: '.dialog.modal-in',
	      }),
	      {
	        // Shortcuts
	        alert: function alert() {
	          var assign;

	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];
	          var text = args[0];
	          var title = args[1];
	          var callbackOk = args[2];
	          if (args.length === 2 && typeof args[1] === 'function') {
	            (assign = args, text = assign[0], callbackOk = assign[1], title = assign[2]);
	          }
	          return new Dialog(app, {
	            title: typeof title === 'undefined' ? defaultDialogTitle() : title,
	            text: text,
	            buttons: [{
	              text: app.params.dialog.buttonOk,
	              bold: true,
	              onClick: callbackOk,
	              keyCodes: keyboardActions ? [13, 27] : null,
	            }],
	            destroyOnClose: destroyOnClose,
	          }).open();
	        },
	        prompt: function prompt() {
	          var assign;

	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];
	          var text = args[0];
	          var title = args[1];
	          var callbackOk = args[2];
	          var callbackCancel = args[3];
	          var defaultValue = args[4];
	          if (typeof args[1] === 'function') {
	            (assign = args, text = assign[0], callbackOk = assign[1], callbackCancel = assign[2], defaultValue = assign[3], title = assign[4]);
	          }
	          defaultValue = typeof defaultValue === 'undefined' || defaultValue === null ? '' : defaultValue;
	          return new Dialog(app, {
	            title: typeof title === 'undefined' ? defaultDialogTitle() : title,
	            text: text,
	            content: ("<div class=\"dialog-input-field input\"><input type=\"text\" class=\"dialog-input\" value=\"" + defaultValue + "\"></div>"),
	            buttons: [
	              {
	                text: app.params.dialog.buttonCancel,
	                keyCodes: keyboardActions ? [27] : null,
	                color: app.theme === 'aurora' ? 'gray' : null,
	              },
	              {
	                text: app.params.dialog.buttonOk,
	                bold: true,
	                keyCodes: keyboardActions ? [13] : null,
	              } ],
	            onClick: function onClick(dialog, index) {
	              var inputValue = dialog.$el.find('.dialog-input').val();
	              if (index === 0 && callbackCancel) { callbackCancel(inputValue); }
	              if (index === 1 && callbackOk) { callbackOk(inputValue); }
	            },
	            destroyOnClose: destroyOnClose,
	          }).open();
	        },
	        confirm: function confirm() {
	          var assign;

	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];
	          var text = args[0];
	          var title = args[1];
	          var callbackOk = args[2];
	          var callbackCancel = args[3];
	          if (typeof args[1] === 'function') {
	            (assign = args, text = assign[0], callbackOk = assign[1], callbackCancel = assign[2], title = assign[3]);
	          }
	          return new Dialog(app, {
	            title: typeof title === 'undefined' ? defaultDialogTitle() : title,
	            text: text,
	            buttons: [
	              {
	                text: app.params.dialog.buttonCancel,
	                onClick: callbackCancel,
	                keyCodes: keyboardActions ? [27] : null,
	                color: app.theme === 'aurora' ? 'gray' : null,
	              },
	              {
	                text: app.params.dialog.buttonOk,
	                bold: true,
	                onClick: callbackOk,
	                keyCodes: keyboardActions ? [13] : null,
	              } ],
	            destroyOnClose: destroyOnClose,
	          }).open();
	        },
	        login: function login() {
	          var assign;

	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];
	          var text = args[0];
	          var title = args[1];
	          var callbackOk = args[2];
	          var callbackCancel = args[3];
	          if (typeof args[1] === 'function') {
	            (assign = args, text = assign[0], callbackOk = assign[1], callbackCancel = assign[2], title = assign[3]);
	          }
	          return new Dialog(app, {
	            title: typeof title === 'undefined' ? defaultDialogTitle() : title,
	            text: text,
	            content: ("\n              <div class=\"dialog-input-field dialog-input-double input\">\n                <input type=\"text\" name=\"dialog-username\" placeholder=\"" + (app.params.dialog.usernamePlaceholder) + "\" class=\"dialog-input\">\n              </div>\n              <div class=\"dialog-input-field dialog-input-double input\">\n                <input type=\"password\" name=\"dialog-password\" placeholder=\"" + (app.params.dialog.passwordPlaceholder) + "\" class=\"dialog-input\">\n              </div>"),
	            buttons: [
	              {
	                text: app.params.dialog.buttonCancel,
	                keyCodes: keyboardActions ? [27] : null,
	                color: app.theme === 'aurora' ? 'gray' : null,
	              },
	              {
	                text: app.params.dialog.buttonOk,
	                bold: true,
	                keyCodes: keyboardActions ? [13] : null,
	              } ],
	            onClick: function onClick(dialog, index) {
	              var username = dialog.$el.find('[name="dialog-username"]').val();
	              var password = dialog.$el.find('[name="dialog-password"]').val();
	              if (index === 0 && callbackCancel) { callbackCancel(username, password); }
	              if (index === 1 && callbackOk) { callbackOk(username, password); }
	            },
	            destroyOnClose: destroyOnClose,
	          }).open();
	        },
	        password: function password() {
	          var assign;

	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];
	          var text = args[0];
	          var title = args[1];
	          var callbackOk = args[2];
	          var callbackCancel = args[3];
	          if (typeof args[1] === 'function') {
	            (assign = args, text = assign[0], callbackOk = assign[1], callbackCancel = assign[2], title = assign[3]);
	          }
	          return new Dialog(app, {
	            title: typeof title === 'undefined' ? defaultDialogTitle() : title,
	            text: text,
	            content: ("\n              <div class=\"dialog-input-field input\">\n                <input type=\"password\" name=\"dialog-password\" placeholder=\"" + (app.params.dialog.passwordPlaceholder) + "\" class=\"dialog-input\">\n              </div>"),
	            buttons: [
	              {
	                text: app.params.dialog.buttonCancel,
	                keyCodes: keyboardActions ? [27] : null,
	                color: app.theme === 'aurora' ? 'gray' : null,
	              },
	              {
	                text: app.params.dialog.buttonOk,
	                bold: true,
	                keyCodes: keyboardActions ? [13] : null,
	              } ],
	            onClick: function onClick(dialog, index) {
	              var password = dialog.$el.find('[name="dialog-password"]').val();
	              if (index === 0 && callbackCancel) { callbackCancel(password); }
	              if (index === 1 && callbackOk) { callbackOk(password); }
	            },
	            destroyOnClose: destroyOnClose,
	          }).open();
	        },
	        preloader: function preloader(title, color) {
	          var preloaderInner = Utils[((app.theme) + "PreloaderContent")] || '';
	          return new Dialog(app, {
	            title: typeof title === 'undefined' || title === null ? app.params.dialog.preloaderTitle : title,
	            content: ("<div class=\"preloader" + (color ? (" color-" + color) : '') + "\">" + preloaderInner + "</div>"),
	            cssClass: 'dialog-preloader',
	            destroyOnClose: destroyOnClose,
	          }).open();
	        },
	        progress: function progress() {
	          var assign, assign$1, assign$2;

	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];
	          var title = args[0];
	          var progress = args[1];
	          var color = args[2];
	          if (args.length === 2) {
	            if (typeof args[0] === 'number') {
	              (assign = args, progress = assign[0], color = assign[1], title = assign[2]);
	            } else if (typeof args[0] === 'string' && typeof args[1] === 'string') {
	              (assign$1 = args, title = assign$1[0], color = assign$1[1], progress = assign$1[2]);
	            }
	          } else if (args.length === 1) {
	            if (typeof args[0] === 'number') {
	              (assign$2 = args, progress = assign$2[0], title = assign$2[1], color = assign$2[2]);
	            }
	          }
	          var infinite = typeof progress === 'undefined';
	          var dialog = new Dialog(app, {
	            title: typeof title === 'undefined' ? app.params.dialog.progressTitle : title,
	            cssClass: 'dialog-progress',
	            content: ("\n              <div class=\"progressbar" + (infinite ? '-infinite' : '') + (color ? (" color-" + color) : '') + "\">\n                " + (!infinite ? '<span></span>' : '') + "\n              </div>\n            "),
	            destroyOnClose: destroyOnClose,
	          });
	          if (!infinite) { dialog.setProgress(progress); }
	          return dialog.open();
	        },
	      }
	    );
	  },
	};

	var Popup = /*@__PURE__*/(function (Modal) {
	  function Popup(app, params) {
	    var extendedParams = Utils.extend(
	      { on: {} },
	      app.params.popup,
	      params
	    );

	    // Extends with open/close Modal methods;
	    Modal.call(this, extendedParams, app);

	    var popup = this;

	    popup.params = extendedParams;

	    // Find Element
	    var $el;
	    if (!popup.params.el) {
	      $el = $(popup.params.content);
	    } else {
	      $el = $(popup.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el.length === 0) {
	      return popup.destroy();
	    }

	    var $backdropEl;
	    if (popup.params.backdrop && popup.params.backdropEl) {
	      $backdropEl = $(popup.params.backdropEl);
	    } else if (popup.params.backdrop) {
	      $backdropEl = app.root.children('.popup-backdrop');
	      if ($backdropEl.length === 0) {
	        $backdropEl = $('<div class="popup-backdrop"></div>');
	        app.root.append($backdropEl);
	      }
	    }

	    Utils.extend(popup, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl && $backdropEl[0],
	      type: 'popup',
	    });

	    function handleClick(e) {
	      var target = e.target;
	      var $target = $(target);
	      var keyboardOpened = !app.device.desktop && app.device.cordova && ((window.Keyboard && window.Keyboard.isVisible) || (window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible));
	      if (keyboardOpened) { return; }
	      if ($target.closest(popup.el).length === 0) {
	        if (
	          popup.params
	          && popup.params.closeByBackdropClick
	          && popup.params.backdrop
	          && popup.backdropEl
	          && popup.backdropEl === target
	        ) {
	          var needToClose = true;
	          popup.$el.nextAll('.popup.modal-in').each(function (index, popupEl) {
	            var popupInstance = popupEl.f7Modal;
	            if (!popupInstance) { return; }
	            if (
	              popupInstance.params.closeByBackdropClick
	              && popupInstance.params.backdrop
	              && popupInstance.backdropEl === popup.backdropEl
	            ) {
	              needToClose = false;
	            }
	          });
	          if (needToClose) {
	            popup.close();
	          }
	        }
	      }
	    }

	    function onKeyDown(e) {
	      var keyCode = e.keyCode;
	      if (keyCode === 27 && popup.params.closeOnEscape) {
	        popup.close();
	      }
	    }
	    if (popup.params.closeOnEscape) {
	      popup.on('popupOpen', function () {
	        $(document).on('keydown', onKeyDown);
	      });
	      popup.on('popupClose', function () {
	        $(document).off('keydown', onKeyDown);
	      });
	    }

	    popup.on('popupOpened', function () {
	      $el.removeClass('swipe-close-to-bottom swipe-close-to-top');
	      if (popup.params.closeByBackdropClick) {
	        app.on('click', handleClick);
	      }
	    });
	    popup.on('popupClose', function () {
	      if (popup.params.closeByBackdropClick) {
	        app.off('click', handleClick);
	      }
	    });

	    var allowSwipeToClose = true;
	    var isTouched = false;
	    var startTouch;
	    var currentTouch;
	    var isScrolling;
	    var touchStartTime;
	    var touchesDiff;
	    var isMoved = false;
	    var pageContentEl;
	    var pageContentScrollTop;
	    var pageContentOffsetHeight;
	    var pageContentScrollHeight;

	    function handleTouchStart(e) {
	      if (isTouched || !allowSwipeToClose || !popup.params.swipeToClose) { return; }
	      if (popup.params.swipeHandler && $(e.target).closest(popup.params.swipeHandler).length === 0) {
	        return;
	      }
	      isTouched = true;
	      isMoved = false;
	      startTouch = {
	        x: e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX,
	        y: e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY,
	      };
	      touchStartTime = Utils.now();
	      isScrolling = undefined;
	      if (!popup.params.swipeHandler && e.type === 'touchstart') {
	        pageContentEl = $(e.target).closest('.page-content')[0];
	      }
	    }
	    function handleTouchMove(e) {
	      if (!isTouched) { return; }
	      currentTouch = {
	        x: e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX,
	        y: e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY,
	      };

	      if (typeof isScrolling === 'undefined') {
	        isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
	      }
	      if (isScrolling) {
	        isTouched = false;
	        isMoved = false;
	        return;
	      }

	      touchesDiff = startTouch.y - currentTouch.y;
	      var direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';
	      $el.transition(0);

	      if (typeof popup.params.swipeToClose === 'string' && direction !== popup.params.swipeToClose) {
	        $el.transform('');
	        return;
	      }

	      if (!isMoved) {
	        if (pageContentEl) {
	          pageContentScrollTop = pageContentEl.scrollTop;
	          pageContentScrollHeight = pageContentEl.scrollHeight;
	          pageContentOffsetHeight = pageContentEl.offsetHeight;
	          if (
	            !(pageContentScrollHeight === pageContentOffsetHeight)
	            && !(direction === 'to-bottom' && pageContentScrollTop === 0)
	            && !(direction === 'to-top' && pageContentScrollTop === (pageContentScrollHeight - pageContentOffsetHeight))
	          ) {
	            $el.transform('');
	            isTouched = false;
	            isMoved = false;
	            return;
	          }
	        }
	        isMoved = true;
	      }
	      e.preventDefault();
	      $el.transition(0).transform(("translate3d(0," + (-touchesDiff) + "px,0)"));
	    }
	    function handleTouchEnd() {
	      isTouched = false;
	      if (!isMoved) {
	        return;
	      }
	      isMoved = false;
	      allowSwipeToClose = false;
	      $el.transition('');
	      var direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';
	      if ((typeof popup.params.swipeToClose === 'string' && direction !== popup.params.swipeToClose)) {
	        $el.transform('');
	        allowSwipeToClose = true;
	        return;
	      }
	      var diff = Math.abs(touchesDiff);
	      var timeDiff = (new Date()).getTime() - touchStartTime;
	      if ((timeDiff < 300 && diff > 20) || (timeDiff >= 300 && diff > 100)) {
	        Utils.nextTick(function () {
	          if (direction === 'to-bottom') {
	            $el.addClass('swipe-close-to-bottom');
	          } else {
	            $el.addClass('swipe-close-to-top');
	          }
	          $el.transform('');
	          popup.close();
	          allowSwipeToClose = true;
	        });
	        return;
	      }
	      allowSwipeToClose = true;
	      $el.transform('');
	    }

	    var passive = Support.passiveListener ? { passive: true } : false;
	    if (popup.params.swipeToClose) {
	      $el.on(app.touchEvents.start, handleTouchStart, passive);
	      app.on('touchmove', handleTouchMove);
	      app.on('touchend:passive', handleTouchEnd);
	      popup.once('popupDestroy', function () {
	        $el.off(app.touchEvents.start, handleTouchStart, passive);
	        app.off('touchmove', handleTouchMove);
	        app.off('touchend:passive', handleTouchEnd);
	      });
	    }

	    $el[0].f7Modal = popup;

	    return popup;
	  }

	  if ( Modal ) Popup.__proto__ = Modal;
	  Popup.prototype = Object.create( Modal && Modal.prototype );
	  Popup.prototype.constructor = Popup;

	  return Popup;
	}(Modal));

	var Popup$1 = {
	  name: 'popup',
	  params: {
	    popup: {
	      backdrop: true,
	      backdropEl: undefined,
	      closeByBackdropClick: true,
	      closeOnEscape: false,
	      swipeToClose: false,
	      swipeHandler: null,
	    },
	  },
	  static: {
	    Popup: Popup,
	  },
	  create: function create() {
	    var app = this;
	    app.popup = ModalMethods({
	      app: app,
	      constructor: Popup,
	      defaultSelector: '.popup.modal-in',
	    });
	  },
	  clicks: {
	    '.popup-open': function openPopup($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.popup.open(data.popup, data.animate);
	    },
	    '.popup-close': function closePopup($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.popup.close(data.popup, data.animate);
	    },
	  },
	};

	var LoginScreen = /*@__PURE__*/(function (Modal) {
	  function LoginScreen(app, params) {
	    var extendedParams = Utils.extend({
	      on: {},
	    }, params);

	    // Extends with open/close Modal methods;
	    Modal.call(this, extendedParams, app);

	    var loginScreen = this;

	    loginScreen.params = extendedParams;

	    // Find Element
	    var $el;
	    if (!loginScreen.params.el) {
	      $el = $(loginScreen.params.content);
	    } else {
	      $el = $(loginScreen.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el.length === 0) {
	      return loginScreen.destroy();
	    }

	    Utils.extend(loginScreen, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      type: 'loginScreen',
	    });

	    $el[0].f7Modal = loginScreen;

	    return loginScreen;
	  }

	  if ( Modal ) LoginScreen.__proto__ = Modal;
	  LoginScreen.prototype = Object.create( Modal && Modal.prototype );
	  LoginScreen.prototype.constructor = LoginScreen;

	  return LoginScreen;
	}(Modal));

	var LoginScreen$1 = {
	  name: 'loginScreen',
	  static: {
	    LoginScreen: LoginScreen,
	  },
	  create: function create() {
	    var app = this;
	    app.loginScreen = ModalMethods({
	      app: app,
	      constructor: LoginScreen,
	      defaultSelector: '.login-screen.modal-in',
	    });
	  },
	  clicks: {
	    '.login-screen-open': function openLoginScreen($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.loginScreen.open(data.loginScreen, data.animate);
	    },
	    '.login-screen-close': function closeLoginScreen($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.loginScreen.close(data.loginScreen, data.animate);
	    },
	  },
	};

	var Popover = /*@__PURE__*/(function (Modal) {
	  function Popover(app, params) {
	    var extendedParams = Utils.extend(
	      { on: {} },
	      app.params.popover,
	      params
	    );

	    // Extends with open/close Modal methods;
	    Modal.call(this, extendedParams, app);

	    var popover = this;

	    popover.params = extendedParams;

	    // Find Element
	    var $el;
	    if (!popover.params.el) {
	      $el = $(popover.params.content);
	    } else {
	      $el = $(popover.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    // Find Target
	    var $targetEl = $(popover.params.targetEl).eq(0);

	    if ($el.length === 0) {
	      return popover.destroy();
	    }

	    // Backdrop
	    var $backdropEl;
	    if (popover.params.backdrop && popover.params.backdropEl) {
	      $backdropEl = $(popover.params.backdropEl);
	    } else if (popover.params.backdrop) {
	      $backdropEl = app.root.children('.popover-backdrop');
	      if ($backdropEl.length === 0) {
	        $backdropEl = $('<div class="popover-backdrop"></div>');
	        app.root.append($backdropEl);
	      }
	    }

	    // Find Angle
	    var $angleEl;
	    if ($el.find('.popover-angle').length === 0) {
	      $angleEl = $('<div class="popover-angle"></div>');
	      $el.prepend($angleEl);
	    } else {
	      $angleEl = $el.find('.popover-angle');
	    }

	    // Open
	    var originalOpen = popover.open;

	    Utils.extend(popover, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      $targetEl: $targetEl,
	      targetEl: $targetEl[0],
	      $angleEl: $angleEl,
	      angleEl: $angleEl[0],
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl && $backdropEl[0],
	      type: 'popover',
	      open: function open() {
	        var assign;

	        var args = [], len = arguments.length;
	        while ( len-- ) args[ len ] = arguments[ len ];
	        var targetEl = args[0];
	        var animate = args[1];
	        if (typeof args[0] === 'boolean') { (assign = args, animate = assign[0], targetEl = assign[1]); }
	        if (targetEl) {
	          popover.$targetEl = $(targetEl);
	          popover.targetEl = popover.$targetEl[0];
	        }
	        return originalOpen.call(popover, animate);
	      },
	    });

	    function handleResize() {
	      popover.resize();
	    }
	    popover.on('popoverOpen', function () {
	      popover.resize();
	      app.on('resize', handleResize);
	      $(window).on('keyboardDidShow keyboardDidHide', handleResize);
	      popover.on('popoverClose popoverBeforeDestroy', function () {
	        app.off('resize', handleResize);
	        $(window).off('keyboardDidShow keyboardDidHide', handleResize);
	      });
	    });

	    function handleClick(e) {
	      var target = e.target;
	      var $target = $(target);
	      var keyboardOpened = !app.device.desktop && app.device.cordova && ((window.Keyboard && window.Keyboard.isVisible) || (window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible));
	      if (keyboardOpened) { return; }
	      if ($target.closest(popover.el).length === 0) {
	        if (
	          popover.params.closeByBackdropClick
	          && popover.params.backdrop
	          && popover.backdropEl
	          && popover.backdropEl === target
	        ) {
	          popover.close();
	        } else if (popover.params.closeByOutsideClick) {
	          popover.close();
	        }
	      }
	    }

	    function onKeyDown(e) {
	      var keyCode = e.keyCode;
	      if (keyCode === 27 && popover.params.closeOnEscape) {
	        popover.close();
	      }
	    }

	    if (popover.params.closeOnEscape) {
	      popover.on('popoverOpen', function () {
	        $(document).on('keydown', onKeyDown);
	      });
	      popover.on('popoverClose', function () {
	        $(document).off('keydown', onKeyDown);
	      });
	    }

	    popover.on('popoverOpened', function () {
	      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
	        app.on('click', handleClick);
	      }
	    });
	    popover.on('popoverClose', function () {
	      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
	        app.off('click', handleClick);
	      }
	    });

	    $el[0].f7Modal = popover;

	    return popover;
	  }

	  if ( Modal ) Popover.__proto__ = Modal;
	  Popover.prototype = Object.create( Modal && Modal.prototype );
	  Popover.prototype.constructor = Popover;

	  Popover.prototype.resize = function resize () {
	    var popover = this;
	    var app = popover.app;
	    var $el = popover.$el;
	    var $targetEl = popover.$targetEl;
	    var $angleEl = popover.$angleEl;
	    var ref = popover.params;
	    var targetX = ref.targetX;
	    var targetY = ref.targetY;
	    $el.css({ left: '', top: '' });
	    var ref$1 = [$el.width(), $el.height()];
	    var width = ref$1[0];
	    var height = ref$1[1];
	    var angleSize = 0;
	    var angleLeft;
	    var angleTop;
	    if (app.theme === 'ios' || app.theme === 'aurora') {
	      $angleEl.removeClass('on-left on-right on-top on-bottom').css({ left: '', top: '' });
	      angleSize = $angleEl.width() / 2;
	    } else {
	      $el.removeClass('popover-on-left popover-on-right popover-on-top popover-on-bottom popover-on-middle').css({ left: '', top: '' });
	    }

	    var targetWidth;
	    var targetHeight;
	    var targetOffsetLeft;
	    var targetOffsetTop;
	    if ($targetEl && $targetEl.length > 0) {
	      targetWidth = $targetEl.outerWidth();
	      targetHeight = $targetEl.outerHeight();

	      var targetOffset = $targetEl.offset();
	      targetOffsetLeft = targetOffset.left - app.left;
	      targetOffsetTop = targetOffset.top - app.top;

	      var targetParentPage = $targetEl.parents('.page');
	      if (targetParentPage.length > 0) {
	        targetOffsetTop -= targetParentPage[0].scrollTop;
	      }
	    } else if (typeof targetX !== 'undefined' && targetY !== 'undefined') {
	      targetOffsetLeft = targetX;
	      targetOffsetTop = targetY;
	      targetWidth = popover.params.targetWidth || 0;
	      targetHeight = popover.params.targetHeight || 0;
	    }

	    var ref$2 = [0, 0, 0];
	    var left = ref$2[0];
	    var top = ref$2[1];
	    var diff = ref$2[2];
	    // Top Position
	    var position = app.theme === 'md' ? 'bottom' : 'top';
	    if (app.theme === 'md') {
	      if (height < app.height - targetOffsetTop - targetHeight) {
	        // On bottom
	        position = 'bottom';
	        top = targetOffsetTop + targetHeight;
	      } else if (height < targetOffsetTop) {
	        // On top
	        top = targetOffsetTop - height;
	        position = 'top';
	      } else {
	        // On middle
	        position = 'middle';
	        top = ((targetHeight / 2) + targetOffsetTop) - (height / 2);
	      }
	      top = Math.max(8, Math.min(top, app.height - height - 8));

	      // Horizontal Position
	      var hPosition;
	      if (targetOffsetLeft < app.width / 2) {
	        hPosition = 'right';
	        left = position === 'middle'
	          ? targetOffsetLeft + targetWidth
	          : targetOffsetLeft;
	      } else {
	        hPosition = 'left';
	        left = position === 'middle'
	          ? targetOffsetLeft - width
	          : (targetOffsetLeft + targetWidth) - width;
	      }
	      left = Math.max(8, Math.min(left, app.width - width - 8));
	      $el.addClass(("popover-on-" + position + " popover-on-" + hPosition));
	    } else {
	      // ios and aurora
	      if ((height + angleSize) < targetOffsetTop) {
	        // On top
	        top = targetOffsetTop - height - angleSize;
	      } else if ((height + angleSize) < app.height - targetOffsetTop - targetHeight) {
	        // On bottom
	        position = 'bottom';
	        top = targetOffsetTop + targetHeight + angleSize;
	      } else {
	        // On middle
	        position = 'middle';
	        top = ((targetHeight / 2) + targetOffsetTop) - (height / 2);
	        diff = top;
	        top = Math.max(5, Math.min(top, app.height - height - 5));
	        diff -= top;
	      }

	      // Horizontal Position
	      if (position === 'top' || position === 'bottom') {
	        left = ((targetWidth / 2) + targetOffsetLeft) - (width / 2);
	        diff = left;
	        left = Math.max(5, Math.min(left, app.width - width - 5));
	        if (position === 'top') {
	          $angleEl.addClass('on-bottom');
	        }
	        if (position === 'bottom') {
	          $angleEl.addClass('on-top');
	        }
	        diff -= left;
	        angleLeft = ((width / 2) - angleSize) + diff;
	        angleLeft = Math.max(Math.min(angleLeft, width - (angleSize * 2) - 13), 13);
	        $angleEl.css({ left: (angleLeft + "px") });
	      } else if (position === 'middle') {
	        left = targetOffsetLeft - width - angleSize;
	        $angleEl.addClass('on-right');
	        if (left < 5 || (left + width > app.width)) {
	          if (left < 5) { left = targetOffsetLeft + targetWidth + angleSize; }
	          if (left + width > app.width) { left = app.width - width - 5; }
	          $angleEl.removeClass('on-right').addClass('on-left');
	        }
	        angleTop = ((height / 2) - angleSize) + diff;
	        angleTop = Math.max(Math.min(angleTop, height - (angleSize * 2) - 13), 13);
	        $angleEl.css({ top: (angleTop + "px") });
	      }
	    }

	    // Apply Styles
	    $el.css({ top: (top + "px"), left: (left + "px") });
	  };

	  return Popover;
	}(Modal));

	var Popover$1 = {
	  name: 'popover',
	  params: {
	    popover: {
	      backdrop: true,
	      backdropEl: undefined,
	      closeByBackdropClick: true,
	      closeByOutsideClick: true,
	      closeOnEscape: false,
	    },
	  },
	  static: {
	    Popover: Popover,
	  },
	  create: function create() {
	    var app = this;
	    app.popover = Utils.extend(
	      ModalMethods({
	        app: app,
	        constructor: Popover,
	        defaultSelector: '.popover.modal-in',
	      }),
	      {
	        open: function open(popoverEl, targetEl, animate) {
	          var $popoverEl = $(popoverEl);
	          var popover = $popoverEl[0].f7Modal;
	          if (!popover) { popover = new Popover(app, { el: $popoverEl, targetEl: targetEl }); }
	          return popover.open(targetEl, animate);
	        },
	      }
	    );
	  },
	  clicks: {
	    '.popover-open': function openPopover($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.popover.open(data.popover, $clickedEl, data.animate);
	    },
	    '.popover-close': function closePopover($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.popover.close(data.popover, data.animate);
	    },
	  },
	};

	/* eslint indent: ["off"] */

	var Actions = /*@__PURE__*/(function (Modal) {
	  function Actions(app, params) {
	    var extendedParams = Utils.extend(
	      { on: {} },
	      app.params.actions,
	      params
	    );

	    // Extends with open/close Modal methods;
	    Modal.call(this, extendedParams, app);

	    var actions = this;

	    actions.params = extendedParams;

	    // Buttons
	    var groups;
	    if (actions.params.buttons) {
	      groups = actions.params.buttons;
	      if (!Array.isArray(groups[0])) { groups = [groups]; }
	    }
	    actions.groups = groups;

	    // Find Element
	    var $el;
	    if (actions.params.el) {
	      $el = $(actions.params.el);
	    } else if (actions.params.content) {
	      $el = $(actions.params.content);
	    } else if (actions.params.buttons) {
	      if (actions.params.convertToPopover) {
	        actions.popoverHtml = actions.renderPopover();
	      }
	      actions.actionsHtml = actions.render();
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el && $el.length === 0 && !(actions.actionsHtml || actions.popoverHtml)) {
	      return actions.destroy();
	    }

	    // Backdrop
	    var $backdropEl;
	    if (actions.params.backdrop && actions.params.backdropEl) {
	      $backdropEl = $(actions.params.backdropEl);
	    } else if (actions.params.backdrop) {
	      $backdropEl = app.root.children('.actions-backdrop');
	      if ($backdropEl.length === 0) {
	        $backdropEl = $('<div class="actions-backdrop"></div>');
	        app.root.append($backdropEl);
	      }
	    }

	    var originalOpen = actions.open;
	    var originalClose = actions.close;

	    var popover;
	    function buttonOnClick(e) {
	      var $buttonEl = $(this);
	      var buttonIndex;
	      var groupIndex;
	      if ($buttonEl.hasClass('list-button') || $buttonEl.hasClass('item-link')) {
	        buttonIndex = $buttonEl.parents('li').index();
	        groupIndex = $buttonEl.parents('.list').index();
	      } else {
	        buttonIndex = $buttonEl.index();
	        groupIndex = $buttonEl.parents('.actions-group').index();
	      }
	      if (typeof groups !== 'undefined') {
	        var button = groups[groupIndex][buttonIndex];
	        if (button.onClick) { button.onClick(actions, e); }
	        if (actions.params.onClick) { actions.params.onClick(actions, e); }
	        if (button.close !== false) { actions.close(); }
	      }
	    }
	    actions.open = function open(animate) {
	      var convertToPopover = false;
	      var ref = actions.params;
	      var targetEl = ref.targetEl;
	      var targetX = ref.targetX;
	      var targetY = ref.targetY;
	      var targetWidth = ref.targetWidth;
	      var targetHeight = ref.targetHeight;
	      if (actions.params.convertToPopover && (targetEl || (targetX !== undefined && targetY !== undefined))) {
	        // Popover
	        if (
	          actions.params.forceToPopover
	          || (app.device.ios && app.device.ipad)
	          || app.width >= 768
	          || (app.device.desktop && app.theme === 'aurora')
	        ) {
	          convertToPopover = true;
	        }
	      }
	      if (convertToPopover && actions.popoverHtml) {
	        popover = app.popover.create({
	          content: actions.popoverHtml,
	          backdrop: actions.params.backdrop,
	          targetEl: targetEl,
	          targetX: targetX,
	          targetY: targetY,
	          targetWidth: targetWidth,
	          targetHeight: targetHeight,
	        });
	        popover.open(animate);
	        popover.once('popoverOpened', function () {
	          popover.$el.find('.list-button, .item-link').each(function (groupIndex, buttonEl) {
	            $(buttonEl).on('click', buttonOnClick);
	          });
	        });
	        popover.once('popoverClosed', function () {
	          popover.$el.find('.list-button, .item-link').each(function (groupIndex, buttonEl) {
	            $(buttonEl).off('click', buttonOnClick);
	          });
	          Utils.nextTick(function () {
	            popover.destroy();
	            popover = undefined;
	          });
	        });
	      } else {
	        actions.$el = actions.actionsHtml ? $(actions.actionsHtml) : actions.$el;
	        actions.$el[0].f7Modal = actions;
	        if (actions.groups) {
	          actions.$el.find('.actions-button').each(function (groupIndex, buttonEl) {
	            $(buttonEl).on('click', buttonOnClick);
	          });
	          actions.once('actionsClosed', function () {
	            actions.$el.find('.actions-button').each(function (groupIndex, buttonEl) {
	              $(buttonEl).off('click', buttonOnClick);
	            });
	          });
	        }
	        actions.el = actions.$el[0];
	        originalOpen.call(actions, animate);
	      }
	      return actions;
	    };

	    actions.close = function close(animate) {
	      if (popover) {
	        popover.close(animate);
	      } else {
	        originalClose.call(actions, animate);
	      }
	      return actions;
	    };

	    Utils.extend(actions, {
	      app: app,
	      $el: $el,
	      el: $el ? $el[0] : undefined,
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl && $backdropEl[0],
	      type: 'actions',
	    });

	    function handleClick(e) {
	      var target = e.target;
	      var $target = $(target);
	      var keyboardOpened = !app.device.desktop && app.device.cordova && ((window.Keyboard && window.Keyboard.isVisible) || (window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible));
	      if (keyboardOpened) { return; }
	      if ($target.closest(actions.el).length === 0) {
	        if (
	          actions.params.closeByBackdropClick
	          && actions.params.backdrop
	          && actions.backdropEl
	          && actions.backdropEl === target
	        ) {
	          actions.close();
	        } else if (actions.params.closeByOutsideClick) {
	          actions.close();
	        }
	      }
	    }

	    function onKeyDown(e) {
	      var keyCode = e.keyCode;
	      if (keyCode === 27 && actions.params.closeOnEscape) {
	        actions.close();
	      }
	    }

	    if (actions.params.closeOnEscape) {
	      actions.on('open', function () {
	        $(document).on('keydown', onKeyDown);
	      });
	      actions.on('close', function () {
	        $(document).off('keydown', onKeyDown);
	      });
	    }

	    actions.on('opened', function () {
	      if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
	        app.on('click', handleClick);
	      }
	    });
	    actions.on('close', function () {
	      if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
	        app.off('click', handleClick);
	      }
	    });

	    if ($el) {
	      $el[0].f7Modal = actions;
	    }

	    return actions;
	  }

	  if ( Modal ) Actions.__proto__ = Modal;
	  Actions.prototype = Object.create( Modal && Modal.prototype );
	  Actions.prototype.constructor = Actions;

	  Actions.prototype.render = function render () {
	    var actions = this;
	    if (actions.params.render) { return actions.params.render.call(actions, actions); }
	    var groups = actions.groups;
	    return ("\n      <div class=\"actions-modal" + (actions.params.grid ? ' actions-grid' : '') + "\">\n        " + (groups.map(function (group) { return ("<div class=\"actions-group\">\n            " + (group.map(function (button) {
	              var buttonClasses = [("actions-" + (button.label ? 'label' : 'button'))];
	              var color = button.color;
	              var bg = button.bg;
	              var bold = button.bold;
	              var disabled = button.disabled;
	              var label = button.label;
	              var text = button.text;
	              var icon = button.icon;
	              if (color) { buttonClasses.push(("color-" + color)); }
	              if (bg) { buttonClasses.push(("bg-color-" + bg)); }
	              if (bold) { buttonClasses.push('actions-button-bold'); }
	              if (disabled) { buttonClasses.push('disabled'); }
	              if (label) {
	                return ("<div class=\"" + (buttonClasses.join(' ')) + "\">" + text + "</div>");
	              }
	              return ("\n                <div class=\"" + (buttonClasses.join(' ')) + "\">\n                  " + (icon ? ("<div class=\"actions-button-media\">" + icon + "</div>") : '') + "\n                  <div class=\"actions-button-text\">" + text + "</div>\n                </div>").trim();
	            }).join('')) + "\n          </div>"); }).join('')) + "\n      </div>\n    ").trim();
	  };

	  Actions.prototype.renderPopover = function renderPopover () {
	    var actions = this;
	    if (actions.params.renderPopover) { return actions.params.renderPopover.call(actions, actions); }
	    var groups = actions.groups;
	    return ("\n      <div class=\"popover popover-from-actions\">\n        <div class=\"popover-inner\">\n          " + (groups.map(function (group) { return ("\n            <div class=\"list\">\n              <ul>\n                " + (group.map(function (button) {
	                  var itemClasses = [];
	                  var color = button.color;
	                  var bg = button.bg;
	                  var bold = button.bold;
	                  var disabled = button.disabled;
	                  var label = button.label;
	                  var text = button.text;
	                  var icon = button.icon;
	                  if (color) { itemClasses.push(("color-" + color)); }
	                  if (bg) { itemClasses.push(("bg-color-" + bg)); }
	                  if (bold) { itemClasses.push('popover-from-actions-bold'); }
	                  if (disabled) { itemClasses.push('disabled'); }
	                  if (label) {
	                    itemClasses.push('popover-from-actions-label');
	                    return ("<li class=\"" + (itemClasses.join(' ')) + "\">" + text + "</li>");
	                  }
	                  if (icon) {
	                    itemClasses.push('item-link item-content');
	                    return ("\n                      <li>\n                        <a class=\"" + (itemClasses.join(' ')) + "\">\n                          <div class=\"item-media\">\n                            " + icon + "\n                          </div>\n                          <div class=\"item-inner\">\n                            <div class=\"item-title\">\n                              " + text + "\n                            </div>\n                          </div>\n                        </a>\n                      </li>\n                    ");
	                  }
	                  itemClasses.push('list-button');
	                  return ("\n                    <li>\n                      <a class=\"" + (itemClasses.join(' ')) + "\">" + text + "</a>\n                    </li>\n                  ");
	                }).join('')) + "\n              </ul>\n            </div>\n          "); }).join('')) + "\n        </div>\n      </div>\n    ").trim();
	  };

	  return Actions;
	}(Modal));

	var Actions$1 = {
	  name: 'actions',
	  params: {
	    actions: {
	      convertToPopover: true,
	      forceToPopover: false,
	      backdrop: true,
	      backdropEl: undefined,
	      closeByBackdropClick: true,
	      closeOnEscape: false,
	      render: null,
	      renderPopover: null,
	    },
	  },
	  static: {
	    Actions: Actions,
	  },
	  create: function create() {
	    var app = this;
	    app.actions = ModalMethods({
	      app: app,
	      constructor: Actions,
	      defaultSelector: '.actions-modal.modal-in',
	    });
	  },
	  clicks: {
	    '.actions-open': function openActions($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.actions.open(data.actions, data.animate);
	    },
	    '.actions-close': function closeActions($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.actions.close(data.actions, data.animate);
	    },
	  },
	};

	var Sheet = /*@__PURE__*/(function (Modal) {
	  function Sheet(app, params) {
	    var extendedParams = Utils.extend(
	      { on: {} },
	      app.params.sheet,
	      params
	    );

	    // Extends with open/close Modal methods;
	    Modal.call(this, extendedParams, app);

	    var sheet = this;

	    sheet.params = extendedParams;
	    if (typeof sheet.params.backdrop === 'undefined') {
	      sheet.params.backdrop = app.theme !== 'ios';
	    }

	    // Find Element
	    var $el;
	    if (!sheet.params.el) {
	      $el = $(sheet.params.content);
	    } else {
	      $el = $(sheet.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el.length === 0) {
	      return sheet.destroy();
	    }
	    var $backdropEl;

	    if (sheet.params.backdrop && sheet.params.backdropEl) {
	      $backdropEl = $(sheet.params.backdropEl);
	    } else if (sheet.params.backdrop) {
	      $backdropEl = app.root.children('.sheet-backdrop');
	      if ($backdropEl.length === 0) {
	        $backdropEl = $('<div class="sheet-backdrop"></div>');
	        app.root.append($backdropEl);
	      }
	    }

	    Utils.extend(sheet, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl && $backdropEl[0],
	      type: 'sheet',
	    });

	    var $pageContentEl;
	    function scrollToElementOnOpen() {
	      var $scrollEl = $(sheet.params.scrollToEl).eq(0);
	      if ($scrollEl.length === 0) { return; }
	      $pageContentEl = $scrollEl.parents('.page-content');
	      if ($pageContentEl.length === 0) { return; }

	      var paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
	      var paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
	      var pageHeight = $pageContentEl[0].offsetHeight - paddingTop - $el.height();
	      var pageScrollHeight = $pageContentEl[0].scrollHeight - paddingTop - $el.height();
	      var pageScroll = $pageContentEl.scrollTop();

	      var newPaddingBottom;

	      var scrollElTop = ($scrollEl.offset().top - paddingTop) + $scrollEl[0].offsetHeight;
	      if (scrollElTop > pageHeight) {
	        var scrollTop = (pageScroll + scrollElTop) - pageHeight;
	        if (scrollTop + pageHeight > pageScrollHeight) {
	          newPaddingBottom = ((scrollTop + pageHeight) - pageScrollHeight) + paddingBottom;
	          if (pageHeight === pageScrollHeight) {
	            newPaddingBottom = $el.height();
	          }
	          $pageContentEl.css({
	            'padding-bottom': (newPaddingBottom + "px"),
	          });
	        }
	        $pageContentEl.scrollTop(scrollTop, 300);
	      }
	    }

	    function scrollToElementOnClose() {
	      if ($pageContentEl && $pageContentEl.length > 0) {
	        $pageContentEl.css({
	          'padding-bottom': '',
	        });
	      }
	    }
	    function handleClick(e) {
	      var target = e.target;
	      var $target = $(target);
	      var keyboardOpened = !app.device.desktop && app.device.cordova && ((window.Keyboard && window.Keyboard.isVisible) || (window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible));
	      if (keyboardOpened) { return; }
	      if ($target.closest(sheet.el).length === 0) {
	        if (
	          sheet.params.closeByBackdropClick
	          && sheet.params.backdrop
	          && sheet.backdropEl
	          && sheet.backdropEl === target
	        ) {
	          sheet.close();
	        } else if (sheet.params.closeByOutsideClick) {
	          sheet.close();
	        }
	      }
	    }

	    function onKeyDown(e) {
	      var keyCode = e.keyCode;
	      if (keyCode === 27 && sheet.params.closeOnEscape) {
	        sheet.close();
	      }
	    }


	    var isTouched = false;
	    var startTouch;
	    var currentTouch;
	    var isScrolling;
	    var touchStartTime;
	    var touchesDiff;
	    var isMoved = false;
	    var isTopSheetModal;
	    var swipeStepTranslate;
	    var startTranslate;
	    var currentTranslate;
	    var sheetElOffsetHeight;
	    var minTranslate;
	    var maxTranslate;

	    function handleTouchStart(e) {
	      if (isTouched || !(sheet.params.swipeToClose || sheet.params.swipeToStep)) { return; }
	      if (sheet.params.swipeHandler && $(e.target).closest(sheet.params.swipeHandler).length === 0) {
	        return;
	      }
	      isTouched = true;
	      isMoved = false;
	      startTouch = {
	        x: e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX,
	        y: e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY,
	      };
	      touchStartTime = Utils.now();
	      isScrolling = undefined;
	      isTopSheetModal = $el.hasClass('sheet-modal-top');
	    }
	    function handleTouchMove(e) {
	      if (!isTouched) { return; }
	      currentTouch = {
	        x: e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX,
	        y: e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY,
	      };

	      if (typeof isScrolling === 'undefined') {
	        isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
	      }
	      if (isScrolling) {
	        isTouched = false;
	        isMoved = false;
	        return;
	      }

	      touchesDiff = startTouch.y - currentTouch.y;

	      if (!isMoved) {
	        sheetElOffsetHeight = $el[0].offsetHeight;
	        startTranslate = Utils.getTranslate($el[0], 'y');
	        if (isTopSheetModal) {
	          minTranslate = sheet.params.swipeToClose ? -sheetElOffsetHeight : -swipeStepTranslate;
	          maxTranslate = 0;
	        } else {
	          minTranslate = 0;
	          maxTranslate = sheet.params.swipeToClose ? sheetElOffsetHeight : swipeStepTranslate;
	        }
	        isMoved = true;
	      }
	      currentTranslate = startTranslate - touchesDiff;
	      currentTranslate = Math.min(Math.max(currentTranslate, minTranslate), maxTranslate);
	      e.preventDefault();
	      $el
	        .transition(0)
	        .transform(("translate3d(0," + currentTranslate + "px,0)"));
	    }
	    function handleTouchEnd() {
	      isTouched = false;
	      if (!isMoved) {
	        return;
	      }
	      isMoved = false;
	      $el.transform('').transition('');

	      var direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';

	      var diff = Math.abs(touchesDiff);
	      if (diff === 0 || currentTranslate === startTranslate) { return; }

	      var timeDiff = (new Date()).getTime() - touchStartTime;

	      if (!sheet.params.swipeToStep) {
	        if (direction !== (isTopSheetModal ? 'to-top' : 'to-bottom')) {
	          return;
	        }
	        if ((timeDiff < 300 && diff > 20) || (timeDiff >= 300 && diff > (sheetElOffsetHeight / 2))) {
	          sheet.close();
	        }
	        return;
	      }

	      var openDirection = isTopSheetModal ? 'to-bottom' : 'to-top';
	      var closeDirection = isTopSheetModal ? 'to-top' : 'to-bottom';
	      var absCurrentTranslate = Math.abs(currentTranslate);
	      var absSwipeStepTranslate = Math.abs(swipeStepTranslate);

	      if (timeDiff < 300 && diff > 10) {
	        if (direction === openDirection && absCurrentTranslate < absSwipeStepTranslate) {
	          // open step
	          $el.removeClass('modal-in-swipe-step');
	          $el.trigger('sheet:stepopen');
	          sheet.emit('local::stepOpen sheetStepOpen', sheet);
	        }
	        if (direction === closeDirection && absCurrentTranslate > absSwipeStepTranslate) {
	          // close sheet
	          if (sheet.params.swipeToClose) {
	            sheet.close();
	          } else {
	            // close step
	            $el.addClass('modal-in-swipe-step');
	            $el.trigger('sheet:stepclose');
	            sheet.emit('local::stepClose sheetStepClose', sheet);
	          }
	        }
	        if (direction === closeDirection && absCurrentTranslate <= absSwipeStepTranslate) {
	          // close step
	          $el.addClass('modal-in-swipe-step');
	          $el.trigger('sheet:stepclose');
	          sheet.emit('local::stepClose sheetStepClose', sheet);
	        }
	        return;
	      }
	      if (timeDiff >= 300) {
	        var stepOpened = !$el.hasClass('modal-in-swipe-step');
	        if (!stepOpened) {
	          if (absCurrentTranslate < (absSwipeStepTranslate / 2)) {
	            // open step
	            $el.removeClass('modal-in-swipe-step');
	            $el.trigger('sheet:stepopen');
	            sheet.emit('local::stepOpen sheetStepOpen', sheet);
	          } else if ((absCurrentTranslate - absSwipeStepTranslate) > (sheetElOffsetHeight - absSwipeStepTranslate) / 2) {
	            // close sheet
	            if (sheet.params.swipeToClose) { sheet.close(); }
	          }
	        } else if (stepOpened) {
	          if (absCurrentTranslate > absSwipeStepTranslate + (sheetElOffsetHeight - absSwipeStepTranslate) / 2) {
	            // close sheet
	            if (sheet.params.swipeToClose) { sheet.close(); }
	          } else if (absCurrentTranslate > absSwipeStepTranslate / 2) {
	            // close step
	            $el.addClass('modal-in-swipe-step');
	            $el.trigger('sheet:stepclose');
	            sheet.emit('local::stepClose sheetStepClose', sheet);
	          }
	        }
	      }
	    }

	    function setSwipeStep(byResize) {
	      var $swipeStepEl = $el.find('.sheet-modal-swipe-step').eq(0);
	      if (!$swipeStepEl.length) { return; }
	      if ($el.hasClass('sheet-modal-top')) {
	        swipeStepTranslate = -($swipeStepEl.offset().top - $el.offset().top + $swipeStepEl[0].offsetHeight);
	      } else {
	        swipeStepTranslate = $el[0].offsetHeight - ($swipeStepEl.offset().top - $el.offset().top + $swipeStepEl[0].offsetHeight);
	      }
	      $el[0].style.setProperty('--f7-sheet-swipe-step', (swipeStepTranslate + "px"));
	      if (!byResize) {
	        $el.addClass('modal-in-swipe-step');
	      }
	    }

	    function onResize() {
	      setSwipeStep(true);
	    }

	    var passive = Support.passiveListener ? { passive: true } : false;
	    if (sheet.params.swipeToClose || sheet.params.swipeToStep) {
	      $el.on(app.touchEvents.start, handleTouchStart, passive);
	      app.on('touchmove', handleTouchMove);
	      app.on('touchend:passive', handleTouchEnd);
	      sheet.once('sheetDestroy', function () {
	        $el.off(app.touchEvents.start, handleTouchStart, passive);
	        app.off('touchmove', handleTouchMove);
	        app.off('touchend:passive', handleTouchEnd);
	      });
	    }

	    sheet.on('sheetOpen', function () {
	      if (sheet.params.closeOnEscape) {
	        $(document).on('keydown', onKeyDown);
	      }
	      if (sheet.params.swipeToStep) {
	        setSwipeStep();
	        app.on('resize', onResize);
	      }
	      if (sheet.params.scrollToEl) {
	        scrollToElementOnOpen();
	      }
	    });
	    sheet.on('sheetOpened', function () {
	      if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
	        app.on('click', handleClick);
	      }
	    });
	    sheet.on('sheetClose', function () {
	      if (sheet.params.swipeToStep) {
	        $el.removeClass('modal-in-swipe-step');
	        app.off('resize', onResize);
	      }
	      if (sheet.params.closeOnEscape) {
	        $(document).off('keydown', onKeyDown);
	      }
	      if (sheet.params.scrollToEl) {
	        scrollToElementOnClose();
	      }
	      if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
	        app.off('click', handleClick);
	      }
	    });

	    sheet.stepOpen = function stepOpen() {
	      $el.removeClass('modal-in-swipe-step');
	    };
	    sheet.stepClose = function stepClose() {
	      $el.addClass('modal-in-swipe-step');
	    };
	    sheet.stepToggle = function stepToggle() {
	      $el.toggleClass('modal-in-swipe-step');
	    };

	    $el[0].f7Modal = sheet;

	    return sheet;
	  }

	  if ( Modal ) Sheet.__proto__ = Modal;
	  Sheet.prototype = Object.create( Modal && Modal.prototype );
	  Sheet.prototype.constructor = Sheet;

	  return Sheet;
	}(Modal));

	var Sheet$1 = {
	  name: 'sheet',
	  params: {
	    sheet: {
	      backdrop: undefined,
	      backdropEl: undefined,
	      closeByBackdropClick: true,
	      closeByOutsideClick: false,
	      closeOnEscape: false,
	      swipeToClose: false,
	      swipeToStep: false,
	      swipeHandler: null,
	    },
	  },
	  static: {
	    Sheet: Sheet,
	  },
	  create: function create() {
	    var app = this;
	    app.sheet = Utils.extend(
	      {},
	      ModalMethods({
	        app: app,
	        constructor: Sheet,
	        defaultSelector: '.sheet-modal.modal-in',
	      }),
	      {
	        stepOpen: function stepOpen(sheet) {
	          var sheetInstance = app.sheet.get(sheet);
	          if (sheetInstance && sheetInstance.stepOpen) { return sheetInstance.stepOpen(); }
	          return undefined;
	        },
	        stepClose: function stepClose(sheet) {
	          var sheetInstance = app.sheet.get(sheet);
	          if (sheetInstance && sheetInstance.stepClose) { return sheetInstance.stepClose(); }
	          return undefined;
	        },
	        stepToggle: function stepToggle(sheet) {
	          var sheetInstance = app.sheet.get(sheet);
	          if (sheetInstance && sheetInstance.stepToggle) { return sheetInstance.stepToggle(); }
	          return undefined;
	        },
	      }
	    );
	  },
	  clicks: {
	    '.sheet-open': function openSheet($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      if ($('.sheet-modal.modal-in').length > 0 && data.sheet && $(data.sheet)[0] !== $('.sheet-modal.modal-in')[0]) {
	        app.sheet.close('.sheet-modal.modal-in');
	      }
	      app.sheet.open(data.sheet, data.animate);
	    },
	    '.sheet-close': function closeSheet($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.sheet.close(data.sheet, data.animate);
	    },
	  },
	};

	var Toast = /*@__PURE__*/(function (Modal) {
	  function Toast(app, params) {
	    var extendedParams = Utils.extend({
	      on: {},
	    }, app.params.toast, params);

	    // Extends with open/close Modal methods;
	    Modal.call(this, extendedParams, app);

	    var toast = this;

	    toast.app = app;

	    toast.params = extendedParams;

	    var ref = toast.params;
	    var closeButton = ref.closeButton;
	    var closeTimeout = ref.closeTimeout;

	    var $el;
	    if (!toast.params.el) {
	      // Find Element
	      var toastHtml = toast.render();

	      $el = $(toastHtml);
	    } else {
	      $el = $(toast.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el.length === 0) {
	      return toast.destroy();
	    }

	    Utils.extend(toast, {
	      $el: $el,
	      el: $el[0],
	      type: 'toast',
	    });

	    $el[0].f7Modal = toast;

	    if (closeButton) {
	      $el.find('.toast-button').on('click', function () {
	        toast.emit('local::closeButtonClick toastCloseButtonClick', toast);
	        toast.close();
	      });

	      toast.on('beforeDestroy', function () {
	        $el.find('.toast-button').off('click');
	      });
	    }

	    var timeoutId;
	    toast.on('open', function () {
	      $('.toast.modal-in').each(function (index, openedEl) {
	        var toastInstance = app.toast.get(openedEl);
	        if (openedEl !== toast.el && toastInstance) {
	          toastInstance.close();
	        }
	      });
	      if (closeTimeout) {
	        timeoutId = Utils.nextTick(function () {
	          toast.close();
	        }, closeTimeout);
	      }
	    });
	    toast.on('close', function () {
	      win.clearTimeout(timeoutId);
	    });

	    if (toast.params.destroyOnClose) {
	      toast.once('closed', function () {
	        setTimeout(function () {
	          toast.destroy();
	        }, 0);
	      });
	    }

	    return toast;
	  }

	  if ( Modal ) Toast.__proto__ = Modal;
	  Toast.prototype = Object.create( Modal && Modal.prototype );
	  Toast.prototype.constructor = Toast;

	  Toast.prototype.render = function render () {
	    var toast = this;
	    if (toast.params.render) { return toast.params.render.call(toast, toast); }
	    var ref = toast.params;
	    var position = ref.position;
	    var cssClass = ref.cssClass;
	    var icon = ref.icon;
	    var text = ref.text;
	    var closeButton = ref.closeButton;
	    var closeButtonColor = ref.closeButtonColor;
	    var closeButtonText = ref.closeButtonText;
	    return ("\n      <div class=\"toast toast-" + position + " " + (cssClass || '') + " " + (icon ? 'toast-with-icon' : '') + "\">\n        <div class=\"toast-content\">\n          " + (icon ? ("<div class=\"toast-icon\">" + icon + "</div>") : '') + "\n          <div class=\"toast-text\">" + text + "</div>\n          " + (closeButton && !icon ? ("\n          <a class=\"toast-button button " + (closeButtonColor ? ("color-" + closeButtonColor) : '') + "\">" + closeButtonText + "</a>\n          ").trim() : '') + "\n        </div>\n      </div>\n    ").trim();
	  };

	  return Toast;
	}(Modal));

	var Toast$1 = {
	  name: 'toast',
	  static: {
	    Toast: Toast,
	  },
	  create: function create() {
	    var app = this;
	    app.toast = Utils.extend(
	      {},
	      ModalMethods({
	        app: app,
	        constructor: Toast,
	        defaultSelector: '.toast.modal-in',
	      }),
	      {
	        // Shortcuts
	        show: function show(params) {
	          Utils.extend(params, {
	            destroyOnClose: true,
	          });
	          return new Toast(app, params).open();
	        },
	      }
	    );
	  },
	  params: {
	    toast: {
	      icon: null,
	      text: null,
	      position: 'bottom',
	      closeButton: false,
	      closeButtonColor: null,
	      closeButtonText: 'Ok',
	      closeTimeout: null,
	      cssClass: null,
	      render: null,
	    },
	  },
	};

	var Preloader = {
	  init: function init(el) {
	    var app = this;
	    var $el = $(el);
	    if ($el.length === 0 || $el.children('.preloader-inner').length > 0 || $el.children('.preloader-inner-line').length > 0) { return; }
	    $el.append(Utils[((app.theme) + "PreloaderContent")]);
	  },
	  // Modal
	  visible: false,
	  show: function show(color) {
	    if ( color === void 0 ) color = 'white';

	    var app = this;
	    if (Preloader.visible) { return; }
	    var preloaderInner = Utils[((app.theme) + "PreloaderContent")] || '';
	    $('html').addClass('with-modal-preloader');
	    app.root.append(("\n      <div class=\"preloader-backdrop\"></div>\n      <div class=\"preloader-modal\">\n        <div class=\"preloader color-" + color + "\">" + preloaderInner + "</div>\n      </div>\n    "));
	    Preloader.visible = true;
	  },
	  hide: function hide() {
	    var app = this;
	    if (!Preloader.visible) { return; }
	    $('html').removeClass('with-modal-preloader');
	    app.root.find('.preloader-backdrop, .preloader-modal').remove();
	    Preloader.visible = false;
	  },
	};
	var Preloader$1 = {
	  name: 'preloader',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      preloader: {
	        init: Preloader.init.bind(app),
	        show: Preloader.show.bind(app),
	        hide: Preloader.hide.bind(app),
	      },
	    });
	  },
	  on: {
	    photoBrowserOpen: function photoBrowserOpen(pb) {
	      var app = this;
	      pb.$el.find('.preloader').each(function (index, preloaderEl) {
	        app.preloader.init(preloaderEl);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.preloader').each(function (index, preloaderEl) {
	        app.preloader.init(preloaderEl);
	      });
	    },
	  },
	  vnode: {
	    preloader: {
	      insert: function insert(vnode) {
	        var app = this;
	        var preloaderEl = vnode.elm;
	        app.preloader.init(preloaderEl);
	      },
	    },
	  },
	};

	var Progressbar = {
	  set: function set() {
	    var assign;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var app = this;
	    var el = args[0];
	    var progress = args[1];
	    var duration = args[2];
	    if (typeof args[0] === 'number') {
	      (assign = args, progress = assign[0], duration = assign[1]);
	      el = app.root;
	    }
	    if (typeof progress === 'undefined' || progress === null) { return el; }
	    if (!progress) { progress = 0; }

	    var $el = $(el || app.root);
	    if ($el.length === 0) {
	      return el;
	    }
	    var progressNormalized = Math.min(Math.max(progress, 0), 100);
	    var $progressbarEl;
	    if ($el.hasClass('progressbar')) { $progressbarEl = $el.eq(0); }
	    else {
	      $progressbarEl = $el.children('.progressbar');
	    }
	    if ($progressbarEl.length === 0 || $progressbarEl.hasClass('progressbar-infinite')) {
	      return $progressbarEl;
	    }
	    var $progressbarLine = $progressbarEl.children('span');
	    if ($progressbarLine.length === 0) {
	      $progressbarLine = $('<span></span>');
	      $progressbarEl.append($progressbarLine);
	    }
	    $progressbarLine
	      .transition(typeof duration !== 'undefined' ? duration : '')
	      .transform(("translate3d(" + ((-100 + progressNormalized)) + "%,0,0)"));

	    return $progressbarEl[0];
	  },
	  show: function show() {
	    var assign, assign$1;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var app = this;

	    // '.page', 50, 'multi'
	    var el = args[0];
	    var progress = args[1];
	    var color = args[2];
	    var type = 'determined';

	    if (args.length === 2) {
	      if ((typeof args[0] === 'string' || typeof args[0] === 'object') && typeof args[1] === 'string') {
	        // '.page', 'multi'
	        (assign = args, el = assign[0], color = assign[1], progress = assign[2]);
	        type = 'infinite';
	      } else if (typeof args[0] === 'number' && typeof args[1] === 'string') {
	        // 50, 'multi'
	        (assign$1 = args, progress = assign$1[0], color = assign$1[1]);
	        el = app.root;
	      }
	    } else if (args.length === 1) {
	      if (typeof args[0] === 'number') {
	        el = app.root;
	        progress = args[0];
	      } else if (typeof args[0] === 'string') {
	        type = 'infinite';
	        el = app.root;
	        color = args[0];
	      }
	    } else if (args.length === 0) {
	      type = 'infinite';
	      el = app.root;
	    }

	    var $el = $(el);
	    if ($el.length === 0) { return undefined; }

	    var $progressbarEl;
	    if ($el.hasClass('progressbar') || $el.hasClass('progressbar-infinite')) {
	      $progressbarEl = $el;
	    } else {
	      $progressbarEl = $el.children('.progressbar:not(.progressbar-out), .progressbar-infinite:not(.progressbar-out)');
	      if ($progressbarEl.length === 0) {
	        $progressbarEl = $(("\n          <span class=\"progressbar" + (type === 'infinite' ? '-infinite' : '') + (color ? (" color-" + color) : '') + " progressbar-in\">\n            " + (type === 'infinite' ? '' : '<span></span>') + "\n          </span>"));
	        $el.append($progressbarEl);
	      }
	    }

	    if (typeof progress !== 'undefined') {
	      app.progressbar.set($progressbarEl, progress);
	    }

	    return $progressbarEl[0];
	  },
	  hide: function hide(el, removeAfterHide) {
	    if ( removeAfterHide === void 0 ) removeAfterHide = true;

	    var app = this;
	    var $el = $(el || app.root);
	    if ($el.length === 0) { return undefined; }
	    var $progressbarEl;
	    if ($el.hasClass('progressbar') || $el.hasClass('progressbar-infinite')) {
	      $progressbarEl = $el;
	    } else {
	      $progressbarEl = $el.children('.progressbar, .progressbar-infinite');
	    }
	    if ($progressbarEl.length === 0 || !$progressbarEl.hasClass('progressbar-in') || $progressbarEl.hasClass('progressbar-out')) {
	      return $progressbarEl;
	    }
	    $progressbarEl
	      .removeClass('progressbar-in')
	      .addClass('progressbar-out')
	      .animationEnd(function () {
	        if (removeAfterHide) {
	          $progressbarEl.remove();
	        }
	      });
	    return $progressbarEl;
	  },
	};

	var Progressbar$1 = {
	  name: 'progressbar',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      progressbar: {
	        set: Progressbar.set.bind(app),
	        show: Progressbar.show.bind(app),
	        hide: Progressbar.hide.bind(app),
	      },
	    });
	  },
	  on: {
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.progressbar').each(function (index, progressbarEl) {
	        var $progressbarEl = $(progressbarEl);
	        app.progressbar.set($progressbarEl, $progressbarEl.attr('data-progress'));
	      });
	    },
	  },
	};

	var Sortable = {
	  init: function init() {
	    var app = this;
	    var isTouched;
	    var isMoved;
	    var touchStartY;
	    var touchesDiff;
	    var $sortingEl;
	    var $sortingItems;
	    var $sortableContainer;
	    var sortingElHeight;
	    var minTop;
	    var maxTop;
	    var $insertAfterEl;
	    var $insertBeforeEl;
	    var indexFrom;
	    var $pageEl;
	    var $pageContentEl;
	    var pageHeight;
	    var pageOffset;
	    var sortingElOffsetLocal;
	    var sortingElOffsetTop;
	    var initialScrollTop;

	    function handleTouchStart(e) {
	      isMoved = false;
	      isTouched = true;
	      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	      $sortingEl = $(this).parent('li');
	      indexFrom = $sortingEl.index();
	      $sortableContainer = $sortingEl.parents('.sortable');
	      var $listGroup = $sortingEl.parents('.list-group');
	      if ($listGroup.length && $listGroup.parents($sortableContainer).length) {
	        $sortableContainer = $listGroup;
	      }
	      $sortingItems = $sortableContainer.children('ul').children('li');
	      if (app.panel) { app.panel.allowOpen = false; }
	      if (app.swipeout) { app.swipeout.allow = false; }
	    }
	    function handleTouchMove(e) {
	      if (!isTouched || !$sortingEl) { return; }
	      var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      if (!isMoved) {
	        $pageEl = $sortingEl.parents('.page');
	        $pageContentEl = $sortingEl.parents('.page-content');
	        var paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
	        var paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
	        initialScrollTop = $pageContentEl[0].scrollTop;
	        pageOffset = $pageEl.offset().top + paddingTop;
	        pageHeight = $pageEl.height() - paddingTop - paddingBottom;
	        $sortingEl.addClass('sorting');
	        $sortableContainer.addClass('sortable-sorting');
	        sortingElOffsetLocal = $sortingEl[0].offsetTop;
	        minTop = $sortingEl[0].offsetTop;
	        maxTop = $sortingEl.parent().height() - sortingElOffsetLocal - $sortingEl.height();
	        sortingElHeight = $sortingEl[0].offsetHeight;
	        sortingElOffsetTop = $sortingEl.offset().top;
	      }
	      isMoved = true;

	      e.preventDefault();
	      e.f7PreventSwipePanel = true;

	      touchesDiff = pageY - touchStartY;

	      var translateScrollOffset = $pageContentEl[0].scrollTop - initialScrollTop;
	      var translate = Math.min(Math.max(touchesDiff + translateScrollOffset, -minTop), maxTop);
	      $sortingEl.transform(("translate3d(0," + translate + "px,0)"));

	      var scrollAddition = 44;
	      var allowScroll = true;
	      if ((touchesDiff + translateScrollOffset) + scrollAddition < -minTop) {
	        allowScroll = false;
	      }
	      if ((touchesDiff + translateScrollOffset) - scrollAddition > maxTop) {
	        allowScroll = false;
	      }

	      $insertBeforeEl = undefined;
	      $insertAfterEl = undefined;

	      var scrollDiff;
	      if (allowScroll) {
	        if (sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition > pageOffset + pageHeight) {
	          // To Bottom
	          scrollDiff = (sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition) - (pageOffset + pageHeight);
	        }
	        if (sortingElOffsetTop + touchesDiff < pageOffset + scrollAddition) {
	          // To Top
	          scrollDiff = (sortingElOffsetTop + touchesDiff) - pageOffset - scrollAddition;
	        }
	        if (scrollDiff) {
	          $pageContentEl[0].scrollTop += scrollDiff;
	        }
	      }

	      $sortingItems.each(function (index, el) {
	        var $currentEl = $(el);
	        if ($currentEl[0] === $sortingEl[0]) { return; }
	        var currentElOffset = $currentEl[0].offsetTop;
	        var currentElHeight = $currentEl.height();
	        var sortingElOffset = sortingElOffsetLocal + translate;

	        if ((sortingElOffset >= currentElOffset - (currentElHeight / 2)) && $sortingEl.index() < $currentEl.index()) {
	          $currentEl.transform(("translate3d(0, " + (-sortingElHeight) + "px,0)"));
	          $insertAfterEl = $currentEl;
	          $insertBeforeEl = undefined;
	        } else if ((sortingElOffset <= currentElOffset + (currentElHeight / 2)) && $sortingEl.index() > $currentEl.index()) {
	          $currentEl.transform(("translate3d(0, " + sortingElHeight + "px,0)"));
	          $insertAfterEl = undefined;
	          if (!$insertBeforeEl) { $insertBeforeEl = $currentEl; }
	        } else {
	          $currentEl.transform('translate3d(0, 0%,0)');
	        }
	      });
	    }
	    function handleTouchEnd() {
	      if (!isTouched || !isMoved) {
	        isTouched = false;
	        isMoved = false;
	        if (isTouched && !isMoved) {
	          if (app.panel) { app.panel.allowOpen = true; }
	          if (app.swipeout) { app.swipeout.allow = true; }
	        }
	        return;
	      }
	      if (app.panel) { app.panel.allowOpen = true; }
	      if (app.swipeout) { app.swipeout.allow = true; }

	      $sortingItems.transform('');
	      $sortingEl.removeClass('sorting');
	      $sortableContainer.removeClass('sortable-sorting');

	      var indexTo;
	      if ($insertAfterEl) { indexTo = $insertAfterEl.index(); }
	      else if ($insertBeforeEl) { indexTo = $insertBeforeEl.index(); }

	      if (app.params.sortable.moveElements) {
	        if ($insertAfterEl) {
	          $sortingEl.insertAfter($insertAfterEl);
	        }
	        if ($insertBeforeEl) {
	          $sortingEl.insertBefore($insertBeforeEl);
	        }
	      }

	      if (($insertAfterEl || $insertBeforeEl)
	         && $sortableContainer.hasClass('virtual-list')
	      ) {
	        indexFrom = $sortingEl[0].f7VirtualListIndex;
	        if (typeof indexFrom === 'undefined') { indexFrom = $sortingEl.attr('data-virtual-list-index'); }
	        if ($insertBeforeEl) {
	          indexTo = $insertBeforeEl[0].f7VirtualListIndex;
	          if (typeof indexTo === 'undefined') { indexTo = $insertBeforeEl.attr('data-virtual-list-index'); }
	        } else {
	          indexTo = $insertAfterEl[0].f7VirtualListIndex;
	          if (typeof indexTo === 'undefined') { indexTo = $insertAfterEl.attr('data-virtual-list-index'); }
	        }
	        if (indexTo !== null) { indexTo = parseInt(indexTo, 10); }
	        else { indexTo = undefined; }

	        var virtualList = $sortableContainer[0].f7VirtualList;
	        if (virtualList) { virtualList.moveItem(indexFrom, indexTo); }
	      }
	      if (typeof indexTo !== 'undefined' && !Number.isNaN(indexTo) && indexTo !== indexFrom) {
	        $sortingEl.trigger('sortable:sort', { from: indexFrom, to: indexTo });
	        app.emit('sortableSort', $sortingEl[0], { from: indexFrom, to: indexTo });
	      }

	      $insertBeforeEl = undefined;
	      $insertAfterEl = undefined;
	      isTouched = false;
	      isMoved = false;
	    }

	    var activeListener = app.support.passiveListener ? { passive: false, capture: false } : false;

	    $(doc).on(app.touchEvents.start, '.list.sortable .sortable-handler', handleTouchStart, activeListener);
	    app.on('touchmove:active', handleTouchMove);
	    app.on('touchend:passive', handleTouchEnd);
	  },
	  enable: function enable(el) {
	    if ( el === void 0 ) el = '.list.sortable';

	    var app = this;
	    var $el = $(el);
	    if ($el.length === 0) { return; }
	    $el.addClass('sortable-enabled');
	    $el.trigger('sortable:enable');
	    app.emit('sortableEnable', $el[0]);
	  },
	  disable: function disable(el) {
	    if ( el === void 0 ) el = '.list.sortable';

	    var app = this;
	    var $el = $(el);
	    if ($el.length === 0) { return; }
	    $el.removeClass('sortable-enabled');
	    $el.trigger('sortable:disable');
	    app.emit('sortableDisable', $el[0]);
	  },
	  toggle: function toggle(el) {
	    if ( el === void 0 ) el = '.list.sortable';

	    var app = this;
	    var $el = $(el);
	    if ($el.length === 0) { return; }
	    if ($el.hasClass('sortable-enabled')) {
	      app.sortable.disable($el);
	    } else {
	      app.sortable.enable($el);
	    }
	  },
	};
	var Sortable$1 = {
	  name: 'sortable',
	  params: {
	    sortable: {
	      moveElements: true,
	    },
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      sortable: {
	        init: Sortable.init.bind(app),
	        enable: Sortable.enable.bind(app),
	        disable: Sortable.disable.bind(app),
	        toggle: Sortable.toggle.bind(app),
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      if (!app.params.sortable) { return; }
	      app.sortable.init();
	    },
	  },
	  clicks: {
	    '.sortable-enable': function enable($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.sortable.enable(data.sortable);
	    },
	    '.sortable-disable': function disable($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.sortable.disable(data.sortable);
	    },
	    '.sortable-toggle': function toggle($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.sortable.toggle(data.sortable);
	    },
	  },
	};

	var Swipeout = {
	  init: function init() {
	    var app = this;
	    var touchesStart = {};
	    var isTouched;
	    var isMoved;
	    var isScrolling;
	    var touchStartTime;
	    var touchesDiff;
	    var $swipeoutEl;
	    var $swipeoutContent;
	    var $actionsRight;
	    var $actionsLeft;
	    var actionsLeftWidth;
	    var actionsRightWidth;
	    var translate;
	    var opened;
	    var openedActionsSide;
	    var $leftButtons;
	    var $rightButtons;
	    var direction;
	    var $overswipeLeftButton;
	    var $overswipeRightButton;
	    var overswipeLeft;
	    var overswipeRight;

	    function handleTouchStart(e) {
	      if (!Swipeout.allow) { return; }
	      isMoved = false;
	      isTouched = true;
	      isScrolling = undefined;
	      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	      touchStartTime = (new Date()).getTime();
	      $swipeoutEl = $(this);
	    }
	    function handleTouchMove(e) {
	      if (!isTouched) { return; }
	      var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	      var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      if (typeof isScrolling === 'undefined') {
	        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
	      }
	      if (isScrolling) {
	        isTouched = false;
	        return;
	      }

	      if (!isMoved) {
	        if ($('.list.sortable-opened').length > 0) { return; }
	        $swipeoutContent = $swipeoutEl.find('.swipeout-content');
	        $actionsRight = $swipeoutEl.find('.swipeout-actions-right');
	        $actionsLeft = $swipeoutEl.find('.swipeout-actions-left');
	        actionsLeftWidth = null;
	        actionsRightWidth = null;
	        $leftButtons = null;
	        $rightButtons = null;
	        $overswipeRightButton = null;
	        $overswipeLeftButton = null;
	        if ($actionsLeft.length > 0) {
	          actionsLeftWidth = $actionsLeft.outerWidth();
	          $leftButtons = $actionsLeft.children('a');
	          $overswipeLeftButton = $actionsLeft.find('.swipeout-overswipe');
	        }
	        if ($actionsRight.length > 0) {
	          actionsRightWidth = $actionsRight.outerWidth();
	          $rightButtons = $actionsRight.children('a');
	          $overswipeRightButton = $actionsRight.find('.swipeout-overswipe');
	        }
	        opened = $swipeoutEl.hasClass('swipeout-opened');
	        if (opened) {
	          openedActionsSide = $swipeoutEl.find('.swipeout-actions-left.swipeout-actions-opened').length > 0 ? 'left' : 'right';
	        }
	        $swipeoutEl.removeClass('swipeout-transitioning');
	        if (!app.params.swipeout.noFollow) {
	          $swipeoutEl.find('.swipeout-actions-opened').removeClass('swipeout-actions-opened');
	          $swipeoutEl.removeClass('swipeout-opened');
	        }
	      }
	      isMoved = true;
	      e.preventDefault();

	      touchesDiff = pageX - touchesStart.x;
	      translate = touchesDiff;

	      if (opened) {
	        if (openedActionsSide === 'right') { translate -= actionsRightWidth; }
	        else { translate += actionsLeftWidth; }
	      }

	      if (
	        (translate > 0 && $actionsLeft.length === 0)
	        || (translate < 0 && $actionsRight.length === 0)
	      ) {
	        if (!opened) {
	          isTouched = false;
	          isMoved = false;
	          $swipeoutContent.transform('');
	          if ($rightButtons && $rightButtons.length > 0) {
	            $rightButtons.transform('');
	          }
	          if ($leftButtons && $leftButtons.length > 0) {
	            $leftButtons.transform('');
	          }
	          return;
	        }
	        translate = 0;
	      }

	      if (translate < 0) { direction = 'to-left'; }
	      else if (translate > 0) { direction = 'to-right'; }
	      else if (!direction) { direction = 'to-left'; }

	      var buttonOffset;
	      var progress;

	      e.f7PreventSwipePanel = true;
	      if (app.params.swipeout.noFollow) {
	        if (opened) {
	          if (openedActionsSide === 'right' && touchesDiff > 0) {
	            app.swipeout.close($swipeoutEl);
	          }
	          if (openedActionsSide === 'left' && touchesDiff < 0) {
	            app.swipeout.close($swipeoutEl);
	          }
	        } else {
	          if (touchesDiff < 0 && $actionsRight.length > 0) {
	            app.swipeout.open($swipeoutEl, 'right');
	          }
	          if (touchesDiff > 0 && $actionsLeft.length > 0) {
	            app.swipeout.open($swipeoutEl, 'left');
	          }
	        }
	        isTouched = false;
	        isMoved = false;
	        return;
	      }
	      overswipeLeft = false;
	      overswipeRight = false;
	      if ($actionsRight.length > 0) {
	        // Show right actions
	        var buttonTranslate = translate;
	        progress = buttonTranslate / actionsRightWidth;
	        if (buttonTranslate < -actionsRightWidth) {
	          buttonTranslate = -actionsRightWidth - (Math.pow( (-buttonTranslate - actionsRightWidth), 0.8 ));
	          translate = buttonTranslate;
	          if ($overswipeRightButton.length > 0) {
	            overswipeRight = true;
	          }
	        }
	        if (direction !== 'to-left') {
	          progress = 0;
	          buttonTranslate = 0;
	        }
	        $rightButtons.each(function (index, buttonEl) {
	          var $buttonEl = $(buttonEl);
	          if (typeof buttonEl.f7SwipeoutButtonOffset === 'undefined') {
	            $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
	          }
	          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
	          if ($overswipeRightButton.length > 0 && $buttonEl.hasClass('swipeout-overswipe') && direction === 'to-left') {
	            $buttonEl.css({ left: ((overswipeRight ? -buttonOffset : 0) + "px") });
	            if (overswipeRight) {
	              if (!$buttonEl.hasClass('swipeout-overswipe-active')) {
	                $swipeoutEl.trigger('swipeout:overswipeenter');
	                app.emit('swipeoutOverswipeEnter', $swipeoutEl[0]);
	              }
	              $buttonEl.addClass('swipeout-overswipe-active');
	            } else {
	              if ($buttonEl.hasClass('swipeout-overswipe-active')) {
	                $swipeoutEl.trigger('swipeout:overswipeexit');
	                app.emit('swipeoutOverswipeExit', $swipeoutEl[0]);
	              }
	              $buttonEl.removeClass('swipeout-overswipe-active');
	            }
	          }
	          $buttonEl.transform(("translate3d(" + (buttonTranslate - (buttonOffset * (1 + Math.max(progress, -1)))) + "px,0,0)"));
	        });
	      }
	      if ($actionsLeft.length > 0) {
	        // Show left actions
	        var buttonTranslate$1 = translate;
	        progress = buttonTranslate$1 / actionsLeftWidth;
	        if (buttonTranslate$1 > actionsLeftWidth) {
	          buttonTranslate$1 = actionsLeftWidth + (Math.pow( (buttonTranslate$1 - actionsLeftWidth), 0.8 ));
	          translate = buttonTranslate$1;
	          if ($overswipeLeftButton.length > 0) {
	            overswipeLeft = true;
	          }
	        }
	        if (direction !== 'to-right') {
	          buttonTranslate$1 = 0;
	          progress = 0;
	        }
	        $leftButtons.each(function (index, buttonEl) {
	          var $buttonEl = $(buttonEl);
	          if (typeof buttonEl.f7SwipeoutButtonOffset === 'undefined') {
	            $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
	          }
	          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
	          if ($overswipeLeftButton.length > 0 && $buttonEl.hasClass('swipeout-overswipe') && direction === 'to-right') {
	            $buttonEl.css({ left: ((overswipeLeft ? buttonOffset : 0) + "px") });
	            if (overswipeLeft) {
	              if (!$buttonEl.hasClass('swipeout-overswipe-active')) {
	                $swipeoutEl.trigger('swipeout:overswipeenter');
	                app.emit('swipeoutOverswipeEnter', $swipeoutEl[0]);
	              }
	              $buttonEl.addClass('swipeout-overswipe-active');
	            } else {
	              if ($buttonEl.hasClass('swipeout-overswipe-active')) {
	                $swipeoutEl.trigger('swipeout:overswipeexit');
	                app.emit('swipeoutOverswipeExit', $swipeoutEl[0]);
	              }
	              $buttonEl.removeClass('swipeout-overswipe-active');
	            }
	          }
	          if ($leftButtons.length > 1) {
	            $buttonEl.css('z-index', $leftButtons.length - index);
	          }
	          $buttonEl.transform(("translate3d(" + (buttonTranslate$1 + (buttonOffset * (1 - Math.min(progress, 1)))) + "px,0,0)"));
	        });
	      }
	      $swipeoutEl.trigger('swipeout', progress);
	      app.emit('swipeout', $swipeoutEl[0], progress);
	      $swipeoutContent.transform(("translate3d(" + translate + "px,0,0)"));
	    }
	    function handleTouchEnd() {
	      if (!isTouched || !isMoved) {
	        isTouched = false;
	        isMoved = false;
	        return;
	      }

	      isTouched = false;
	      isMoved = false;
	      var timeDiff = (new Date()).getTime() - touchStartTime;
	      var $actions = direction === 'to-left' ? $actionsRight : $actionsLeft;
	      var actionsWidth = direction === 'to-left' ? actionsRightWidth : actionsLeftWidth;
	      var action;
	      var $buttons;
	      var i;

	      if (
	        (
	          timeDiff < 300
	          && (
	            (touchesDiff < -10 && direction === 'to-left')
	            || (touchesDiff > 10 && direction === 'to-right')
	          )
	        )
	        || (
	          timeDiff >= 300
	          && (Math.abs(translate) > actionsWidth / 2)
	        )
	      ) {
	        action = 'open';
	      } else {
	        action = 'close';
	      }
	      if (timeDiff < 300) {
	        if (Math.abs(translate) === 0) { action = 'close'; }
	        if (Math.abs(translate) === actionsWidth) { action = 'open'; }
	      }

	      if (action === 'open') {
	        Swipeout.el = $swipeoutEl[0];
	        $swipeoutEl.trigger('swipeout:open');
	        app.emit('swipeoutOpen', $swipeoutEl[0]);
	        $swipeoutEl.addClass('swipeout-opened swipeout-transitioning');
	        var newTranslate = direction === 'to-left' ? -actionsWidth : actionsWidth;
	        $swipeoutContent.transform(("translate3d(" + newTranslate + "px,0,0)"));
	        $actions.addClass('swipeout-actions-opened');
	        $buttons = direction === 'to-left' ? $rightButtons : $leftButtons;
	        if ($buttons) {
	          for (i = 0; i < $buttons.length; i += 1) {
	            $($buttons[i]).transform(("translate3d(" + newTranslate + "px,0,0)"));
	          }
	        }
	        if (overswipeRight) {
	          $actionsRight.find('.swipeout-overswipe')[0].click();
	        }
	        if (overswipeLeft) {
	          $actionsLeft.find('.swipeout-overswipe')[0].click();
	        }
	      } else {
	        $swipeoutEl.trigger('swipeout:close');
	        app.emit('swipeoutClose', $swipeoutEl[0]);
	        Swipeout.el = undefined;
	        $swipeoutEl.addClass('swipeout-transitioning').removeClass('swipeout-opened');
	        $swipeoutContent.transform('');
	        $actions.removeClass('swipeout-actions-opened');
	      }

	      var buttonOffset;
	      if ($leftButtons && $leftButtons.length > 0 && $leftButtons !== $buttons) {
	        $leftButtons.each(function (index, buttonEl) {
	          var $buttonEl = $(buttonEl);
	          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
	          if (typeof buttonOffset === 'undefined') {
	            $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
	          }
	          $buttonEl.transform(("translate3d(" + buttonOffset + "px,0,0)"));
	        });
	      }
	      if ($rightButtons && $rightButtons.length > 0 && $rightButtons !== $buttons) {
	        $rightButtons.each(function (index, buttonEl) {
	          var $buttonEl = $(buttonEl);
	          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
	          if (typeof buttonOffset === 'undefined') {
	            $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
	          }
	          $buttonEl.transform(("translate3d(" + (-buttonOffset) + "px,0,0)"));
	        });
	      }
	      $swipeoutContent.transitionEnd(function () {
	        if ((opened && action === 'open') || (!opened && action === 'close')) { return; }
	        $swipeoutEl.trigger(action === 'open' ? 'swipeout:opened' : 'swipeout:closed');
	        app.emit(action === 'open' ? 'swipeoutOpened' : 'swipeoutClosed', $swipeoutEl[0]);
	        $swipeoutEl.removeClass('swipeout-transitioning');
	        if (opened && action === 'close') {
	          if ($actionsRight.length > 0) {
	            $rightButtons.transform('');
	          }
	          if ($actionsLeft.length > 0) {
	            $leftButtons.transform('');
	          }
	        }
	      });
	    }

	    var passiveListener = app.support.passiveListener ? { passive: true } : false;

	    app.on('touchstart', function (e) {
	      if (Swipeout.el) {
	        var $targetEl = $(e.target);
	        if (!(
	          $(Swipeout.el).is($targetEl[0])
	          || $targetEl.parents('.swipeout').is(Swipeout.el)
	          || $targetEl.hasClass('modal-in')
	          || ($targetEl.attr('class') || '').indexOf('-backdrop') > 0
	          || $targetEl.hasClass('actions-modal')
	          || $targetEl.parents('.actions-modal.modal-in, .dialog.modal-in').length > 0
	        )) {
	          app.swipeout.close(Swipeout.el);
	        }
	      }
	    });
	    $(doc).on(app.touchEvents.start, 'li.swipeout', handleTouchStart, passiveListener);
	    app.on('touchmove:active', handleTouchMove);
	    app.on('touchend:passive', handleTouchEnd);
	  },
	  allow: true,
	  el: undefined,
	  open: function open() {
	    var assign;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var app = this;
	    var el = args[0];
	    var side = args[1];
	    var callback = args[2];
	    if (typeof args[1] === 'function') {
	      (assign = args, el = assign[0], callback = assign[1], side = assign[2]);
	    }
	    var $el = $(el).eq(0);

	    if ($el.length === 0) { return; }
	    if (!$el.hasClass('swipeout') || $el.hasClass('swipeout-opened')) { return; }
	    if (!side) {
	      if ($el.find('.swipeout-actions-right').length > 0) { side = 'right'; }
	      else { side = 'left'; }
	    }
	    var $swipeoutActions = $el.find((".swipeout-actions-" + side));
	    var $swipeoutContent = $el.find('.swipeout-content');
	    if ($swipeoutActions.length === 0) { return; }
	    $el.trigger('swipeout:open').addClass('swipeout-opened').removeClass('swipeout-transitioning');
	    app.emit('swipeoutOpen', $el[0]);
	    $swipeoutActions.addClass('swipeout-actions-opened');
	    var $buttons = $swipeoutActions.children('a');
	    var swipeoutActionsWidth = $swipeoutActions.outerWidth();
	    var translate = side === 'right' ? -swipeoutActionsWidth : swipeoutActionsWidth;
	    if ($buttons.length > 1) {
	      $buttons.each(function (buttonIndex, buttonEl) {
	        var $buttonEl = $(buttonEl);
	        if (side === 'right') {
	          $buttonEl.transform(("translate3d(" + (-buttonEl.offsetLeft) + "px,0,0)"));
	        } else {
	          $buttonEl.css('z-index', $buttons.length - buttonIndex).transform(("translate3d(" + (swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft) + "px,0,0)"));
	        }
	      });
	    }
	    $el.addClass('swipeout-transitioning');
	    $swipeoutContent.transitionEnd(function () {
	      $el.trigger('swipeout:opened');
	      app.emit('swipeoutOpened', $el[0]);
	      if (callback) { callback.call($el[0]); }
	    });
	    Utils.nextFrame(function () {
	      $buttons.transform(("translate3d(" + translate + "px,0,0)"));
	      $swipeoutContent.transform(("translate3d(" + translate + "px,0,0)"));
	    });
	    Swipeout.el = $el[0];
	  },
	  close: function close(el, callback) {
	    var app = this;
	    var $el = $(el).eq(0);
	    if ($el.length === 0) { return; }
	    if (!$el.hasClass('swipeout-opened')) { return; }
	    var side = $el.find('.swipeout-actions-opened').hasClass('swipeout-actions-right') ? 'right' : 'left';
	    var $swipeoutActions = $el.find('.swipeout-actions-opened').removeClass('swipeout-actions-opened');
	    var $buttons = $swipeoutActions.children('a');
	    var swipeoutActionsWidth = $swipeoutActions.outerWidth();
	    Swipeout.allow = false;
	    $el.trigger('swipeout:close');
	    app.emit('swipeoutClose', $el[0]);
	    $el.removeClass('swipeout-opened').addClass('swipeout-transitioning');

	    var closeTimeout;
	    function onSwipeoutClose() {
	      Swipeout.allow = true;
	      if ($el.hasClass('swipeout-opened')) { return; }
	      $el.removeClass('swipeout-transitioning');
	      $buttons.transform('');
	      $el.trigger('swipeout:closed');
	      app.emit('swipeoutClosed', $el[0]);
	      if (callback) { callback.call($el[0]); }
	      if (closeTimeout) { clearTimeout(closeTimeout); }
	    }
	    $el.find('.swipeout-content').transform('').transitionEnd(onSwipeoutClose);
	    closeTimeout = setTimeout(onSwipeoutClose, 500);

	    $buttons.each(function (index, buttonEl) {
	      var $buttonEl = $(buttonEl);
	      if (side === 'right') {
	        $buttonEl.transform(("translate3d(" + (-buttonEl.offsetLeft) + "px,0,0)"));
	      } else {
	        $buttonEl.transform(("translate3d(" + (swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft) + "px,0,0)"));
	      }
	      $buttonEl.css({ left: '0px' }).removeClass('swipeout-overswipe-active');
	    });
	    if (Swipeout.el && Swipeout.el === $el[0]) { Swipeout.el = undefined; }
	  },
	  delete: function delete$1(el, callback) {
	    var app = this;
	    var $el = $(el).eq(0);
	    if ($el.length === 0) { return; }
	    Swipeout.el = undefined;
	    $el.trigger('swipeout:delete');
	    app.emit('swipeoutDelete', $el[0]);
	    $el.css({ height: (($el.outerHeight()) + "px") });
	    $el.transitionEnd(function () {
	      $el.trigger('swipeout:deleted');
	      app.emit('swipeoutDeleted', $el[0]);
	      if (callback) { callback.call($el[0]); }
	      if ($el.parents('.virtual-list').length > 0) {
	        var virtualList = $el.parents('.virtual-list')[0].f7VirtualList;
	        var virtualIndex = $el[0].f7VirtualListIndex;
	        if (virtualList && typeof virtualIndex !== 'undefined') { virtualList.deleteItem(virtualIndex); }
	      } else if (app.params.swipeout.removeElements) {
	        if (app.params.swipeout.removeElementsWithTimeout) {
	          setTimeout(function () {
	            $el.remove();
	          }, app.params.swipeout.removeElementsTimeout);
	        } else {
	          $el.remove();
	        }
	      } else {
	        $el.removeClass('swipeout-deleting swipeout-transitioning');
	      }
	    });
	    // eslint-disable-next-line
	    // $el[0]._clientLeft = $el[0].clientLeft;
	    Utils.nextFrame(function () {
	      $el
	        .addClass('swipeout-deleting swipeout-transitioning')
	        .css({ height: '0px' })
	        .find('.swipeout-content')
	        .transform('translate3d(-100%,0,0)');
	    });
	  },
	};
	var Swipeout$1 = {
	  name: 'swipeout',
	  params: {
	    swipeout: {
	      actionsNoFold: false,
	      noFollow: false,
	      removeElements: true,
	      removeElementsWithTimeout: false,
	      removeElementsTimeout: 0,
	    },
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      swipeout: {
	        init: Swipeout.init.bind(app),
	        open: Swipeout.open.bind(app),
	        close: Swipeout.close.bind(app),
	        delete: Swipeout.delete.bind(app),
	      },
	    });
	    Object.defineProperty(app.swipeout, 'el', {
	      enumerable: true,
	      configurable: true,
	      get: function () { return Swipeout.el; },
	      set: function set(el) {
	        Swipeout.el = el;
	      },
	    });
	    Object.defineProperty(app.swipeout, 'allow', {
	      enumerable: true,
	      configurable: true,
	      get: function () { return Swipeout.allow; },
	      set: function set(allow) {
	        Swipeout.allow = allow;
	      },
	    });
	  },
	  clicks: {
	    '.swipeout-open': function openSwipeout($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.swipeout.open(data.swipeout, data.side);
	    },
	    '.swipeout-close': function closeSwipeout($clickedEl) {
	      var app = this;
	      var $swipeoutEl = $clickedEl.closest('.swipeout');
	      if ($swipeoutEl.length === 0) { return; }
	      app.swipeout.close($swipeoutEl);
	    },
	    '.swipeout-delete': function deleteSwipeout($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var $swipeoutEl = $clickedEl.closest('.swipeout');
	      if ($swipeoutEl.length === 0) { return; }
	      var confirm = data.confirm;
	      var confirmTitle = data.confirmTitle;
	      if (data.confirm) {
	        app.dialog.confirm(confirm, confirmTitle, function () {
	          app.swipeout.delete($swipeoutEl);
	        });
	      } else {
	        app.swipeout.delete($swipeoutEl);
	      }
	    },
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      if (!app.params.swipeout) { return; }
	      app.swipeout.init();
	    },
	  },
	};

	var Accordion = {
	  toggleClicked: function toggleClicked($clickedEl) {
	    var app = this;
	    var $accordionItemEl = $clickedEl.closest('.accordion-item').eq(0);
	    if (!$accordionItemEl.length) { $accordionItemEl = $clickedEl.parents('li').eq(0); }

	    var $accordionContent = $clickedEl.parents('.accordion-item-content').eq(0);
	    if ($accordionContent.length) {
	      if ($accordionContent.parents($accordionItemEl).length) { return; }
	    }

	    if ($clickedEl.parents('li').length > 1 && $clickedEl.parents('li')[0] !== $accordionItemEl[0]) { return; }
	    app.accordion.toggle($accordionItemEl);
	  },
	  open: function open(el) {
	    var app = this;
	    var $el = $(el);
	    var prevented = false;
	    function prevent() {
	      prevented = true;
	    }
	    $el.trigger('accordion:beforeopen', { prevent: prevent }, prevent);
	    app.emit('accordionBeforeOpen', $el[0], prevent);
	    if (prevented) { return; }
	    var $list = $el.parents('.accordion-list').eq(0);
	    var $contentEl = $el.children('.accordion-item-content');
	    $contentEl.removeAttr('aria-hidden');
	    if ($contentEl.length === 0) { $contentEl = $el.find('.accordion-item-content'); }
	    if ($contentEl.length === 0) { return; }
	    var $openedItem = $list.length > 0 && $el.parent().children('.accordion-item-opened');
	    if ($openedItem.length > 0) {
	      app.accordion.close($openedItem);
	    }
	    $contentEl.transitionEnd(function () {
	      if ($el.hasClass('accordion-item-opened')) {
	        $contentEl.transition(0);
	        $contentEl.css('height', 'auto');
	        Utils.nextFrame(function () {
	          $contentEl.transition('');
	          $el.trigger('accordion:opened');
	          app.emit('accordionOpened', $el[0]);
	        });
	      } else {
	        $contentEl.css('height', '');
	        $el.trigger('accordion:closed');
	        app.emit('accordionClosed', $el[0]);
	      }
	    });
	    $contentEl.css('height', (($contentEl[0].scrollHeight) + "px"));
	    $el.trigger('accordion:open');
	    $el.addClass('accordion-item-opened');
	    app.emit('accordionOpen', $el[0]);
	  },
	  close: function close(el) {
	    var app = this;
	    var $el = $(el);
	    var prevented = false;
	    function prevent() {
	      prevented = true;
	    }
	    $el.trigger('accordion:beforeclose', { prevent: prevent }, prevent);
	    app.emit('accordionBeforeClose', $el[0], prevent);
	    if (prevented) { return; }
	    var $contentEl = $el.children('.accordion-item-content');
	    if ($contentEl.length === 0) { $contentEl = $el.find('.accordion-item-content'); }
	    $el.removeClass('accordion-item-opened');
	    $contentEl.attr('aria-hidden', true);
	    $contentEl.transition(0);
	    $contentEl.css('height', (($contentEl[0].scrollHeight) + "px"));
	    // Close
	    $contentEl.transitionEnd(function () {
	      if ($el.hasClass('accordion-item-opened')) {
	        $contentEl.transition(0);
	        $contentEl.css('height', 'auto');
	        Utils.nextFrame(function () {
	          $contentEl.transition('');
	          $el.trigger('accordion:opened');
	          app.emit('accordionOpened', $el[0]);
	        });
	      } else {
	        $contentEl.css('height', '');
	        $el.trigger('accordion:closed');
	        app.emit('accordionClosed', $el[0]);
	      }
	    });
	    Utils.nextFrame(function () {
	      $contentEl.transition('');
	      $contentEl.css('height', '');
	      $el.trigger('accordion:close');
	      app.emit('accordionClose', $el[0]);
	    });
	  },
	  toggle: function toggle(el) {
	    var app = this;
	    var $el = $(el);
	    if ($el.length === 0) { return; }
	    if ($el.hasClass('accordion-item-opened')) { app.accordion.close(el); }
	    else { app.accordion.open(el); }
	  },
	};

	var Accordion$1 = {
	  name: 'accordion',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      accordion: {
	        open: Accordion.open.bind(app),
	        close: Accordion.close.bind(app),
	        toggle: Accordion.toggle.bind(app),
	      },
	    });
	  },
	  clicks: {
	    '.accordion-item .item-link, .accordion-item-toggle, .links-list.accordion-list > ul > li > a': function open($clickedEl) {
	      var app = this;
	      Accordion.toggleClicked.call(app, $clickedEl);
	    },
	  },
	};

	var ContactsList = {
	  name: 'contactsList',
	};

	var VirtualList = /*@__PURE__*/(function (Framework7Class) {
	  function VirtualList(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class.call(this, params, [app]);
	    var vl = this;

	    var defaultHeight;
	    if (app.theme === 'md') {
	      defaultHeight = 48;
	    } else if (app.theme === 'ios') {
	      defaultHeight = 44;
	    } else if (app.theme === 'aurora') {
	      defaultHeight = 38;
	    }

	    var defaults = {
	      cols: 1,
	      height: defaultHeight,
	      cache: true,
	      dynamicHeightBufferSize: 1,
	      showFilteredItemsOnly: false,
	      renderExternal: undefined,
	      setListHeight: true,
	      searchByItem: undefined,
	      searchAll: undefined,
	      itemTemplate: undefined,
	      ul: null,
	      createUl: true,
	      renderItem: function renderItem(item) {
	        return ("\n          <li>\n            <div class=\"item-content\">\n              <div class=\"item-inner\">\n                <div class=\"item-title\">" + item + "</div>\n              </div>\n            </div>\n          </li>\n        ").trim();
	      },
	      on: {},
	    };

	    // Extend defaults with modules params
	    vl.useModulesParams(defaults);

	    vl.params = Utils.extend(defaults, params);
	    if (vl.params.height === undefined || !vl.params.height) {
	      vl.params.height = defaultHeight;
	    }

	    vl.$el = $(params.el);
	    vl.el = vl.$el[0];

	    if (vl.$el.length === 0) { return undefined; }
	    vl.$el[0].f7VirtualList = vl;

	    vl.items = vl.params.items;
	    if (vl.params.showFilteredItemsOnly) {
	      vl.filteredItems = [];
	    }
	    if (vl.params.itemTemplate) {
	      if (typeof vl.params.itemTemplate === 'string') { vl.renderItem = app.t7.compile(vl.params.itemTemplate); }
	      else if (typeof vl.params.itemTemplate === 'function') { vl.renderItem = vl.params.itemTemplate; }
	    } else if (vl.params.renderItem) {
	      vl.renderItem = vl.params.renderItem;
	    }
	    vl.$pageContentEl = vl.$el.parents('.page-content');
	    vl.pageContentEl = vl.$pageContentEl[0];

	    // Bad scroll
	    if (typeof vl.params.updatableScroll !== 'undefined') {
	      vl.updatableScroll = vl.params.updatableScroll;
	    } else {
	      vl.updatableScroll = true;
	      if (Device.ios && Device.osVersion.split('.')[0] < 8) {
	        vl.updatableScroll = false;
	      }
	    }

	    // Append <ul>
	    var ul = vl.params.ul;
	    vl.$ul = ul ? $(vl.params.ul) : vl.$el.children('ul');
	    if (vl.$ul.length === 0 && vl.params.createUl) {
	      vl.$el.append('<ul></ul>');
	      vl.$ul = vl.$el.children('ul');
	    }
	    vl.ul = vl.$ul[0];

	    var $itemsWrapEl;
	    if (!vl.ul && !vl.params.createUl) { $itemsWrapEl = vl.$el; }
	    else { $itemsWrapEl = vl.$ul; }

	    Utils.extend(vl, {
	      $itemsWrapEl: $itemsWrapEl,
	      itemsWrapEl: $itemsWrapEl[0],
	      // DOM cached items
	      domCache: {},
	      displayDomCache: {},
	      // Temporary DOM Element
	      tempDomElement: doc.createElement('ul'),
	      // Last repain position
	      lastRepaintY: null,
	      // Fragment
	      fragment: doc.createDocumentFragment(),
	      // Props
	      pageHeight: undefined,
	      rowsPerScreen: undefined,
	      rowsBefore: undefined,
	      rowsAfter: undefined,
	      rowsToRender: undefined,
	      maxBufferHeight: 0,
	      listHeight: undefined,
	      dynamicHeight: typeof vl.params.height === 'function',
	    });

	    // Install Modules
	    vl.useModules();

	    // Attach events
	    var handleScrollBound = vl.handleScroll.bind(vl);
	    var handleResizeBound = vl.handleResize.bind(vl);
	    var $pageEl;
	    var $tabEl;
	    var $panelEl;
	    var $popupEl;
	    vl.attachEvents = function attachEvents() {
	      $pageEl = vl.$el.parents('.page').eq(0);
	      $tabEl = vl.$el.parents('.tab').eq(0);
	      $panelEl = vl.$el.parents('.panel').eq(0);
	      $popupEl = vl.$el.parents('.popup').eq(0);

	      vl.$pageContentEl.on('scroll', handleScrollBound);
	      if ($pageEl) { $pageEl.on('page:reinit', handleResizeBound); }
	      if ($tabEl) { $tabEl.on('tab:show', handleResizeBound); }
	      if ($panelEl) { $panelEl.on('panel:open', handleResizeBound); }
	      if ($popupEl) { $popupEl.on('popup:open', handleResizeBound); }
	      app.on('resize', handleResizeBound);
	    };
	    vl.detachEvents = function attachEvents() {
	      vl.$pageContentEl.off('scroll', handleScrollBound);
	      if ($pageEl) { $pageEl.off('page:reinit', handleResizeBound); }
	      if ($tabEl) { $tabEl.off('tab:show', handleResizeBound); }
	      if ($panelEl) { $panelEl.off('panel:open', handleResizeBound); }
	      if ($popupEl) { $popupEl.off('popup:open', handleResizeBound); }
	      app.off('resize', handleResizeBound);
	    };
	    // Init
	    vl.init();

	    return vl;
	  }

	  if ( Framework7Class ) VirtualList.__proto__ = Framework7Class;
	  VirtualList.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  VirtualList.prototype.constructor = VirtualList;

	  VirtualList.prototype.setListSize = function setListSize () {
	    var vl = this;
	    var items = vl.filteredItems || vl.items;
	    vl.pageHeight = vl.$pageContentEl[0].offsetHeight;
	    if (vl.dynamicHeight) {
	      vl.listHeight = 0;
	      vl.heights = [];
	      for (var i = 0; i < items.length; i += 1) {
	        var itemHeight = vl.params.height(items[i]);
	        vl.listHeight += itemHeight;
	        vl.heights.push(itemHeight);
	      }
	    } else {
	      vl.listHeight = Math.ceil(items.length / vl.params.cols) * vl.params.height;
	      vl.rowsPerScreen = Math.ceil(vl.pageHeight / vl.params.height);
	      vl.rowsBefore = vl.params.rowsBefore || vl.rowsPerScreen * 2;
	      vl.rowsAfter = vl.params.rowsAfter || vl.rowsPerScreen;
	      vl.rowsToRender = (vl.rowsPerScreen + vl.rowsBefore + vl.rowsAfter);
	      vl.maxBufferHeight = (vl.rowsBefore / 2) * vl.params.height;
	    }

	    if (vl.updatableScroll || vl.params.setListHeight) {
	      vl.$itemsWrapEl.css({ height: ((vl.listHeight) + "px") });
	    }
	  };

	  VirtualList.prototype.render = function render (force, forceScrollTop) {
	    var vl = this;
	    if (force) { vl.lastRepaintY = null; }

	    var scrollTop = -(vl.$el[0].getBoundingClientRect().top - vl.$pageContentEl[0].getBoundingClientRect().top);

	    if (typeof forceScrollTop !== 'undefined') { scrollTop = forceScrollTop; }
	    if (vl.lastRepaintY === null || Math.abs(scrollTop - vl.lastRepaintY) > vl.maxBufferHeight || (!vl.updatableScroll && (vl.$pageContentEl[0].scrollTop + vl.pageHeight >= vl.$pageContentEl[0].scrollHeight))) {
	      vl.lastRepaintY = scrollTop;
	    } else {
	      return;
	    }

	    var items = vl.filteredItems || vl.items;
	    var fromIndex;
	    var toIndex;
	    var heightBeforeFirstItem = 0;
	    var heightBeforeLastItem = 0;
	    if (vl.dynamicHeight) {
	      var itemTop = 0;
	      var itemHeight;
	      vl.maxBufferHeight = vl.pageHeight;

	      for (var j = 0; j < vl.heights.length; j += 1) {
	        itemHeight = vl.heights[j];
	        if (typeof fromIndex === 'undefined') {
	          if (itemTop + itemHeight >= scrollTop - (vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize)) { fromIndex = j; }
	          else { heightBeforeFirstItem += itemHeight; }
	        }

	        if (typeof toIndex === 'undefined') {
	          if (itemTop + itemHeight >= scrollTop + (vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize) || j === vl.heights.length - 1) { toIndex = j + 1; }
	          heightBeforeLastItem += itemHeight;
	        }
	        itemTop += itemHeight;
	      }
	      toIndex = Math.min(toIndex, items.length);
	    } else {
	      fromIndex = (parseInt(scrollTop / vl.params.height, 10) - vl.rowsBefore) * vl.params.cols;
	      if (fromIndex < 0) {
	        fromIndex = 0;
	      }
	      toIndex = Math.min(fromIndex + (vl.rowsToRender * vl.params.cols), items.length);
	    }

	    var topPosition;
	    var renderExternalItems = [];
	    vl.reachEnd = false;
	    var i;
	    for (i = fromIndex; i < toIndex; i += 1) {
	      var itemEl = (void 0);
	      // Define real item index
	      var index = vl.items.indexOf(items[i]);

	      if (i === fromIndex) { vl.currentFromIndex = index; }
	      if (i === toIndex - 1) { vl.currentToIndex = index; }
	      if (vl.filteredItems) {
	        if (vl.items[index] === vl.filteredItems[vl.filteredItems.length - 1]) { vl.reachEnd = true; }
	      } else if (index === vl.items.length - 1) { vl.reachEnd = true; }

	      // Find items
	      if (vl.params.renderExternal) {
	        renderExternalItems.push(items[i]);
	      } else if (vl.domCache[index]) {
	        itemEl = vl.domCache[index];
	        itemEl.f7VirtualListIndex = index;
	      } else {
	        if (vl.renderItem) {
	          vl.tempDomElement.innerHTML = vl.renderItem(items[i], index).trim();
	        } else {
	          vl.tempDomElement.innerHTML = items[i].toString().trim();
	        }
	        itemEl = vl.tempDomElement.childNodes[0];
	        if (vl.params.cache) { vl.domCache[index] = itemEl; }
	        itemEl.f7VirtualListIndex = index;
	      }

	      // Set item top position
	      if (i === fromIndex) {
	        if (vl.dynamicHeight) {
	          topPosition = heightBeforeFirstItem;
	        } else {
	          topPosition = ((i * vl.params.height) / vl.params.cols);
	        }
	      }
	      if (!vl.params.renderExternal) {
	        itemEl.style.top = topPosition + "px";

	        // Before item insert
	        vl.emit('local::itemBeforeInsert vlItemBeforeInsert', vl, itemEl, items[i]);

	        // Append item to fragment
	        vl.fragment.appendChild(itemEl);
	      }
	    }

	    // Update list height with not updatable scroll
	    if (!vl.updatableScroll) {
	      if (vl.dynamicHeight) {
	        vl.itemsWrapEl.style.height = heightBeforeLastItem + "px";
	      } else {
	        vl.itemsWrapEl.style.height = ((i * vl.params.height) / vl.params.cols) + "px";
	      }
	    }

	    // Update list html
	    if (vl.params.renderExternal) {
	      if (items && items.length === 0) {
	        vl.reachEnd = true;
	      }
	    } else {
	      vl.emit('local::beforeClear vlBeforeClear', vl, vl.fragment);
	      vl.itemsWrapEl.innerHTML = '';

	      vl.emit('local::itemsBeforeInsert vlItemsBeforeInsert', vl, vl.fragment);

	      if (items && items.length === 0) {
	        vl.reachEnd = true;
	        if (vl.params.emptyTemplate) { vl.itemsWrapEl.innerHTML = vl.params.emptyTemplate; }
	      } else {
	        vl.itemsWrapEl.appendChild(vl.fragment);
	      }

	      vl.emit('local::itemsAfterInsert vlItemsAfterInsert', vl, vl.fragment);
	    }

	    if (typeof forceScrollTop !== 'undefined' && force) {
	      vl.$pageContentEl.scrollTop(forceScrollTop, 0);
	    }
	    if (vl.params.renderExternal) {
	      vl.params.renderExternal(vl, {
	        fromIndex: fromIndex,
	        toIndex: toIndex,
	        listHeight: vl.listHeight,
	        topPosition: topPosition,
	        items: renderExternalItems,
	      });
	    }
	  };

	  // Filter
	  VirtualList.prototype.filterItems = function filterItems (indexes, resetScrollTop) {
	    if ( resetScrollTop === void 0 ) resetScrollTop = true;

	    var vl = this;
	    vl.filteredItems = [];
	    for (var i = 0; i < indexes.length; i += 1) {
	      vl.filteredItems.push(vl.items[indexes[i]]);
	    }
	    if (resetScrollTop) {
	      vl.$pageContentEl[0].scrollTop = 0;
	    }
	    vl.update();
	  };

	  VirtualList.prototype.resetFilter = function resetFilter () {
	    var vl = this;
	    if (vl.params.showFilteredItemsOnly) {
	      vl.filteredItems = [];
	    } else {
	      vl.filteredItems = null;
	      delete vl.filteredItems;
	    }
	    vl.update();
	  };

	  VirtualList.prototype.scrollToItem = function scrollToItem (index) {
	    var vl = this;
	    if (index > vl.items.length) { return false; }
	    var itemTop = 0;
	    if (vl.dynamicHeight) {
	      for (var i = 0; i < index; i += 1) {
	        itemTop += vl.heights[i];
	      }
	    } else {
	      itemTop = index * vl.params.height;
	    }
	    var listTop = vl.$el[0].offsetTop;
	    vl.render(true, (listTop + itemTop) - parseInt(vl.$pageContentEl.css('padding-top'), 10));
	    return true;
	  };

	  VirtualList.prototype.handleScroll = function handleScroll () {
	    var vl = this;
	    vl.render();
	  };

	  // Handle resize event
	  VirtualList.prototype.isVisible = function isVisible () {
	    var vl = this;
	    return !!(vl.el.offsetWidth || vl.el.offsetHeight || vl.el.getClientRects().length);
	  };

	  VirtualList.prototype.handleResize = function handleResize () {
	    var vl = this;
	    if (vl.isVisible()) {
	      vl.setListSize();
	      vl.render(true);
	    }
	  };

	  // Append
	  VirtualList.prototype.appendItems = function appendItems (items) {
	    var vl = this;
	    for (var i = 0; i < items.length; i += 1) {
	      vl.items.push(items[i]);
	    }
	    vl.update();
	  };

	  VirtualList.prototype.appendItem = function appendItem (item) {
	    var vl = this;
	    vl.appendItems([item]);
	  };

	  // Replace
	  VirtualList.prototype.replaceAllItems = function replaceAllItems (items) {
	    var vl = this;
	    vl.items = items;
	    delete vl.filteredItems;
	    vl.domCache = {};
	    vl.update();
	  };

	  VirtualList.prototype.replaceItem = function replaceItem (index, item) {
	    var vl = this;
	    vl.items[index] = item;
	    if (vl.params.cache) { delete vl.domCache[index]; }
	    vl.update();
	  };

	  // Prepend
	  VirtualList.prototype.prependItems = function prependItems (items) {
	    var vl = this;
	    for (var i = items.length - 1; i >= 0; i -= 1) {
	      vl.items.unshift(items[i]);
	    }
	    if (vl.params.cache) {
	      var newCache = {};
	      Object.keys(vl.domCache).forEach(function (cached) {
	        newCache[parseInt(cached, 10) + items.length] = vl.domCache[cached];
	      });
	      vl.domCache = newCache;
	    }
	    vl.update();
	  };

	  VirtualList.prototype.prependItem = function prependItem (item) {
	    var vl = this;
	    vl.prependItems([item]);
	  };

	  // Move
	  VirtualList.prototype.moveItem = function moveItem (from, to) {
	    var vl = this;
	    var fromIndex = from;
	    var toIndex = to;
	    if (fromIndex === toIndex) { return; }
	    // remove item from array
	    var item = vl.items.splice(fromIndex, 1)[0];
	    if (toIndex >= vl.items.length) {
	      // Add item to the end
	      vl.items.push(item);
	      toIndex = vl.items.length - 1;
	    } else {
	    // Add item to new index
	      vl.items.splice(toIndex, 0, item);
	    }
	    // Update cache
	    if (vl.params.cache) {
	      var newCache = {};
	      Object.keys(vl.domCache).forEach(function (cached) {
	        var cachedIndex = parseInt(cached, 10);
	        var leftIndex = fromIndex < toIndex ? fromIndex : toIndex;
	        var rightIndex = fromIndex < toIndex ? toIndex : fromIndex;
	        var indexShift = fromIndex < toIndex ? -1 : 1;
	        if (cachedIndex < leftIndex || cachedIndex > rightIndex) { newCache[cachedIndex] = vl.domCache[cachedIndex]; }
	        if (cachedIndex === leftIndex) { newCache[rightIndex] = vl.domCache[cachedIndex]; }
	        if (cachedIndex > leftIndex && cachedIndex <= rightIndex) { newCache[cachedIndex + indexShift] = vl.domCache[cachedIndex]; }
	      });
	      vl.domCache = newCache;
	    }
	    vl.update();
	  };

	  // Insert before
	  VirtualList.prototype.insertItemBefore = function insertItemBefore (index, item) {
	    var vl = this;
	    if (index === 0) {
	      vl.prependItem(item);
	      return;
	    }
	    if (index >= vl.items.length) {
	      vl.appendItem(item);
	      return;
	    }
	    vl.items.splice(index, 0, item);
	    // Update cache
	    if (vl.params.cache) {
	      var newCache = {};
	      Object.keys(vl.domCache).forEach(function (cached) {
	        var cachedIndex = parseInt(cached, 10);
	        if (cachedIndex >= index) {
	          newCache[cachedIndex + 1] = vl.domCache[cachedIndex];
	        }
	      });
	      vl.domCache = newCache;
	    }
	    vl.update();
	  };

	  // Delete
	  VirtualList.prototype.deleteItems = function deleteItems (indexes) {
	    var vl = this;
	    var prevIndex;
	    var indexShift = 0;
	    var loop = function ( i ) {
	      var index = indexes[i];
	      if (typeof prevIndex !== 'undefined') {
	        if (index > prevIndex) {
	          indexShift = -i;
	        }
	      }
	      index += indexShift;
	      prevIndex = indexes[i];
	      // Delete item
	      var deletedItem = vl.items.splice(index, 1)[0];

	      // Delete from filtered
	      if (vl.filteredItems && vl.filteredItems.indexOf(deletedItem) >= 0) {
	        vl.filteredItems.splice(vl.filteredItems.indexOf(deletedItem), 1);
	      }
	      // Update cache
	      if (vl.params.cache) {
	        var newCache = {};
	        Object.keys(vl.domCache).forEach(function (cached) {
	          var cachedIndex = parseInt(cached, 10);
	          if (cachedIndex === index) {
	            delete vl.domCache[index];
	          } else if (parseInt(cached, 10) > index) {
	            newCache[cachedIndex - 1] = vl.domCache[cached];
	          } else {
	            newCache[cachedIndex] = vl.domCache[cached];
	          }
	        });
	        vl.domCache = newCache;
	      }
	    };

	    for (var i = 0; i < indexes.length; i += 1) loop( i );
	    vl.update();
	  };

	  VirtualList.prototype.deleteAllItems = function deleteAllItems () {
	    var vl = this;
	    vl.items = [];
	    delete vl.filteredItems;
	    if (vl.params.cache) { vl.domCache = {}; }
	    vl.update();
	  };

	  VirtualList.prototype.deleteItem = function deleteItem (index) {
	    var vl = this;
	    vl.deleteItems([index]);
	  };

	  // Clear cache
	  VirtualList.prototype.clearCache = function clearCache () {
	    var vl = this;
	    vl.domCache = {};
	  };

	  // Update Virtual List
	  VirtualList.prototype.update = function update (deleteCache) {
	    var vl = this;
	    if (deleteCache && vl.params.cache) {
	      vl.domCache = {};
	    }
	    vl.setListSize();
	    vl.render(true);
	  };

	  VirtualList.prototype.init = function init () {
	    var vl = this;
	    vl.attachEvents();
	    vl.setListSize();
	    vl.render();
	  };

	  VirtualList.prototype.destroy = function destroy () {
	    var vl = this;
	    vl.detachEvents();
	    vl.$el[0].f7VirtualList = null;
	    delete vl.$el[0].f7VirtualList;
	    Utils.deleteProps(vl);
	    vl = null;
	  };

	  return VirtualList;
	}(Framework7Class));

	var VirtualList$1 = {
	  name: 'virtualList',
	  static: {
	    VirtualList: VirtualList,
	  },
	  create: function create() {
	    var app = this;
	    app.virtualList = ConstructorMethods({
	      defaultSelector: '.virtual-list',
	      constructor: VirtualList,
	      app: app,
	      domProp: 'f7VirtualList',
	    });
	  },
	};

	var ListIndex = /*@__PURE__*/(function (Framework7Class) {
	  function ListIndex(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class.call(this, params, [app]);
	    var index = this;

	    var defaults = {
	      el: null, // where to render indexes
	      listEl: null, // list el to generate indexes
	      indexes: 'auto', // or array of indexes
	      iosItemHeight: 14,
	      mdItemHeight: 14,
	      auroraItemHeight: 14,
	      scrollList: true,
	      label: false,
	      // eslint-disable-next-line
	      renderItem: function renderItem(itemContent, itemIndex) {
	        return ("\n          <li>" + itemContent + "</li>\n        ").trim();
	      },
	      renderSkipPlaceholder: function renderSkipPlaceholder() {
	        return '<li class="list-index-skip-placeholder"></li>';
	      },
	      on: {},
	    };

	    // Extend defaults with modules params
	    index.useModulesParams(defaults);

	    index.params = Utils.extend(defaults, params);

	    var $el;
	    var $listEl;
	    var $pageContentEl;
	    var $ul;

	    if (index.params.el) {
	      $el = $(index.params.el);
	    } else {
	      return index;
	    }

	    if ($el[0].f7ListIndex) {
	      return $el[0].f7ListIndex;
	    }

	    $ul = $el.find('ul');
	    if ($ul.length === 0) {
	      $ul = $('<ul></ul>');
	      $el.append($ul);
	    }

	    if (index.params.listEl) {
	      $listEl = $(index.params.listEl);
	    }

	    if (index.params.indexes === 'auto' && !$listEl) {
	      return index;
	    }

	    if ($listEl) {
	      $pageContentEl = $listEl.parents('.page-content').eq(0);
	    } else {
	      $pageContentEl = $el.siblings('.page-content').eq(0);
	      if ($pageContentEl.length === 0) {
	        $pageContentEl = $el.parents('.page').eq(0).find('.page-content').eq(0);
	      }
	    }

	    $el[0].f7ListIndex = index;

	    Utils.extend(index, {
	      app: app,
	      $el: $el,
	      el: $el && $el[0],
	      $ul: $ul,
	      ul: $ul && $ul[0],
	      $listEl: $listEl,
	      listEl: $listEl && $listEl[0],
	      $pageContentEl: $pageContentEl,
	      pageContentEl: $pageContentEl && $pageContentEl[0],
	      indexes: params.indexes,
	      height: 0,
	      skipRate: 0,
	    });

	    // Install Modules
	    index.useModules();

	    // Attach events
	    function handleResize() {
	      var height = { index: index };
	      index.calcSize();
	      if (height !== index.height) {
	        index.render();
	      }
	    }

	    function handleClick(e) {
	      var $clickedLi = $(e.target).closest('li');
	      if (!$clickedLi.length) { return; }

	      var itemIndex = $clickedLi.index();
	      if (index.skipRate > 0) {
	        var percentage = itemIndex / ($clickedLi.siblings('li').length - 1);
	        itemIndex = Math.round((index.indexes.length - 1) * percentage);
	      }
	      var itemContent = index.indexes[itemIndex];

	      index.$el.trigger('listindex:click', itemContent, itemIndex);
	      index.emit('local::click listIndexClick', index, itemContent, itemIndex);
	      index.$el.trigger('listindex:select', itemContent, itemIndex);
	      index.emit('local::select listIndexSelect', index, itemContent, itemIndex);

	      if (index.$listEl && index.params.scrollList) {
	        index.scrollListToIndex(itemContent, itemIndex);
	      }
	    }

	    var touchesStart = {};
	    var isTouched;
	    var isMoved;
	    var topPoint;
	    var bottomPoint;
	    var $labelEl;
	    var previousIndex = null;
	    function handleTouchStart(e) {
	      var $children = $ul.children();
	      if (!$children.length) { return; }
	      topPoint = $children[0].getBoundingClientRect().top;
	      bottomPoint = $children[$children.length - 1].getBoundingClientRect().top + $children[0].offsetHeight;

	      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	      isTouched = true;
	      isMoved = false;
	      previousIndex = null;
	    }
	    function handleTouchMove(e) {
	      if (!isTouched) { return; }
	      if (!isMoved && index.params.label) {
	        $labelEl = $('<span class="list-index-label"></span>');
	        $el.append($labelEl);
	      }
	      isMoved = true;
	      var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      e.preventDefault();

	      var percentage = (pageY - topPoint) / (bottomPoint - topPoint);
	      percentage = Math.min(Math.max(percentage, 0), 1);

	      var itemIndex = Math.round((index.indexes.length - 1) * percentage);
	      var itemContent = index.indexes[itemIndex];


	      var ulHeight = bottomPoint - topPoint;
	      var bubbleBottom = ((index.height - ulHeight) / 2) + ((1 - percentage) * ulHeight);

	      if (itemIndex !== previousIndex) {
	        if (index.params.label) {
	          $labelEl.html(itemContent).transform(("translateY(-" + bubbleBottom + "px)"));
	        }

	        if (index.$listEl && index.params.scrollList) {
	          index.scrollListToIndex(itemContent, itemIndex);
	        }
	      }

	      previousIndex = itemIndex;

	      index.$el.trigger('listindex:select', index);
	      index.emit('local::select listIndexSelect', index, itemContent, itemIndex);
	    }
	    function handleTouchEnd() {
	      if (!isTouched) { return; }
	      isTouched = false;
	      isMoved = false;
	      if (index.params.label) {
	        if ($labelEl) { $labelEl.remove(); }
	        $labelEl = undefined;
	      }
	    }
	    var passiveListener = app.support.passiveListener ? { passive: true } : false;
	    index.attachEvents = function attachEvents() {
	      $el.parents('.tab').on('tab:show', handleResize);
	      $el.parents('.page').on('page:reinit', handleResize);
	      $el.parents('.panel').on('panel:open', handleResize);
	      $el
	        .parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast')
	        .on('modal:open', handleResize);
	      app.on('resize', handleResize);

	      $el.on('click', handleClick);
	      $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
	      app.on('touchmove:active', handleTouchMove);
	      app.on('touchend:passive', handleTouchEnd);
	    };
	    index.detachEvents = function attachEvents() {
	      $el.parents('.tab').off('tab:show', handleResize);
	      $el.parents('.page').off('page:reinit', handleResize);
	      $el.parents('.panel').off('panel:open', handleResize);
	      $el
	        .parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast')
	        .off('modal:open', handleResize);
	      app.off('resize', handleResize);

	      $el.off('click', handleClick);
	      $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
	      app.off('touchmove:active', handleTouchMove);
	      app.off('touchend:passive', handleTouchEnd);
	    };
	    // Init
	    index.init();

	    return index;
	  }

	  if ( Framework7Class ) ListIndex.__proto__ = Framework7Class;
	  ListIndex.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  ListIndex.prototype.constructor = ListIndex;
	  // eslint-disable-next-line
	  ListIndex.prototype.scrollListToIndex = function scrollListToIndex (itemContent, itemIndex) {
	    var index = this;
	    var $listEl = index.$listEl;
	    var $pageContentEl = index.$pageContentEl;
	    var app = index.app;
	    if (!$listEl || !$pageContentEl || $pageContentEl.length === 0) { return index; }

	    var $scrollToEl;
	    $listEl.find('.list-group-title, .item-divider').each(function (elIndex, el) {
	      if ($scrollToEl) { return; }
	      var $el = $(el);
	      if ($el.text() === itemContent) {
	        $scrollToEl = $el;
	      }
	    });
	    if (!$scrollToEl || $scrollToEl.length === 0) { return index; }

	    var parentTop = $scrollToEl.parent().offset().top;
	    var paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
	    var scrollTop = $pageContentEl[0].scrollTop;
	    var scrollToElTop = $scrollToEl.offset().top;
	    if ($pageContentEl.parents('.page-with-navbar-large').length) {
	      var navbarInnerEl = app.navbar.getElByPage($pageContentEl.parents('.page-with-navbar-large').eq(0));
	      var $titleLargeEl = $(navbarInnerEl).find('.title-large');
	      if ($titleLargeEl.length) {
	        paddingTop -= $titleLargeEl[0].offsetHeight || 0;
	      }
	    }

	    if (parentTop <= paddingTop) {
	      $pageContentEl.scrollTop((parentTop + scrollTop) - paddingTop);
	    } else {
	      $pageContentEl.scrollTop((scrollToElTop + scrollTop) - paddingTop);
	    }
	    return index;
	  };

	  ListIndex.prototype.renderSkipPlaceholder = function renderSkipPlaceholder () {
	    var index = this;
	    return index.params.renderSkipPlaceholder.call(index);
	  };

	  ListIndex.prototype.renderItem = function renderItem (itemContent, itemIndex) {
	    var index = this;
	    return index.params.renderItem.call(index, itemContent, itemIndex);
	  };

	  ListIndex.prototype.render = function render () {
	    var index = this;
	    var $ul = index.$ul;
	    var indexes = index.indexes;
	    var skipRate = index.skipRate;
	    var wasSkipped;

	    var html = indexes.map(function (itemContent, itemIndex) {
	      if (itemIndex % skipRate !== 0 && skipRate > 0) {
	        wasSkipped = true;
	        return '';
	      }
	      var itemHtml = index.renderItem(itemContent, itemIndex);
	      if (wasSkipped) {
	        itemHtml = index.renderSkipPlaceholder() + itemHtml;
	      }
	      wasSkipped = false;
	      return itemHtml;
	    }).join('');

	    $ul.html(html);

	    return index;
	  };

	  ListIndex.prototype.calcSize = function calcSize () {
	    var index = this;
	    var app = index.app;
	    var params = index.params;
	    var el = index.el;
	    var indexes = index.indexes;
	    var height = el.offsetHeight;
	    var itemHeight = params[((app.theme) + "ItemHeight")];
	    var maxItems = Math.floor(height / itemHeight);
	    var items = indexes.length;
	    var skipRate = 0;
	    if (items > maxItems) {
	      skipRate = Math.ceil(((items * 2) - 1) / maxItems);
	    }

	    index.height = height;
	    index.skipRate = skipRate;

	    return index;
	  };

	  ListIndex.prototype.calcIndexes = function calcIndexes () {
	    var index = this;
	    if (index.params.indexes === 'auto') {
	      index.indexes = [];

	      index.$listEl.find('.list-group-title, .item-divider').each(function (elIndex, el) {
	        var elContent = $(el).text();
	        if (index.indexes.indexOf(elContent) < 0) {
	          index.indexes.push(elContent);
	        }
	      });
	    } else {
	      index.indexes = index.params.indexes;
	    }
	    return index;
	  };

	  ListIndex.prototype.update = function update () {
	    var index = this;
	    index.calcIndexes();
	    index.calcSize();
	    index.render();

	    return index;
	  };

	  ListIndex.prototype.init = function init () {
	    var index = this;
	    index.calcIndexes();
	    index.calcSize();
	    index.render();
	    index.attachEvents();
	  };

	  ListIndex.prototype.destroy = function destroy () {
	    var index = this;
	    index.$el.trigger('listindex:beforedestroy', index);
	    index.emit('local::beforeDestroy listIndexBeforeDestroy', index);
	    index.detachEvents();
	    if (index.$el[0]) {
	      index.$el[0].f7ListIndex = null;
	      delete index.$el[0].f7ListIndex;
	    }
	    Utils.deleteProps(index);
	    index = null;
	  };

	  return ListIndex;
	}(Framework7Class));

	var ListIndex$1 = {
	  name: 'listIndex',
	  static: {
	    ListIndex: ListIndex,
	  },
	  create: function create() {
	    var app = this;
	    app.listIndex = ConstructorMethods({
	      defaultSelector: '.list-index',
	      constructor: ListIndex,
	      app: app,
	      domProp: 'f7ListIndex',
	    });
	  },
	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $(tabEl).find('.list-index-init').each(function (index, listIndexEl) {
	        var params = Utils.extend($(listIndexEl).dataset(), { el: listIndexEl });
	        app.listIndex.create(params);
	      });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      $(tabEl).find('.list-index-init').each(function (index, listIndexEl) {
	        if (listIndexEl.f7ListIndex) { listIndexEl.f7ListIndex.destroy(); }
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.list-index-init').each(function (index, listIndexEl) {
	        var params = Utils.extend($(listIndexEl).dataset(), { el: listIndexEl });
	        app.listIndex.create(params);
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      page.$el.find('.list-index-init').each(function (index, listIndexEl) {
	        if (listIndexEl.f7ListIndex) { listIndexEl.f7ListIndex.destroy(); }
	      });
	    },
	  },
	  vnode: {
	    'list-index-init': {
	      insert: function insert(vnode) {
	        var app = this;
	        var listIndexEl = vnode.elm;
	        var params = Utils.extend($(listIndexEl).dataset(), { el: listIndexEl });
	        app.listIndex.create(params);
	      },
	      destroy: function destroy(vnode) {
	        var listIndexEl = vnode.elm;
	        if (listIndexEl.f7ListIndex) { listIndexEl.f7ListIndex.destroy(); }
	      },
	    },
	  },
	};

	var Timeline = {
	  name: 'timeline',
	};

	var Tab = {
	  show: function show() {
	    var assign, assign$1, assign$2;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var app = this;

	    var tabEl;
	    var tabLinkEl;
	    var animate;
	    var tabRoute;
	    if (args.length === 1 && args[0].constructor === Object) {
	      tabEl = args[0].tabEl;
	      tabLinkEl = args[0].tabLinkEl;
	      animate = args[0].animate;
	      tabRoute = args[0].tabRoute;
	    } else {
	      (assign = args, tabEl = assign[0], tabLinkEl = assign[1], animate = assign[2], tabRoute = assign[3]);
	      if (typeof args[1] === 'boolean') {
	        (assign$1 = args, tabEl = assign$1[0], animate = assign$1[1], tabLinkEl = assign$1[2], tabRoute = assign$1[3]);
	        if (args.length > 2 && tabLinkEl.constructor === Object) {
	          (assign$2 = args, tabEl = assign$2[0], animate = assign$2[1], tabRoute = assign$2[2], tabLinkEl = assign$2[3]);
	        }
	      }
	    }
	    if (typeof animate === 'undefined') { animate = true; }

	    var $newTabEl = $(tabEl);
	    if (tabRoute && $newTabEl[0]) {
	      $newTabEl[0].f7TabRoute = tabRoute;
	    }

	    if ($newTabEl.length === 0 || $newTabEl.hasClass('tab-active')) {
	      return {
	        $newTabEl: $newTabEl,
	        newTabEl: $newTabEl[0],
	      };
	    }

	    var $tabLinkEl;
	    if (tabLinkEl) { $tabLinkEl = $(tabLinkEl); }

	    var $tabsEl = $newTabEl.parent('.tabs');
	    if ($tabsEl.length === 0) {
	      return {
	        $newTabEl: $newTabEl,
	        newTabEl: $newTabEl[0],
	      };
	    }

	    // Release swipeouts in hidden tabs
	    if (app.swipeout) { app.swipeout.allowOpen = true; }

	    // Animated tabs
	    var tabsChangedCallbacks = [];

	    function onTabsChanged(callback) {
	      tabsChangedCallbacks.push(callback);
	    }
	    function tabsChanged() {
	      tabsChangedCallbacks.forEach(function (callback) {
	        callback();
	      });
	    }

	    var animated = false;

	    if ($tabsEl.parent().hasClass('tabs-animated-wrap')) {
	      $tabsEl.parent()[animate ? 'removeClass' : 'addClass']('not-animated');

	      var transitionDuration = parseFloat($tabsEl.css('transition-duration').replace(',', '.'));
	      if (animate && transitionDuration) {
	        $tabsEl.transitionEnd(tabsChanged);
	        animated = true;
	      }

	      var tabsTranslate = (app.rtl ? $newTabEl.index() : -$newTabEl.index()) * 100;
	      $tabsEl.transform(("translate3d(" + tabsTranslate + "%,0,0)"));
	    }

	    // Swipeable tabs
	    var swiper;
	    if ($tabsEl.parent().hasClass('tabs-swipeable-wrap') && app.swiper) {
	      swiper = $tabsEl.parent()[0].swiper;
	      if (swiper && swiper.activeIndex !== $newTabEl.index()) {
	        animated = true;
	        swiper
	          .once('slideChangeTransitionEnd', function () {
	            tabsChanged();
	          })
	          .slideTo($newTabEl.index(), animate ? undefined : 0);
	      } else if (swiper && swiper.animating) {
	        animated = true;
	        swiper
	          .once('slideChangeTransitionEnd', function () {
	            tabsChanged();
	          });
	      }
	    }

	    // Remove active class from old tabs
	    var $oldTabEl = $tabsEl.children('.tab-active');
	    $oldTabEl.removeClass('tab-active');
	    if (!swiper || (swiper && !swiper.animating) || (swiper && tabRoute)) {
	      $oldTabEl.trigger('tab:hide');
	      app.emit('tabHide', $oldTabEl[0]);
	    }

	    // Trigger 'show' event on new tab
	    $newTabEl.addClass('tab-active');
	    if (!swiper || (swiper && !swiper.animating) || (swiper && tabRoute)) {
	      $newTabEl.trigger('tab:show');
	      app.emit('tabShow', $newTabEl[0]);
	    }

	    // Find related link for new tab
	    if (!$tabLinkEl) {
	      // Search by id
	      if (typeof tabEl === 'string') { $tabLinkEl = $((".tab-link[href=\"" + tabEl + "\"]")); }
	      else { $tabLinkEl = $((".tab-link[href=\"#" + ($newTabEl.attr('id')) + "\"]")); }
	      // Search by data-tab
	      if (!$tabLinkEl || ($tabLinkEl && $tabLinkEl.length === 0)) {
	        $('[data-tab]').each(function (index, el) {
	          if ($newTabEl.is($(el).attr('data-tab'))) { $tabLinkEl = $(el); }
	        });
	      }
	      if (tabRoute && (!$tabLinkEl || ($tabLinkEl && $tabLinkEl.length === 0))) {
	        $tabLinkEl = $(("[data-route-tab-id=\"" + (tabRoute.route.tab.id) + "\"]"));
	        if ($tabLinkEl.length === 0) {
	          $tabLinkEl = $((".tab-link[href=\"" + (tabRoute.url) + "\"]"));
	        }
	      }
	      if ($tabLinkEl.length > 1 && $newTabEl.parents('.page').length) {
	        // eslint-disable-next-line
	        $tabLinkEl = $tabLinkEl.filter(function (index, tabLinkElement) {
	          return $(tabLinkElement).parents('.page')[0] === $newTabEl.parents('.page')[0];
	        });
	        if (app.theme === 'ios' && $tabLinkEl.length === 0 && tabRoute) {
	          var $pageEl = $newTabEl.parents('.page');
	          var $navbarEl = $(app.navbar.getElByPage($pageEl));
	          $tabLinkEl = $navbarEl.find(("[data-route-tab-id=\"" + (tabRoute.route.tab.id) + "\"]"));
	          if ($tabLinkEl.length === 0) {
	            $tabLinkEl = $navbarEl.find((".tab-link[href=\"" + (tabRoute.url) + "\"]"));
	          }
	        }
	      }
	    }
	    if ($tabLinkEl.length > 0) {
	      // Find related link for old tab
	      var $oldTabLinkEl;
	      if ($oldTabEl && $oldTabEl.length > 0) {
	        // Search by id
	        var oldTabId = $oldTabEl.attr('id');
	        if (oldTabId) {
	          $oldTabLinkEl = $((".tab-link[href=\"#" + oldTabId + "\"]"));
	          // Search by data-route-tab-id
	          if (!$oldTabLinkEl || ($oldTabLinkEl && $oldTabLinkEl.length === 0)) {
	            $oldTabLinkEl = $((".tab-link[data-route-tab-id=\"" + oldTabId + "\"]"));
	          }
	        }
	        // Search by data-tab
	        if (!$oldTabLinkEl || ($oldTabLinkEl && $oldTabLinkEl.length === 0)) {
	          $('[data-tab]').each(function (index, tabLinkElement) {
	            if ($oldTabEl.is($(tabLinkElement).attr('data-tab'))) { $oldTabLinkEl = $(tabLinkElement); }
	          });
	        }
	        if (!$oldTabLinkEl || ($oldTabLinkEl && $oldTabLinkEl.length === 0)) {
	          $oldTabLinkEl = $tabLinkEl.siblings('.tab-link-active');
	        }
	      } else if (tabRoute) {
	        $oldTabLinkEl = $tabLinkEl.siblings('.tab-link-active');
	      }

	      if ($oldTabLinkEl && $oldTabLinkEl.length > 1 && $oldTabEl && $oldTabEl.parents('.page').length) {
	        // eslint-disable-next-line
	        $oldTabLinkEl = $oldTabLinkEl.filter(function (index, tabLinkElement) {
	          return $(tabLinkElement).parents('.page')[0] === $oldTabEl.parents('.page')[0];
	        });
	      }

	      if ($oldTabLinkEl && $oldTabLinkEl.length > 0) { $oldTabLinkEl.removeClass('tab-link-active'); }

	      // Update links' classes
	      if ($tabLinkEl && $tabLinkEl.length > 0) {
	        $tabLinkEl.addClass('tab-link-active');
	        // Material Highlight
	        if (app.theme === 'md' && app.toolbar) {
	          var $tabbarEl = $tabLinkEl.parents('.tabbar, .tabbar-labels');
	          if ($tabbarEl.length > 0) {
	            app.toolbar.setHighlight($tabbarEl);
	          }
	        }
	      }
	    }
	    return {
	      $newTabEl: $newTabEl,
	      newTabEl: $newTabEl[0],
	      $oldTabEl: $oldTabEl,
	      oldTabEl: $oldTabEl[0],
	      onTabsChanged: onTabsChanged,
	      animated: animated,
	    };
	  },
	};
	var Tabs = {
	  name: 'tabs',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      tab: {
	        show: Tab.show.bind(app),
	      },
	    });
	  },
	  clicks: {
	    '.tab-link': function tabLinkClick($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      if (($clickedEl.attr('href') && $clickedEl.attr('href').indexOf('#') === 0) || $clickedEl.attr('data-tab')) {
	        app.tab.show({
	          tabEl: data.tab || $clickedEl.attr('href'),
	          tabLinkEl: $clickedEl,
	          animate: data.animate,
	        });
	      }
	    },
	  },
	};

	function swipePanel(panel) {
	  var app = panel.app;
	  Utils.extend(panel, {
	    swipeable: true,
	    swipeInitialized: true,
	  });
	  var params = app.params.panel;
	  var $el = panel.$el;
	  var $backdropEl = panel.$backdropEl;
	  var side = panel.side;
	  var effect = panel.effect;
	  var otherPanel;

	  var isTouched;
	  var isMoved;
	  var isScrolling;
	  var touchesStart = {};
	  var touchStartTime;
	  var touchesDiff;
	  var translate;
	  var backdropOpacity;
	  var panelWidth;
	  var direction;

	  var $viewEl;

	  var touchMoves = 0;
	  function handleTouchStart(e) {
	    if (!panel.swipeable) { return; }
	    if (!app.panel.allowOpen || (!params.swipe && !params.swipeOnlyClose) || isTouched) { return; }
	    if ($('.modal-in:not(.toast):not(.notification), .photo-browser-in').length > 0) { return; }
	    otherPanel = app.panel[side === 'left' ? 'right' : 'left'] || {};
	    if (!panel.opened && otherPanel.opened) { return; }
	    if (!(params.swipeCloseOpposite || params.swipeOnlyClose)) {
	      if (otherPanel.opened) { return; }
	    }
	    if (e.target && e.target.nodeName.toLowerCase() === 'input' && e.target.type === 'range') { return; }
	    if ($(e.target).closest('.range-slider, .tabs-swipeable-wrap, .calendar-months, .no-swipe-panel, .card-opened').length > 0) { return; }
	    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	    if (params.swipeOnlyClose && !panel.opened) {
	      return;
	    }
	    if (params.swipe !== 'both' && params.swipeCloseOpposite && params.swipe !== side && !panel.opened) {
	      return;
	    }
	    if (params.swipeActiveArea && !panel.opened) {
	      if (side === 'left') {
	        if (touchesStart.x > params.swipeActiveArea) { return; }
	      }
	      if (side === 'right') {
	        if (touchesStart.x < app.width - params.swipeActiveArea) { return; }
	      }
	    }
	    if (params.swipeCloseActiveAreaSide && panel.opened) {
	      if (side === 'left') {
	        if (touchesStart.x < ($el[0].offsetWidth - params.swipeCloseActiveAreaSide)) { return; }
	      }
	      if (side === 'right') {
	        if (touchesStart.x > ((app.width - $el[0].offsetWidth) + params.swipeCloseActiveAreaSide)) { return; }
	      }
	    }
	    touchMoves = 0;
	    $viewEl = $(panel.getViewEl());
	    isMoved = false;
	    isTouched = true;
	    isScrolling = undefined;

	    touchStartTime = Utils.now();
	    direction = undefined;
	  }
	  function handleTouchMove(e) {
	    if (!isTouched) { return; }
	    touchMoves += 1;
	    if (touchMoves < 2) { return; }
	    if (e.f7PreventSwipePanel || app.preventSwipePanelBySwipeBack || app.preventSwipePanel) {
	      isTouched = false;
	      return;
	    }
	    var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	    var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	    if (typeof isScrolling === 'undefined') {
	      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
	    }
	    if (isScrolling) {
	      isTouched = false;
	      return;
	    }
	    if (!direction) {
	      if (pageX > touchesStart.x) {
	        direction = 'to-right';
	      } else {
	        direction = 'to-left';
	      }

	      if (params.swipe === 'both') {
	        if (params.swipeActiveArea > 0 && !panel.opened) {
	          if (side === 'left' && touchesStart.x > params.swipeActiveArea) {
	            isTouched = false;
	            return;
	          }
	          if (side === 'right' && touchesStart.x < app.width - params.swipeActiveArea) {
	            isTouched = false;
	            return;
	          }
	        }
	      }
	      if ($el.hasClass('panel-visible-by-breakpoint')) {
	        isTouched = false;
	        return;
	      }

	      if (
	        (side === 'left'
	          && (
	            direction === 'to-left' && !$el.hasClass('panel-active')
	          )
	        )
	        || (side === 'right'
	          && (
	            direction === 'to-right' && !$el.hasClass('panel-active')
	          )
	        )
	      ) {
	        isTouched = false;
	        return;
	      }
	    }

	    var threshold = panel.opened ? 0 : -params.swipeThreshold;
	    if (side === 'right') { threshold = -threshold; }

	    if (params.swipeNoFollow) {
	      var touchesDiffNoFollow = (pageX - touchesStart.x);
	      var timeDiff = (new Date()).getTime() - touchStartTime;
	      var needToSwitch;
	      if (!panel.opened && (
	        (side === 'left' && touchesDiffNoFollow > -threshold)
	        || (side === 'right' && -touchesDiffNoFollow > threshold)
	      )) {
	        needToSwitch = true;
	      }
	      if (panel.opened && (
	        (side === 'left' && touchesDiffNoFollow < 0)
	        || (side === 'right' && touchesDiffNoFollow > 0)
	      )) {
	        needToSwitch = true;
	      }

	      if (needToSwitch) {
	        if (timeDiff < 300) {
	          if (direction === 'to-left') {
	            if (side === 'right') { app.panel.open(side); }
	            if (side === 'left' && $el.hasClass('panel-active')) { app.panel.close(); }
	          }
	          if (direction === 'to-right') {
	            if (side === 'left') { app.panel.open(side); }
	            if (side === 'right' && $el.hasClass('panel-active')) { app.panel.close(); }
	          }
	        }
	        isTouched = false;
	        isMoved = false;
	      }
	      return;
	    }

	    if (!isMoved) {
	      if (!panel.opened) {
	        $el.css('display', 'block');
	        $backdropEl.css('display', 'block');
	        $el.trigger('panel:swipeopen', panel);
	        panel.emit('local::swipeOpen panelSwipeOpen', panel);
	      }
	      panelWidth = $el[0].offsetWidth;
	      $el.transition(0);
	    }

	    isMoved = true;

	    e.preventDefault();

	    touchesDiff = (pageX - touchesStart.x) + threshold;

	    if (side === 'right') {
	      if (effect === 'cover') {
	        translate = touchesDiff + (panel.opened ? 0 : panelWidth);
	        if (translate < 0) { translate = 0; }
	        if (translate > panelWidth) {
	          translate = panelWidth;
	        }
	      } else {
	        translate = touchesDiff - (panel.opened ? panelWidth : 0);
	        if (translate > 0) { translate = 0; }
	        if (translate < -panelWidth) {
	          translate = -panelWidth;
	        }
	      }
	    } else {
	      translate = touchesDiff + (panel.opened ? panelWidth : 0);
	      if (translate < 0) { translate = 0; }
	      if (translate > panelWidth) {
	        translate = panelWidth;
	      }
	    }
	    if (effect === 'reveal') {
	      $viewEl.transform(("translate3d(" + translate + "px,0,0)")).transition(0);
	      $backdropEl.transform(("translate3d(" + translate + "px,0,0)")).transition(0);

	      $el.trigger('panel:swipe', panel, Math.abs(translate / panelWidth));
	      panel.emit('local::swipe panelSwipe', panel, Math.abs(translate / panelWidth));
	    } else {
	      if (side === 'left') { translate -= panelWidth; }
	      $el.transform(("translate3d(" + translate + "px,0,0)")).transition(0);

	      $backdropEl.transition(0);
	      backdropOpacity = 1 - Math.abs(translate / panelWidth);
	      $backdropEl.css({ opacity: backdropOpacity });

	      $el.trigger('panel:swipe', panel, Math.abs(translate / panelWidth));
	      panel.emit('local::swipe panelSwipe', panel, Math.abs(translate / panelWidth));
	    }
	  }
	  function handleTouchEnd() {
	    if (!isTouched || !isMoved) {
	      isTouched = false;
	      isMoved = false;
	      return;
	    }
	    isTouched = false;
	    isMoved = false;
	    var timeDiff = (new Date()).getTime() - touchStartTime;
	    var action;
	    var edge = (translate === 0 || Math.abs(translate) === panelWidth);

	    var threshold = params.swipeThreshold || 0;

	    if (!panel.opened) {
	      if (Math.abs(touchesDiff) < threshold) {
	        action = 'reset';
	      } else if (effect === 'cover') {
	        if (translate === 0) {
	          action = 'swap'; // open
	        } else if (timeDiff < 300 && Math.abs(translate) > 0) {
	          action = 'swap'; // open
	        } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
	          action = 'swap'; // open
	        } else {
	          action = 'reset'; // close
	        }
	      } else if (translate === 0) {
	        action = 'reset';
	      } else if (
	        (timeDiff < 300 && Math.abs(translate) > 0)
	        || (timeDiff >= 300 && (Math.abs(translate) >= panelWidth / 2))
	      ) {
	        action = 'swap';
	      } else {
	        action = 'reset';
	      }
	    } else if (effect === 'cover') {
	      if (translate === 0) {
	        action = 'reset'; // open
	      } else if (timeDiff < 300 && Math.abs(translate) > 0) {
	        action = 'swap'; // open
	      } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
	        action = 'reset'; // open
	      } else {
	        action = 'swap'; // close
	      }
	    } else if (translate === -panelWidth) {
	      action = 'reset';
	    } else if (
	      (timeDiff < 300 && Math.abs(translate) >= 0)
	      || (timeDiff >= 300 && (Math.abs(translate) <= panelWidth / 2))
	    ) {
	      if (side === 'left' && translate === panelWidth) { action = 'reset'; }
	      else { action = 'swap'; }
	    } else {
	      action = 'reset';
	    }
	    if (action === 'swap') {
	      if (panel.opened) {
	        panel.close(!edge);
	      } else {
	        panel.open(!edge);
	      }
	    }
	    if (action === 'reset') {
	      if (!panel.opened) {
	        if (edge) {
	          $el.css({ display: '' });
	        } else {
	          var target = effect === 'reveal' ? $viewEl : $el;
	          $('html').addClass('with-panel-transitioning');
	          target.transitionEnd(function () {
	            if ($el.hasClass('panel-active')) { return; }
	            $el.css({ display: '' });
	            $('html').removeClass('with-panel-transitioning');
	          });
	        }
	      }
	    }
	    if (effect === 'reveal') {
	      Utils.nextFrame(function () {
	        $viewEl.transition('');
	        $viewEl.transform('');
	      });
	    }
	    $el.transition('').transform('');
	    $backdropEl.css({ display: '' }).transform('').transition('').css('opacity', '');
	  }

	  // Add Events
	  app.on('touchstart:passive', handleTouchStart);
	  app.on('touchmove:active', handleTouchMove);
	  app.on('touchend:passive', handleTouchEnd);
	  panel.on('panelDestroy', function () {
	    app.off('touchstart:passive', handleTouchStart);
	    app.off('touchmove:active', handleTouchMove);
	    app.off('touchend:passive', handleTouchEnd);
	  });
	}

	function resizablePanel(panel) {
	  var app = panel.app;
	  Utils.extend(panel, {
	    resizable: true,
	    resizableWidth: null,
	    resizableInitialized: true,
	  });
	  var $htmlEl = $('html');
	  var $el = panel.$el;
	  var $backdropEl = panel.$backdropEl;
	  var side = panel.side;
	  var effect = panel.effect;
	  if (!$el) { return; }

	  var isTouched;
	  var isMoved;
	  var touchesStart = {};
	  var touchesDiff;
	  var panelWidth;

	  var $viewEl;

	  var panelMinWidth;
	  var panelMaxWidth;
	  var visibleByBreakpoint;

	  function transformCSSWidth(v) {
	    if (!v) { return null; }
	    if (v.indexOf('%') >= 0 || v.indexOf('vw') >= 0) {
	      return parseInt(v, 10) / 100 * app.width;
	    }
	    var newV = parseInt(v, 10);
	    if (Number.isNaN(newV)) { return null; }
	    return newV;
	  }

	  function isResizable() {
	    return panel.resizable && $el.hasClass('panel-resizable');
	  }

	  function handleTouchStart(e) {
	    if (!isResizable()) { return; }
	    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	    isMoved = false;
	    isTouched = true;
	    panelMinWidth = transformCSSWidth($el.css('min-width'));
	    panelMaxWidth = transformCSSWidth($el.css('max-width'));
	    visibleByBreakpoint = $el.hasClass('panel-visible-by-breakpoint');
	  }
	  function handleTouchMove(e) {
	    if (!isTouched) { return; }
	    var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;

	    if (!isMoved) {
	      panelWidth = $el[0].offsetWidth;
	      $el.transition(0);
	      $el.addClass('panel-resizing');
	      $htmlEl.css('cursor', 'col-resize');
	      if (effect === 'reveal' || visibleByBreakpoint) {
	        $viewEl = $(panel.getViewEl());
	      }
	      if (effect === 'reveal' && !visibleByBreakpoint) {
	        $backdropEl.transition(0);
	        $viewEl.transition(0);
	      }
	    }

	    isMoved = true;

	    e.preventDefault();

	    touchesDiff = (pageX - touchesStart.x);

	    var newPanelWidth = side === 'left' ? panelWidth + touchesDiff : panelWidth - touchesDiff;
	    if (panelMinWidth && !Number.isNaN(panelMinWidth)) {
	      newPanelWidth = Math.max(newPanelWidth, panelMinWidth);
	    }
	    if (panelMaxWidth && !Number.isNaN(panelMaxWidth)) {
	      newPanelWidth = Math.min(newPanelWidth, panelMaxWidth);
	    }
	    newPanelWidth = Math.min(Math.max(newPanelWidth, 0), app.width);

	    panel.resizableWidth = newPanelWidth;
	    $el[0].style.width = newPanelWidth + "px";
	    if (effect === 'reveal' && !visibleByBreakpoint) {
	      if ($viewEl) {
	        $viewEl.transform(("translate3d(" + (side === 'left' ? newPanelWidth : -newPanelWidth) + "px, 0, 0)"));
	      }
	      if ($backdropEl) {
	        $backdropEl.transform(("translate3d(" + (side === 'left' ? newPanelWidth : -newPanelWidth) + "px, 0, 0)"));
	      }
	    } else if (visibleByBreakpoint && $viewEl) {
	      $viewEl.css(("margin-" + side), (newPanelWidth + "px"));
	    }

	    $el.trigger('panel:resize', panel, newPanelWidth);
	    panel.emit('local::resize panelResize', panel, newPanelWidth);
	  }
	  function handleTouchEnd() {
	    $('html').css('cursor', '');
	    if (!isTouched || !isMoved) {
	      isTouched = false;
	      isMoved = false;
	      return;
	    }
	    isTouched = false;
	    isMoved = false;

	    $htmlEl[0].style.setProperty(("--f7-panel-" + side + "-width"), ((panel.resizableWidth) + "px"));
	    $el[0].style.width = '';
	    if (effect === 'reveal' && !visibleByBreakpoint) {
	      $viewEl.transform('');
	      $backdropEl.transform('');
	    }
	    $el.removeClass('panel-resizing');
	    Utils.nextFrame(function () {
	      if (visibleByBreakpoint) { return; }
	      $el.transition('');
	      if (effect === 'reveal') {
	        $backdropEl.transition('');
	        if ($viewEl) { $viewEl.transition(''); }
	      }
	    });
	  }

	  function handleResize() {
	    if (!panel.opened || !panel.resizableWidth) { return; }
	    panelMinWidth = transformCSSWidth($el.css('min-width'));
	    panelMaxWidth = transformCSSWidth($el.css('max-width'));

	    if (panelMinWidth && !Number.isNaN(panelMinWidth) && panel.resizableWidth < panelMinWidth) {
	      panel.resizableWidth = Math.max(panel.resizableWidth, panelMinWidth);
	    }
	    if (panelMaxWidth && !Number.isNaN(panelMaxWidth) && panel.resizableWidth > panelMaxWidth) {
	      panel.resizableWidth = Math.min(panel.resizableWidth, panelMaxWidth);
	    }
	    panel.resizableWidth = Math.min(Math.max(panel.resizableWidth, 0), app.width);

	    $htmlEl[0].style.setProperty(("--f7-panel-" + side + "-width"), ((panel.resizableWidth) + "px"));
	  }

	  if (panel.$el.find('.panel-resize-handler').length === 0) {
	    panel.$el.append('<div class="panel-resize-handler"></div>');
	  }
	  panel.$resizeHandlerEl = panel.$el.children('.panel-resize-handler');

	  $el.addClass('panel-resizable');

	  // Add Events
	  var passive = Support.passiveListener ? { passive: true } : false;

	  panel.$el.on(app.touchEvents.start, '.panel-resize-handler', handleTouchStart, passive);
	  app.on('touchmove:active', handleTouchMove);
	  app.on('touchend:passive', handleTouchEnd);
	  app.on('resize', handleResize);
	  panel.on('beforeOpen', handleResize);

	  panel.once('panelDestroy', function () {
	    $el.removeClass('panel-resizable');
	    panel.$resizeHandlerEl.remove();
	    panel.$el.off(app.touchEvents.start, '.panel-resize-handler', handleTouchStart, passive);
	    app.off('touchmove:active', handleTouchMove);
	    app.off('touchend:passive', handleTouchEnd);
	    app.off('resize', handleResize);
	    panel.off('beforeOpen', handleResize);
	  });
	}

	var Panel = /*@__PURE__*/(function (Framework7Class) {
	  function Panel(app, params) {
	    var obj;

	    if ( params === void 0 ) params = {};
	    Framework7Class.call(this, params, [app]);
	    var panel = this;

	    var el = params.el;

	    if (!el && params.content) {
	      el = params.content;
	    }

	    var $el = $(el);
	    if ($el.length === 0) { return panel; }
	    if ($el[0].f7Panel) { return $el[0].f7Panel; }

	    $el[0].f7Panel = panel;

	    var opened = params.opened;
	    var side = params.side;
	    var effect = params.effect;
	    if (typeof opened === 'undefined') { opened = $el.hasClass('panel-active'); }
	    if (typeof side === 'undefined') { side = $el.hasClass('panel-left') ? 'left' : 'right'; }
	    if (typeof effect === 'undefined') { effect = $el.hasClass('panel-cover') ? 'cover' : 'reveal'; }

	    if (!app.panel[side]) {
	      Utils.extend(app.panel, ( obj = {}, obj[side] = panel, obj ));
	    } else {
	      throw new Error(("Framework7: Can't create panel; app already has a " + side + " panel!"));
	    }

	    var $backdropEl = $('.panel-backdrop');

	    if ($backdropEl.length === 0) {
	      $backdropEl = $('<div class="panel-backdrop"></div>');
	      $backdropEl.insertBefore($el);
	    }

	    Utils.extend(panel, {
	      app: app,
	      side: side,
	      effect: effect,
	      $el: $el,
	      el: $el[0],
	      opened: opened,
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl[0],
	      params: params,
	    });

	    // Install Modules
	    panel.useModules();

	    // Init
	    panel.init();

	    return panel;
	  }

	  if ( Framework7Class ) Panel.__proto__ = Framework7Class;
	  Panel.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  Panel.prototype.constructor = Panel;

	  Panel.prototype.getViewEl = function getViewEl () {
	    var panel = this;
	    var app = panel.app;
	    var viewEl;
	    if (app.root.children('.views').length > 0) {
	      viewEl = app.root.children('.views')[0];
	    } else {
	      viewEl = app.root.children('.view')[0];
	    }
	    return viewEl;
	  };

	  Panel.prototype.setBreakpoint = function setBreakpoint (emitEvents) {
	    var obj, obj$1, obj$2;

	    if ( emitEvents === void 0 ) emitEvents = true;
	    var panel = this;
	    var app = panel.app;
	    var side = panel.side;
	    var $el = panel.$el;
	    var $viewEl = $(panel.getViewEl());
	    var breakpoint = app.params.panel[(side + "Breakpoint")];
	    var wasVisible = $el.hasClass('panel-visible-by-breakpoint');

	    if (app.width >= breakpoint) {
	      if (!wasVisible) {
	        $('html').removeClass(("with-panel-" + side + "-reveal with-panel-" + side + "-cover with-panel"));
	        $el.css('display', '').addClass('panel-visible-by-breakpoint').removeClass('panel-active');
	        panel.onOpen();
	        panel.onOpened();
	        $viewEl.css(( obj = {}, obj[("margin-" + side)] = (($el.width()) + "px"), obj ));
	        app.allowPanelOpen = true;
	        if (emitEvents) {
	          app.emit('local::breakpoint panelBreakpoint');
	          panel.$el.trigger('panel:breakpoint', panel);
	        }
	      } else {
	        $viewEl.css(( obj$1 = {}, obj$1[("margin-" + side)] = (($el.width()) + "px"), obj$1 ));
	      }
	    } else if (wasVisible) {
	      $el.css('display', '').removeClass('panel-visible-by-breakpoint panel-active');
	      panel.onClose();
	      panel.onClosed();
	      $viewEl.css(( obj$2 = {}, obj$2[("margin-" + side)] = '', obj$2 ));
	      if (emitEvents) {
	        app.emit('local::breakpoint panelBreakpoint');
	        panel.$el.trigger('panel:breakpoint', panel);
	      }
	    }
	  };

	  Panel.prototype.initBreakpoints = function initBreakpoints () {
	    var panel = this;
	    var app = panel.app;
	    panel.resizeHandler = function resizeHandler() {
	      panel.setBreakpoint();
	    };
	    if (app.params.panel[((panel.side) + "Breakpoint")]) {
	      app.on('resize', panel.resizeHandler);
	    }
	    panel.setBreakpoint();
	    return panel;
	  };

	  Panel.prototype.initSwipePanel = function initSwipePanel () {
	    {
	      swipePanel(this);
	    }
	  };

	  Panel.prototype.initResizablePanel = function initResizablePanel () {
	    resizablePanel(this);
	  };

	  Panel.prototype.toggle = function toggle (animate) {
	    if ( animate === void 0 ) animate = true;

	    var panel = this;
	    if (panel.opened) { panel.close(animate); }
	    else { panel.open(animate); }
	  };

	  Panel.prototype.onOpen = function onOpen () {
	    var panel = this;
	    panel.opened = true;

	    panel.$el.trigger('panel:beforeopen', panel);
	    panel.emit('local::beforeOpen panelBeforeOpen', panel);

	    panel.$el.trigger('panel:open', panel);
	    panel.emit('local::open panelOpen', panel);
	  };

	  Panel.prototype.onOpened = function onOpened () {
	    var panel = this;
	    var app = panel.app;
	    app.panel.allowOpen = true;

	    panel.$el.trigger('panel:opened', panel);
	    panel.emit('local::opened panelOpened', panel);
	  };

	  Panel.prototype.onClose = function onClose () {
	    var panel = this;
	    panel.opened = false;
	    panel.$el.addClass('panel-closing');

	    panel.$el.trigger('panel:beforeclose', panel);
	    panel.emit('local::beforeClose panelBeforeClose', panel);

	    panel.$el.trigger('panel:close', panel);
	    panel.emit('local::close panelClose', panel);
	  };

	  Panel.prototype.onClosed = function onClosed () {
	    var panel = this;
	    var app = panel.app;
	    app.panel.allowOpen = true;
	    panel.$el.removeClass('panel-closing');
	    panel.$el.trigger('panel:closed', panel);
	    panel.emit('local::closed panelClosed', panel);
	  };

	  Panel.prototype.open = function open (animate) {
	    if ( animate === void 0 ) animate = true;

	    var panel = this;
	    var app = panel.app;
	    if (!app.panel.allowOpen) { return false; }

	    var side = panel.side;
	    var effect = panel.effect;
	    var $el = panel.$el;
	    var $backdropEl = panel.$backdropEl;
	    var opened = panel.opened;

	    var $panelParentEl = $el.parent();
	    var wasInDom = $el.parents(document).length > 0;

	    if (!$panelParentEl.is(app.root) || $el.prevAll('.views, .view').length) {
	      var $insertBeforeEl = app.root.children('.panel, .views, .view').eq(0);
	      var $insertAfterEl = app.root.children('.statusbar').eq(0);

	      if ($insertBeforeEl.length) {
	        $el.insertBefore($insertBeforeEl);
	      } else if ($insertAfterEl.length) {
	        $el.insertAfter($insertBeforeEl);
	      } else {
	        app.root.prepend($el);
	      }

	      if ($backdropEl
	        && $backdropEl.length
	        && (
	          (
	            !$backdropEl.parent().is(app.root)
	            && $backdropEl.nextAll('.panel').length === 0
	          )
	          || (
	            $backdropEl.parent().is(app.root)
	            && $backdropEl.nextAll('.panel').length === 0
	          )
	        )
	      ) {
	        $backdropEl.insertBefore($el);
	      }

	      panel.once('panelClosed', function () {
	        if (wasInDom) {
	          $panelParentEl.append($el);
	        } else {
	          $el.remove();
	        }
	      });
	    }

	    // Ignore if opened
	    if (opened || $el.hasClass('panel-visible-by-breakpoint') || $el.hasClass('panel-active')) { return false; }

	    // Close if some panel is opened
	    app.panel.close(side === 'left' ? 'right' : 'left', animate);

	    app.panel.allowOpen = false;

	    $el[animate ? 'removeClass' : 'addClass']('not-animated');
	    $el
	      .css({ display: 'block' })
	      .addClass('panel-active');

	    $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
	    $backdropEl.css({ display: 'block' });

	    /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
	    // panel._clientLeft = $el[0].clientLeft;

	    // Transition End;
	    var transitionEndTarget = effect === 'reveal' ? $el.nextAll('.view, .views').eq(0) : $el;

	    function panelTransitionEnd() {
	      transitionEndTarget.transitionEnd(function (e) {
	        if ($(e.target).is(transitionEndTarget)) {
	          if ($el.hasClass('panel-active')) {
	            panel.onOpened();
	            $backdropEl.css({ display: '' });
	          } else {
	            panel.onClosed();
	            $backdropEl.css({ display: '' });
	          }
	        } else { panelTransitionEnd(); }
	      });
	    }

	    if (animate) {
	      Utils.nextFrame(function () {
	        $('html').addClass(("with-panel with-panel-" + side + "-" + effect));
	        panel.onOpen();
	        panelTransitionEnd();
	      });
	    } else {
	      $('html').addClass(("with-panel with-panel-" + side + "-" + effect));
	      panel.onOpen();
	      panel.onOpened();
	      $backdropEl.css({ display: '' });
	    }

	    return true;
	  };

	  Panel.prototype.close = function close (animate) {
	    if ( animate === void 0 ) animate = true;

	    var panel = this;
	    var app = panel.app;

	    var side = panel.side;
	    var effect = panel.effect;
	    var $el = panel.$el;
	    var $backdropEl = panel.$backdropEl;
	    var opened = panel.opened;
	    if (!opened || $el.hasClass('panel-visible-by-breakpoint') || !$el.hasClass('panel-active')) { return false; }

	    $el[animate ? 'removeClass' : 'addClass']('not-animated');
	    $el.removeClass('panel-active');

	    $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');

	    var transitionEndTarget = effect === 'reveal' ? $el.nextAll('.view, .views').eq(0) : $el;

	    panel.onClose();
	    app.panel.allowOpen = false;

	    if (animate) {
	      transitionEndTarget.transitionEnd(function () {
	        if ($el.hasClass('panel-active')) { return; }
	        $el.css({ display: '' });
	        $('html').removeClass('with-panel-transitioning');
	        panel.onClosed();
	      });
	      $('html')
	        .removeClass(("with-panel with-panel-" + side + "-" + effect))
	        .addClass('with-panel-transitioning');
	    } else {
	      $el.css({ display: '' });
	      $el.removeClass('not-animated');
	      $('html').removeClass(("with-panel with-panel-transitioning with-panel-" + side + "-" + effect));
	      panel.onClosed();
	    }
	    return true;
	  };

	  Panel.prototype.init = function init () {
	    var panel = this;
	    var app = panel.app;
	    if (app.params.panel[((panel.side) + "Breakpoint")]) {
	      panel.initBreakpoints();
	    }
	    {
	      if (
	        (app.params.panel.swipe === panel.side)
	        || (app.params.panel.swipe === 'both')
	        || (app.params.panel.swipe && app.params.panel.swipe !== panel.side && app.params.panel.swipeCloseOpposite)
	      ) {
	        panel.initSwipePanel();
	      }
	    }
	    if (panel.params.resizable || panel.$el.hasClass('panel-resizable')) {
	      panel.initResizablePanel();
	    }
	  };

	  Panel.prototype.destroy = function destroy () {
	    var obj;

	    var panel = this;
	    var app = panel.app;

	    if (!panel.$el) {
	      // Panel already destroyed
	      return;
	    }

	    panel.emit('local::beforeDestroy panelBeforeDestroy', panel);
	    panel.$el.trigger('panel:beforedestroy', panel);

	    if (panel.resizeHandler) {
	      app.off('resize', panel.resizeHandler);
	    }

	    if (panel.$el.hasClass('panel-visible-by-breakpoint')) {
	      var $viewEl = $(panel.getViewEl());
	      panel.$el.css('display', '').removeClass('panel-visible-by-breakpoint panel-active');
	      $viewEl.css(( obj = {}, obj[("margin-" + (panel.side))] = '', obj ));
	      app.emit('local::breakpoint panelBreakpoint');
	      panel.$el.trigger('panel:breakpoint', panel);
	    }

	    panel.$el.trigger('panel:destroy', panel);
	    panel.emit('local::destroy panelDestroy');
	    delete app.panel[panel.side];
	    if (panel.el) {
	      panel.el.f7Panel = null;
	      delete panel.el.f7Panel;
	    }
	    Utils.deleteProps(panel);
	    panel = null;
	  };

	  return Panel;
	}(Framework7Class));

	var Panel$1 = {
	  name: 'panel',
	  params: {
	    panel: {
	      leftBreakpoint: 0,
	      rightBreakpoint: 0,
	      swipe: undefined, // or 'left' or 'right' or 'both'
	      swipeActiveArea: 0,
	      swipeCloseActiveAreaSide: 0,
	      swipeCloseOpposite: true,
	      swipeOnlyClose: false,
	      swipeNoFollow: false,
	      swipeThreshold: 0,
	      closeByBackdropClick: true,
	    },
	  },
	  static: {
	    Panel: Panel,
	  },
	  instance: {
	    panel: {
	      allowOpen: true,
	    },
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app.panel, {
	      disableResizable: function disableResizable(panel) {
	        if ( panel === void 0 ) panel = 'both';

	        var side;
	        var panels = [];
	        if (typeof panel === 'string') {
	          if (panel === 'both') {
	            side = 'both';
	            panels = [app.panel.left, app.panel.right];
	          } else {
	            side = panel;
	            panels.push(app.panel[side]);
	          }
	        } else {
	          panels = [panel];
	        }
	        panels.forEach(function (panelInstance) {
	          panelInstance.resizable = false;
	          panelInstance.$el.removeClass('panel-resizable');
	        });
	      },
	      enableResizable: function enableResizable(panel) {
	        if ( panel === void 0 ) panel = 'both';

	        var side;
	        var panels = [];
	        if (typeof panel === 'string') {
	          if (panel === 'both') {
	            side = 'both';
	            panels = [app.panel.left, app.panel.right];
	          } else {
	            side = panel;
	            panels.push(app.panel[side]);
	          }
	        } else {
	          panels = [panel];
	        }
	        panels.forEach(function (panelInstance) {
	          if (!panelInstance) { return; }
	          if (!panelInstance.resizableInitialized) {
	            panelInstance.initResizablePanel();
	          } else {
	            panelInstance.resizable = true;
	            panelInstance.$el.addClass('panel-resizable');
	          }
	        });
	      },
	      disableSwipe: function disableSwipe(panel) {
	        if ( panel === void 0 ) panel = 'both';

	        var side;
	        var panels = [];
	        if (typeof panel === 'string') {
	          if (panel === 'both') {
	            side = 'both';
	            panels = [app.panel.left, app.panel.right];
	          } else {
	            side = panel;
	            panels.push(app.panel[side]);
	          }
	        } else {
	          panels = [panel];
	        }
	        panels.forEach(function (panelInstance) {
	          panelInstance.swipeable = false;
	        });
	      },
	      enableSwipe: function enableSwipe(panel) {
	        if ( panel === void 0 ) panel = 'both';

	        var panels = [];
	        var side;
	        if (typeof panel === 'string') {
	          side = panel;
	          if (
	            (app.params.panel.swipe === 'left' && side === 'right')
	            || (app.params.panel.swipe === 'right' && side === 'left')
	            || side === 'both'
	          ) {
	            side = 'both';
	            app.params.panel.swipe = side;
	            panels = [app.panel.left, app.panel.right];
	          } else {
	            app.params.panel.swipe = side;
	            panels.push(app.panel[side]);
	          }
	        } else if (panel) {
	          panels.push(panel);
	        }
	        panels.forEach(function (panelInstance) {
	          if (!panelInstance) { return; }
	          if (!panelInstance.swipeInitialized) {
	            panelInstance.initSwipePanel();
	          } else {
	            panelInstance.swipeable = true;
	          }
	        });
	      },
	      create: function create(params) {
	        return new Panel(app, params);
	      },
	      open: function open(side, animate) {
	        var panelSide = side;
	        if (!panelSide) {
	          if ($('.panel').length > 1) {
	            return false;
	          }
	          panelSide = $('.panel').hasClass('panel-left') ? 'left' : 'right';
	        }
	        if (!panelSide) { return false; }
	        if (app.panel[panelSide]) {
	          return app.panel[panelSide].open(animate);
	        }
	        var $panelEl = $((".panel-" + panelSide));
	        if ($panelEl.length > 0) {
	          return app.panel.create({ el: $panelEl }).open(animate);
	        }
	        return false;
	      },
	      close: function close(side, animate) {
	        var $panelEl;
	        var panelSide;
	        if (panelSide) {
	          panelSide = side;
	          $panelEl = $((".panel-" + panelSide));
	        } else {
	          $panelEl = $('.panel.panel-active');
	          panelSide = $panelEl.hasClass('panel-left') ? 'left' : 'right';
	        }
	        if (!panelSide) { return false; }
	        if (app.panel[panelSide]) {
	          return app.panel[panelSide].close(animate);
	        }
	        if ($panelEl.length > 0) {
	          return app.panel.create({ el: $panelEl }).close(animate);
	        }
	        return false;
	      },
	      toggle: function toggle(side, animate) {
	        var $panelEl;
	        var panelSide = side;
	        if (side) {
	          panelSide = side;
	          $panelEl = $((".panel-" + panelSide));
	        } else if ($('.panel.panel-active').length) {
	          $panelEl = $('.panel.panel-active');
	          panelSide = $panelEl.hasClass('panel-left') ? 'left' : 'right';
	        } else {
	          if ($('.panel').length > 1) {
	            return false;
	          }
	          panelSide = $('.panel').hasClass('panel-left') ? 'left' : 'right';
	          $panelEl = $((".panel-" + panelSide));
	        }
	        if (!panelSide) { return false; }
	        if (app.panel[panelSide]) {
	          return app.panel[panelSide].toggle(animate);
	        }
	        if ($panelEl.length > 0) {
	          return app.panel.create({ el: $panelEl }).toggle(animate);
	        }
	        return false;
	      },
	      get: function get(side) {
	        var panelSide = side;
	        if (!panelSide) {
	          if ($('.panel').length > 1) {
	            return undefined;
	          }
	          panelSide = $('.panel').hasClass('panel-left') ? 'left' : 'right';
	        }
	        if (!panelSide) { return undefined; }
	        if (app.panel[panelSide]) {
	          return app.panel[panelSide];
	        }
	        var $panelEl = $((".panel-" + panelSide));
	        if ($panelEl.length > 0) {
	          return app.panel.create({ el: $panelEl });
	        }
	        return undefined;
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var app = this;

	      // Create Panels
	      $('.panel').each(function (index, panelEl) {
	        var side = $(panelEl).hasClass('panel-left') ? 'left' : 'right';
	        app.panel[side] = app.panel.create({ el: panelEl, side: side });
	      });
	    },
	  },
	  clicks: {
	    '.panel-open': function open(clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var side = 'left';
	      if (data.panel === 'right' || ($('.panel').length === 1 && $('.panel').hasClass('panel-right'))) {
	        side = 'right';
	      }
	      app.panel.open(side, data.animate);
	    },
	    '.panel-close': function close(clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var side = data.panel;
	      app.panel.close(side, data.animate);
	    },
	    '.panel-toggle': function close(clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var side = data.panel;
	      app.panel.toggle(side, data.animate);
	    },
	    '.panel-backdrop': function close() {
	      var app = this;
	      var $panelEl = $('.panel-active');
	      var instance = $panelEl[0] && $panelEl[0].f7Panel;
	      $panelEl.trigger('panel:backdrop-click');
	      if (instance) {
	        instance.emit('backdropClick', instance);
	      }
	      app.emit('panelBackdropClick', instance || $panelEl[0]);
	      if (app.params.panel.closeByBackdropClick) { app.panel.close(); }
	    },
	  },
	};

	/* eslint no-param-reassign: "off" */

	var CardExpandable = {
	  open: function open(cardEl, animate) {
	    var assign;

	    if ( cardEl === void 0 ) cardEl = '.card-expandable';
	    if ( animate === void 0 ) animate = true;
	    var app = this;

	    if ($('.card-opened').length) { return; }
	    var $cardEl = $(cardEl).eq(0);

	    if (!$cardEl || !$cardEl.length) { return; }
	    if ($cardEl.hasClass('card-opened') || $cardEl.hasClass('card-opening') || $cardEl.hasClass('card-closing')) { return; }

	    var $pageEl = $cardEl.parents('.page').eq(0);
	    if (!$pageEl.length) { return; }

	    var prevented;

	    function prevent() {
	      prevented = true;
	    }

	    $cardEl.trigger('card:beforeopen', { prevent: prevent });
	    app.emit('cardBeforeOpen', $cardEl[0], prevent);

	    if (prevented) { return; }

	    var cardParams = Object.assign({ animate: animate }, app.params.card, $cardEl.dataset());

	    var $pageContentEl = $cardEl.parents('.page-content');

	    var $backdropEl;
	    if ($cardEl.attr('data-backdrop-el')) {
	      $backdropEl = $($cardEl.attr('data-backdrop-el'));
	    }
	    if (!$backdropEl && cardParams.backdrop) {
	      $backdropEl = $pageContentEl.find('.card-backdrop');
	      if (!$backdropEl.length) {
	        $backdropEl = $('<div class="card-backdrop"></div>');
	        $pageContentEl.append($backdropEl);
	      }
	    }

	    var $navbarEl;
	    var $toolbarEl;
	    if (cardParams.hideNavbarOnOpen) {
	      $navbarEl = $pageEl.children('.navbar');
	      if (!$navbarEl.length) {
	        if ($pageEl[0].f7Page) { $navbarEl = $pageEl[0].f7Page.$navbarEl; }
	      }
	    }
	    if (cardParams.hideToolbarOnOpen) {
	      $toolbarEl = $pageEl.children('.toolbar');
	      if (!$toolbarEl.length) {
	        $toolbarEl = $pageEl.parents('.view').children('.toolbar');
	      }
	      if (!$toolbarEl.length) {
	        $toolbarEl = $pageEl.parents('.views').children('.toolbar');
	      }
	    }

	    var currTransform = $cardEl.css('transform');
	    var hasTransform;
	    if (currTransform && currTransform.match(/[2-9]/)) {
	      hasTransform = true;
	    }
	    var $cardContentEl = $cardEl.children('.card-content');

	    var $cardSizeEl = $(document.createElement('div')).addClass('card-expandable-size');
	    $cardEl.append($cardSizeEl);

	    var cardWidth = $cardEl[0].offsetWidth;
	    var cardHeight = $cardEl[0].offsetHeight;
	    var pageWidth = $pageEl[0].offsetWidth;
	    var pageHeight = $pageEl[0].offsetHeight;

	    var maxWidth = $cardSizeEl[0].offsetWidth || pageWidth;
	    var maxHeight = $cardSizeEl[0].offsetHeight || pageHeight;

	    var scaleX = maxWidth / cardWidth;
	    var scaleY = maxHeight / cardHeight;

	    var offset = $cardEl.offset();
	    var pageOffset = $pageEl.offset();
	    offset.left -= pageOffset.left;

	    var cardLeftOffset;
	    var cardTopOffset;

	    if (hasTransform) {
	      var transformValues = currTransform
	        .replace(/matrix\(|\)/g, '')
	        .split(',')
	        .map(function (el) { return el.trim(); });
	      if (transformValues && transformValues.length > 1) {
	        var scale = parseFloat(transformValues[0]);
	        cardLeftOffset = offset.left - cardWidth * (1 - scale) / 2;
	        cardTopOffset = offset.top - pageOffset.top - cardHeight * (1 - scale) / 2;
	        if (app.rtl) { cardLeftOffset -= $cardEl[0].scrollLeft; }
	      } else {
	        cardLeftOffset = $cardEl[0].offsetLeft;
	        cardTopOffset = $cardEl[0].offsetTop - ($pageContentEl.length ? $pageContentEl[0].scrollTop : 0);
	      }
	    } else {
	      cardLeftOffset = offset.left;
	      cardTopOffset = offset.top - pageOffset.top;
	      if (app.rtl) { cardLeftOffset -= $cardEl[0].scrollLeft; }
	    }

	    cardLeftOffset -= (pageWidth - maxWidth) / 2;
	    cardTopOffset -= (pageHeight - maxHeight) / 2;

	    var cardRightOffset = maxWidth - cardWidth - cardLeftOffset;
	    if (app.rtl) {
	      (assign = [cardRightOffset, cardLeftOffset], cardLeftOffset = assign[0], cardRightOffset = assign[1]);
	    }
	    var cardBottomOffset = maxHeight - cardHeight - cardTopOffset;
	    var translateX = (cardRightOffset - cardLeftOffset) / 2;
	    var translateY = (cardBottomOffset - cardTopOffset) / 2;
	    if (cardParams.hideNavbarOnOpen && $navbarEl && $navbarEl.length) {
	      app.navbar.hide($navbarEl, cardParams.animate);
	    }
	    if (cardParams.hideToolbarOnOpen && $toolbarEl && $toolbarEl.length) {
	      app.toolbar.hide($toolbarEl, cardParams.animate);
	    }
	    if ($backdropEl) {
	      $backdropEl.removeClass('card-backdrop-out').addClass('card-backdrop-in');
	    }
	    $cardEl.removeClass('card-transitioning');
	    if (cardParams.animate) {
	      $cardEl.addClass('card-opening');
	    }
	    $cardEl.trigger('card:open');
	    app.emit('cardOpen', $cardEl[0]);
	    function transitionEnd() {
	      $pageEl.addClass('page-with-card-opened');
	      if (app.device.ios && $pageContentEl.length) {
	        $pageContentEl.css('height', (($pageContentEl[0].offsetHeight + 1) + "px"));
	        setTimeout(function () {
	          $pageContentEl.css('height', '');
	        });
	      }
	      $cardEl.addClass('card-opened');
	      $cardEl.removeClass('card-opening');
	      $cardEl.trigger('card:opened');
	      app.emit('cardOpened', $cardEl[0]);
	    }
	    $cardContentEl
	      .css({
	        width: (maxWidth + "px"),
	        height: (maxHeight + "px"),
	      })
	      .transform(("translate3d(" + (app.rtl ? (cardLeftOffset + translateX) : (-cardLeftOffset - translateX)) + "px, 0px, 0) scale(" + (1 / scaleX) + ", " + (1 / scaleY) + ")"));

	    $cardEl
	      .transform(("translate3d(" + translateX + "px, " + translateY + "px, 0) scale(" + scaleX + ", " + scaleY + ")"));
	    if (cardParams.animate) {
	      $cardEl.transitionEnd(function () {
	        transitionEnd();
	      });
	    } else {
	      transitionEnd();
	    }

	    function onResize() {
	      var assign;

	      $cardEl.removeClass('card-transitioning');
	      cardWidth = $cardEl[0].offsetWidth;
	      cardHeight = $cardEl[0].offsetHeight;
	      pageWidth = $pageEl[0].offsetWidth;
	      pageHeight = $pageEl[0].offsetHeight;
	      maxWidth = $cardSizeEl[0].offsetWidth || pageWidth;
	      maxHeight = $cardSizeEl[0].offsetHeight || pageHeight;

	      scaleX = maxWidth / cardWidth;
	      scaleY = maxHeight / cardHeight;

	      $cardEl.transform('translate3d(0px, 0px, 0) scale(1)');
	      offset = $cardEl.offset();
	      pageOffset = $pageEl.offset();
	      offset.left -= pageOffset.left;
	      offset.top -= pageOffset.top;

	      cardLeftOffset = offset.left - (pageWidth - maxWidth) / 2;
	      if (app.rtl) { cardLeftOffset -= $cardEl[0].scrollLeft; }
	      cardTopOffset = offset.top - (pageHeight - maxHeight) / 2;

	      cardRightOffset = maxWidth - cardWidth - cardLeftOffset;
	      cardBottomOffset = maxHeight - cardHeight - cardTopOffset;
	      if (app.rtl) {
	        (assign = [cardRightOffset, cardLeftOffset], cardLeftOffset = assign[0], cardRightOffset = assign[1]);
	      }
	      translateX = (cardRightOffset - cardLeftOffset) / 2;
	      translateY = (cardBottomOffset - cardTopOffset) / 2;

	      $cardEl.transform(("translate3d(" + translateX + "px, " + translateY + "px, 0) scale(" + scaleX + ", " + scaleY + ")"));
	      $cardContentEl
	        .css({
	          width: (maxWidth + "px"),
	          height: (maxHeight + "px"),
	        })
	        .transform(("translate3d(" + (app.rtl ? (cardLeftOffset + translateX) : (-cardLeftOffset - translateX)) + "px, 0px, 0) scale(" + (1 / scaleX) + ", " + (1 / scaleY) + ")"));
	    }

	    var cardScrollTop;
	    var isTouched;
	    var isMoved;
	    var touchStartX;
	    var touchStartY;
	    var touchEndX;
	    var touchEndY;
	    var isScrolling;
	    var progress;
	    var isV;
	    var isH;
	    function onTouchStart(e) {
	      if (!$(e.target).closest($cardEl).length) { return; }
	      if (!$cardEl.hasClass('card-opened')) { return; }
	      cardScrollTop = $cardContentEl.scrollTop();
	      isTouched = true;
	      touchStartX = e.targetTouches[0].pageX;
	      touchStartY = e.targetTouches[0].pageY;
	      isScrolling = undefined;
	      isV = false;
	      isH = false;
	    }
	    function onTouchMove(e) {
	      if (!isTouched) { return; }
	      touchEndX = e.targetTouches[0].pageX;
	      touchEndY = e.targetTouches[0].pageY;
	      if (typeof isScrolling === 'undefined') {
	        isScrolling = !!(isScrolling || Math.abs(touchEndY - touchStartY) > Math.abs(touchEndX - touchStartX));
	      }
	      if (!isH && !isV) {
	        if (!isScrolling && e.targetTouches[0].clientX <= 50) {
	          isH = true;
	        } else {
	          isV = true;
	        }
	      }

	      if (!(isH || isV) || (isV && cardScrollTop !== 0)) {
	        isTouched = true;
	        isMoved = true;
	        return;
	      }
	      if (!isMoved) {
	        $cardEl.removeClass('card-transitioning');
	      }

	      isMoved = true;
	      progress = isV ? Math.max((touchEndY - touchStartY) / 150, 0) : Math.max((touchEndX - touchStartX) / (cardWidth / 2), 0);
	      if ((progress > 0 && isV) || isH) {
	        if (isV && app.device.ios) {
	          $cardContentEl.css('-webkit-overflow-scrolling', 'auto');
	          $cardContentEl.scrollTop(0);
	        }
	        e.preventDefault();
	      }

	      if (progress > 1) { progress = Math.pow( progress, 0.3 ); }
	      if (progress > (isV ? 1.3 : 1.1)) {
	        isTouched = false;
	        isMoved = false;
	        app.card.close($cardEl);
	      } else {
	        $cardEl.transform(("translate3d(" + translateX + "px, " + translateY + "px, 0) scale(" + (scaleX * (1 - progress * 0.2)) + ", " + (scaleY * (1 - progress * 0.2)) + ")"));
	      }
	    }
	    function onTouchEnd() {
	      if (!isTouched || !isMoved) { return; }
	      isTouched = false;
	      isMoved = false;
	      if (app.device.ios) {
	        $cardContentEl.css('-webkit-overflow-scrolling', '');
	      }
	      if (progress >= 0.8) {
	        app.card.close($cardEl);
	      } else {
	        $cardEl
	          .addClass('card-transitioning')
	          .transform(("translate3d(" + translateX + "px, " + translateY + "px, 0) scale(" + scaleX + ", " + scaleY + ")"));
	      }
	    }

	    $cardEl[0].detachEventHandlers = function detachEventHandlers() {
	      app.off('resize', onResize);
	      if (Support.touch && cardParams.swipeToClose) {
	        app.off('touchstart:passive', onTouchStart);
	        app.off('touchmove:active', onTouchMove);
	        app.off('touchend:passive', onTouchEnd);
	      }
	    };

	    app.on('resize', onResize);
	    if (Support.touch && cardParams.swipeToClose) {
	      app.on('touchstart:passive', onTouchStart);
	      app.on('touchmove:active', onTouchMove);
	      app.on('touchend:passive', onTouchEnd);
	    }
	  },
	  close: function close(cardEl, animate) {
	    if ( cardEl === void 0 ) cardEl = '.card-expandable.card-opened';
	    if ( animate === void 0 ) animate = true;

	    var app = this;
	    var $cardEl = $(cardEl).eq(0);
	    if (!$cardEl || !$cardEl.length) { return; }
	    if (!$cardEl.hasClass('card-opened') || $cardEl.hasClass('card-opening') || $cardEl.hasClass('card-closing')) { return; }

	    var $cardContentEl = $cardEl.children('.card-content');
	    var $pageContentEl = $cardEl.parents('.page-content');

	    var $pageEl = $cardEl.parents('.page').eq(0);
	    if (!$pageEl.length) { return; }

	    var cardParams = Object.assign({ animate: animate }, app.params.card, $cardEl.dataset());

	    var $navbarEl;
	    var $toolbarEl;

	    var $backdropEl;
	    if ($cardEl.attr('data-backdrop-el')) {
	      $backdropEl = $($cardEl.attr('data-backdrop-el'));
	    }
	    if (cardParams.backdrop) {
	      $backdropEl = $cardEl.parents('.page-content').find('.card-backdrop');
	    }

	    if (cardParams.hideNavbarOnOpen) {
	      $navbarEl = $pageEl.children('.navbar');
	      if (!$navbarEl.length) {
	        if ($pageEl[0].f7Page) { $navbarEl = $pageEl[0].f7Page.$navbarEl; }
	      }
	      if ($navbarEl && $navbarEl.length) {
	        app.navbar.show($navbarEl, cardParams.animate);
	      }
	    }
	    if (cardParams.hideToolbarOnOpen) {
	      $toolbarEl = $pageEl.children('.toolbar');
	      if (!$toolbarEl.length) {
	        $toolbarEl = $pageEl.parents('.view').children('.toolbar');
	      }
	      if (!$toolbarEl.length) {
	        $toolbarEl = $pageEl.parents('.views').children('.toolbar');
	      }
	      if ($toolbarEl && $toolbarEl.length) {
	        app.toolbar.show($toolbarEl, cardParams.animate);
	      }
	    }

	    $pageEl.removeClass('page-with-card-opened');

	    if (app.device.ios && $pageContentEl.length) {
	      $pageContentEl.css('height', (($pageContentEl[0].offsetHeight + 1) + "px"));
	      setTimeout(function () {
	        $pageContentEl.css('height', '');
	      });
	    }

	    if ($backdropEl && $backdropEl.length) {
	      $backdropEl.removeClass('card-backdrop-in').addClass('card-backdrop-out');
	    }

	    $cardEl.removeClass('card-opened card-transitioning');
	    if (cardParams.animate) {
	      $cardEl.addClass('card-closing');
	    } else {
	      $cardEl.addClass('card-no-transition');
	    }
	    $cardEl.transform('');
	    $cardEl.trigger('card:close');
	    app.emit('cardClose', $cardEl[0]);

	    function transitionEnd() {
	      $cardEl.removeClass('card-closing card-no-transition');
	      $cardEl.trigger('card:closed');
	      $cardEl.find('.card-expandable-size').remove();
	      app.emit('cardClosed', $cardEl[0]);
	    }
	    $cardContentEl
	      .css({
	        width: '',
	        height: '',
	      })
	      .transform('')
	      .scrollTop(0, animate ? 300 : 0);
	    if (animate) {
	      $cardContentEl.transitionEnd(function () {
	        transitionEnd();
	      });
	    } else {
	      transitionEnd();
	    }

	    if ($cardEl[0].detachEventHandlers) {
	      $cardEl[0].detachEventHandlers();
	      delete $cardEl[0].detachEventHandlers;
	    }
	  },
	  toggle: function toggle(cardEl, animate) {
	    if ( cardEl === void 0 ) cardEl = '.card-expandable';

	    var app = this;
	    var $cardEl = $(cardEl).eq(0);
	    if (!$cardEl.length) { return; }
	    if ($cardEl.hasClass('card-opened')) {
	      app.card.close($cardEl, animate);
	    } else {
	      app.card.open($cardEl, animate);
	    }
	  },
	};

	var Card = {
	  name: 'card',
	  params: {
	    card: {
	      hideNavbarOnOpen: true,
	      hideToolbarOnOpen: true,
	      swipeToClose: true,
	      closeByBackdropClick: true,
	      backdrop: true,
	    },
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      card: {
	        open: CardExpandable.open.bind(app),
	        close: CardExpandable.close.bind(app),
	        toggle: CardExpandable.toggle.bind(app),
	      },
	    });
	  },
	  on: {
	    pageBeforeIn: function pageBeforeIn(page) {
	      var app = this;
	      if (app.params.card.hideNavbarOnOpen && page.navbarEl && page.$el.find('.card-opened.card-expandable').length) {
	        app.navbar.hide(page.navbarEl);
	      }

	      if (app.params.card.hideToolbarOnOpen && page.$el.find('.card-opened.card-expandable').length) {
	        var $toolbarEl = page.$el.children('.toolbar');
	        if (!$toolbarEl.length) {
	          $toolbarEl = page.$el.parents('.view').children('.toolbar');
	        }
	        if (!$toolbarEl.length) {
	          $toolbarEl = page.$el.parents('.views').children('.toolbar');
	        }
	        if ($toolbarEl && $toolbarEl.length) {
	          app.toolbar.hide($toolbarEl);
	        }
	      }
	    },
	  },
	  clicks: {
	    '.card-close': function closeCard($clickedEl, data) {
	      var app = this;
	      app.card.close(data.card, data.animate);
	    },
	    '.card-open': function closeCard($clickedEl, data) {
	      var app = this;
	      app.card.open(data.card, data.animate);
	    },
	    '.card-expandable': function toggleExpandableCard($clickedEl, data, e) {
	      var app = this;
	      if ($clickedEl.hasClass('card-opened') || $clickedEl.hasClass('card-opening') || $clickedEl.hasClass('card-closing')) { return; }
	      if ($(e.target).closest('.card-prevent-open, .card-close').length) { return; }
	      app.card.open($clickedEl);
	    },
	    '.card-backdrop-in': function onBackdropClick() {
	      var app = this;
	      var needToClose = false;
	      if (app.params.card.closeByBackdropClick) { needToClose = true; }
	      var $openedCardEl = $('.card-opened');
	      if (!$openedCardEl.length) { return; }
	      if ($openedCardEl.attr('data-close-on-backdrop-click') === 'true') {
	        needToClose = true;
	      } else if ($openedCardEl.attr('data-close-on-backdrop-click') === 'false') {
	        needToClose = false;
	      }
	      if (needToClose) { app.card.close($openedCardEl); }
	    },
	  },
	};

	var Chip = {
	  name: 'chip',
	};

	// Form Data
	var FormData$1 = {
	  store: function store(form, data) {
	    var app = this;
	    var formId = form;

	    var $formEl = $(form);
	    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
	      formId = $formEl.attr('id');
	    }
	    // Store form data in app.formsData
	    app.form.data[("form-" + formId)] = data;

	    // Store form data in local storage also
	    try {
	      win.localStorage[("f7form-" + formId)] = JSON.stringify(data);
	    } catch (e) {
	      throw e;
	    }
	  },
	  get: function get(form) {
	    var app = this;
	    var formId = form;

	    var $formEl = $(form);
	    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
	      formId = $formEl.attr('id');
	    }

	    try {
	      if (win.localStorage[("f7form-" + formId)]) {
	        return JSON.parse(win.localStorage[("f7form-" + formId)]);
	      }
	    } catch (e) {
	      throw e;
	    }
	    if (app.form.data[("form-" + formId)]) {
	      return app.form.data[("form-" + formId)];
	    }
	    return undefined;
	  },
	  remove: function remove(form) {
	    var app = this;
	    var formId = form;

	    var $formEl = $(form);
	    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
	      formId = $formEl.attr('id');
	    }

	    // Delete form data from app.formsData
	    if (app.form.data[("form-" + formId)]) {
	      app.form.data[("form-" + formId)] = '';
	      delete app.form.data[("form-" + formId)];
	    }

	    // Delete form data from local storage also
	    try {
	      if (win.localStorage[("f7form-" + formId)]) {
	        win.localStorage[("f7form-" + formId)] = '';
	        win.localStorage.removeItem(("f7form-" + formId));
	      }
	    } catch (e) {
	      throw e;
	    }
	  },
	};

	// Form Storage
	var FormStorage = {
	  init: function init(formEl) {
	    var app = this;
	    var $formEl = $(formEl);
	    var formId = $formEl.attr('id');
	    if (!formId) { return; }
	    var initialData = app.form.getFormData(formId);
	    if (initialData) {
	      app.form.fillFromData($formEl, initialData);
	    }
	    function store() {
	      var data = app.form.convertToData($formEl);
	      if (!data) { return; }
	      app.form.storeFormData(formId, data);
	      $formEl.trigger('form:storedata', data);
	      app.emit('formStoreData', $formEl[0], data);
	    }
	    $formEl.on('change submit', store);
	  },
	  destroy: function destroy(formEl) {
	    var $formEl = $(formEl);
	    $formEl.off('change submit');
	  },
	};

	// Form To/From Data
	function formToData(formEl) {
	  var app = this;
	  var $formEl = $(formEl).eq(0);
	  if ($formEl.length === 0) { return undefined; }

	  // Form data
	  var data = {};

	  // Skip input types
	  var skipTypes = ['submit', 'image', 'button', 'file'];
	  var skipNames = [];
	  $formEl.find('input, select, textarea').each(function (inputIndex, inputEl) {
	    var $inputEl = $(inputEl);
	    if ($inputEl.hasClass('ignore-store-data') || $inputEl.hasClass('no-store-data')) {
	      return;
	    }
	    var name = $inputEl.attr('name');
	    var type = $inputEl.attr('type');
	    var tag = inputEl.nodeName.toLowerCase();
	    if (skipTypes.indexOf(type) >= 0) { return; }
	    if (skipNames.indexOf(name) >= 0 || !name) { return; }
	    if (tag === 'select' && $inputEl.prop('multiple')) {
	      skipNames.push(name);
	      data[name] = [];
	      $formEl.find(("select[name=\"" + name + "\"] option")).each(function (index, el) {
	        if (el.selected) { data[name].push(el.value); }
	      });
	    } else {
	      switch (type) {
	        case 'checkbox':
	          skipNames.push(name);
	          data[name] = [];
	          $formEl.find(("input[name=\"" + name + "\"]")).each(function (index, el) {
	            if (el.checked) { data[name].push(el.value); }
	          });
	          break;
	        case 'radio':
	          skipNames.push(name);
	          $formEl.find(("input[name=\"" + name + "\"]")).each(function (index, el) {
	            if (el.checked) { data[name] = el.value; }
	          });
	          break;
	        default:
	          data[name] = $inputEl.val();
	          break;
	      }
	    }
	  });
	  $formEl.trigger('form:todata', data);
	  app.emit('formToData', $formEl[0], data);

	  return data;
	}
	function formFromData(formEl, formData) {
	  var app = this;
	  var $formEl = $(formEl).eq(0);
	  if (!$formEl.length) { return; }

	  var data = formData;
	  var formId = $formEl.attr('id');

	  if (!data && formId) {
	    data = app.form.getFormData(formId);
	  }

	  if (!data) { return; }

	  // Skip input types
	  var skipTypes = ['submit', 'image', 'button', 'file'];
	  var skipNames = [];

	  $formEl.find('input, select, textarea').each(function (inputIndex, inputEl) {
	    var $inputEl = $(inputEl);
	    if ($inputEl.hasClass('ignore-store-data') || $inputEl.hasClass('no-store-data')) {
	      return;
	    }
	    var name = $inputEl.attr('name');
	    var type = $inputEl.attr('type');
	    var tag = inputEl.nodeName.toLowerCase();
	    if (typeof data[name] === 'undefined' || data[name] === null) { return; }
	    if (skipTypes.indexOf(type) >= 0) { return; }
	    if (skipNames.indexOf(name) >= 0 || !name) { return; }
	    if (tag === 'select' && $inputEl.prop('multiple')) {
	      skipNames.push(name);
	      $formEl.find(("select[name=\"" + name + "\"] option")).each(function (index, el) {
	        var selectEl = el;
	        if (data[name].indexOf(el.value) >= 0) { selectEl.selected = true; }
	        else { selectEl.selected = false; }
	      });
	    } else {
	      switch (type) {
	        case 'checkbox':
	          skipNames.push(name);
	          $formEl.find(("input[name=\"" + name + "\"]")).each(function (index, el) {
	            var checkboxEl = el;
	            if (data[name].indexOf(el.value) >= 0) { checkboxEl.checked = true; }
	            else { checkboxEl.checked = false; }
	          });
	          break;
	        case 'radio':
	          skipNames.push(name);
	          $formEl.find(("input[name=\"" + name + "\"]")).each(function (index, el) {
	            var radioEl = el;
	            if (data[name] === el.value) { radioEl.checked = true; }
	            else { radioEl.checked = false; }
	          });
	          break;
	        default:
	          $inputEl.val(data[name]);
	          break;
	      }
	    }
	    if (tag === 'select' || tag === 'input' || tag === 'textarea') {
	      $inputEl.trigger('change', 'fromdata');
	    }
	  });
	  $formEl.trigger('form:fromdata', data);
	  app.emit('formFromData', $formEl[0], data);
	}

	function initAjaxForm() {
	  var app = this;

	  function onSubmitChange(e, fromData) {
	    var $formEl = $(this);
	    if (e.type === 'change' && !$formEl.hasClass('form-ajax-submit-onchange')) { return; }
	    if (e.type === 'submit') { e.preventDefault(); }

	    if (e.type === 'change' && fromData === 'fromdata') { return; }

	    var method = ($formEl.attr('method') || 'GET').toUpperCase();
	    var contentType = $formEl.prop('enctype') || $formEl.attr('enctype');

	    var url = $formEl.attr('action');
	    if (!url) { return; }

	    var data;
	    if (method === 'POST') {
	      if (contentType === 'application/x-www-form-urlencoded') {
	        data = app.form.convertToData($formEl[0]);
	      } else {
	        data = new win.FormData($formEl[0]);
	      }
	    } else {
	      data = Utils.serializeObject(app.form.convertToData($formEl[0]));
	    }

	    app.request({
	      method: method,
	      url: url,
	      contentType: contentType,
	      data: data,
	      beforeSend: function beforeSend(xhr) {
	        $formEl.trigger('formajax:beforesend', { data: data, xhr: xhr });
	        app.emit('formAjaxBeforeSend', $formEl[0], data, xhr);
	      },
	      error: function error(xhr) {
	        $formEl.trigger('formajax:error', { data: data, xhr: xhr });
	        app.emit('formAjaxError', $formEl[0], data, xhr);
	      },
	      complete: function complete(xhr) {
	        $formEl.trigger('formajax:complete', { data: data, xhr: xhr });
	        app.emit('formAjaxComplete', $formEl[0], data, xhr);
	      },
	      success: function success(response, status, xhr) {
	        $formEl.trigger('formajax:success', { data: data, xhr: xhr });
	        app.emit('formAjaxSuccess', $formEl[0], data, xhr);
	      },
	    });
	  }
	  $(doc).on('submit change', 'form.form-ajax-submit, form.form-ajax-submit-onchange', onSubmitChange);
	}

	var Form = {
	  name: 'form',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      form: {
	        data: {},
	        storeFormData: FormData$1.store.bind(app),
	        getFormData: FormData$1.get.bind(app),
	        removeFormData: FormData$1.remove.bind(app),
	        convertToData: formToData.bind(app),
	        fillFromData: formFromData.bind(app),
	        storage: {
	          init: FormStorage.init.bind(app),
	          destroy: FormStorage.destroy.bind(app),
	        },
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      initAjaxForm.call(app);
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var app = this;
	      $(tabEl).find('.form-store-data').each(function (index, formEl) {
	        app.form.storage.destroy(formEl);
	      });
	    },
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $(tabEl).find('.form-store-data').each(function (index, formEl) {
	        app.form.storage.init(formEl);
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.form-store-data').each(function (index, formEl) {
	        app.form.storage.destroy(formEl);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.form-store-data').each(function (index, formEl) {
	        app.form.storage.init(formEl);
	      });
	    },
	  },
	};

	var Input = {
	  ignoreTypes: ['checkbox', 'button', 'submit', 'range', 'radio', 'image'],
	  createTextareaResizableShadow: function createTextareaResizableShadow() {
	    var $shadowEl = $(doc.createElement('textarea'));
	    $shadowEl.addClass('textarea-resizable-shadow');
	    $shadowEl.prop({
	      disabled: true,
	      readonly: true,
	    });
	    Input.textareaResizableShadow = $shadowEl;
	  },
	  textareaResizableShadow: undefined,
	  resizeTextarea: function resizeTextarea(textareaEl) {
	    var app = this;
	    var $textareaEl = $(textareaEl);
	    if (!Input.textareaResizableShadow) {
	      Input.createTextareaResizableShadow();
	    }
	    var $shadowEl = Input.textareaResizableShadow;
	    if (!$textareaEl.length) { return; }
	    if (!$textareaEl.hasClass('resizable')) { return; }
	    if (Input.textareaResizableShadow.parents().length === 0) {
	      app.root.append($shadowEl);
	    }

	    var styles = win.getComputedStyle($textareaEl[0]);
	    ('padding-top padding-bottom padding-left padding-right margin-left margin-right margin-top margin-bottom width font-size font-family font-style font-weight line-height font-variant text-transform letter-spacing border box-sizing display').split(' ').forEach(function (style) {
	      var styleValue = styles[style];
	      if (('font-size line-height letter-spacing width').split(' ').indexOf(style) >= 0) {
	        styleValue = styleValue.replace(',', '.');
	      }
	      $shadowEl.css(style, styleValue);
	    });
	    var currentHeight = $textareaEl[0].clientHeight;

	    $shadowEl.val('');
	    var initialHeight = $shadowEl[0].scrollHeight;

	    $shadowEl.val($textareaEl.val());
	    $shadowEl.css('height', 0);
	    var scrollHeight = $shadowEl[0].scrollHeight;

	    if (currentHeight !== scrollHeight) {
	      if (scrollHeight > initialHeight) {
	        $textareaEl.css('height', (scrollHeight + "px"));
	        $textareaEl.trigger('textarea:resize', { initialHeight: initialHeight, currentHeight: currentHeight, scrollHeight: scrollHeight });
	      } else if (scrollHeight < currentHeight) {
	        $textareaEl.css('height', '');
	        $textareaEl.trigger('textarea:resize', { initialHeight: initialHeight, currentHeight: currentHeight, scrollHeight: scrollHeight });
	      }
	    }
	  },
	  validate: function validate(inputEl) {
	    var $inputEl = $(inputEl);
	    if (!$inputEl.length) { return; }
	    var $itemInputEl = $inputEl.parents('.item-input');
	    var $inputWrapEl = $inputEl.parents('.input');
	    var validity = $inputEl[0].validity;
	    var validationMessage = $inputEl.dataset().errorMessage || $inputEl[0].validationMessage || '';
	    if (!validity) { return; }
	    if (!validity.valid) {
	      var $errorEl = $inputEl.nextAll('.item-input-error-message, .input-error-message');
	      if (validationMessage) {
	        if ($errorEl.length === 0) {
	          $errorEl = $(("<div class=\"" + ($inputWrapEl.length ? 'input-error-message' : 'item-input-error-message') + "\"></div>"));
	          $errorEl.insertAfter($inputEl);
	        }
	        $errorEl.text(validationMessage);
	      }
	      if ($errorEl.length > 0) {
	        $itemInputEl.addClass('item-input-with-error-message');
	        $inputWrapEl.addClass('input-with-error-message');
	      }
	      $itemInputEl.addClass('item-input-invalid');
	      $inputWrapEl.addClass('input-invalid');
	      $inputEl.addClass('input-invalid');
	    } else {
	      $itemInputEl.removeClass('item-input-invalid item-input-with-error-message');
	      $inputWrapEl.removeClass('input-invalid input-with-error-message');
	      $inputEl.removeClass('input-invalid');
	    }
	  },
	  validateInputs: function validateInputs(el) {
	    var app = this;
	    $(el).find('input, textarea, select').each(function (index, inputEl) {
	      app.input.validate(inputEl);
	    });
	  },
	  focus: function focus(inputEl) {
	    var $inputEl = $(inputEl);
	    var type = $inputEl.attr('type');
	    if (Input.ignoreTypes.indexOf(type) >= 0) { return; }
	    $inputEl.parents('.item-input').addClass('item-input-focused');
	    $inputEl.parents('.input').addClass('input-focused');
	    $inputEl.addClass('input-focused');
	  },
	  blur: function blur(inputEl) {
	    var $inputEl = $(inputEl);
	    $inputEl.parents('.item-input').removeClass('item-input-focused');
	    $inputEl.parents('.input').removeClass('input-focused');
	    $inputEl.removeClass('input-focused');
	  },
	  checkEmptyState: function checkEmptyState(inputEl) {
	    var $inputEl = $(inputEl);
	    if (!$inputEl.is('input, select, textarea')) {
	      $inputEl = $inputEl.find('input, select, textarea').eq(0);
	    }
	    if (!$inputEl.length) { return; }

	    var value = $inputEl.val();
	    var $itemInputEl = $inputEl.parents('.item-input');
	    var $inputWrapEl = $inputEl.parents('.input');
	    if ((value && (typeof value === 'string' && value.trim() !== '')) || (Array.isArray(value) && value.length > 0)) {
	      $itemInputEl.addClass('item-input-with-value');
	      $inputWrapEl.addClass('input-with-value');
	      $inputEl.addClass('input-with-value');
	      $inputEl.trigger('input:notempty');
	    } else {
	      $itemInputEl.removeClass('item-input-with-value');
	      $inputWrapEl.removeClass('input-with-value');
	      $inputEl.removeClass('input-with-value');
	      $inputEl.trigger('input:empty');
	    }
	  },
	  scrollIntoView: function scrollIntoView(inputEl, duration, centered, force) {
	    if ( duration === void 0 ) duration = 0;

	    var $inputEl = $(inputEl);
	    var $scrollableEl = $inputEl.parents('.page-content, .panel').eq(0);
	    if (!$scrollableEl.length) {
	      return false;
	    }
	    var contentHeight = $scrollableEl[0].offsetHeight;
	    var contentScrollTop = $scrollableEl[0].scrollTop;
	    var contentPaddingTop = parseInt($scrollableEl.css('padding-top'), 10);
	    var contentPaddingBottom = parseInt($scrollableEl.css('padding-bottom'), 10);
	    var contentOffsetTop = $scrollableEl.offset().top - contentScrollTop;

	    var inputOffsetTop = $inputEl.offset().top - contentOffsetTop;
	    var inputHeight = $inputEl[0].offsetHeight;

	    var min = (inputOffsetTop + contentScrollTop) - contentPaddingTop;
	    var max = ((inputOffsetTop + contentScrollTop) - contentHeight) + contentPaddingBottom + inputHeight;
	    var centeredPosition = min + ((max - min) / 2);

	    if (contentScrollTop > min) {
	      $scrollableEl.scrollTop(centered ? centeredPosition : min, duration);
	      return true;
	    }
	    if (contentScrollTop < max) {
	      $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
	      return true;
	    }
	    if (force) {
	      $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
	    }
	    return false;
	  },
	  init: function init() {
	    var app = this;
	    Input.createTextareaResizableShadow();
	    function onFocus() {
	      var inputEl = this;
	      if (app.params.input.scrollIntoViewOnFocus) {
	        if (Device.android) {
	          $(win).once('resize', function () {
	            if (doc && doc.activeElement === inputEl) {
	              app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewDuration, app.params.input.scrollIntoViewCentered, app.params.input.scrollIntoViewAlways);
	            }
	          });
	        } else {
	          app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewDuration, app.params.input.scrollIntoViewCentered, app.params.input.scrollIntoViewAlways);
	        }
	      }
	      app.input.focus(inputEl);
	    }
	    function onBlur() {
	      var $inputEl = $(this);
	      var tag = $inputEl[0].nodeName.toLowerCase();
	      app.input.blur($inputEl);
	      if ($inputEl.dataset().validate || $inputEl.attr('validate') !== null || $inputEl.attr('data-validate-on-blur') !== null) {
	        app.input.validate($inputEl);
	      }
	      // Resize textarea
	      if (tag === 'textarea' && $inputEl.hasClass('resizable')) {
	        if (Input.textareaResizableShadow) { Input.textareaResizableShadow.remove(); }
	      }
	    }
	    function onChange() {
	      var $inputEl = $(this);
	      var type = $inputEl.attr('type');
	      var tag = $inputEl[0].nodeName.toLowerCase();
	      if (Input.ignoreTypes.indexOf(type) >= 0) { return; }

	      // Check Empty State
	      app.input.checkEmptyState($inputEl);

	      // Check validation
	      if ($inputEl.attr('data-validate-on-blur') === null && ($inputEl.dataset().validate || $inputEl.attr('validate') !== null)) {
	        app.input.validate($inputEl);
	      }

	      // Resize textarea
	      if (tag === 'textarea' && $inputEl.hasClass('resizable')) {
	        app.input.resizeTextarea($inputEl);
	      }
	    }
	    function onInvalid(e) {
	      var $inputEl = $(this);
	      if ($inputEl.attr('data-validate-on-blur') === null && ($inputEl.dataset().validate || $inputEl.attr('validate') !== null)) {
	        e.preventDefault();
	        app.input.validate($inputEl);
	      }
	    }
	    function clearInput() {
	      var $clicked = $(this);
	      var $inputEl = $clicked.siblings('input, textarea').eq(0);
	      var previousValue = $inputEl.val();
	      $inputEl
	        .val('')
	        .trigger('input change')
	        .focus()
	        .trigger('input:clear', previousValue);
	    }
	    $(doc).on('click', '.input-clear-button', clearInput);
	    $(doc).on('change input', 'input, textarea, select', onChange, true);
	    $(doc).on('focus', 'input, textarea, select', onFocus, true);
	    $(doc).on('blur', 'input, textarea, select', onBlur, true);
	    $(doc).on('invalid', 'input, textarea, select', onInvalid, true);
	  },
	};

	var Input$1 = {
	  name: 'input',
	  params: {
	    input: {
	      scrollIntoViewOnFocus: Device.android,
	      scrollIntoViewCentered: false,
	      scrollIntoViewDuration: 0,
	      scrollIntoViewAlways: false,
	    },
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      input: {
	        scrollIntoView: Input.scrollIntoView.bind(app),
	        focus: Input.focus.bind(app),
	        blur: Input.blur.bind(app),
	        validate: Input.validate.bind(app),
	        validateInputs: Input.validateInputs.bind(app),
	        checkEmptyState: Input.checkEmptyState.bind(app),
	        resizeTextarea: Input.resizeTextarea.bind(app),
	        init: Input.init.bind(app),
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      app.input.init();
	    },
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      var $tabEl = $(tabEl);
	      $tabEl.find('.item-input, .input').each(function (itemInputIndex, itemInputEl) {
	        var $itemInputEl = $(itemInputEl);
	        $itemInputEl.find('input, select, textarea').each(function (inputIndex, inputEl) {
	          var $inputEl = $(inputEl);
	          if (Input.ignoreTypes.indexOf($inputEl.attr('type')) >= 0) { return; }
	          app.input.checkEmptyState($inputEl);
	        });
	      });
	      $tabEl.find('textarea.resizable').each(function (textareaIndex, textareaEl) {
	        app.input.resizeTextarea(textareaEl);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      var $pageEl = page.$el;
	      $pageEl.find('.item-input, .input').each(function (itemInputIndex, itemInputEl) {
	        var $itemInputEl = $(itemInputEl);
	        $itemInputEl.find('input, select, textarea').each(function (inputIndex, inputEl) {
	          var $inputEl = $(inputEl);
	          if (Input.ignoreTypes.indexOf($inputEl.attr('type')) >= 0) { return; }
	          app.input.checkEmptyState($inputEl);
	        });
	      });
	      $pageEl.find('textarea.resizable').each(function (textareaIndex, textareaEl) {
	        app.input.resizeTextarea(textareaEl);
	      });
	    },
	  },
	};

	var Checkbox = {
	  name: 'checkbox',
	};

	var Radio = {
	  name: 'radio',
	};

	var Toggle = /*@__PURE__*/(function (Framework7Class) {
	  function Toggle(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class.call(this, params, [app]);
	    var toggle = this;

	    var defaults = {};

	    // Extend defaults with modules params
	    toggle.useModulesParams(defaults);

	    toggle.params = Utils.extend(defaults, params);

	    var el = toggle.params.el;
	    if (!el) { return toggle; }

	    var $el = $(el);
	    if ($el.length === 0) { return toggle; }

	    if ($el[0].f7Toggle) { return $el[0].f7Toggle; }

	    var $inputEl = $el.children('input[type="checkbox"]');

	    Utils.extend(toggle, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      $inputEl: $inputEl,
	      inputEl: $inputEl[0],
	      disabled: $el.hasClass('disabled') || $inputEl.hasClass('disabled') || $inputEl.attr('disabled') || $inputEl[0].disabled,
	    });

	    Object.defineProperty(toggle, 'checked', {
	      enumerable: true,
	      configurable: true,
	      set: function set(checked) {
	        if (!toggle || typeof toggle.$inputEl === 'undefined') { return; }
	        if (toggle.checked === checked) { return; }
	        $inputEl[0].checked = checked;
	        toggle.$inputEl.trigger('change');
	      },
	      get: function get() {
	        return $inputEl[0].checked;
	      },
	    });

	    $el[0].f7Toggle = toggle;

	    var isTouched;
	    var touchesStart = {};
	    var isScrolling;
	    var touchesDiff;
	    var toggleWidth;
	    var touchStartTime;
	    var touchStartChecked;
	    function handleTouchStart(e) {
	      if (isTouched || toggle.disabled) { return; }
	      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	      touchesDiff = 0;

	      isTouched = true;
	      isScrolling = undefined;
	      touchStartTime = Utils.now();
	      touchStartChecked = toggle.checked;

	      toggleWidth = $el[0].offsetWidth;
	      Utils.nextTick(function () {
	        if (isTouched) {
	          $el.addClass('toggle-active-state');
	        }
	      });
	    }
	    function handleTouchMove(e) {
	      if (!isTouched || toggle.disabled) { return; }
	      var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	      var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      var inverter = app.rtl ? -1 : 1;

	      if (typeof isScrolling === 'undefined') {
	        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
	      }
	      if (isScrolling) {
	        isTouched = false;
	        return;
	      }
	      e.preventDefault();

	      touchesDiff = pageX - touchesStart.x;


	      var changed;
	      if (touchesDiff * inverter < 0 && Math.abs(touchesDiff) > toggleWidth / 3 && touchStartChecked) {
	        changed = true;
	      }
	      if (touchesDiff * inverter > 0 && Math.abs(touchesDiff) > toggleWidth / 3 && !touchStartChecked) {
	        changed = true;
	      }
	      if (changed) {
	        touchesStart.x = pageX;
	        toggle.checked = !touchStartChecked;
	        touchStartChecked = !touchStartChecked;
	      }
	    }
	    function handleTouchEnd() {
	      if (!isTouched || toggle.disabled) {
	        if (isScrolling) { $el.removeClass('toggle-active-state'); }
	        isTouched = false;
	        return;
	      }
	      var inverter = app.rtl ? -1 : 1;
	      isTouched = false;

	      $el.removeClass('toggle-active-state');

	      var changed;
	      if ((Utils.now() - touchStartTime) < 300) {
	        if (touchesDiff * inverter < 0 && touchStartChecked) {
	          changed = true;
	        }
	        if (touchesDiff * inverter > 0 && !touchStartChecked) {
	          changed = true;
	        }
	        if (changed) {
	          toggle.checked = !touchStartChecked;
	        }
	      }
	    }
	    function handleInputChange() {
	      toggle.$el.trigger('toggle:change', toggle);
	      toggle.emit('local::change toggleChange', toggle);
	    }
	    toggle.attachEvents = function attachEvents() {
	      if (Support.touch) {
	        var passive = Support.passiveListener ? { passive: true } : false;
	        $el.on(app.touchEvents.start, handleTouchStart, passive);
	        app.on('touchmove', handleTouchMove);
	        app.on('touchend:passive', handleTouchEnd);
	      }
	      toggle.$inputEl.on('change', handleInputChange);
	    };
	    toggle.detachEvents = function detachEvents() {
	      if (Support.touch) {
	        var passive = Support.passiveListener ? { passive: true } : false;
	        $el.off(app.touchEvents.start, handleTouchStart, passive);
	        app.off('touchmove', handleTouchMove);
	        app.off('touchend:passive', handleTouchEnd);
	      }
	      toggle.$inputEl.off('change', handleInputChange);
	    };

	    // Install Modules
	    toggle.useModules();

	    // Init
	    toggle.init();
	  }

	  if ( Framework7Class ) Toggle.__proto__ = Framework7Class;
	  Toggle.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  Toggle.prototype.constructor = Toggle;

	  Toggle.prototype.toggle = function toggle () {
	    var toggle = this;
	    toggle.checked = !toggle.checked;
	  };

	  Toggle.prototype.init = function init () {
	    var toggle = this;
	    toggle.attachEvents();
	  };

	  Toggle.prototype.destroy = function destroy () {
	    var toggle = this;
	    toggle.$el.trigger('toggle:beforedestroy', toggle);
	    toggle.emit('local::beforeDestroy toggleBeforeDestroy', toggle);
	    delete toggle.$el[0].f7Toggle;
	    toggle.detachEvents();
	    Utils.deleteProps(toggle);
	    toggle = null;
	  };

	  return Toggle;
	}(Framework7Class));

	var Toggle$1 = {
	  name: 'toggle',
	  create: function create() {
	    var app = this;
	    app.toggle = ConstructorMethods({
	      defaultSelector: '.toggle',
	      constructor: Toggle,
	      app: app,
	      domProp: 'f7Toggle',
	    });
	  },
	  static: {
	    Toggle: Toggle,
	  },
	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $(tabEl).find('.toggle-init').each(function (index, toggleEl) { return app.toggle.create({ el: toggleEl }); });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      $(tabEl).find('.toggle-init').each(function (index, toggleEl) {
	        if (toggleEl.f7Toggle) { toggleEl.f7Toggle.destroy(); }
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.toggle-init').each(function (index, toggleEl) { return app.toggle.create({ el: toggleEl }); });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      page.$el.find('.toggle-init').each(function (index, toggleEl) {
	        if (toggleEl.f7Toggle) { toggleEl.f7Toggle.destroy(); }
	      });
	    },
	  },
	  vnode: {
	    'toggle-init': {
	      insert: function insert(vnode) {
	        var app = this;
	        var toggleEl = vnode.elm;
	        app.toggle.create({ el: toggleEl });
	      },
	      destroy: function destroy(vnode) {
	        var toggleEl = vnode.elm;
	        if (toggleEl.f7Toggle) { toggleEl.f7Toggle.destroy(); }
	      },
	    },
	  },
	};

	var Range = /*@__PURE__*/(function (Framework7Class) {
	  function Range(app, params) {
	    Framework7Class.call(this, params, [app]);

	    var range = this;

	    var defaults = {
	      el: null,
	      inputEl: null,
	      dual: false,
	      step: 1,
	      label: false,
	      min: 0,
	      max: 100,
	      value: 0,
	      draggableBar: true,
	      vertical: false,
	      verticalReversed: false,
	      formatLabel: null,
	      scale: false,
	      scaleSteps: 5,
	      scaleSubSteps: 0,
	      formatScaleLabel: null,
	      limitKnobPosition: app.theme === 'ios',
	    };

	    // Extend defaults with modules params
	    range.useModulesParams(defaults);

	    range.params = Utils.extend(defaults, params);

	    var el = range.params.el;
	    if (!el) { return range; }

	    var $el = $(el);
	    if ($el.length === 0) { return range; }

	    if ($el[0].f7Range) { return $el[0].f7Range; }

	    var dataset = $el.dataset();

	    ('step min max value scaleSteps scaleSubSteps').split(' ').forEach(function (paramName) {
	      if (typeof params[paramName] === 'undefined' && typeof dataset[paramName] !== 'undefined') {
	        range.params[paramName] = parseFloat(dataset[paramName]);
	      }
	    });
	    ('dual label vertical verticalReversed scale').split(' ').forEach(function (paramName) {
	      if (typeof params[paramName] === 'undefined' && typeof dataset[paramName] !== 'undefined') {
	        range.params[paramName] = dataset[paramName];
	      }
	    });

	    if (!range.params.value) {
	      if (typeof dataset.value !== 'undefined') { range.params.value = dataset.value; }
	      if (typeof dataset.valueLeft !== 'undefined' && typeof dataset.valueRight !== 'undefined') {
	        range.params.value = [parseFloat(dataset.valueLeft), parseFloat(dataset.valueRight)];
	      }
	    }

	    var $inputEl;
	    if (!range.params.dual) {
	      if (range.params.inputEl) {
	        $inputEl = $(range.params.inputEl);
	      } else if ($el.find('input[type="range"]').length) {
	        $inputEl = $el.find('input[type="range"]').eq(0);
	      }
	    }

	    var ref = range.params;
	    var dual = ref.dual;
	    var step = ref.step;
	    var label = ref.label;
	    var min = ref.min;
	    var max = ref.max;
	    var value = ref.value;
	    var vertical = ref.vertical;
	    var verticalReversed = ref.verticalReversed;
	    var scale = ref.scale;
	    var scaleSteps = ref.scaleSteps;
	    var scaleSubSteps = ref.scaleSubSteps;
	    var limitKnobPosition = ref.limitKnobPosition;

	    Utils.extend(range, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      $inputEl: $inputEl,
	      inputEl: $inputEl ? $inputEl[0] : undefined,
	      dual: dual,
	      step: step,
	      label: label,
	      min: min,
	      max: max,
	      value: value,
	      previousValue: value,
	      vertical: vertical,
	      verticalReversed: verticalReversed,
	      scale: scale,
	      scaleSteps: scaleSteps,
	      scaleSubSteps: scaleSubSteps,
	      limitKnobPosition: limitKnobPosition,
	    });

	    if ($inputEl) {
	      ('step min max').split(' ').forEach(function (paramName) {
	        if (!params[paramName] && $inputEl.attr(paramName)) {
	          range.params[paramName] = parseFloat($inputEl.attr(paramName));
	          range[paramName] = parseFloat($inputEl.attr(paramName));
	        }
	      });
	      if (typeof $inputEl.val() !== 'undefined') {
	        range.params.value = parseFloat($inputEl.val());
	        range.value = parseFloat($inputEl.val());
	      }
	    }

	    // Dual
	    if (range.dual) {
	      $el.addClass('range-slider-dual');
	    }
	    if (range.label) {
	      $el.addClass('range-slider-label');
	    }

	    // Vertical
	    if (range.vertical) {
	      $el.addClass('range-slider-vertical');
	      if (range.verticalReversed) {
	        $el.addClass('range-slider-vertical-reversed');
	      }
	    } else {
	      $el.addClass('range-slider-horizontal');
	    }

	    // Check for layout
	    var $barEl = $('<div class="range-bar"></div>');
	    var $barActiveEl = $('<div class="range-bar-active"></div>');
	    $barEl.append($barActiveEl);

	    // Create Knobs
	    var knobHTML = "\n      <div class=\"range-knob-wrap\">\n        <div class=\"range-knob\"></div>\n        " + (range.label ? '<div class="range-knob-label"></div>' : '') + "\n      </div>\n    ";
	    var knobs = [$(knobHTML)];

	    if (range.dual) {
	      knobs.push($(knobHTML));
	    }

	    $el.append($barEl);
	    knobs.forEach(function ($knobEl) {
	      $el.append($knobEl);
	    });

	    // Labels
	    var labels = [];
	    if (range.label) {
	      labels.push(knobs[0].find('.range-knob-label'));
	      if (range.dual) {
	        labels.push(knobs[1].find('.range-knob-label'));
	      }
	    }

	    // Scale
	    var $scaleEl;
	    if (range.scale && range.scaleSteps > 1) {
	      $scaleEl = $(("\n        <div class=\"range-scale\">\n          " + (range.renderScale()) + "\n        </div>\n      "));
	      $el.append($scaleEl);
	    }

	    Utils.extend(range, {
	      knobs: knobs,
	      labels: labels,
	      $barEl: $barEl,
	      $barActiveEl: $barActiveEl,
	      $scaleEl: $scaleEl,
	    });

	    $el[0].f7Range = range;

	    // Touch Events
	    var isTouched;
	    var touchesStart = {};
	    var isScrolling;
	    var rangeOffset;
	    var rangeOffsetLeft;
	    var rangeOffsetTop;
	    var $touchedKnobEl;
	    var dualValueIndex;
	    var valueChangedByTouch;
	    var targetTouchIdentifier;
	    function onTouchChange() {
	      valueChangedByTouch = true;
	    }
	    function handleTouchStart(e) {
	      if (isTouched) { return; }
	      if (!range.params.draggableBar) {
	        if ($(e.target).closest('.range-knob').length === 0) {
	          return;
	        }
	      }
	      valueChangedByTouch = false;
	      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	      if (e.type === 'touchstart') {
	        targetTouchIdentifier = e.targetTouches[0].identifier;
	      }

	      isTouched = true;
	      isScrolling = undefined;
	      rangeOffset = $el.offset();
	      rangeOffsetLeft = rangeOffset.left;
	      rangeOffsetTop = rangeOffset.top;

	      var progress;
	      if (range.vertical) {
	        progress = (touchesStart.y - rangeOffsetTop) / range.rangeHeight;
	        if (!range.verticalReversed) { progress = 1 - progress; }
	      } else if (range.app.rtl) {
	        progress = ((rangeOffsetLeft + range.rangeWidth) - touchesStart.x) / range.rangeWidth;
	      } else {
	        progress = (touchesStart.x - rangeOffsetLeft) / range.rangeWidth;
	      }

	      var newValue = (progress * (range.max - range.min)) + range.min;
	      if (range.dual) {
	        if (Math.abs(range.value[0] - newValue) < Math.abs(range.value[1] - newValue)) {
	          dualValueIndex = 0;
	          $touchedKnobEl = range.knobs[0];
	          newValue = [newValue, range.value[1]];
	        } else {
	          dualValueIndex = 1;
	          $touchedKnobEl = range.knobs[1];
	          newValue = [range.value[0], newValue];
	        }
	      } else {
	        $touchedKnobEl = range.knobs[0];
	        newValue = (progress * (range.max - range.min)) + range.min;
	      }
	      Utils.nextTick(function () {
	        if (isTouched) { $touchedKnobEl.addClass('range-knob-active-state'); }
	      }, 70);
	      range.on('change', onTouchChange);
	      range.setValue(newValue, true);
	    }
	    function handleTouchMove(e) {
	      if (!isTouched) { return; }
	      var pageX;
	      var pageY;
	      if (e.type === 'touchmove') {
	        for (var i = 0; i < e.targetTouches.length; i += 1) {
	          if (e.targetTouches[i].identifier === targetTouchIdentifier) {
	            pageX = e.targetTouches[i].pageX;
	            pageY = e.targetTouches[i].pageY;
	          }
	        }
	      } else {
	        pageX = e.pageX;
	        pageY = e.pageY;
	      }
	      if (typeof pageX === 'undefined' && typeof pageY === 'undefined') { return; }

	      if (typeof isScrolling === 'undefined' && !range.vertical) {
	        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
	      }
	      if (isScrolling) {
	        isTouched = false;
	        return;
	      }
	      e.preventDefault();

	      var progress;
	      if (range.vertical) {
	        progress = (pageY - rangeOffsetTop) / range.rangeHeight;
	        if (!range.verticalReversed) { progress = 1 - progress; }
	      } else if (range.app.rtl) {
	        progress = ((rangeOffsetLeft + range.rangeWidth) - pageX) / range.rangeWidth;
	      } else {
	        progress = (pageX - rangeOffsetLeft) / range.rangeWidth;
	      }

	      var newValue = (progress * (range.max - range.min)) + range.min;
	      if (range.dual) {
	        var leftValue;
	        var rightValue;
	        if (dualValueIndex === 0) {
	          leftValue = newValue;
	          rightValue = range.value[1];
	          if (leftValue > rightValue) {
	            rightValue = leftValue;
	          }
	        } else {
	          leftValue = range.value[0];
	          rightValue = newValue;
	          if (rightValue < leftValue) {
	            leftValue = rightValue;
	          }
	        }
	        newValue = [leftValue, rightValue];
	      }
	      range.setValue(newValue, true);
	    }
	    function handleTouchEnd(e) {
	      if (e.type === 'touchend') {
	        var touchEnded;
	        for (var i = 0; i < e.changedTouches.length; i += 1) {
	          if (e.changedTouches[i].identifier === targetTouchIdentifier) { touchEnded = true; }
	        }
	        if (!touchEnded) { return; }
	      }
	      if (!isTouched) {
	        if (isScrolling) { $touchedKnobEl.removeClass('range-knob-active-state'); }
	        isTouched = false;
	        return;
	      }
	      range.off('change', onTouchChange);
	      isTouched = false;
	      $touchedKnobEl.removeClass('range-knob-active-state');
	      if (valueChangedByTouch && range.$inputEl && !range.dual) {
	        range.$inputEl.trigger('change');
	      }
	      valueChangedByTouch = false;
	      if (typeof range.previousValue !== 'undefined') {
	        if (
	          (
	            range.dual
	            && (
	              range.previousValue[0] !== range.value[0]
	              || range.previousValue[1] !== range.value[1]
	            )
	          )
	          || (
	            !range.dual
	            && range.previousValue !== range.value
	          )
	        ) {
	          range.$el.trigger('range:changed', range, range.value);
	          range.emit('local::changed rangeChanged', range, range.value);
	        }
	      }
	    }

	    function handleResize() {
	      range.calcSize();
	      range.layout();
	    }
	    var parentModals;
	    var parentPanel;
	    var parentPage;
	    range.attachEvents = function attachEvents() {
	      var passive = Support.passiveListener ? { passive: true } : false;
	      range.$el.on(app.touchEvents.start, handleTouchStart, passive);
	      app.on('touchmove', handleTouchMove);
	      app.on('touchend:passive', handleTouchEnd);
	      app.on('tabShow', handleResize);
	      app.on('resize', handleResize);
	      parentModals = range.$el.parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast');
	      parentModals.on('modal:open', handleResize);
	      parentPanel = range.$el.parents('.panel');
	      parentPanel.on('panel:open', handleResize);
	      parentPage = range.$el.parents('.page').eq(0);
	      parentPage.on('page:reinit', handleResize);
	    };
	    range.detachEvents = function detachEvents() {
	      var passive = Support.passiveListener ? { passive: true } : false;
	      range.$el.off(app.touchEvents.start, handleTouchStart, passive);
	      app.off('touchmove', handleTouchMove);
	      app.off('touchend:passive', handleTouchEnd);
	      app.off('tabShow', handleResize);
	      app.off('resize', handleResize);
	      if (parentModals) {
	        parentModals.off('modal:open', handleResize);
	      }
	      if (parentPanel) {
	        parentPanel.off('panel:open', handleResize);
	      }
	      if (parentPage) {
	        parentPage.off('page:reinit', handleResize);
	      }
	      parentModals = null;
	      parentPanel = null;
	      parentPage = null;
	    };

	    // Install Modules
	    range.useModules();

	    // Init
	    range.init();

	    return range;
	  }

	  if ( Framework7Class ) Range.__proto__ = Framework7Class;
	  Range.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  Range.prototype.constructor = Range;

	  Range.prototype.calcSize = function calcSize () {
	    var range = this;
	    if (range.vertical) {
	      var height = range.$el.outerHeight();
	      if (height === 0) { return; }
	      range.rangeHeight = height;
	      range.knobHeight = range.knobs[0].outerHeight();
	    } else {
	      var width = range.$el.outerWidth();
	      if (width === 0) { return; }
	      range.rangeWidth = width;
	      range.knobWidth = range.knobs[0].outerWidth();
	    }
	  };

	  Range.prototype.layout = function layout () {
	    var obj;

	    var range = this;
	    var app = range.app;
	    var knobWidth = range.knobWidth;
	    var knobHeight = range.knobHeight;
	    var rangeWidth = range.rangeWidth;
	    var rangeHeight = range.rangeHeight;
	    var min = range.min;
	    var max = range.max;
	    var knobs = range.knobs;
	    var $barActiveEl = range.$barActiveEl;
	    var value = range.value;
	    var label = range.label;
	    var labels = range.labels;
	    var vertical = range.vertical;
	    var verticalReversed = range.verticalReversed;
	    var limitKnobPosition = range.limitKnobPosition;
	    var knobSize = vertical ? knobHeight : knobWidth;
	    var rangeSize = vertical ? rangeHeight : rangeWidth;
	    // eslint-disable-next-line
	    var positionProperty = vertical
	      ? (verticalReversed ? 'top' : 'bottom')
	      : (app.rtl ? 'right' : 'left');
	    if (range.dual) {
	      var progress = [((value[0] - min) / (max - min)), ((value[1] - min) / (max - min))];
	      $barActiveEl.css(( obj = {}, obj[positionProperty] = ((progress[0] * 100) + "%"), obj[vertical ? 'height' : 'width'] = (((progress[1] - progress[0]) * 100) + "%"), obj ));
	      knobs.forEach(function ($knobEl, knobIndex) {
	        var startPos = rangeSize * progress[knobIndex];
	        if (limitKnobPosition) {
	          var realStartPos = (rangeSize * progress[knobIndex]) - (knobSize / 2);
	          if (realStartPos < 0) { startPos = knobSize / 2; }
	          if ((realStartPos + knobSize) > rangeSize) { startPos = rangeSize - (knobSize / 2); }
	        }
	        $knobEl.css(positionProperty, (startPos + "px"));
	        if (label) { labels[knobIndex].text(range.formatLabel(value[knobIndex], labels[knobIndex][0])); }
	      });
	    } else {
	      var progress$1 = ((value - min) / (max - min));
	      $barActiveEl.css(vertical ? 'height' : 'width', ((progress$1 * 100) + "%"));

	      var startPos = rangeSize * progress$1;
	      if (limitKnobPosition) {
	        var realStartPos = (rangeSize * progress$1) - (knobSize / 2);
	        if (realStartPos < 0) { startPos = knobSize / 2; }
	        if ((realStartPos + knobSize) > rangeSize) { startPos = rangeSize - (knobSize / 2); }
	      }
	      knobs[0].css(positionProperty, (startPos + "px"));
	      if (label) { labels[0].text(range.formatLabel(value, labels[0][0])); }
	    }
	    if ((range.dual && value.indexOf(min) >= 0) || (!range.dual && value === min)) {
	      range.$el.addClass('range-slider-min');
	    } else {
	      range.$el.removeClass('range-slider-min');
	    }
	    if ((range.dual && value.indexOf(max) >= 0) || (!range.dual && value === max)) {
	      range.$el.addClass('range-slider-max');
	    } else {
	      range.$el.removeClass('range-slider-max');
	    }
	  };

	  Range.prototype.setValue = function setValue (newValue, byTouchMove) {
	    var range = this;
	    var step = range.step;
	    var min = range.min;
	    var max = range.max;
	    var valueChanged;
	    var oldValue;
	    if (range.dual) {
	      oldValue = [range.value[0], range.value[1]];
	      var newValues = newValue;
	      if (!Array.isArray(newValues)) { newValues = [newValue, newValue]; }
	      if (newValue[0] > newValue[1]) {
	        newValues = [newValues[0], newValues[0]];
	      }
	      newValues = newValues.map(function (value) { return Math.max(Math.min(Math.round(value / step) * step, max), min); });
	      if (newValues[0] === range.value[0] && newValues[1] === range.value[1]) {
	        return range;
	      }
	      newValues.forEach(function (value, valueIndex) {
	        range.value[valueIndex] = value;
	      });
	      valueChanged = oldValue[0] !== newValues[0] || oldValue[1] !== newValues[1];
	      range.layout();
	    } else {
	      oldValue = range.value;
	      var value = Math.max(Math.min(Math.round(newValue / step) * step, max), min);
	      range.value = value;
	      range.layout();
	      valueChanged = oldValue !== value;
	    }

	    if (valueChanged) {
	      range.previousValue = oldValue;
	    }
	    // Events
	    if (!valueChanged) { return range; }
	    range.$el.trigger('range:change', range, range.value);
	    if (range.$inputEl && !range.dual) {
	      range.$inputEl.val(range.value);
	      if (!byTouchMove) {
	        range.$inputEl.trigger('input change');
	      } else {
	        range.$inputEl.trigger('input');
	      }
	    }
	    if (!byTouchMove) {
	      range.$el.trigger('range:changed', range, range.value);
	      range.emit('local::changed rangeChanged', range, range.value);
	    }
	    range.emit('local::change rangeChange', range, range.value);
	    return range;
	  };

	  Range.prototype.getValue = function getValue () {
	    return this.value;
	  };

	  Range.prototype.formatLabel = function formatLabel (value, labelEl) {
	    var range = this;
	    if (range.params.formatLabel) { return range.params.formatLabel.call(range, value, labelEl); }
	    return value;
	  };

	  Range.prototype.formatScaleLabel = function formatScaleLabel (value) {
	    var range = this;
	    if (range.params.formatScaleLabel) { return range.params.formatScaleLabel.call(range, value); }
	    return value;
	  };

	  Range.prototype.renderScale = function renderScale () {
	    var range = this;
	    var app = range.app;
	    var verticalReversed = range.verticalReversed;
	    var vertical = range.vertical;

	    // eslint-disable-next-line
	    var positionProperty = vertical
	      ? (verticalReversed ? 'top' : 'bottom')
	      : (app.rtl ? 'right' : 'left');

	    var html = '';

	    Array
	      .from({ length: range.scaleSteps + 1 })
	      .forEach(function (scaleEl, index) {
	        var scaleStepValue = (range.max - range.min) / range.scaleSteps;
	        var scaleValue = range.min + scaleStepValue * index;
	        var progress = ((scaleValue - range.min) / (range.max - range.min));
	        html += "<div class=\"range-scale-step\" style=\"" + positionProperty + ": " + (progress * 100) + "%\">" + (range.formatScaleLabel(scaleValue)) + "</div>";

	        if (range.scaleSubSteps && range.scaleSubSteps > 1 && index < range.scaleSteps) {
	          Array
	            .from({ length: range.scaleSubSteps - 1 })
	            .forEach(function (subStepEl, subIndex) {
	              var subStep = scaleStepValue / range.scaleSubSteps;
	              var scaleSubValue = scaleValue + subStep * (subIndex + 1);
	              var subProgress = ((scaleSubValue - range.min) / (range.max - range.min));
	              html += "<div class=\"range-scale-step range-scale-substep\" style=\"" + positionProperty + ": " + (subProgress * 100) + "%\"></div>";
	            });
	        }
	      });

	    return html;
	  };

	  Range.prototype.updateScale = function updateScale () {
	    var range = this;
	    if (!range.scale || range.scaleSteps < 2) {
	      if (range.$scaleEl) { range.$scaleEl.remove(); }
	      delete range.$scaleEl;
	      return;
	    }
	    if (!range.$scaleEl) {
	      range.$scaleEl = $('<div class="range-scale"></div>');
	      range.$el.append(range.$scaleEl);
	    }

	    range.$scaleEl.html(range.renderScale());
	  };

	  Range.prototype.init = function init () {
	    var range = this;
	    range.calcSize();
	    range.layout();
	    range.attachEvents();
	    return range;
	  };

	  Range.prototype.destroy = function destroy () {
	    var range = this;
	    range.$el.trigger('range:beforedestroy', range);
	    range.emit('local::beforeDestroy rangeBeforeDestroy', range);
	    delete range.$el[0].f7Range;
	    range.detachEvents();
	    Utils.deleteProps(range);
	    range = null;
	  };

	  return Range;
	}(Framework7Class));

	var Range$1 = {
	  name: 'range',
	  create: function create() {
	    var app = this;
	    app.range = Utils.extend(
	      ConstructorMethods({
	        defaultSelector: '.range-slider',
	        constructor: Range,
	        app: app,
	        domProp: 'f7Range',
	      }),
	      {
	        getValue: function getValue(el) {
	          if ( el === void 0 ) el = '.range-slider';

	          var range = app.range.get(el);
	          if (range) { return range.getValue(); }
	          return undefined;
	        },
	        setValue: function setValue(el, value) {
	          if ( el === void 0 ) el = '.range-slider';

	          var range = app.range.get(el);
	          if (range) { return range.setValue(value); }
	          return undefined;
	        },
	      }
	    );
	  },
	  static: {
	    Range: Range,
	  },
	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $(tabEl).find('.range-slider-init').each(function (index, rangeEl) { return new Range(app, {
	        el: rangeEl,
	      }); });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      $(tabEl).find('.range-slider-init').each(function (index, rangeEl) {
	        if (rangeEl.f7Range) { rangeEl.f7Range.destroy(); }
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.range-slider-init').each(function (index, rangeEl) { return new Range(app, {
	        el: rangeEl,
	      }); });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      page.$el.find('.range-slider-init').each(function (index, rangeEl) {
	        if (rangeEl.f7Range) { rangeEl.f7Range.destroy(); }
	      });
	    },
	  },
	  vnode: {
	    'range-slider-init': {
	      insert: function insert(vnode) {
	        var rangeEl = vnode.elm;
	        var app = this;
	        app.range.create({ el: rangeEl });
	      },
	      destroy: function destroy(vnode) {
	        var rangeEl = vnode.elm;
	        if (rangeEl.f7Range) { rangeEl.f7Range.destroy(); }
	      },
	    },
	  },
	};

	var Stepper = /*@__PURE__*/(function (Framework7Class) {
	  function Stepper(app, params) {
	    Framework7Class.call(this, params, [app]);
	    var stepper = this;

	    var defaults = {
	      el: null,
	      inputEl: null,
	      valueEl: null,
	      value: 0,
	      formatValue: null,
	      step: 1,
	      min: 0,
	      max: 100,
	      watchInput: true,
	      autorepeat: false,
	      autorepeatDynamic: false,
	      wraps: false,
	      manualInputMode: false,
	      decimalPoint: 4,
	      buttonsEndInputMode: true,
	    };

	    // Extend defaults with modules params
	    stepper.useModulesParams(defaults);

	    stepper.params = Utils.extend(defaults, params);
	    if (stepper.params.value < stepper.params.min) {
	      stepper.params.value = stepper.params.min;
	    }
	    if (stepper.params.value > stepper.params.max) {
	      stepper.params.value = stepper.params.max;
	    }

	    var el = stepper.params.el;
	    if (!el) { return stepper; }

	    var $el = $(el);
	    if ($el.length === 0) { return stepper; }

	    if ($el[0].f7Stepper) { return $el[0].f7Stepper; }

	    var $inputEl;
	    if (stepper.params.inputEl) {
	      $inputEl = $(stepper.params.inputEl);
	    } else if ($el.find('.stepper-input-wrap').find('input, textarea').length) {
	      $inputEl = $el.find('.stepper-input-wrap').find('input, textarea').eq(0);
	    }

	    if ($inputEl && $inputEl.length) {
	      ('step min max').split(' ').forEach(function (paramName) {
	        if (!params[paramName] && $inputEl.attr(paramName)) {
	          stepper.params[paramName] = parseFloat($inputEl.attr(paramName));
	        }
	      });

	      var decimalPoint$1 = parseInt(stepper.params.decimalPoint, 10);
	      if (Number.isNaN(decimalPoint$1)) {
	        stepper.params.decimalPoint = 0;
	      } else {
	        stepper.params.decimalPoint = decimalPoint$1;
	      }

	      var inputValue = parseFloat($inputEl.val());
	      if (typeof params.value === 'undefined' && !Number.isNaN(inputValue) && (inputValue || inputValue === 0)) {
	        stepper.params.value = inputValue;
	      }
	    }

	    var $valueEl;
	    if (stepper.params.valueEl) {
	      $valueEl = $(stepper.params.valueEl);
	    } else if ($el.find('.stepper-value').length) {
	      $valueEl = $el.find('.stepper-value').eq(0);
	    }

	    var $buttonPlusEl = $el.find('.stepper-button-plus');
	    var $buttonMinusEl = $el.find('.stepper-button-minus');

	    var ref = stepper.params;
	    var step = ref.step;
	    var min = ref.min;
	    var max = ref.max;
	    var value = ref.value;
	    var decimalPoint = ref.decimalPoint;

	    Utils.extend(stepper, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      $buttonPlusEl: $buttonPlusEl,
	      buttonPlusEl: $buttonPlusEl[0],
	      $buttonMinusEl: $buttonMinusEl,
	      buttonMinusEl: $buttonMinusEl[0],
	      $inputEl: $inputEl,
	      inputEl: $inputEl ? $inputEl[0] : undefined,
	      $valueEl: $valueEl,
	      valueEl: $valueEl ? $valueEl[0] : undefined,
	      step: step,
	      min: min,
	      max: max,
	      value: value,
	      decimalPoint: decimalPoint,
	      typeModeChanged: false,
	    });

	    $el[0].f7Stepper = stepper;

	    // Handle Events
	    var touchesStart = {};
	    var isTouched;
	    var isScrolling;
	    var preventButtonClick;
	    var intervalId;
	    var timeoutId;
	    var autorepeatAction = null;
	    var autorepeatInAction = false;
	    var manualInput = false;

	    function dynamicRepeat(current, progressions, startsIn, progressionStep, repeatEvery, action) {
	      clearTimeout(timeoutId);
	      timeoutId = setTimeout(function () {
	        if (current === 1) {
	          preventButtonClick = true;
	          autorepeatInAction = true;
	        }
	        clearInterval(intervalId);
	        action();
	        intervalId = setInterval(function () {
	          action();
	        }, repeatEvery);
	        if (current < progressions) {
	          dynamicRepeat(current + 1, progressions, startsIn, progressionStep, repeatEvery / 2, action);
	        }
	      }, current === 1 ? startsIn : progressionStep);
	    }

	    function onTouchStart(e) {
	      if (isTouched) { return; }
	      if (manualInput) { return; }
	      if ($(e.target).closest($buttonPlusEl).length) {
	        autorepeatAction = 'increment';
	      } else if ($(e.target).closest($buttonMinusEl).length) {
	        autorepeatAction = 'decrement';
	      }
	      if (!autorepeatAction) { return; }

	      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	      isTouched = true;
	      isScrolling = undefined;

	      var progressions = stepper.params.autorepeatDynamic ? 4 : 1;
	      dynamicRepeat(1, progressions, 500, 1000, 300, function () {
	        stepper[autorepeatAction]();
	      });
	    }
	    function onTouchMove(e) {
	      if (!isTouched) { return; }
	      if (manualInput) { return; }
	      var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	      var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

	      if (typeof isScrolling === 'undefined' && !autorepeatInAction) {
	        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
	      }
	      var distance = Math.pow( ((Math.pow( (pageX - touchesStart.x), 2 )) + (Math.pow( (pageY - touchesStart.y), 2 ))), 0.5 );

	      if (isScrolling || distance > 20) {
	        isTouched = false;
	        clearTimeout(timeoutId);
	        clearInterval(intervalId);
	      }
	    }
	    function onTouchEnd() {
	      clearTimeout(timeoutId);
	      clearInterval(intervalId);
	      autorepeatAction = null;
	      autorepeatInAction = false;
	      isTouched = false;
	    }

	    function onMinusClick() {
	      if (manualInput) {
	        if (stepper.params.buttonsEndInputMode) {
	          manualInput = false;
	          stepper.endTypeMode(true);
	        }
	        return;
	      }
	      if (preventButtonClick) {
	        preventButtonClick = false;
	        return;
	      }
	      stepper.decrement(true);
	    }
	    function onPlusClick() {
	      if (manualInput) {
	        if (stepper.params.buttonsEndInputMode) {
	          manualInput = false;
	          stepper.endTypeMode(true);
	        }
	        return;
	      }
	      if (preventButtonClick) {
	        preventButtonClick = false;
	        return;
	      }
	      stepper.increment(true);
	    }
	    function onInputClick(e) {
	      if (!e.target.readOnly && stepper.params.manualInputMode) {
	        manualInput = true;
	        if (typeof e.target.selectionStart === 'number') {
	          e.target.selectionStart = e.target.value.length;
	          e.target.selectionEnd = e.target.value.length;
	        }
	      }
	    }
	    function onInputKey(e) {
	      if (e.keyCode === 13 || e.which === 13) {
	        e.preventDefault();
	        manualInput = false;
	        stepper.endTypeMode();
	      }
	    }
	    function onInputBlur() {
	      manualInput = false;
	      stepper.endTypeMode(true);
	    }
	    function onInput(e) {
	      if (manualInput) {
	        stepper.typeValue(e.target.value);
	        return;
	      }
	      if (e.detail && e.detail.sentByF7Stepper) { return; }
	      stepper.setValue(e.target.value, true);
	    }
	    stepper.attachEvents = function attachEvents() {
	      $buttonMinusEl.on('click', onMinusClick);
	      $buttonPlusEl.on('click', onPlusClick);
	      if (stepper.params.watchInput && $inputEl && $inputEl.length) {
	        $inputEl.on('input', onInput);
	        $inputEl.on('click', onInputClick);
	        $inputEl.on('blur', onInputBlur);
	        $inputEl.on('keyup', onInputKey);
	      }
	      if (stepper.params.autorepeat) {
	        app.on('touchstart:passive', onTouchStart);
	        app.on('touchmove:active', onTouchMove);
	        app.on('touchend:passive', onTouchEnd);
	      }
	    };
	    stepper.detachEvents = function detachEvents() {
	      $buttonMinusEl.off('click', onMinusClick);
	      $buttonPlusEl.off('click', onPlusClick);
	      if (stepper.params.watchInput && $inputEl && $inputEl.length) {
	        $inputEl.off('input', onInput);
	        $inputEl.off('click', onInputClick);
	        $inputEl.off('blur', onInputBlur);
	        $inputEl.off('keyup', onInputKey);
	      }
	    };

	    // Install Modules
	    stepper.useModules();

	    // Init
	    stepper.init();

	    return stepper;
	  }

	  if ( Framework7Class ) Stepper.__proto__ = Framework7Class;
	  Stepper.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  Stepper.prototype.constructor = Stepper;

	  Stepper.prototype.minus = function minus () {
	    return this.decrement();
	  };

	  Stepper.prototype.plus = function plus () {
	    return this.increment();
	  };

	  Stepper.prototype.decrement = function decrement () {
	    var stepper = this;
	    return stepper.setValue(stepper.value - stepper.step, false, true);
	  };

	  Stepper.prototype.increment = function increment () {
	    var stepper = this;
	    return stepper.setValue(stepper.value + stepper.step, false, true);
	  };

	  Stepper.prototype.setValue = function setValue (newValue, forceUpdate, withWraps) {
	    var stepper = this;
	    var step = stepper.step;
	    var min = stepper.min;
	    var max = stepper.max;

	    var oldValue = stepper.value;

	    var value = Math.round(newValue / step) * step;
	    if (stepper.params.wraps && withWraps) {
	      if (value > max) { value = min; }
	      if (value < min) { value = max; }
	    } else {
	      value = Math.max(Math.min(value, max), min);
	    }

	    if (Number.isNaN(value)) {
	      value = oldValue;
	    }
	    stepper.value = value;

	    var valueChanged = oldValue !== value;

	    // Events
	    if (!valueChanged && !forceUpdate) { return stepper; }

	    stepper.$el.trigger('stepper:change', stepper, stepper.value);
	    var formattedValue = stepper.formatValue(stepper.value);
	    if (stepper.$inputEl && stepper.$inputEl.length) {
	      stepper.$inputEl.val(formattedValue);
	      stepper.$inputEl.trigger('input change', { sentByF7Stepper: true });
	    }
	    if (stepper.$valueEl && stepper.$valueEl.length) {
	      stepper.$valueEl.html(formattedValue);
	    }
	    stepper.emit('local::change stepperChange', stepper, stepper.value);
	    return stepper;
	  };

	  Stepper.prototype.endTypeMode = function endTypeMode (noBlur) {
	    var stepper = this;
	    var min = stepper.min;
	    var max = stepper.max;
	    var value = parseFloat(stepper.value);

	    if (Number.isNaN(value)) { value = 0; }

	    value = Math.max(Math.min(value, max), min);

	    stepper.value = value;
	    if (!stepper.typeModeChanged) {
	      if (stepper.$inputEl && stepper.$inputEl.length && !noBlur) {
	        stepper.$inputEl.blur();
	      }
	      return stepper;
	    }
	    stepper.typeModeChanged = false;

	    stepper.$el.trigger('stepper:change', stepper, stepper.value);
	    var formattedValue = stepper.formatValue(stepper.value);
	    if (stepper.$inputEl && stepper.$inputEl.length) {
	      stepper.$inputEl.val(formattedValue);
	      stepper.$inputEl.trigger('input change', { sentByF7Stepper: true });
	      if (!noBlur) { stepper.$inputEl.blur(); }
	    }
	    if (stepper.$valueEl && stepper.$valueEl.length) {
	      stepper.$valueEl.html(formattedValue);
	    }
	    stepper.emit('local::change stepperChange', stepper, stepper.value);
	    return stepper;
	  };

	  Stepper.prototype.typeValue = function typeValue (value) {
	    var stepper = this;
	    stepper.typeModeChanged = true;
	    var inputTxt = String(value);
	    if (inputTxt.lastIndexOf('.') + 1 === inputTxt.length || inputTxt.lastIndexOf(',') + 1 === inputTxt.length) {
	      if (inputTxt.lastIndexOf('.') !== inputTxt.indexOf('.') || inputTxt.lastIndexOf(',') !== inputTxt.indexOf(',')) {
	        inputTxt = inputTxt.slice(0, -1);
	        stepper.value = inputTxt;
	        stepper.$inputEl.val(stepper.value);
	        return stepper;
	      }
	    } else {
	      var newValue = parseFloat(inputTxt.replace(',', '.'));
	      if (newValue === 0) {
	        stepper.value = inputTxt.replace(',', '.');
	        stepper.$inputEl.val(stepper.value);
	        return stepper;
	      }
	      if (Number.isNaN(newValue)) {
	        stepper.value = 0;
	        stepper.$inputEl.val(stepper.value);
	        return stepper;
	      }
	      var powVal = Math.pow( 10, stepper.params.decimalPoint );
	      newValue = (Math.round((newValue) * powVal)).toFixed(stepper.params.decimalPoint + 1) / powVal;
	      stepper.value = parseFloat(String(newValue).replace(',', '.'));
	      stepper.$inputEl.val(stepper.value);
	      return stepper;
	    }
	    stepper.value = inputTxt;
	    stepper.$inputEl.val(inputTxt);
	    return stepper;
	  };

	  Stepper.prototype.getValue = function getValue () {
	    return this.value;
	  };

	  Stepper.prototype.formatValue = function formatValue (value) {
	    var stepper = this;
	    if (!stepper.params.formatValue) { return value; }
	    return stepper.params.formatValue.call(stepper, value);
	  };

	  Stepper.prototype.init = function init () {
	    var stepper = this;
	    stepper.attachEvents();
	    if (stepper.$valueEl && stepper.$valueEl.length) {
	      var formattedValue = stepper.formatValue(stepper.value);
	      stepper.$valueEl.html(formattedValue);
	    }
	    return stepper;
	  };

	  Stepper.prototype.destroy = function destroy () {
	    var stepper = this;
	    stepper.$el.trigger('stepper:beforedestroy', stepper);
	    stepper.emit('local::beforeDestroy stepperBeforeDestroy', stepper);
	    delete stepper.$el[0].f7Stepper;
	    stepper.detachEvents();
	    Utils.deleteProps(stepper);
	    stepper = null;
	  };

	  return Stepper;
	}(Framework7Class));

	var Stepper$1 = {
	  name: 'stepper',
	  create: function create() {
	    var app = this;
	    app.stepper = Utils.extend(
	      ConstructorMethods({
	        defaultSelector: '.stepper',
	        constructor: Stepper,
	        app: app,
	        domProp: 'f7Stepper',
	      }),
	      {
	        getValue: function getValue(el) {
	          if ( el === void 0 ) el = '.stepper';

	          var stepper = app.stepper.get(el);
	          if (stepper) { return stepper.getValue(); }
	          return undefined;
	        },
	        setValue: function setValue(el, value) {
	          if ( el === void 0 ) el = '.stepper';

	          var stepper = app.stepper.get(el);
	          if (stepper) { return stepper.setValue(value); }
	          return undefined;
	        },
	      }
	    );
	  },
	  static: {
	    Stepper: Stepper,
	  },
	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $(tabEl).find('.stepper-init').each(function (index, stepperEl) {
	        var dataset = $(stepperEl).dataset();
	        app.stepper.create(Utils.extend({ el: stepperEl }, dataset || {}));
	      });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      $(tabEl).find('.stepper-init').each(function (index, stepperEl) {
	        if (stepperEl.f7Stepper) { stepperEl.f7Stepper.destroy(); }
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.stepper-init').each(function (index, stepperEl) {
	        var dataset = $(stepperEl).dataset();
	        app.stepper.create(Utils.extend({ el: stepperEl }, dataset || {}));
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      page.$el.find('.stepper-init').each(function (index, stepperEl) {
	        if (stepperEl.f7Stepper) { stepperEl.f7Stepper.destroy(); }
	      });
	    },
	  },
	  vnode: {
	    'stepper-init': {
	      insert: function insert(vnode) {
	        var app = this;
	        var stepperEl = vnode.elm;
	        var dataset = $(stepperEl).dataset();
	        app.stepper.create(Utils.extend({ el: stepperEl }, dataset || {}));
	      },
	      destroy: function destroy(vnode) {
	        var stepperEl = vnode.elm;
	        if (stepperEl.f7Stepper) { stepperEl.f7Stepper.destroy(); }
	      },
	    },
	  },
	};

	var SmartSelect = /*@__PURE__*/(function (Framework7Class) {
	  function SmartSelect(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class.call(this, params, [app]);
	    var ss = this;

	    var defaults = Utils.extend({
	      on: {},
	    }, app.params.smartSelect);

	    if (typeof defaults.searchbarDisableButton === 'undefined') {
	      defaults.searchbarDisableButton = app.theme !== 'aurora';
	    }

	    // Extend defaults with modules params
	    ss.useModulesParams(defaults);

	    ss.params = Utils.extend({}, defaults, params);

	    ss.app = app;

	    var $el = $(ss.params.el).eq(0);
	    if ($el.length === 0) { return ss; }

	    if ($el[0].f7SmartSelect) { return $el[0].f7SmartSelect; }

	    var $selectEl = $el.find('select').eq(0);
	    if ($selectEl.length === 0) { return ss; }

	    var $valueEl = $(ss.params.valueEl);
	    if ($valueEl.length === 0) {
	      $valueEl = $el.find('.item-after');
	    }
	    if ($valueEl.length === 0) {
	      $valueEl = $('<div class="item-after"></div>');
	      $valueEl.insertAfter($el.find('.item-title'));
	    }

	    // View
	    var view;

	    // Url
	    var url = params.url;
	    if (!url) {
	      if ($el.attr('href') && $el.attr('href') !== '#') { url = $el.attr('href'); }
	      else if ($selectEl.attr('name')) { url = ($selectEl.attr('name').toLowerCase()) + "-select/"; }
	    }
	    if (!url) { url = ss.params.url; }

	    var multiple = $selectEl[0].multiple;
	    var inputType = multiple ? 'checkbox' : 'radio';
	    var id = Utils.id();

	    Utils.extend(ss, {
	      $el: $el,
	      el: $el[0],
	      $selectEl: $selectEl,
	      selectEl: $selectEl[0],
	      $valueEl: $valueEl,
	      valueEl: $valueEl[0],
	      url: url,
	      multiple: multiple,
	      inputType: inputType,
	      id: id,
	      view: view,
	      inputName: (inputType + "-" + id),
	      selectName: $selectEl.attr('name'),
	      maxLength: $selectEl.attr('maxlength') || params.maxLength,
	    });

	    $el[0].f7SmartSelect = ss;

	    // Events
	    function onClick() {
	      ss.open();
	    }
	    function onChange() {
	      var value = ss.$selectEl.val();
	      ss.$el.trigger('smartselect:change', ss, value);
	      ss.emit('local::change smartSelectChange', ss, value);
	      ss.setTextValue();
	    }
	    ss.attachEvents = function attachEvents() {
	      $el.on('click', onClick);
	      $el.on('change', 'select', onChange);
	    };
	    ss.detachEvents = function detachEvents() {
	      $el.off('click', onClick);
	      $el.off('change', 'select', onChange);
	    };

	    function handleInputChange() {
	      var optionEl;
	      var text;
	      var inputEl = this;
	      var value = inputEl.value;
	      var optionText = [];
	      var displayAs;
	      if (inputEl.type === 'checkbox') {
	        for (var i = 0; i < ss.selectEl.options.length; i += 1) {
	          optionEl = ss.selectEl.options[i];
	          if (optionEl.value === value) {
	            optionEl.selected = inputEl.checked;
	          }
	          if (optionEl.selected) {
	            displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-value-as');
	            text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
	            optionText.push(text.trim());
	          }
	        }
	        if (ss.maxLength) {
	          ss.checkMaxLength();
	        }
	      } else {
	        optionEl = ss.$selectEl.find(("option[value=\"" + value + "\"]"))[0];
	        displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-as');
	        text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
	        optionText = [text];
	        ss.selectEl.value = value;
	      }

	      ss.$selectEl.trigger('change');
	      ss.$valueEl.text(optionText.join(', '));
	      if (ss.params.closeOnSelect && ss.inputType === 'radio') {
	        ss.close();
	      }
	    }

	    ss.attachInputsEvents = function attachInputsEvents() {
	      ss.$containerEl.on('change', 'input[type="checkbox"], input[type="radio"]', handleInputChange);
	    };
	    ss.detachInputsEvents = function detachInputsEvents() {
	      ss.$containerEl.off('change', 'input[type="checkbox"], input[type="radio"]', handleInputChange);
	    };

	    // Install Modules
	    ss.useModules();

	    // Init
	    ss.init();

	    return ss;
	  }

	  if ( Framework7Class ) SmartSelect.__proto__ = Framework7Class;
	  SmartSelect.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  SmartSelect.prototype.constructor = SmartSelect;

	  SmartSelect.prototype.setValue = function setValue (value) {
	    var ss = this;
	    var newValue = value;
	    var optionText = [];
	    var optionEl;
	    var displayAs;
	    var text;
	    if (ss.multiple) {
	      if (!Array.isArray(newValue)) { newValue = [newValue]; }
	      for (var i = 0; i < ss.selectEl.options.length; i += 1) {
	        optionEl = ss.selectEl.options[i];
	        if (newValue.indexOf(optionEl.value) >= 0) {
	          optionEl.selected = true;
	        } else {
	          optionEl.selected = false;
	        }
	        if (optionEl.selected) {
	          displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-value-as');
	          text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
	          optionText.push(text.trim());
	        }
	      }
	    } else {
	      optionEl = ss.$selectEl.find(("option[value=\"" + newValue + "\"]"))[0];
	      if (optionEl) {
	        displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-as');
	        text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
	        optionText = [text];
	      }
	      ss.selectEl.value = newValue;
	    }
	    ss.$valueEl.text(optionText.join(', '));
	    return ss;
	  };

	  SmartSelect.prototype.getValue = function getValue () {
	    var ss = this;
	    return ss.$selectEl.val();
	  };

	  SmartSelect.prototype.getView = function getView () {
	    var ss = this;
	    var view = ss.view || ss.params.view;
	    if (!view) {
	      view = ss.$el.parents('.view').length && ss.$el.parents('.view')[0].f7View;
	    }
	    if (!view) {
	      throw Error('Smart Select requires initialized View');
	    }
	    ss.view = view;
	    return view;
	  };

	  SmartSelect.prototype.checkMaxLength = function checkMaxLength () {
	    var ss = this;
	    var $containerEl = ss.$containerEl;
	    if (ss.selectEl.selectedOptions.length >= ss.maxLength) {
	      $containerEl.find('input[type="checkbox"]').each(function (index, inputEl) {
	        if (!inputEl.checked) {
	          $(inputEl).parents('li').addClass('disabled');
	        } else {
	          $(inputEl).parents('li').removeClass('disabled');
	        }
	      });
	    } else {
	      $containerEl.find('.disabled').removeClass('disabled');
	    }
	  };

	  SmartSelect.prototype.setTextValue = function setTextValue (value) {
	    var ss = this;
	    var valueArray = [];
	    if (typeof value !== 'undefined') {
	      if (Array.isArray(value)) {
	        valueArray = value;
	      } else {
	        valueArray = [value];
	      }
	    } else {
	      ss.$selectEl.find('option').each(function (optionIndex, optionEl) {
	        var $optionEl = $(optionEl);
	        if (optionEl.selected) {
	          var displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $optionEl.data('display-value-as');
	          if (displayAs && typeof displayAs !== 'undefined') {
	            valueArray.push(displayAs);
	          } else {
	            valueArray.push(optionEl.textContent.trim());
	          }
	        }
	      });
	    }
	    ss.$valueEl.text(valueArray.join(', '));
	  };

	  SmartSelect.prototype.getItemsData = function getItemsData () {
	    var ss = this;
	    var items = [];
	    var previousGroupEl;
	    ss.$selectEl.find('option').each(function (index, optionEl) {
	      var $optionEl = $(optionEl);
	      var optionData = $optionEl.dataset();
	      var optionImage = optionData.optionImage || ss.params.optionImage;
	      var optionIcon = optionData.optionIcon || ss.params.optionIcon;
	      var optionHasMedia = optionImage || optionIcon;
	      // if (material) optionHasMedia = optionImage || optionIcon;
	      var optionColor = optionData.optionColor;

	      var optionClassName = optionData.optionClass || '';
	      if ($optionEl[0].disabled) { optionClassName += ' disabled'; }

	      var optionGroupEl = $optionEl.parent('optgroup')[0];
	      var optionGroupLabel = optionGroupEl && optionGroupEl.label;
	      var optionIsLabel = false;
	      if (optionGroupEl && optionGroupEl !== previousGroupEl) {
	        optionIsLabel = true;
	        previousGroupEl = optionGroupEl;
	        items.push({
	          groupLabel: optionGroupLabel,
	          isLabel: optionIsLabel,
	        });
	      }
	      items.push({
	        value: $optionEl[0].value,
	        text: $optionEl[0].textContent.trim(),
	        selected: $optionEl[0].selected,
	        groupEl: optionGroupEl,
	        groupLabel: optionGroupLabel,
	        image: optionImage,
	        icon: optionIcon,
	        color: optionColor,
	        className: optionClassName,
	        disabled: $optionEl[0].disabled,
	        id: ss.id,
	        hasMedia: optionHasMedia,
	        checkbox: ss.inputType === 'checkbox',
	        radio: ss.inputType === 'radio',
	        inputName: ss.inputName,
	        inputType: ss.inputType,
	      });
	    });
	    ss.items = items;
	    return items;
	  };

	  SmartSelect.prototype.renderSearchbar = function renderSearchbar () {
	    var ss = this;
	    if (ss.params.renderSearchbar) { return ss.params.renderSearchbar.call(ss); }
	    var searchbarHTML = "\n      <form class=\"searchbar\">\n        <div class=\"searchbar-inner\">\n          <div class=\"searchbar-input-wrap\">\n            <input type=\"search\" placeholder=\"" + (ss.params.searchbarPlaceholder) + "\"/>\n            <i class=\"searchbar-icon\"></i>\n            <span class=\"input-clear-button\"></span>\n          </div>\n          " + (ss.params.searchbarDisableButton ? ("\n          <span class=\"searchbar-disable-button\">" + (ss.params.searchbarDisableText) + "</span>\n          ") : '') + "\n        </div>\n      </form>\n    ";
	    return searchbarHTML;
	  };

	  SmartSelect.prototype.renderItem = function renderItem (item, index) {
	    var ss = this;
	    if (ss.params.renderItem) { return ss.params.renderItem.call(ss, item, index); }
	    var itemHtml;
	    if (item.isLabel) {
	      itemHtml = "<li class=\"item-divider\">" + (item.groupLabel) + "</li>";
	    } else {
	      itemHtml = "\n        <li class=\"" + (item.className || '') + "\">\n          <label class=\"item-" + (item.inputType) + " item-content\">\n            <input type=\"" + (item.inputType) + "\" name=\"" + (item.inputName) + "\" value=\"" + (item.value) + "\" " + (item.selected ? 'checked' : '') + "/>\n            <i class=\"icon icon-" + (item.inputType) + "\"></i>\n            " + (item.hasMedia ? ("\n              <div class=\"item-media\">\n                " + (item.icon ? ("<i class=\"icon " + (item.icon) + "\"></i>") : '') + "\n                " + (item.image ? ("<img src=\"" + (item.image) + "\">") : '') + "\n              </div>\n            ") : '') + "\n            <div class=\"item-inner\">\n              <div class=\"item-title" + (item.color ? (" color-" + (item.color)) : '') + "\">" + (item.text) + "</div>\n            </div>\n          </label>\n        </li>\n      ";
	    }
	    return itemHtml;
	  };

	  SmartSelect.prototype.renderItems = function renderItems () {
	    var ss = this;
	    if (ss.params.renderItems) { return ss.params.renderItems.call(ss, ss.items); }
	    var itemsHtml = "\n      " + (ss.items.map(function (item, index) { return ("" + (ss.renderItem(item, index))); }).join('')) + "\n    ";
	    return itemsHtml;
	  };

	  SmartSelect.prototype.renderPage = function renderPage () {
	    var ss = this;
	    if (ss.params.renderPage) { return ss.params.renderPage.call(ss, ss.items); }
	    var pageTitle = ss.params.pageTitle;
	    if (typeof pageTitle === 'undefined') {
	      var $itemTitleEl = ss.$el.find('.item-title');
	      pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : '';
	    }
	    var cssClass = ss.params.cssClass;
	    var pageHtml = "\n      <div class=\"page smart-select-page " + cssClass + "\" data-name=\"smart-select-page\" data-select-name=\"" + (ss.selectName) + "\">\n        <div class=\"navbar " + (ss.params.navbarColorTheme ? ("color-" + (ss.params.navbarColorTheme)) : '') + "\">\n          <div class=\"navbar-inner sliding " + (ss.params.navbarColorTheme ? ("color-" + (ss.params.navbarColorTheme)) : '') + "\">\n            <div class=\"left\">\n              <a class=\"link back\">\n                <i class=\"icon icon-back\"></i>\n                <span class=\"if-not-md\">" + (ss.params.pageBackLinkText) + "</span>\n              </a>\n            </div>\n            " + (pageTitle ? ("<div class=\"title\">" + pageTitle + "</div>") : '') + "\n            " + (ss.params.searchbar ? ("<div class=\"subnavbar\">" + (ss.renderSearchbar()) + "</div>") : '') + "\n          </div>\n        </div>\n        " + (ss.params.searchbar ? '<div class="searchbar-backdrop"></div>' : '') + "\n        <div class=\"page-content\">\n          <div class=\"list smart-select-list-" + (ss.id) + " " + (ss.params.virtualList ? ' virtual-list' : '') + " " + (ss.params.formColorTheme ? ("color-" + (ss.params.formColorTheme)) : '') + "\">\n            <ul>" + (!ss.params.virtualList && ss.renderItems(ss.items)) + "</ul>\n          </div>\n        </div>\n      </div>\n    ";
	    return pageHtml;
	  };

	  SmartSelect.prototype.renderPopup = function renderPopup () {
	    var ss = this;
	    if (ss.params.renderPopup) { return ss.params.renderPopup.call(ss, ss.items); }
	    var pageTitle = ss.params.pageTitle;
	    if (typeof pageTitle === 'undefined') {
	      var $itemTitleEl = ss.$el.find('.item-title');
	      pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : '';
	    }
	    var cssClass = ss.params.cssClass || '';
	    var popupHtml = "\n      <div class=\"popup smart-select-popup " + cssClass + " " + (ss.params.popupTabletFullscreen ? 'popup-tablet-fullscreen' : '') + "\" data-select-name=\"" + (ss.selectName) + "\">\n        <div class=\"view\">\n          <div class=\"page smart-select-page " + (ss.params.searchbar ? 'page-with-subnavbar' : '') + "\" data-name=\"smart-select-page\">\n            <div class=\"navbar " + (ss.params.navbarColorTheme ? ("color-" + (ss.params.navbarColorTheme)) : '') + "\">\n              <div class=\"navbar-inner sliding\">\n                " + (pageTitle ? ("<div class=\"title\">" + pageTitle + "</div>") : '') + "\n                <div class=\"right\">\n                  <a class=\"link popup-close\" data-popup=\".smart-select-popup[data-select-name='" + (ss.selectName) + "']\">" + (ss.params.popupCloseLinkText) + "</span></a>\n                </div>\n                " + (ss.params.searchbar ? ("<div class=\"subnavbar\">" + (ss.renderSearchbar()) + "</div>") : '') + "\n              </div>\n            </div>\n            " + (ss.params.searchbar ? '<div class="searchbar-backdrop"></div>' : '') + "\n            <div class=\"page-content\">\n              <div class=\"list smart-select-list-" + (ss.id) + " " + (ss.params.virtualList ? ' virtual-list' : '') + " " + (ss.params.formColorTheme ? ("color-" + (ss.params.formColorTheme)) : '') + "\">\n                <ul>" + (!ss.params.virtualList && ss.renderItems(ss.items)) + "</ul>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    ";
	    return popupHtml;
	  };

	  SmartSelect.prototype.renderSheet = function renderSheet () {
	    var ss = this;
	    if (ss.params.renderSheet) { return ss.params.renderSheet.call(ss, ss.items); }
	    var cssClass = ss.params.cssClass;
	    var sheetHtml = "\n      <div class=\"sheet-modal smart-select-sheet " + cssClass + "\" data-select-name=\"" + (ss.selectName) + "\">\n        <div class=\"toolbar toolbar-top " + (ss.params.toolbarColorTheme ? ("color-" + (ss.params.toolbarColorTheme)) : '') + "\">\n          <div class=\"toolbar-inner\">\n            <div class=\"left\"></div>\n            <div class=\"right\">\n              <a class=\"link sheet-close\">" + (ss.params.sheetCloseLinkText) + "</a>\n            </div>\n          </div>\n        </div>\n        <div class=\"sheet-modal-inner\">\n          <div class=\"page-content\">\n            <div class=\"list smart-select-list-" + (ss.id) + " " + (ss.params.virtualList ? ' virtual-list' : '') + " " + (ss.params.formColorTheme ? ("color-" + (ss.params.formColorTheme)) : '') + "\">\n              <ul>" + (!ss.params.virtualList && ss.renderItems(ss.items)) + "</ul>\n            </div>\n          </div>\n        </div>\n      </div>\n    ";
	    return sheetHtml;
	  };

	  SmartSelect.prototype.renderPopover = function renderPopover () {
	    var ss = this;
	    if (ss.params.renderPopover) { return ss.params.renderPopover.call(ss, ss.items); }
	    var cssClass = ss.params.cssClass;
	    var popoverHtml = "\n      <div class=\"popover smart-select-popover " + cssClass + "\" data-select-name=\"" + (ss.selectName) + "\">\n        <div class=\"popover-inner\">\n          <div class=\"list smart-select-list-" + (ss.id) + " " + (ss.params.virtualList ? ' virtual-list' : '') + " " + (ss.params.formColorTheme ? ("color-" + (ss.params.formColorTheme)) : '') + "\">\n            <ul>" + (!ss.params.virtualList && ss.renderItems(ss.items)) + "</ul>\n          </div>\n        </div>\n      </div>\n    ";
	    return popoverHtml;
	  };

	  SmartSelect.prototype.scrollToSelectedItem = function scrollToSelectedItem () {
	    var ss = this;
	    var params = ss.params;
	    var $containerEl = ss.$containerEl;
	    if (!ss.opened) { return ss; }
	    if (params.virtualList) {
	      var selectedIndex;
	      ss.vl.items.forEach(function (item, index) {
	        if (typeof selectedIndex === 'undefined' && item.selected) {
	          selectedIndex = index;
	        }
	      });
	      if (typeof selectedIndex !== 'undefined') {
	        ss.vl.scrollToItem(selectedIndex);
	      }
	    } else {
	      var $selectedItemEl = $containerEl.find('input:checked').parents('li');
	      var $pageContentEl = $containerEl.find('.page-content');
	      $pageContentEl.scrollTop($selectedItemEl.offset().top - $pageContentEl.offset().top - parseInt($pageContentEl.css('padding-top'), 10));
	    }
	    return ss;
	  };

	  SmartSelect.prototype.onOpen = function onOpen (type, containerEl) {
	    var ss = this;
	    var app = ss.app;
	    var $containerEl = $(containerEl);
	    ss.$containerEl = $containerEl;
	    ss.openedIn = type;
	    ss.opened = true;

	    // Init VL
	    if (ss.params.virtualList) {
	      ss.vl = app.virtualList.create({
	        el: $containerEl.find('.virtual-list'),
	        items: ss.items,
	        renderItem: ss.renderItem.bind(ss),
	        height: ss.params.virtualListHeight,
	        searchByItem: function searchByItem(query, item) {
	          if (item.text && item.text.toLowerCase().indexOf(query.trim().toLowerCase()) >= 0) { return true; }
	          return false;
	        },
	      });
	    }
	    if (ss.params.scrollToSelectedItem) {
	      ss.scrollToSelectedItem();
	    }

	    // Init SB
	    if (ss.params.searchbar) {
	      var $searchbarEl = $containerEl.find('.searchbar');
	      if (type === 'page' && app.theme === 'ios') {
	        $searchbarEl = $(app.navbar.getElByPage($containerEl)).find('.searchbar');
	      }

	      if (ss.params.appendSearchbarNotFound && (type === 'page' || type === 'popup')) {
	        var $notFoundEl = null;

	        if (typeof ss.params.appendSearchbarNotFound === 'string') {
	          $notFoundEl = $(("<div class=\"block searchbar-not-found\">" + (ss.params.appendSearchbarNotFound) + "</div>"));
	        } else if (typeof ss.params.appendSearchbarNotFound === 'boolean') {
	          $notFoundEl = $('<div class="block searchbar-not-found">Nothing found</div>');
	        } else {
	          $notFoundEl = ss.params.appendSearchbarNotFound;
	        }

	        if ($notFoundEl) {
	          $containerEl.find('.page-content').append($notFoundEl[0]);
	        }
	      }

	      var searchbarParams = Utils.extend({
	        el: $searchbarEl,
	        backdropEl: $containerEl.find('.searchbar-backdrop'),
	        searchContainer: (".smart-select-list-" + (ss.id)),
	        searchIn: '.item-title',
	      }, typeof ss.params.searchbar === 'object' ? ss.params.searchbar : {});

	      ss.searchbar = app.searchbar.create(searchbarParams);
	    }

	    // Check for max length
	    if (ss.maxLength) {
	      ss.checkMaxLength();
	    }

	    // Close on select
	    if (ss.params.closeOnSelect) {
	      ss.$containerEl.find(("input[type=\"radio\"][name=\"" + (ss.inputName) + "\"]:checked")).parents('label').once('click', function () {
	        ss.close();
	      });
	    }

	    // Attach input events
	    ss.attachInputsEvents();

	    ss.$el.trigger('smartselect:open', ss);
	    ss.emit('local::open smartSelectOpen', ss);
	  };

	  SmartSelect.prototype.onOpened = function onOpened () {
	    var ss = this;

	    ss.$el.trigger('smartselect:opened', ss);
	    ss.emit('local::opened smartSelectOpened', ss);
	  };

	  SmartSelect.prototype.onClose = function onClose () {
	    var ss = this;
	    if (ss.destroyed) { return; }

	    // Destroy VL
	    if (ss.vl && ss.vl.destroy) {
	      ss.vl.destroy();
	      ss.vl = null;
	      delete ss.vl;
	    }

	    // Destroy SB
	    if (ss.searchbar && ss.searchbar.destroy) {
	      ss.searchbar.destroy();
	      ss.searchbar = null;
	      delete ss.searchbar;
	    }
	    // Detach events
	    ss.detachInputsEvents();

	    ss.$el.trigger('smartselect:close', ss);
	    ss.emit('local::close smartSelectClose', ss);
	  };

	  SmartSelect.prototype.onClosed = function onClosed () {
	    var ss = this;
	    if (ss.destroyed) { return; }
	    ss.opened = false;
	    ss.$containerEl = null;
	    delete ss.$containerEl;

	    ss.$el.trigger('smartselect:closed', ss);
	    ss.emit('local::closed smartSelectClosed', ss);
	  };

	  SmartSelect.prototype.openPage = function openPage () {
	    var ss = this;
	    if (ss.opened) { return ss; }
	    ss.getItemsData();
	    var pageHtml = ss.renderPage(ss.items);
	    var view = ss.getView();

	    view.router.navigate({
	      url: ss.url,
	      route: {
	        content: pageHtml,
	        path: ss.url,
	        on: {
	          pageBeforeIn: function pageBeforeIn(e, page) {
	            ss.onOpen('page', page.el);
	          },
	          pageAfterIn: function pageAfterIn(e, page) {
	            ss.onOpened('page', page.el);
	          },
	          pageBeforeOut: function pageBeforeOut(e, page) {
	            ss.onClose('page', page.el);
	          },
	          pageAfterOut: function pageAfterOut(e, page) {
	            ss.onClosed('page', page.el);
	          },
	        },
	      },
	    });
	    return ss;
	  };

	  SmartSelect.prototype.openPopup = function openPopup () {
	    var ss = this;
	    if (ss.opened) { return ss; }
	    ss.getItemsData();
	    var popupHtml = ss.renderPopup(ss.items);

	    var popupParams = {
	      content: popupHtml,
	      on: {
	        popupOpen: function popupOpen(popup) {
	          ss.onOpen('popup', popup.el);
	        },
	        popupOpened: function popupOpened(popup) {
	          ss.onOpened('popup', popup.el);
	        },
	        popupClose: function popupClose(popup) {
	          ss.onClose('popup', popup.el);
	        },
	        popupClosed: function popupClosed(popup) {
	          ss.onClosed('popup', popup.el);
	        },
	      },
	    };

	    if (ss.params.routableModals) {
	      var view = ss.getView();
	      view.router.navigate({
	        url: ss.url,
	        route: {
	          path: ss.url,
	          popup: popupParams,
	        },
	      });
	    } else {
	      ss.modal = ss.app.popup.create(popupParams).open();
	    }
	    return ss;
	  };

	  SmartSelect.prototype.openSheet = function openSheet () {
	    var ss = this;
	    if (ss.opened) { return ss; }
	    ss.getItemsData();
	    var sheetHtml = ss.renderSheet(ss.items);

	    var sheetParams = {
	      content: sheetHtml,
	      backdrop: false,
	      scrollToEl: ss.$el,
	      closeByOutsideClick: true,
	      on: {
	        sheetOpen: function sheetOpen(sheet) {
	          ss.onOpen('sheet', sheet.el);
	        },
	        sheetOpened: function sheetOpened(sheet) {
	          ss.onOpened('sheet', sheet.el);
	        },
	        sheetClose: function sheetClose(sheet) {
	          ss.onClose('sheet', sheet.el);
	        },
	        sheetClosed: function sheetClosed(sheet) {
	          ss.onClosed('sheet', sheet.el);
	        },
	      },
	    };

	    if (ss.params.routableModals) {
	      var view = ss.getView();
	      view.router.navigate({
	        url: ss.url,
	        route: {
	          path: ss.url,
	          sheet: sheetParams,
	        },
	      });
	    } else {
	      ss.modal = ss.app.sheet.create(sheetParams).open();
	    }
	    return ss;
	  };

	  SmartSelect.prototype.openPopover = function openPopover () {
	    var ss = this;
	    if (ss.opened) { return ss; }
	    ss.getItemsData();
	    var popoverHtml = ss.renderPopover(ss.items);
	    var popoverParams = {
	      content: popoverHtml,
	      targetEl: ss.$el,
	      on: {
	        popoverOpen: function popoverOpen(popover) {
	          ss.onOpen('popover', popover.el);
	        },
	        popoverOpened: function popoverOpened(popover) {
	          ss.onOpened('popover', popover.el);
	        },
	        popoverClose: function popoverClose(popover) {
	          ss.onClose('popover', popover.el);
	        },
	        popoverClosed: function popoverClosed(popover) {
	          ss.onClosed('popover', popover.el);
	        },
	      },
	    };
	    if (ss.params.routableModals) {
	      var view = ss.getView();
	      view.router.navigate({
	        url: ss.url,
	        route: {
	          path: ss.url,
	          popover: popoverParams,
	        },
	      });
	    } else {
	      ss.modal = ss.app.popover.create(popoverParams).open();
	    }
	    return ss;
	  };

	  SmartSelect.prototype.open = function open (type) {
	    var ss = this;
	    if (ss.opened) { return ss; }
	    var openIn = type || ss.params.openIn;
	    ss[("open" + (openIn.split('').map(function (el, index) {
	      if (index === 0) { return el.toUpperCase(); }
	      return el;
	    }).join('')))]();
	    return ss;
	  };

	  SmartSelect.prototype.close = function close () {
	    var ss = this;
	    if (!ss.opened) { return ss; }
	    if (ss.params.routableModals || ss.openedIn === 'page') {
	      var view = ss.getView();
	      view.router.back();
	    } else {
	      ss.modal.once('modalClosed', function () {
	        Utils.nextTick(function () {
	          ss.modal.destroy();
	          delete ss.modal;
	        });
	      });
	      ss.modal.close();
	    }
	    return ss;
	  };

	  SmartSelect.prototype.init = function init () {
	    var ss = this;
	    ss.attachEvents();
	    ss.setTextValue();
	  };

	  SmartSelect.prototype.destroy = function destroy () {
	    var ss = this;
	    ss.emit('local::beforeDestroy smartSelectBeforeDestroy', ss);
	    ss.$el.trigger('smartselect:beforedestroy', ss);
	    ss.detachEvents();
	    delete ss.$el[0].f7SmartSelect;
	    Utils.deleteProps(ss);
	    ss.destroyed = true;
	  };

	  return SmartSelect;
	}(Framework7Class));

	var SmartSelect$1 = {
	  name: 'smartSelect',
	  params: {
	    smartSelect: {
	      el: undefined,
	      valueEl: undefined,
	      openIn: 'page', // or 'popup' or 'sheet' or 'popover'
	      pageTitle: undefined,
	      pageBackLinkText: 'Back',
	      popupCloseLinkText: 'Close',
	      popupTabletFullscreen: false,
	      sheetCloseLinkText: 'Done',
	      searchbar: false,
	      searchbarPlaceholder: 'Search',
	      searchbarDisableText: 'Cancel',
	      searchbarDisableButton: undefined,
	      closeOnSelect: false,
	      virtualList: false,
	      virtualListHeight: undefined,
	      scrollToSelectedItem: false,
	      formColorTheme: undefined,
	      navbarColorTheme: undefined,
	      routableModals: true,
	      url: 'select/',
	      cssClass: '',
	      /*
	        Custom render functions
	      */
	      renderPage: undefined,
	      renderPopup: undefined,
	      renderSheet: undefined,
	      renderPopover: undefined,
	      renderItems: undefined,
	      renderItem: undefined,
	      renderSearchbar: undefined,
	    },
	  },
	  static: {
	    SmartSelect: SmartSelect,
	  },
	  create: function create() {
	    var app = this;
	    app.smartSelect = Utils.extend(
	      ConstructorMethods({
	        defaultSelector: '.smart-select',
	        constructor: SmartSelect,
	        app: app,
	        domProp: 'f7SmartSelect',
	      }),
	      {
	        open: function open(smartSelectEl) {
	          var ss = app.smartSelect.get(smartSelectEl);
	          if (ss && ss.open) { return ss.open(); }
	          return undefined;
	        },
	        close: function close(smartSelectEl) {
	          var ss = app.smartSelect.get(smartSelectEl);
	          if (ss && ss.close) { return ss.close(); }
	          return undefined;
	        },
	      }
	    );
	  },

	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $(tabEl).find('.smart-select-init').each(function (index, smartSelectEl) {
	        app.smartSelect.create(Utils.extend({ el: smartSelectEl }, $(smartSelectEl).dataset()));
	      });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      $(tabEl).find('.smart-select-init').each(function (index, smartSelectEl) {
	        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
	          smartSelectEl.f7SmartSelect.destroy();
	        }
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.smart-select-init').each(function (index, smartSelectEl) {
	        app.smartSelect.create(Utils.extend({ el: smartSelectEl }, $(smartSelectEl).dataset()));
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      page.$el.find('.smart-select-init').each(function (index, smartSelectEl) {
	        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
	          smartSelectEl.f7SmartSelect.destroy();
	        }
	      });
	    },
	  },
	  clicks: {
	    '.smart-select': function open($clickedEl, data) {
	      var app = this;
	      if (!$clickedEl[0].f7SmartSelect) {
	        var ss = app.smartSelect.create(Utils.extend({ el: $clickedEl }, data));
	        ss.open();
	      }
	    },
	  },
	  vnode: {
	    'smart-select-init': {
	      insert: function insert(vnode) {
	        var app = this;
	        var smartSelectEl = vnode.elm;
	        app.smartSelect.create(Utils.extend({ el: smartSelectEl }, $(smartSelectEl).dataset()));
	      },
	      destroy: function destroy(vnode) {
	        var smartSelectEl = vnode.elm;
	        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
	          smartSelectEl.f7SmartSelect.destroy();
	        }
	      },
	    },
	  },
	};

	var Grid = {
	  name: 'grid',
	};

	/*
	Converts a Gregorian date to Jalaali.
	*/
	function toJalaali (gy, gm, gd) {
	  if (Object.prototype.toString.call(gy) === '[object Date]') {
	    gd = gy.getDate();
	    gm = gy.getMonth() + 1;
	    gy = gy.getFullYear();
	  }
	  return d2j(g2d(gy, gm, gd))
	}

	/*
	Converts a Jalaali date to Gregorian.
	*/
	function toGregorian (jy, jm, jd) {
	  return d2g(j2d(jy, jm, jd))
	}

	// /*
	// Checks whether a Jalaali date is valid or not.
	// */
	// function isValidJalaaliDate (jy, jm, jd) {
	//   return jy >= -61 && jy <= 3177 &&
	//         jm >= 1 && jm <= 12 &&
	//         jd >= 1 && jd <= monthLength(jy, jm)
	// }

	/*
	Is this a leap year or not?
	*/
	function isLeapJalaaliYear (jy) {
	  return jalCal(jy).leap === 0
	}

	/*
	Number of days in a given month in a Jalaali year.
	*/
	function monthLength (jy, jm) {
	  if (jm <= 6) { return 31 }
	  if (jm <= 11) { return 30 }
	  if (isLeapJalaaliYear(jy)) { return 30 }
	  return 29
	}

	/*
	This function determines if the Jalaali (Persian) year is
	leap (366-day long) or is the common year (365 days), and
	finds the day in March (Gregorian calendar) of the first
	day of the Jalaali year (jy).
	@param jy Jalaali calendar year (-61 to 3177)
	@return
	  leap: number of years since the last leap year (0 to 4)
	  gy: Gregorian year of the beginning of Jalaali year
	  march: the March day of Farvardin the 1st (1st day of jy)
	@see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm
	@see: http://www.fourmilab.ch/documents/calendar/
	*/
	function jalCal (jy) {
	// Jalaali years starting the 33-year rule.
	  var breaks = [-61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210, 1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178];
	  var bl = breaks.length;
	  var gy = jy + 621;
	  var leapJ = -14;
	  var jp = breaks[0];
	  var jm;
	  var jump;
	  var leap;
	  var leapG;
	  var march;
	  var n;
	  var i;

	  if (jy < jp || jy >= breaks[bl - 1]) { throw new Error('Invalid Jalaali year ' + jy) }

	  // Find the limiting years for the Jalaali year jy.
	  for (i = 1; i < bl; i += 1) {
	    jm = breaks[i];
	    jump = jm - jp;
	    if (jy < jm) { break }
	    leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);
	    jp = jm;
	  }
	  n = jy - jp;

	  // Find the number of leap years from AD 621 to the beginning
	  // of the current Jalaali year in the Persian calendar.
	  leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);
	  if (mod(jump, 33) === 4 && jump - n === 4) { leapJ += 1; }

	  // And the same in the Gregorian calendar (until the year gy).
	  leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150;

	  // Determine the Gregorian date of Farvardin the 1st.
	  march = 20 + leapJ - leapG;

	  // Find how many years have passed since the last leap year.
	  if (jump - n < 6) { n = n - jump + div(jump + 4, 33) * 33; }
	  leap = mod(mod(n + 1, 33) - 1, 4);
	  if (leap === -1) {
	    leap = 4;
	  }

	  return { leap: leap,
	    gy: gy,
	    march: march
	  }
	}

	/*
	Converts a date of the Jalaali calendar to the Julian Day number.
	@param jy Jalaali year (1 to 3100)
	@param jm Jalaali month (1 to 12)
	@param jd Jalaali day (1 to 29/31)
	@return Julian Day number
	*/
	function j2d (jy, jm, jd) {
	  var r = jalCal(jy);
	  return g2d(r.gy, 3, r.march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1
	}

	/*
	Converts the Julian Day number to a date in the Jalaali calendar.
	@param jdn Julian Day number
	@return
	  jy: Jalaali year (1 to 3100)
	  jm: Jalaali month (1 to 12)
	  jd: Jalaali day (1 to 29/31)
	*/
	function d2j (jdn) {
	  var gy = d2g(jdn).gy; // Calculate Gregorian year (gy).
	  var jy = gy - 621;
	  var r = jalCal(jy);
	  var jdn1f = g2d(gy, 3, r.march);
	  var jd;
	  var jm;
	  var k;

	  // Find number of days that passed since 1 Farvardin.
	  k = jdn - jdn1f;
	  if (k >= 0) {
	    if (k <= 185) {
	    // The first 6 months.
	      jm = 1 + div(k, 31);
	      jd = mod(k, 31) + 1;
	      return { jy: jy,
	        jm: jm,
	        jd: jd
	      }
	    } else {
	    // The remaining months.
	      k -= 186;
	    }
	  } else {
	  // Previous Jalaali year.
	    jy -= 1;
	    k += 179;
	    if (r.leap === 1) { k += 1; }
	  }
	  jm = 7 + div(k, 30);
	  jd = mod(k, 30) + 1;
	  return { jy: jy,
	    jm: jm,
	    jd: jd
	  }
	}

	/*
	Calculates the Julian Day number from Gregorian or Julian
	calendar dates. This integer number corresponds to the noon of
	the date (i.e. 12 hours of Universal Time).
	The procedure was tested to be good since 1 March, -100100 (of both
	calendars) up to a few million years into the future.
	@param gy Calendar year (years BC numbered 0, -1, -2, ...)
	@param gm Calendar month (1 to 12)
	@param gd Calendar day of the month (1 to 28/29/30/31)
	@return Julian Day number
	*/
	function g2d (gy, gm, gd) {
	  var d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) +
	    div(153 * mod(gm + 9, 12) + 2, 5) +
	    gd - 34840408;
	  d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;
	  return d
	}

	/*
	Calculates Gregorian and Julian calendar dates from the Julian Day number
	(jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both
	calendars) to some millions years ahead of the present.
	@param jdn Julian Day number
	@return
	  gy: Calendar year (years BC numbered 0, -1, -2, ...)
	  gm: Calendar month (1 to 12)
	  gd: Calendar day of the month M (1 to 28/29/30/31)
	*/
	function d2g (jdn) {
	  var j,
	    i,
	    gd,
	    gm,
	    gy;
	  j = 4 * jdn + 139361631;
	  j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
	  i = div(mod(j, 1461), 4) * 5 + 308;
	  gd = div(mod(i, 153), 5) + 1;
	  gm = mod(div(i, 153), 12) + 1;
	  gy = div(j, 1461) - 100100 + div(8 - gm, 6);
	  return { gy: gy,
	    gm: gm,
	    gd: gd
	  }
	}

	/*
	Utility helper functions.
	*/

	function div (a, b) {
	  return ~~(a / b)
	}

	function mod (a, b) {
	  return a - ~~(a / b) * b
	}

	function fixDate (y, m, d) {
	  if (m > 11) {
	    y += Math.floor(m / 12);
	    m = m % 12;
	  }
	  while (m < 0) {
	    y -= 1;
	    m += 12;
	  }
	  while (d > monthLength(y, m + 1)) {
	    m = m !== 11 ? m + 1 : 0;
	    y = m === 0 ? y + 1 : y;
	    d -= monthLength(y, m + 1);
	  }
	  while (d <= 0) {
	    m = m !== 0 ? m - 1 : 11;
	    y = m === 11 ? y - 1 : y;
	    d += monthLength(y, m + 1);
	  }
	  return [y, m || 0, d || 1]
	}

	/*
	  Copyright nainemom <nainemom@gmail.com>
	  https://github.com/nainemom/idate/blob/dev/package.json
	*/

	var methods = [
	  'getHours',
	  'getMilliseconds',
	  'getMinutes',
	  'getSeconds',
	  'getTime',
	  'getTimezoneOffset',
	  'getUTCDate',
	  'getUTCDay',
	  'getUTCFullYear',
	  'getUTCHours',
	  'getUTCMilliseconds',
	  'getUTCMinutes',
	  'getUTCMonth',
	  'getUTCSeconds',
	  'now',
	  'parse',
	  'setHours',
	  'setMilliseconds',
	  'setMinutes',
	  'setSeconds',
	  'setTime',
	  'setUTCDate',
	  'setUTCFullYear',
	  'setUTCHours',
	  'setUTCMilliseconds',
	  'setUTCMinutes',
	  'setUTCMonth',
	  'setUTCSeconds',
	  'toDateString',
	  'toISOString',
	  'toJSON',
	  'toLocaleDateString',
	  'toLocaleTimeString',
	  'toLocaleString',
	  'toTimeString',
	  'toUTCString',
	  'UTC',
	  'valueOf'
	];

	var DAY_NAMES = ['Shanbe', 'Yekshanbe', 'Doshanbe', 'Seshanbe', 'Chaharshanbe', 'Panjshanbe', 'Jom\'e'];
	var PERSIAN_DAY_NAMES = ['شنبه', 'یکشنبه', 'دوشنبه', 'سه‌شنبه', 'چهارشنبه', 'پنجشنبه', 'جمعه'];
	var MONTH_NAMES = ['Farvardin', 'Ordibehesht', 'Khordad', 'Tir', 'Mordad', 'Shahrivar', 'Mehr', 'Aban', 'Azar', 'Dey', 'Bahman', 'Esfand'];
	var PERSIAN_MONTH_NAMES = ['فروردین', 'اردیبهشت', 'خرداد', 'تیر', 'مرداد', 'شهریور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'];
	var PERSIAN_NUMBERS = ['۰', '۱', '۲', '۳', '۴', '۵', '۶', '۷', '۸', '۹'];

	var IDate = /*@__PURE__*/(function (Date) {
	  function IDate () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    Date.call(this);

	    var date;
	    if (args.length === 0) {
	      date = Date.now();
	    } else if (args.length === 1) {
	      date = args[0] instanceof Date ? args[0].getTime() : args[0];
	    } else {
	      var fixed = fixDate(
	        args[0],
	        args[1] || 0,
	        typeof args[2] === 'undefined' ? 1 : args[2]);
	      var converted$1 = toGregorian(fixed[0], fixed[1] + 1, fixed[2]);
	      date = [converted$1.gy, converted$1.gm - 1, converted$1.gd].concat([args[3] || 0, args[4] || 0, args[5] || 0, args[6] || 0]);
	    }

	    if (Array.isArray(date)) {
	      this.gdate = new (Function.prototype.bind.apply( Date, [ null ].concat( date) ));
	    } else {
	      this.gdate = new Date(date);
	    }

	    var converted = toJalaali(this.gdate.getFullYear(), this.gdate.getMonth() + 1, this.gdate.getDate());
	    this.jdate = [converted.jy, converted.jm - 1, converted.jd];

	    methods.forEach(function (method) {
	      IDate.prototype[method] = function () {
	        var ref;

	        return (ref = this.gdate)[method].apply(ref, arguments)
	      };
	    });
	  }

	  if ( Date ) IDate.__proto__ = Date;
	  IDate.prototype = Object.create( Date && Date.prototype );
	  IDate.prototype.constructor = IDate;

	  IDate.prototype.getFullYear = function getFullYear () {
	    return this.jdate[0]
	  };

	  IDate.prototype.setFullYear = function setFullYear (value) {
	    this.jdate = fixDate(value, this.jdate[1], this.jdate[2]);
	    this.syncDate();
	    return this.gdate.getTime()
	  };

	  IDate.prototype.getMonth = function getMonth () {
	    return this.jdate[1]
	  };

	  IDate.prototype.setMonth = function setMonth (value) {
	    this.jdate = fixDate(this.jdate[0], value, this.jdate[2]);
	    this.syncDate();
	    return this.gdate.getTime()
	  };

	  IDate.prototype.getDate = function getDate () {
	    return this.jdate[2]
	  };

	  IDate.prototype.setDate = function setDate (value) {
	    this.jdate = fixDate(this.jdate[0], this.jdate[1], value);
	    this.syncDate();
	    return this.gdate.getTime()
	  };

	  IDate.prototype.getDay = function getDay () {
	    return (this.gdate.getDay() + 1) % 7
	  };

	  IDate.prototype.syncDate = function syncDate () {
	    var converted = toGregorian(this.jdate[0], this.jdate[1] + 1, this.jdate[2]);
	    this.gdate.setFullYear(converted.gy);
	    this.gdate.setMonth(converted.gm - 1);
	    this.gdate.setDate(converted.gd);
	  };
	  IDate.prototype.toString = function toString (persianString) {
	    if ( persianString === void 0 ) persianString = true;

	    var replaceNums = function (str) {
	      return str.replace(/./g, function (c) { return PERSIAN_NUMBERS[c] || c; })
	    };
	    var padNumber = function (num) { return num.toString().length === 1 ? ("0" + num) : num.toString(); };
	    var time = (padNumber(this.getHours())) + ":" + (padNumber(this.getMinutes())) + ":" + (padNumber(this.getSeconds()));
	    if (persianString) {
	      return replaceNums(((PERSIAN_DAY_NAMES[this.getDay()]) + " " + (this.getDate()) + " " + (PERSIAN_MONTH_NAMES[this.getMonth()]) + " " + (this.getFullYear()) + " ساعت " + time))
	    }
	    return ((DAY_NAMES[this.getDay()]) + " " + (this.getDate()) + " " + (MONTH_NAMES[this.getMonth()]) + " " + (this.getFullYear()) + " " + time)
	  };

	  return IDate;
	}(Date));

	var Calendar = /*@__PURE__*/(function (Framework7Class) {
	  function Calendar(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class.call(this, params, [app]);
	    var calendar = this;

	    calendar.params = Utils.extend({}, app.params.calendar, params);

	    if (calendar.params.calendarType === 'jalali') {
	      Object.keys(calendar.params.jalali).forEach(function (param) {
	        if (!params[param]) {
	          calendar.params[param] = calendar.params.jalali[param];
	        }
	      });
	    }

	    if (calendar.params.calendarType === 'jalali') {
	      calendar.DateHandleClass = IDate;
	    } else {
	      calendar.DateHandleClass = Date;
	    }

	    var $containerEl;
	    if (calendar.params.containerEl) {
	      $containerEl = $(calendar.params.containerEl);
	      if ($containerEl.length === 0) { return calendar; }
	    }

	    var $inputEl;
	    if (calendar.params.inputEl) {
	      $inputEl = $(calendar.params.inputEl);
	    }

	    var view;
	    if ($inputEl) {
	      view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
	    }
	    if (!view) { view = app.views.main; }

	    var isHorizontal = calendar.params.direction === 'horizontal';

	    var inverter = 1;
	    if (isHorizontal) {
	      inverter = app.rtl ? -1 : 1;
	    }

	    Utils.extend(calendar, {
	      app: app,
	      $containerEl: $containerEl,
	      containerEl: $containerEl && $containerEl[0],
	      inline: $containerEl && $containerEl.length > 0,
	      $inputEl: $inputEl,
	      inputEl: $inputEl && $inputEl[0],
	      initialized: false,
	      opened: false,
	      url: calendar.params.url,
	      isHorizontal: isHorizontal,
	      inverter: inverter,
	      view: view,
	      animating: false,
	    });

	    function onInputClick() {
	      calendar.open();
	    }
	    function onInputFocus(e) {
	      e.preventDefault();
	    }
	    function onHtmlClick(e) {
	      var $targetEl = $(e.target);
	      if (calendar.isPopover()) { return; }
	      if (!calendar.opened || calendar.closing) { return; }
	      if ($targetEl.closest('[class*="backdrop"]').length) { return; }
	      if ($inputEl && $inputEl.length > 0) {
	        if ($targetEl[0] !== $inputEl[0] && $targetEl.closest('.sheet-modal, .calendar-modal').length === 0) {
	          calendar.close();
	        }
	      } else if ($(e.target).closest('.sheet-modal, .calendar-modal').length === 0) {
	        calendar.close();
	      }
	    }

	    // Events
	    Utils.extend(calendar, {
	      attachInputEvents: function attachInputEvents() {
	        calendar.$inputEl.on('click', onInputClick);
	        if (calendar.params.inputReadOnly) {
	          calendar.$inputEl.on('focus mousedown', onInputFocus);
	        }
	      },
	      detachInputEvents: function detachInputEvents() {
	        calendar.$inputEl.off('click', onInputClick);
	        if (calendar.params.inputReadOnly) {
	          calendar.$inputEl.off('focus mousedown', onInputFocus);
	        }
	      },
	      attachHtmlEvents: function attachHtmlEvents() {
	        app.on('click', onHtmlClick);
	      },
	      detachHtmlEvents: function detachHtmlEvents() {
	        app.off('click', onHtmlClick);
	      },
	    });
	    calendar.attachCalendarEvents = function attachCalendarEvents() {
	      var allowItemClick = true;
	      var isTouched;
	      var isMoved;
	      var touchStartX;
	      var touchStartY;
	      var touchCurrentX;
	      var touchCurrentY;
	      var touchStartTime;
	      var touchEndTime;
	      var currentTranslate;
	      var wrapperWidth;
	      var wrapperHeight;
	      var percentage;
	      var touchesDiff;
	      var isScrolling;

	      var $el = calendar.$el;
	      var $wrapperEl = calendar.$wrapperEl;

	      function handleTouchStart(e) {
	        if (isMoved || isTouched) { return; }
	        isTouched = true;
	        touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	        touchCurrentX = touchStartX;
	        touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	        touchCurrentY = touchStartY;
	        touchStartTime = (new calendar.DateHandleClass()).getTime();
	        percentage = 0;
	        allowItemClick = true;
	        isScrolling = undefined;
	        currentTranslate = calendar.monthsTranslate;
	      }
	      function handleTouchMove(e) {
	        if (!isTouched) { return; }
	        var isH = calendar.isHorizontal;

	        touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	        touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	        if (typeof isScrolling === 'undefined') {
	          isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
	        }
	        if (isH && isScrolling) {
	          isTouched = false;
	          return;
	        }
	        e.preventDefault();
	        if (calendar.animating) {
	          isTouched = false;
	          return;
	        }
	        allowItemClick = false;
	        if (!isMoved) {
	          // First move
	          isMoved = true;
	          wrapperWidth = $wrapperEl[0].offsetWidth;
	          wrapperHeight = $wrapperEl[0].offsetHeight;
	          $wrapperEl.transition(0);
	        }

	        touchesDiff = isH ? touchCurrentX - touchStartX : touchCurrentY - touchStartY;
	        percentage = touchesDiff / (isH ? wrapperWidth : wrapperHeight);
	        currentTranslate = ((calendar.monthsTranslate * calendar.inverter) + percentage) * 100;

	        // Transform wrapper
	        $wrapperEl.transform(("translate3d(" + (isH ? currentTranslate : 0) + "%, " + (isH ? 0 : currentTranslate) + "%, 0)"));
	      }
	      function handleTouchEnd() {
	        if (!isTouched || !isMoved) {
	          isTouched = false;
	          isMoved = false;
	          return;
	        }
	        isTouched = false;
	        isMoved = false;

	        touchEndTime = new calendar.DateHandleClass().getTime();
	        if (touchEndTime - touchStartTime < 300) {
	          if (Math.abs(touchesDiff) < 10) {
	            calendar.resetMonth();
	          } else if (touchesDiff >= 10) {
	            if (app.rtl) { calendar.nextMonth(); }
	            else { calendar.prevMonth(); }
	          } else if (app.rtl) { calendar.prevMonth(); }
	          else { calendar.nextMonth(); }
	        } else if (percentage <= -0.5) {
	          if (app.rtl) { calendar.prevMonth(); }
	          else { calendar.nextMonth(); }
	        } else if (percentage >= 0.5) {
	          if (app.rtl) { calendar.nextMonth(); }
	          else { calendar.prevMonth(); }
	        } else {
	          calendar.resetMonth();
	        }

	        // Allow click
	        setTimeout(function () {
	          allowItemClick = true;
	        }, 100);
	      }

	      function handleDayClick(e) {
	        if (!allowItemClick) { return; }
	        var $dayEl = $(e.target).parents('.calendar-day');
	        if ($dayEl.length === 0 && $(e.target).hasClass('calendar-day')) {
	          $dayEl = $(e.target);
	        }
	        if ($dayEl.length === 0) { return; }
	        if ($dayEl.hasClass('calendar-day-disabled')) { return; }
	        if (!calendar.params.rangePicker) {
	          if ($dayEl.hasClass('calendar-day-next')) { calendar.nextMonth(); }
	          if ($dayEl.hasClass('calendar-day-prev')) { calendar.prevMonth(); }
	        }
	        var dateYear = parseInt($dayEl.attr('data-year'), 10);
	        var dateMonth = parseInt($dayEl.attr('data-month'), 10);
	        var dateDay = parseInt($dayEl.attr('data-day'), 10);
	        calendar.emit(
	          'local::dayClick calendarDayClick',
	          calendar,
	          $dayEl[0],
	          dateYear,
	          dateMonth,
	          dateDay
	        );
	        if (!$dayEl.hasClass('calendar-day-selected') || calendar.params.multiple || calendar.params.rangePicker) {
	          calendar.addValue(new calendar.DateHandleClass(dateYear, dateMonth, dateDay, 0, 0, 0));
	        }
	        if (calendar.params.closeOnSelect) {
	          if (
	            (calendar.params.rangePicker && calendar.value.length === 2)
	            || !calendar.params.rangePicker
	          ) {
	            calendar.close();
	          }
	        }
	      }

	      function onNextMonthClick() {
	        calendar.nextMonth();
	      }

	      function onPrevMonthClick() {
	        calendar.prevMonth();
	      }

	      function onNextYearClick() {
	        calendar.nextYear();
	      }

	      function onPrevYearClick() {
	        calendar.prevYear();
	      }

	      var passiveListener = app.touchEvents.start === 'touchstart' && app.support.passiveListener ? { passive: true, capture: false } : false;
	      // Selectors clicks
	      $el.find('.calendar-prev-month-button').on('click', onPrevMonthClick);
	      $el.find('.calendar-next-month-button').on('click', onNextMonthClick);
	      $el.find('.calendar-prev-year-button').on('click', onPrevYearClick);
	      $el.find('.calendar-next-year-button').on('click', onNextYearClick);
	      // Day clicks
	      $wrapperEl.on('click', handleDayClick);
	      // Touch events
	      {
	        if (calendar.params.touchMove) {
	          $wrapperEl.on(app.touchEvents.start, handleTouchStart, passiveListener);
	          app.on('touchmove:active', handleTouchMove);
	          app.on('touchend:passive', handleTouchEnd);
	        }
	      }

	      calendar.detachCalendarEvents = function detachCalendarEvents() {
	        $el.find('.calendar-prev-month-button').off('click', onPrevMonthClick);
	        $el.find('.calendar-next-month-button').off('click', onNextMonthClick);
	        $el.find('.calendar-prev-year-button').off('click', onPrevYearClick);
	        $el.find('.calendar-next-year-button').off('click', onNextYearClick);
	        $wrapperEl.off('click', handleDayClick);
	        {
	          if (calendar.params.touchMove) {
	            $wrapperEl.off(app.touchEvents.start, handleTouchStart, passiveListener);
	            app.off('touchmove:active', handleTouchMove);
	            app.off('touchend:passive', handleTouchEnd);
	          }
	        }
	      };
	    };

	    calendar.init();

	    return calendar;
	  }

	  if ( Framework7Class ) Calendar.__proto__ = Framework7Class;
	  Calendar.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  Calendar.prototype.constructor = Calendar;
	  // eslint-disable-next-line
	  Calendar.prototype.normalizeDate = function normalizeDate (date) {
	    var calendar = this;
	    var d = new calendar.DateHandleClass(date);
	    return new calendar.DateHandleClass(d.getFullYear(), d.getMonth(), d.getDate());
	  };

	  Calendar.prototype.normalizeValues = function normalizeValues (values) {
	    var calendar = this;
	    var newValues = [];
	    if (values && Array.isArray(values)) {
	      newValues = values.map(function (val) { return calendar.normalizeDate(val); });
	    }
	    return newValues;
	  };

	  Calendar.prototype.initInput = function initInput () {
	    var calendar = this;
	    if (!calendar.$inputEl) { return; }
	    if (calendar.params.inputReadOnly) { calendar.$inputEl.prop('readOnly', true); }
	  };

	  Calendar.prototype.isPopover = function isPopover () {
	    var calendar = this;
	    var app = calendar.app;
	    var modal = calendar.modal;
	    var params = calendar.params;
	    if (params.openIn === 'sheet') { return false; }
	    if (modal && modal.type !== 'popover') { return false; }

	    if (!calendar.inline && calendar.inputEl) {
	      if (params.openIn === 'popover') { return true; }
	      if (app.device.ios) {
	        return !!app.device.ipad;
	      }
	      if (app.width >= 768) {
	        return true;
	      }
	      if (app.device.desktop && app.theme === 'aurora') {
	        return true;
	      }
	    }
	    return false;
	  };

	  Calendar.prototype.formatDate = function formatDate (d) {
	    var calendar = this;
	    var date = new calendar.DateHandleClass(d);
	    var year = date.getFullYear();
	    var month = date.getMonth();
	    var month1 = month + 1;
	    var day = date.getDate();
	    var weekDay = date.getDay();
	    var ref = calendar.params;
	    var dateFormat = ref.dateFormat;
	    var monthNames = ref.monthNames;
	    var monthNamesShort = ref.monthNamesShort;
	    var dayNames = ref.dayNames;
	    var dayNamesShort = ref.dayNamesShort;

	    return dateFormat
	      .replace(/yyyy/g, year)
	      .replace(/yy/g, String(year).substring(2))
	      .replace(/mm/g, month1 < 10 ? ("0" + month1) : month1)
	      .replace(/m(\W+)/g, (month1 + "$1"))
	      .replace(/MM/g, monthNames[month])
	      .replace(/M(\W+)/g, ((monthNamesShort[month]) + "$1"))
	      .replace(/dd/g, day < 10 ? ("0" + day) : day)
	      .replace(/d(\W+)/g, (day + "$1"))
	      .replace(/DD/g, dayNames[weekDay])
	      .replace(/D(\W+)/g, ((dayNamesShort[weekDay]) + "$1"));
	  };

	  Calendar.prototype.formatValue = function formatValue () {
	    var calendar = this;
	    var value = calendar.value;
	    if (calendar.params.formatValue) {
	      return calendar.params.formatValue.call(calendar, value);
	    }
	    return value
	      .map(function (v) { return calendar.formatDate(v); })
	      .join(calendar.params.rangePicker ? ' - ' : ', ');
	  };

	  Calendar.prototype.addValue = function addValue (newValue) {
	    var calendar = this;
	    var ref = calendar.params;
	    var multiple = ref.multiple;
	    var rangePicker = ref.rangePicker;
	    var rangePickerMinDays = ref.rangePickerMinDays;
	    var rangePickerMaxDays = ref.rangePickerMaxDays;
	    if (multiple) {
	      if (!calendar.value) { calendar.value = []; }
	      var inValuesIndex;
	      for (var i = 0; i < calendar.value.length; i += 1) {
	        if (new calendar.DateHandleClass(newValue).getTime() === new calendar.DateHandleClass(calendar.value[i]).getTime()) {
	          inValuesIndex = i;
	        }
	      }
	      if (typeof inValuesIndex === 'undefined') {
	        calendar.value.push(newValue);
	      } else {
	        calendar.value.splice(inValuesIndex, 1);
	      }
	      calendar.updateValue();
	    } else if (rangePicker) {
	      if (!calendar.value) { calendar.value = []; }
	      if (calendar.value.length === 2 || calendar.value.length === 0) {
	        calendar.value = [];
	      }

	      if ((calendar.value.length === 0
	        || ((Math.abs(calendar.value[0].getTime() - newValue.getTime()) >= (rangePickerMinDays - 1) * 60 * 60 * 24 * 1000) && (rangePickerMaxDays === 0 || Math.abs(calendar.value[0].getTime() - newValue.getTime()) <= (rangePickerMaxDays - 1) * 60 * 60 * 24 * 1000)))) { calendar.value.push(newValue); }
	      else { calendar.value = []; }

	      calendar.value.sort(function (a, b) { return a - b; });
	      calendar.updateValue();
	    } else {
	      calendar.value = [newValue];
	      calendar.updateValue();
	    }
	  };

	  Calendar.prototype.setValue = function setValue (values) {
	    var calendar = this;
	    var currentValue = calendar.value;
	    if (Array.isArray(currentValue) && Array.isArray(values) && currentValue.length === values.length) {
	      var equal = true;
	      currentValue.forEach(function (v, index) {
	        if (v !== values[index]) { equal = false; }
	      });
	      if (equal) { return; }
	    }
	    calendar.value = values;
	    calendar.updateValue();
	  };

	  Calendar.prototype.getValue = function getValue () {
	    var calendar = this;
	    return calendar.value;
	  };

	  Calendar.prototype.updateValue = function updateValue (onlyHeader) {
	    var calendar = this;
	    var $el = calendar.$el;
	    var $wrapperEl = calendar.$wrapperEl;
	    var $inputEl = calendar.$inputEl;
	    var value = calendar.value;
	    var params = calendar.params;
	    var i;
	    if ($el && $el.length > 0) {
	      $wrapperEl.find('.calendar-day-selected').removeClass('calendar-day-selected');
	      var valueDate;
	      if (params.rangePicker && value.length === 2) {
	        for (i = new calendar.DateHandleClass(value[0]).getTime(); i <= new calendar.DateHandleClass(value[1]).getTime(); i += 24 * 60 * 60 * 1000) {
	          valueDate = new calendar.DateHandleClass(i);
	          $wrapperEl.find((".calendar-day[data-date=\"" + (valueDate.getFullYear()) + "-" + (valueDate.getMonth()) + "-" + (valueDate.getDate()) + "\"]")).addClass('calendar-day-selected');
	        }
	      } else {
	        for (i = 0; i < calendar.value.length; i += 1) {
	          valueDate = new calendar.DateHandleClass(value[i]);
	          $wrapperEl.find((".calendar-day[data-date=\"" + (valueDate.getFullYear()) + "-" + (valueDate.getMonth()) + "-" + (valueDate.getDate()) + "\"]")).addClass('calendar-day-selected');
	        }
	      }
	    }
	    if (!onlyHeader) {
	      calendar.emit('local::change calendarChange', calendar, value);
	    }


	    if (($inputEl && $inputEl.length) || params.header) {
	      var inputValue = calendar.formatValue(value);
	      if (params.header && $el && $el.length) {
	        $el.find('.calendar-selected-date').text(inputValue);
	      }
	      if ($inputEl && $inputEl.length && !onlyHeader) {
	        $inputEl.val(inputValue);
	        $inputEl.trigger('change');
	      }
	    }
	  };

	  Calendar.prototype.updateCurrentMonthYear = function updateCurrentMonthYear (dir) {
	    var calendar = this;
	    var $months = calendar.$months;
	    var $el = calendar.$el;
	    var params = calendar.params;
	    if (typeof dir === 'undefined') {
	      calendar.currentMonth = parseInt($months.eq(1).attr('data-month'), 10);
	      calendar.currentYear = parseInt($months.eq(1).attr('data-year'), 10);
	    } else {
	      calendar.currentMonth = parseInt($months.eq(dir === 'next' ? ($months.length - 1) : 0).attr('data-month'), 10);
	      calendar.currentYear = parseInt($months.eq(dir === 'next' ? ($months.length - 1) : 0).attr('data-year'), 10);
	    }
	    $el.find('.current-month-value').text(params.monthNames[calendar.currentMonth]);
	    $el.find('.current-year-value').text(calendar.currentYear);
	  };

	  Calendar.prototype.update = function update () {
	    var calendar = this;
	    var currentYear = calendar.currentYear;
	    var currentMonth = calendar.currentMonth;
	    var $wrapperEl = calendar.$wrapperEl;
	    var currentDate = new calendar.DateHandleClass(currentYear, currentMonth);
	    var prevMonthHtml = calendar.renderMonth(currentDate, 'prev');
	    var currentMonthHtml = calendar.renderMonth(currentDate);
	    var nextMonthHtml = calendar.renderMonth(currentDate, 'next');

	    $wrapperEl
	      .transition(0)
	      .html(("" + prevMonthHtml + currentMonthHtml + nextMonthHtml))
	      .transform('translate3d(0,0,0)');
	    calendar.$months = $wrapperEl.find('.calendar-month');
	    calendar.monthsTranslate = 0;
	    calendar.setMonthsTranslate();
	    calendar.$months.each(function (index, monthEl) {
	      calendar.emit(
	        'local::monthAdd calendarMonthAdd',
	        monthEl
	      );
	    });
	  };

	  Calendar.prototype.onMonthChangeStart = function onMonthChangeStart (dir) {
	    var calendar = this;
	    var $months = calendar.$months;
	    var currentYear = calendar.currentYear;
	    var currentMonth = calendar.currentMonth;
	    calendar.updateCurrentMonthYear(dir);
	    $months.removeClass('calendar-month-current calendar-month-prev calendar-month-next');
	    var currentIndex = dir === 'next' ? $months.length - 1 : 0;

	    $months.eq(currentIndex).addClass('calendar-month-current');
	    $months.eq(dir === 'next' ? currentIndex - 1 : currentIndex + 1).addClass(dir === 'next' ? 'calendar-month-prev' : 'calendar-month-next');

	    calendar.emit(
	      'local::monthYearChangeStart calendarMonthYearChangeStart',
	      calendar,
	      currentYear,
	      currentMonth
	    );
	  };

	  Calendar.prototype.onMonthChangeEnd = function onMonthChangeEnd (dir, rebuildBoth) {
	    var calendar = this;
	    var currentYear = calendar.currentYear;
	    var currentMonth = calendar.currentMonth;
	    var $wrapperEl = calendar.$wrapperEl;
	    var monthsTranslate = calendar.monthsTranslate;
	    calendar.animating = false;
	    var nextMonthHtml;
	    var prevMonthHtml;
	    var currentMonthHtml;
	    $wrapperEl
	      .find('.calendar-month:not(.calendar-month-prev):not(.calendar-month-current):not(.calendar-month-next)')
	      .remove();

	    if (typeof dir === 'undefined') {
	      dir = 'next'; // eslint-disable-line
	      rebuildBoth = true; // eslint-disable-line
	    }
	    if (!rebuildBoth) {
	      currentMonthHtml = calendar.renderMonth(new calendar.DateHandleClass(currentYear, currentMonth), dir);
	    } else {
	      $wrapperEl.find('.calendar-month-next, .calendar-month-prev').remove();
	      prevMonthHtml = calendar.renderMonth(new calendar.DateHandleClass(currentYear, currentMonth), 'prev');
	      nextMonthHtml = calendar.renderMonth(new calendar.DateHandleClass(currentYear, currentMonth), 'next');
	    }
	    if (dir === 'next' || rebuildBoth) {
	      $wrapperEl.append(currentMonthHtml || nextMonthHtml);
	    }
	    if (dir === 'prev' || rebuildBoth) {
	      $wrapperEl.prepend(currentMonthHtml || prevMonthHtml);
	    }
	    var $months = $wrapperEl.find('.calendar-month');
	    calendar.$months = $months;
	    calendar.setMonthsTranslate(monthsTranslate);
	    calendar.emit(
	      'local::monthAdd calendarMonthAdd',
	      calendar,
	      dir === 'next' ? $months.eq($months.length - 1)[0] : $months.eq(0)[0]
	    );
	    calendar.emit(
	      'local::monthYearChangeEnd calendarMonthYearChangeEnd',
	      calendar,
	      currentYear,
	      currentMonth
	    );
	  };

	  Calendar.prototype.setMonthsTranslate = function setMonthsTranslate (translate) {
	    var calendar = this;
	    var $months = calendar.$months;
	    var isH = calendar.isHorizontal;
	    var inverter = calendar.inverter;
	    // eslint-disable-next-line
	    translate = translate || calendar.monthsTranslate || 0;
	    if (typeof calendar.monthsTranslate === 'undefined') {
	      calendar.monthsTranslate = translate;
	    }
	    $months.removeClass('calendar-month-current calendar-month-prev calendar-month-next');
	    var prevMonthTranslate = -(translate + 1) * 100 * inverter;
	    var currentMonthTranslate = -translate * 100 * inverter;
	    var nextMonthTranslate = -(translate - 1) * 100 * inverter;
	    $months.eq(0)
	      .transform(("translate3d(" + (isH ? prevMonthTranslate : 0) + "%, " + (isH ? 0 : prevMonthTranslate) + "%, 0)"))
	      .addClass('calendar-month-prev');
	    $months.eq(1)
	      .transform(("translate3d(" + (isH ? currentMonthTranslate : 0) + "%, " + (isH ? 0 : currentMonthTranslate) + "%, 0)"))
	      .addClass('calendar-month-current');
	    $months.eq(2)
	      .transform(("translate3d(" + (isH ? nextMonthTranslate : 0) + "%, " + (isH ? 0 : nextMonthTranslate) + "%, 0)"))
	      .addClass('calendar-month-next');
	  };

	  Calendar.prototype.nextMonth = function nextMonth (transition) {
	    var calendar = this;
	    var params = calendar.params;
	    var $wrapperEl = calendar.$wrapperEl;
	    var inverter = calendar.inverter;
	    var isH = calendar.isHorizontal;
	    if (typeof transition === 'undefined' || typeof transition === 'object') {
	      transition = ''; // eslint-disable-line
	      if (!params.animate) { transition = 0; } // eslint-disable-line
	    }
	    var nextMonth = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr('data-month'), 10);
	    var nextYear = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr('data-year'), 10);
	    var nextDate = new calendar.DateHandleClass(nextYear, nextMonth);
	    var nextDateTime = nextDate.getTime();
	    var transitionEndCallback = !calendar.animating;
	    if (params.maxDate) {
	      if (nextDateTime > new calendar.DateHandleClass(params.maxDate).getTime()) {
	        calendar.resetMonth();
	        return;
	      }
	    }
	    calendar.monthsTranslate -= 1;
	    if (nextMonth === calendar.currentMonth) {
	      var nextMonthTranslate = -(calendar.monthsTranslate) * 100 * inverter;
	      var nextMonthHtml = $(calendar.renderMonth(nextDateTime, 'next'))
	        .transform(("translate3d(" + (isH ? nextMonthTranslate : 0) + "%, " + (isH ? 0 : nextMonthTranslate) + "%, 0)"))
	        .addClass('calendar-month-next');
	      $wrapperEl.append(nextMonthHtml[0]);
	      calendar.$months = $wrapperEl.find('.calendar-month');
	      calendar.emit(
	        'local::monthAdd calendarMonthAdd',
	        calendar.$months.eq(calendar.$months.length - 1)[0]
	      );
	    }
	    calendar.animating = true;
	    calendar.onMonthChangeStart('next');
	    var translate = (calendar.monthsTranslate * 100) * inverter;

	    $wrapperEl.transition(transition).transform(("translate3d(" + (isH ? translate : 0) + "%, " + (isH ? 0 : translate) + "%, 0)"));
	    if (transitionEndCallback) {
	      $wrapperEl.transitionEnd(function () {
	        calendar.onMonthChangeEnd('next');
	      });
	    }
	    if (!params.animate) {
	      calendar.onMonthChangeEnd('next');
	    }
	  };

	  Calendar.prototype.prevMonth = function prevMonth (transition) {
	    var calendar = this;
	    var params = calendar.params;
	    var $wrapperEl = calendar.$wrapperEl;
	    var inverter = calendar.inverter;
	    var isH = calendar.isHorizontal;
	    if (typeof transition === 'undefined' || typeof transition === 'object') {
	      transition = ''; // eslint-disable-line
	      if (!params.animate) { transition = 0; } // eslint-disable-line
	    }
	    var prevMonth = parseInt(calendar.$months.eq(0).attr('data-month'), 10);
	    var prevYear = parseInt(calendar.$months.eq(0).attr('data-year'), 10);
	    var prevDate = new calendar.DateHandleClass(prevYear, prevMonth + 1, -1);
	    var prevDateTime = prevDate.getTime();
	    var transitionEndCallback = !calendar.animating;
	    if (params.minDate) {
	      var minDate = new calendar.DateHandleClass(params.minDate);
	      minDate = new calendar.DateHandleClass(minDate.getFullYear(), minDate.getMonth(), 1);
	      if (prevDateTime < minDate.getTime()) {
	        calendar.resetMonth();
	        return;
	      }
	    }
	    calendar.monthsTranslate += 1;
	    if (prevMonth === calendar.currentMonth) {
	      var prevMonthTranslate = -(calendar.monthsTranslate) * 100 * inverter;
	      var prevMonthHtml = $(calendar.renderMonth(prevDateTime, 'prev'))
	        .transform(("translate3d(" + (isH ? prevMonthTranslate : 0) + "%, " + (isH ? 0 : prevMonthTranslate) + "%, 0)"))
	        .addClass('calendar-month-prev');
	      $wrapperEl.prepend(prevMonthHtml[0]);
	      calendar.$months = $wrapperEl.find('.calendar-month');
	      calendar.emit(
	        'local::monthAdd calendarMonthAdd',
	        calendar.$months.eq(0)[0]
	      );
	    }
	    calendar.animating = true;
	    calendar.onMonthChangeStart('prev');
	    var translate = (calendar.monthsTranslate * 100) * inverter;
	    $wrapperEl
	      .transition(transition)
	      .transform(("translate3d(" + (isH ? translate : 0) + "%, " + (isH ? 0 : translate) + "%, 0)"));
	    if (transitionEndCallback) {
	      $wrapperEl.transitionEnd(function () {
	        calendar.onMonthChangeEnd('prev');
	      });
	    }
	    if (!params.animate) {
	      calendar.onMonthChangeEnd('prev');
	    }
	  };

	  Calendar.prototype.resetMonth = function resetMonth (transition) {
	    if ( transition === void 0 ) transition = '';

	    var calendar = this;
	    var $wrapperEl = calendar.$wrapperEl;
	    var inverter = calendar.inverter;
	    var isH = calendar.isHorizontal;
	    var monthsTranslate = calendar.monthsTranslate;
	    var translate = (monthsTranslate * 100) * inverter;
	    $wrapperEl
	      .transition(transition)
	      .transform(("translate3d(" + (isH ? translate : 0) + "%, " + (isH ? 0 : translate) + "%, 0)"));
	  };
	  // eslint-disable-next-line
	  Calendar.prototype.setYearMonth = function setYearMonth (year, month, transition) {
	    var calendar = this;
	    var params = calendar.params;
	    var isH = calendar.isHorizontal;
	    var $wrapperEl = calendar.$wrapperEl;
	    var inverter = calendar.inverter;
	    // eslint-disable-next-line
	    if (typeof year === 'undefined') { year = calendar.currentYear; }
	    // eslint-disable-next-line
	    if (typeof month === 'undefined') { month = calendar.currentMonth; }
	    if (typeof transition === 'undefined' || typeof transition === 'object') {
	      // eslint-disable-next-line
	      transition = '';
	      // eslint-disable-next-line
	      if (!params.animate) { transition = 0; }
	    }
	    var targetDate;
	    if (year < calendar.currentYear) {
	      targetDate = new calendar.DateHandleClass(year, month + 1, -1).getTime();
	    } else {
	      targetDate = new calendar.DateHandleClass(year, month).getTime();
	    }
	    if (params.maxDate && targetDate > new calendar.DateHandleClass(params.maxDate).getTime()) {
	      return false;
	    }
	    if (params.minDate) {
	      var minDate = new calendar.DateHandleClass(params.minDate);
	      minDate = new calendar.DateHandleClass(minDate.getFullYear(), minDate.getMonth(), 1);
	      if (targetDate < minDate.getTime()) {
	        return false;
	      }
	    }
	    var currentDate = new calendar.DateHandleClass(calendar.currentYear, calendar.currentMonth).getTime();
	    var dir = targetDate > currentDate ? 'next' : 'prev';
	    var newMonthHTML = calendar.renderMonth(new calendar.DateHandleClass(year, month));
	    calendar.monthsTranslate = calendar.monthsTranslate || 0;
	    var prevTranslate = calendar.monthsTranslate;
	    var monthTranslate;
	    var transitionEndCallback = !calendar.animating;
	    if (targetDate > currentDate) {
	      // To next
	      calendar.monthsTranslate -= 1;
	      if (!calendar.animating) { calendar.$months.eq(calendar.$months.length - 1).remove(); }
	      $wrapperEl.append(newMonthHTML);
	      calendar.$months = $wrapperEl.find('.calendar-month');
	      monthTranslate = -(prevTranslate - 1) * 100 * inverter;
	      calendar.$months
	        .eq(calendar.$months.length - 1)
	        .transform(("translate3d(" + (isH ? monthTranslate : 0) + "%, " + (isH ? 0 : monthTranslate) + "%, 0)"))
	        .addClass('calendar-month-next');
	    } else {
	      // To prev
	      calendar.monthsTranslate += 1;
	      if (!calendar.animating) { calendar.$months.eq(0).remove(); }
	      $wrapperEl.prepend(newMonthHTML);
	      calendar.$months = $wrapperEl.find('.calendar-month');
	      monthTranslate = -(prevTranslate + 1) * 100 * inverter;
	      calendar.$months
	        .eq(0)
	        .transform(("translate3d(" + (isH ? monthTranslate : 0) + "%, " + (isH ? 0 : monthTranslate) + "%, 0)"))
	        .addClass('calendar-month-prev');
	    }
	    calendar.emit(
	      'local::monthAdd calendarMonthAdd',
	      dir === 'next'
	        ? calendar.$months.eq(calendar.$months.length - 1)[0]
	        : calendar.$months.eq(0)[0]
	    );

	    calendar.animating = true;
	    calendar.onMonthChangeStart(dir);
	    var wrapperTranslate = (calendar.monthsTranslate * 100) * inverter;
	    $wrapperEl
	      .transition(transition)
	      .transform(("translate3d(" + (isH ? wrapperTranslate : 0) + "%, " + (isH ? 0 : wrapperTranslate) + "%, 0)"));
	    if (transitionEndCallback) {
	      $wrapperEl.transitionEnd(function () {
	        calendar.onMonthChangeEnd(dir, true);
	      });
	    }
	    if (!params.animate) {
	      calendar.onMonthChangeEnd(dir);
	    }
	  };

	  Calendar.prototype.nextYear = function nextYear () {
	    var calendar = this;
	    calendar.setYearMonth(calendar.currentYear + 1);
	  };

	  Calendar.prototype.prevYear = function prevYear () {
	    var calendar = this;
	    calendar.setYearMonth(calendar.currentYear - 1);
	  };
	  // eslint-disable-next-line
	  Calendar.prototype.dateInRange = function dateInRange (dayDate, range) {
	    var calendar = this;
	    var match = false;
	    var i;
	    if (!range) { return false; }
	    if (Array.isArray(range)) {
	      for (i = 0; i < range.length; i += 1) {
	        if (range[i].from || range[i].to) {
	          if (range[i].from && range[i].to) {
	            if ((dayDate <= new calendar.DateHandleClass(range[i].to).getTime()) && (dayDate >= new calendar.DateHandleClass(range[i].from).getTime())) {
	              match = true;
	            }
	          } else if (range[i].from) {
	            if (dayDate >= new calendar.DateHandleClass(range[i].from).getTime()) {
	              match = true;
	            }
	          } else if (range[i].to) {
	            if (dayDate <= new calendar.DateHandleClass(range[i].to).getTime()) {
	              match = true;
	            }
	          }
	        } else if (range[i].date) {
	          if (dayDate === new calendar.DateHandleClass(range[i].date).getTime()) {
	            match = true;
	          }
	        } else if (dayDate === new calendar.DateHandleClass(range[i]).getTime()) {
	          match = true;
	        }
	      }
	    } else if (range.from || range.to) {
	      if (range.from && range.to) {
	        if ((dayDate <= new calendar.DateHandleClass(range.to).getTime()) && (dayDate >= new calendar.DateHandleClass(range.from).getTime())) {
	          match = true;
	        }
	      } else if (range.from) {
	        if (dayDate >= new calendar.DateHandleClass(range.from).getTime()) {
	          match = true;
	        }
	      } else if (range.to) {
	        if (dayDate <= new calendar.DateHandleClass(range.to).getTime()) {
	          match = true;
	        }
	      }
	    } else if (range.date) {
	      match = dayDate === new calendar.DateHandleClass(range.date).getTime();
	    } else if (typeof range === 'function') {
	      match = range(new calendar.DateHandleClass(dayDate));
	    }
	    return match;
	  };
	  // eslint-disable-next-line
	  Calendar.prototype.daysInMonth = function daysInMonth (date) {
	    var calendar = this;
	    var d = new calendar.DateHandleClass(date);
	    return new calendar.DateHandleClass(d.getFullYear(), d.getMonth() + 1, 0).getDate();
	  };

	  Calendar.prototype.renderMonths = function renderMonths (date) {
	    var calendar = this;
	    if (calendar.params.renderMonths) {
	      return calendar.params.renderMonths.call(calendar, date);
	    }
	    return ("\n    <div class=\"calendar-months-wrapper\">\n    " + (calendar.renderMonth(date, 'prev')) + "\n    " + (calendar.renderMonth(date)) + "\n    " + (calendar.renderMonth(date, 'next')) + "\n    </div>\n  ").trim();
	  };

	  Calendar.prototype.renderMonth = function renderMonth (d, offset) {
	    var calendar = this;
	    var params = calendar.params;
	    var value = calendar.value;
	    if (params.renderMonth) {
	      return params.renderMonth.call(calendar, d, offset);
	    }
	    var date = new calendar.DateHandleClass(d);
	    var year = date.getFullYear();
	    var month = date.getMonth();

	    if (offset === 'next') {
	      if (month === 11) { date = new calendar.DateHandleClass(year + 1, 0); }
	      else { date = new calendar.DateHandleClass(year, month + 1, 1); }
	    }
	    if (offset === 'prev') {
	      if (month === 0) { date = new calendar.DateHandleClass(year - 1, 11); }
	      else { date = new calendar.DateHandleClass(year, month - 1, 1); }
	    }
	    if (offset === 'next' || offset === 'prev') {
	      month = date.getMonth();
	      year = date.getFullYear();
	    }

	    var currentValues = [];
	    var today = new calendar.DateHandleClass().setHours(0, 0, 0, 0);
	    var minDate = params.minDate ? new calendar.DateHandleClass(params.minDate).getTime() : null;
	    var maxDate = params.maxDate ? new calendar.DateHandleClass(params.maxDate).getTime() : null;
	    var rows = 6;
	    var cols = 7;
	    var daysInPrevMonth = calendar.daysInMonth(new calendar.DateHandleClass(date.getFullYear(), date.getMonth()).getTime() - (10 * 24 * 60 * 60 * 1000));
	    var daysInMonth = calendar.daysInMonth(date);
	    var minDayNumber = params.firstDay === 6 ? 0 : 1;

	    var monthHtml = '';
	    var dayIndex = 0 + (params.firstDay - 1);
	    var disabled;
	    var hasEvents;
	    var firstDayOfMonthIndex = new calendar.DateHandleClass(date.getFullYear(), date.getMonth()).getDay();
	    if (firstDayOfMonthIndex === 0) { firstDayOfMonthIndex = 7; }

	    if (value && value.length) {
	      for (var i = 0; i < value.length; i += 1) {
	        currentValues.push(new calendar.DateHandleClass(value[i]).setHours(0, 0, 0, 0));
	      }
	    }

	    for (var row = 1; row <= rows; row += 1) {
	      var rowHtml = '';
	      var loop = function ( col ) {
	        dayIndex += 1;
	        var dayDate = (void 0);
	        var dayNumber = dayIndex - firstDayOfMonthIndex;
	        var addClass = '';
	        if (row === 1 && col === 1 && dayNumber > minDayNumber && params.firstDay !== 1) {
	          dayIndex -= 7;
	          dayNumber = dayIndex - firstDayOfMonthIndex;
	        }

	        var weekDayIndex = ((col - 1) + params.firstDay > 6)
	          ? ((col - 1 - 7) + params.firstDay)
	          : ((col - 1) + params.firstDay);

	        if (dayNumber < 0) {
	          dayNumber = daysInPrevMonth + dayNumber + 1;
	          addClass += ' calendar-day-prev';
	          dayDate = new calendar.DateHandleClass(month - 1 < 0 ? year - 1 : year, month - 1 < 0 ? 11 : month - 1, dayNumber).getTime();
	        } else {
	          dayNumber += 1;
	          if (dayNumber > daysInMonth) {
	            dayNumber -= daysInMonth;
	            addClass += ' calendar-day-next';
	            dayDate = new calendar.DateHandleClass(month + 1 > 11 ? year + 1 : year, month + 1 > 11 ? 0 : month + 1, dayNumber).getTime();
	          } else {
	            dayDate = new calendar.DateHandleClass(year, month, dayNumber).getTime();
	          }
	        }
	        // Today
	        if (dayDate === today) { addClass += ' calendar-day-today'; }

	        // Selected
	        if (params.rangePicker && currentValues.length === 2) {
	          if (dayDate >= currentValues[0] && dayDate <= currentValues[1]) { addClass += ' calendar-day-selected'; }
	        } else if (currentValues.indexOf(dayDate) >= 0) { addClass += ' calendar-day-selected'; }
	        // Weekend
	        if (params.weekendDays.indexOf(weekDayIndex) >= 0) {
	          addClass += ' calendar-day-weekend';
	        }
	        // Events
	        var eventsHtml = '';
	        hasEvents = false;
	        if (params.events) {
	          if (calendar.dateInRange(dayDate, params.events)) {
	            hasEvents = true;
	          }
	        }
	        if (hasEvents) {
	          addClass += ' calendar-day-has-events';
	          eventsHtml = "\n            <span class=\"calendar-day-events\">\n              <span class=\"calendar-day-event\"></span>\n            </span>\n          ";
	          if (Array.isArray(params.events)) {
	            var eventDots = [];
	            params.events.forEach(function (ev) {
	              var color = ev.color || '';
	              if (eventDots.indexOf(color) < 0 && calendar.dateInRange(dayDate, ev)) {
	                eventDots.push(color);
	              }
	            });
	            eventsHtml = "\n              <span class=\"calendar-day-events\">\n                " + (eventDots.map(function (color) { return ("\n                  <span class=\"calendar-day-event\" style=\"" + (color ? ("background-color: " + color) : '') + "\"></span>\n                ").trim(); }).join('')) + "\n              </span>\n            ";
	          }
	        }
	        // Custom Ranges
	        if (params.rangesClasses) {
	          for (var k = 0; k < params.rangesClasses.length; k += 1) {
	            if (calendar.dateInRange(dayDate, params.rangesClasses[k].range)) {
	              addClass += " " + (params.rangesClasses[k].cssClass);
	            }
	          }
	        }
	        // Disabled
	        disabled = false;
	        if ((minDate && dayDate < minDate) || (maxDate && dayDate > maxDate)) {
	          disabled = true;
	        }
	        if (params.disabled) {
	          if (calendar.dateInRange(dayDate, params.disabled)) {
	            disabled = true;
	          }
	        }
	        if (disabled) {
	          addClass += ' calendar-day-disabled';
	        }

	        dayDate = new calendar.DateHandleClass(dayDate);
	        var dayYear = dayDate.getFullYear();
	        var dayMonth = dayDate.getMonth();
	        rowHtml += ("\n          <div data-year=\"" + dayYear + "\" data-month=\"" + dayMonth + "\" data-day=\"" + dayNumber + "\" class=\"calendar-day" + addClass + "\" data-date=\"" + dayYear + "-" + dayMonth + "-" + dayNumber + "\">\n            <span class=\"calendar-day-number\">" + dayNumber + eventsHtml + "</span>\n          </div>").trim();
	      };

	      for (var col = 1; col <= cols; col += 1) loop( col );
	      monthHtml += "<div class=\"calendar-row\">" + rowHtml + "</div>";
	    }
	    monthHtml = "<div class=\"calendar-month\" data-year=\"" + year + "\" data-month=\"" + month + "\">" + monthHtml + "</div>";
	    return monthHtml;
	  };

	  Calendar.prototype.renderWeekHeader = function renderWeekHeader () {
	    var calendar = this;
	    if (calendar.params.renderWeekHeader) {
	      return calendar.params.renderWeekHeader.call(calendar);
	    }
	    var params = calendar.params;
	    var weekDaysHtml = '';
	    for (var i = 0; i < 7; i += 1) {
	      var dayIndex = (i + params.firstDay > 6)
	        ? ((i - 7) + params.firstDay)
	        : (i + params.firstDay);
	      var dayName = params.dayNamesShort[dayIndex];
	      weekDaysHtml += "<div class=\"calendar-week-day\">" + dayName + "</div>";
	    }
	    return ("\n    <div class=\"calendar-week-header\">\n      " + weekDaysHtml + "\n    </div>\n  ").trim();
	  };

	  Calendar.prototype.renderMonthSelector = function renderMonthSelector () {
	    var calendar = this;
	    if (calendar.params.renderMonthSelector) {
	      return calendar.params.renderMonthSelector.call(calendar);
	    }

	    return "\n    <div class=\"calendar-month-selector\">\n      <a class=\"link icon-only calendar-prev-month-button\">\n        <i class=\"icon icon-prev\"></i>\n      </a>\n      <span class=\"current-month-value\"></span>\n      <a class=\"link icon-only calendar-next-month-button\">\n        <i class=\"icon icon-next\"></i>\n      </a>\n    </div>\n  ".trim();
	  };

	  Calendar.prototype.renderYearSelector = function renderYearSelector () {
	    var calendar = this;
	    if (calendar.params.renderYearSelector) {
	      return calendar.params.renderYearSelector.call(calendar);
	    }
	    return "\n    <div class=\"calendar-year-selector\">\n      <a class=\"link icon-only calendar-prev-year-button\">\n        <i class=\"icon icon-prev\"></i>\n      </a>\n      <span class=\"current-year-value\"></span>\n      <a class=\"link icon-only calendar-next-year-button\">\n        <i class=\"icon icon-next\"></i>\n      </a>\n    </div>\n  ".trim();
	  };

	  Calendar.prototype.renderHeader = function renderHeader () {
	    var calendar = this;
	    if (calendar.params.renderHeader) {
	      return calendar.params.renderHeader.call(calendar);
	    }
	    return ("\n    <div class=\"calendar-header\">\n      <div class=\"calendar-selected-date\">" + (calendar.params.headerPlaceholder) + "</div>\n    </div>\n  ").trim();
	  };

	  Calendar.prototype.renderFooter = function renderFooter () {
	    var calendar = this;
	    var app = calendar.app;
	    if (calendar.params.renderFooter) {
	      return calendar.params.renderFooter.call(calendar);
	    }
	    return ("\n    <div class=\"calendar-footer\">\n      <a class=\"" + (app.theme === 'md' ? 'button' : 'link') + " calendar-close sheet-close popover-close\">" + (calendar.params.toolbarCloseText) + "</a>\n    </div>\n  ").trim();
	  };

	  Calendar.prototype.renderToolbar = function renderToolbar () {
	    var calendar = this;
	    if (calendar.params.renderToolbar) {
	      return calendar.params.renderToolbar.call(calendar, calendar);
	    }
	    return ("\n    <div class=\"toolbar toolbar-top no-shadow\">\n      <div class=\"toolbar-inner\">\n        " + (calendar.params.monthSelector ? calendar.renderMonthSelector() : '') + "\n        " + (calendar.params.yearSelector ? calendar.renderYearSelector() : '') + "\n      </div>\n    </div>\n  ").trim();
	  };
	  // eslint-disable-next-line
	  Calendar.prototype.renderInline = function renderInline () {
	    var calendar = this;
	    var ref = calendar.params;
	    var cssClass = ref.cssClass;
	    var toolbar = ref.toolbar;
	    var header = ref.header;
	    var footer = ref.footer;
	    var rangePicker = ref.rangePicker;
	    var weekHeader = ref.weekHeader;
	    var value = calendar.value;
	    var date = value && value.length ? value[0] : new calendar.DateHandleClass().setHours(0, 0, 0);
	    var inlineHtml = ("\n    <div class=\"calendar calendar-inline " + (rangePicker ? 'calendar-range' : '') + " " + (cssClass || '') + "\">\n      " + (header ? calendar.renderHeader() : '') + "\n      " + (toolbar ? calendar.renderToolbar() : '') + "\n      " + (weekHeader ? calendar.renderWeekHeader() : '') + "\n      <div class=\"calendar-months\">\n        " + (calendar.renderMonths(date)) + "\n      </div>\n      " + (footer ? calendar.renderFooter() : '') + "\n    </div>\n  ").trim();

	    return inlineHtml;
	  };

	  Calendar.prototype.renderCustomModal = function renderCustomModal () {
	    var calendar = this;
	    var ref = calendar.params;
	    var cssClass = ref.cssClass;
	    var toolbar = ref.toolbar;
	    var header = ref.header;
	    var footer = ref.footer;
	    var rangePicker = ref.rangePicker;
	    var weekHeader = ref.weekHeader;
	    var value = calendar.value;
	    var date = value && value.length ? value[0] : new calendar.DateHandleClass().setHours(0, 0, 0);
	    var sheetHtml = ("\n    <div class=\"calendar calendar-modal " + (rangePicker ? 'calendar-range' : '') + " " + (cssClass || '') + "\">\n      " + (header ? calendar.renderHeader() : '') + "\n      " + (toolbar ? calendar.renderToolbar() : '') + "\n      " + (weekHeader ? calendar.renderWeekHeader() : '') + "\n      <div class=\"calendar-months\">\n        " + (calendar.renderMonths(date)) + "\n      </div>\n      " + (footer ? calendar.renderFooter() : '') + "\n    </div>\n  ").trim();

	    return sheetHtml;
	  };

	  Calendar.prototype.renderSheet = function renderSheet () {
	    var calendar = this;
	    var ref = calendar.params;
	    var cssClass = ref.cssClass;
	    var toolbar = ref.toolbar;
	    var header = ref.header;
	    var footer = ref.footer;
	    var rangePicker = ref.rangePicker;
	    var weekHeader = ref.weekHeader;
	    var value = calendar.value;
	    var date = value && value.length ? value[0] : new calendar.DateHandleClass().setHours(0, 0, 0);
	    var sheetHtml = ("\n    <div class=\"sheet-modal calendar calendar-sheet " + (rangePicker ? 'calendar-range' : '') + " " + (cssClass || '') + "\">\n      " + (header ? calendar.renderHeader() : '') + "\n      " + (toolbar ? calendar.renderToolbar() : '') + "\n      " + (weekHeader ? calendar.renderWeekHeader() : '') + "\n      <div class=\"sheet-modal-inner calendar-months\">\n        " + (calendar.renderMonths(date)) + "\n      </div>\n      " + (footer ? calendar.renderFooter() : '') + "\n    </div>\n  ").trim();

	    return sheetHtml;
	  };

	  Calendar.prototype.renderPopover = function renderPopover () {
	    var calendar = this;
	    var ref = calendar.params;
	    var cssClass = ref.cssClass;
	    var toolbar = ref.toolbar;
	    var header = ref.header;
	    var footer = ref.footer;
	    var rangePicker = ref.rangePicker;
	    var weekHeader = ref.weekHeader;
	    var value = calendar.value;
	    var date = value && value.length ? value[0] : new calendar.DateHandleClass().setHours(0, 0, 0);
	    var popoverHtml = ("\n    <div class=\"popover calendar-popover\">\n      <div class=\"popover-inner\">\n        <div class=\"calendar " + (rangePicker ? 'calendar-range' : '') + " " + (cssClass || '') + "\">\n        " + (header ? calendar.renderHeader() : '') + "\n        " + (toolbar ? calendar.renderToolbar() : '') + "\n        " + (weekHeader ? calendar.renderWeekHeader() : '') + "\n        <div class=\"calendar-months\">\n          " + (calendar.renderMonths(date)) + "\n        </div>\n        " + (footer ? calendar.renderFooter() : '') + "\n        </div>\n      </div>\n    </div>\n  ").trim();

	    return popoverHtml;
	  };

	  Calendar.prototype.render = function render () {
	    var calendar = this;
	    var params = calendar.params;
	    if (params.render) { return params.render.call(calendar); }
	    if (!calendar.inline) {
	      var modalType = params.openIn;
	      if (modalType === 'auto') { modalType = calendar.isPopover() ? 'popover' : 'sheet'; }

	      if (modalType === 'popover') { return calendar.renderPopover(); }
	      if (modalType === 'sheet') { return calendar.renderSheet(); }
	      return calendar.renderCustomModal();
	    }
	    return calendar.renderInline();
	  };

	  Calendar.prototype.onOpen = function onOpen () {
	    var calendar = this;
	    var initialized = calendar.initialized;
	    var $el = calendar.$el;
	    var app = calendar.app;
	    var $inputEl = calendar.$inputEl;
	    var inline = calendar.inline;
	    var value = calendar.value;
	    var params = calendar.params;
	    calendar.closing = false;
	    calendar.opened = true;
	    calendar.opening = true;

	    // Init main events
	    calendar.attachCalendarEvents();

	    var updateValue = !value && params.value;

	    // Set value
	    if (!initialized) {
	      if (value) { calendar.setValue(value, 0); }
	      else if (params.value) {
	        calendar.setValue(calendar.normalizeValues(params.value), 0);
	      }
	    } else if (value) {
	      calendar.setValue(value, 0);
	    }

	    // Update current month and year
	    calendar.updateCurrentMonthYear();

	    // Set initial translate
	    calendar.monthsTranslate = 0;
	    calendar.setMonthsTranslate();

	    // Update input value
	    if (updateValue) { calendar.updateValue(); }
	    else if (params.header && value) {
	      calendar.updateValue(true);
	    }

	    // Extra focus
	    if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
	      $inputEl.trigger('focus');
	    }

	    calendar.initialized = true;

	    calendar.$months.each(function (index, monthEl) {
	      calendar.emit('local::monthAdd calendarMonthAdd', monthEl);
	    });

	    // Trigger events
	    if ($el) {
	      $el.trigger('calendar:open', calendar);
	    }
	    if ($inputEl) {
	      $inputEl.trigger('calendar:open', calendar);
	    }
	    calendar.emit('local::open calendarOpen', calendar);
	  };

	  Calendar.prototype.onOpened = function onOpened () {
	    var calendar = this;
	    calendar.opening = false;
	    if (calendar.$el) {
	      calendar.$el.trigger('calendar:opened', calendar);
	    }
	    if (calendar.$inputEl) {
	      calendar.$inputEl.trigger('calendar:opened', calendar);
	    }
	    calendar.emit('local::opened calendarOpened', calendar);
	  };

	  Calendar.prototype.onClose = function onClose () {
	    var calendar = this;
	    var app = calendar.app;
	    calendar.opening = false;
	    calendar.closing = true;

	    if (calendar.$inputEl && app.theme === 'md') {
	      calendar.$inputEl.trigger('blur');
	    }
	    if (calendar.detachCalendarEvents) {
	      calendar.detachCalendarEvents();
	    }

	    if (calendar.$el) {
	      calendar.$el.trigger('calendar:close', calendar);
	    }
	    if (calendar.$inputEl) {
	      calendar.$inputEl.trigger('calendar:close', calendar);
	    }
	    calendar.emit('local::close calendarClose', calendar);
	  };

	  Calendar.prototype.onClosed = function onClosed () {
	    var calendar = this;
	    calendar.opened = false;
	    calendar.closing = false;

	    if (!calendar.inline) {
	      Utils.nextTick(function () {
	        if (calendar.modal && calendar.modal.el && calendar.modal.destroy) {
	          if (!calendar.params.routableModals) {
	            calendar.modal.destroy();
	          }
	        }
	        delete calendar.modal;
	      });
	    }
	    if (calendar.$el) {
	      calendar.$el.trigger('calendar:closed', calendar);
	    }
	    if (calendar.$inputEl) {
	      calendar.$inputEl.trigger('calendar:closed', calendar);
	    }
	    calendar.emit('local::closed calendarClosed', calendar);
	  };

	  Calendar.prototype.open = function open () {
	    var obj;

	    var calendar = this;
	    var app = calendar.app;
	    var opened = calendar.opened;
	    var inline = calendar.inline;
	    var $inputEl = calendar.$inputEl;
	    var params = calendar.params;
	    if (opened) { return; }

	    if (inline) {
	      calendar.$el = $(calendar.render());
	      calendar.$el[0].f7Calendar = calendar;
	      calendar.$wrapperEl = calendar.$el.find('.calendar-months-wrapper');
	      calendar.$months = calendar.$wrapperEl.find('.calendar-month');
	      calendar.$containerEl.append(calendar.$el);
	      calendar.onOpen();
	      calendar.onOpened();
	      return;
	    }
	    var modalType = params.openIn;
	    if (modalType === 'auto') {
	      modalType = calendar.isPopover() ? 'popover' : 'sheet';
	    }
	    var modalContent = calendar.render();

	    var modalParams = {
	      targetEl: $inputEl,
	      scrollToEl: calendar.params.scrollToInput ? $inputEl : undefined,
	      content: modalContent,
	      backdrop: calendar.params.backdrop === true || (modalType === 'popover' && app.params.popover.backdrop !== false && calendar.params.backdrop !== false),
	      closeByBackdropClick: calendar.params.closeByBackdropClick,
	      on: {
	        open: function open() {
	          var modal = this;
	          calendar.modal = modal;
	          calendar.$el = modalType === 'popover' ? modal.$el.find('.calendar') : modal.$el;
	          calendar.$wrapperEl = calendar.$el.find('.calendar-months-wrapper');
	          calendar.$months = calendar.$wrapperEl.find('.calendar-month');
	          calendar.$el[0].f7Calendar = calendar;
	          if (modalType === 'customModal') {
	            $(calendar.$el).find('.calendar-close').once('click', function () {
	              calendar.close();
	            });
	          }
	          calendar.onOpen();
	        },
	        opened: function opened() { calendar.onOpened(); },
	        close: function close() { calendar.onClose(); },
	        closed: function closed() { calendar.onClosed(); },
	      },
	    };
	    if (calendar.params.routableModals) {
	      calendar.view.router.navigate({
	        url: calendar.url,
	        route: ( obj = {
	          path: calendar.url
	        }, obj[modalType] = modalParams, obj ),
	      });
	    } else {
	      calendar.modal = app[modalType].create(modalParams);
	      calendar.modal.open();
	    }
	  };

	  Calendar.prototype.close = function close () {
	    var calendar = this;
	    var opened = calendar.opened;
	    var inline = calendar.inline;
	    if (!opened) { return; }
	    if (inline) {
	      calendar.onClose();
	      calendar.onClosed();
	      return;
	    }
	    if (calendar.params.routableModals) {
	      calendar.view.router.back();
	    } else {
	      calendar.modal.close();
	    }
	  };

	  Calendar.prototype.init = function init () {
	    var calendar = this;

	    calendar.initInput();

	    if (calendar.inline) {
	      calendar.open();
	      calendar.emit('local::init calendarInit', calendar);
	      return;
	    }

	    if (!calendar.initialized && calendar.params.value) {
	      calendar.setValue(calendar.normalizeValues(calendar.params.value));
	    }

	    // Attach input Events
	    if (calendar.$inputEl) {
	      calendar.attachInputEvents();
	    }
	    if (calendar.params.closeByOutsideClick) {
	      calendar.attachHtmlEvents();
	    }
	    calendar.emit('local::init calendarInit', calendar);
	  };

	  Calendar.prototype.destroy = function destroy () {
	    var calendar = this;
	    if (calendar.destroyed) { return; }
	    var $el = calendar.$el;
	    calendar.emit('local::beforeDestroy calendarBeforeDestroy', calendar);
	    if ($el) { $el.trigger('calendar:beforedestroy', calendar); }

	    calendar.close();

	    // Detach Events
	    if (calendar.$inputEl) {
	      calendar.detachInputEvents();
	    }
	    if (calendar.params.closeByOutsideClick) {
	      calendar.detachHtmlEvents();
	    }

	    if ($el && $el.length) { delete calendar.$el[0].f7Calendar; }
	    Utils.deleteProps(calendar);
	    calendar.destroyed = true;
	  };

	  return Calendar;
	}(Framework7Class));

	var Calendar$1 = {
	  name: 'calendar',
	  static: {
	    Calendar: Calendar,
	  },
	  create: function create() {
	    var app = this;
	    app.calendar = ConstructorMethods({
	      defaultSelector: '.calendar',
	      constructor: Calendar,
	      app: app,
	      domProp: 'f7Calendar',
	    });
	    app.calendar.close = function close(el) {
	      if ( el === void 0 ) el = '.calendar';

	      var $el = $(el);
	      if ($el.length === 0) { return; }
	      var calendar = $el[0].f7Calendar;
	      if (!calendar || (calendar && !calendar.opened)) { return; }
	      calendar.close();
	    };
	  },
	  params: {
	    calendar: {
	      // Calendar settings
	      calendarType: 'gregorian', // or 'jalali'
	      monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
	      monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
	      dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
	      dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
	      firstDay: 1, // First day of the week, Monday
	      weekendDays: [0, 6], // Sunday and Saturday
	      jalali: {
	        monthNames: ['فروردین', 'اردیبهشت', 'خرداد', 'تیر', 'مرداد', 'شهریور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'],
	        monthNamesShort: ['فَر', 'اُر', 'خُر', 'تیر', 'مُر', 'شَه', 'مهر', 'آب', 'آذر', 'دی', 'بَه', 'اِس'],
	        dayNames: ['یک‌شنبه', 'دوشنبه', 'سه‌شنبه', 'چهارشنبه', 'پنج‌شنبه', 'جمعه', 'شنبه'],
	        dayNamesShort: ['1ش', '۲ش', '۳ش', '۴ش', '۵ش', 'ج', 'ش'],
	        firstDay: 6, // Saturday
	        weekendDays: [5], // Friday
	      },
	      multiple: false,
	      rangePicker: false,
	      rangePickerMinDays: 1, // when calendar is used as rangePicker
	      rangePickerMaxDays: 0, // when calendar is used as rangePicker, 0 means unlimited
	      dateFormat: 'yyyy-mm-dd',
	      direction: 'horizontal', // or 'vertical'
	      minDate: null,
	      maxDate: null,
	      disabled: null, // dates range of disabled days
	      events: null, // dates range of days with events
	      rangesClasses: null, // array with custom classes date ranges
	      touchMove: true,
	      animate: true,
	      closeOnSelect: false,
	      monthSelector: true,
	      yearSelector: true,
	      weekHeader: true,
	      value: null,
	      // Common opener settings
	      containerEl: null,
	      openIn: 'auto', // or 'popover' or 'sheet' or 'customModal'
	      formatValue: null,
	      inputEl: null,
	      inputReadOnly: true,
	      closeByOutsideClick: true,
	      scrollToInput: true,
	      header: false,
	      headerPlaceholder: 'Select date',
	      footer: false,
	      toolbar: true,
	      toolbarCloseText: 'Done',
	      cssClass: null,
	      routableModals: true,
	      view: null,
	      url: 'date/',
	      backdrop: null,
	      closeByBackdropClick: true,
	      // Render functions
	      renderWeekHeader: null,
	      renderMonths: null,
	      renderMonth: null,
	      renderMonthSelector: null,
	      renderYearSelector: null,
	      renderHeader: null,
	      renderFooter: null,
	      renderToolbar: null,
	      renderInline: null,
	      renderPopover: null,
	      renderSheet: null,
	      render: null,
	    },
	  },
	};

	function pickerColumn (colEl, updateItems) {
	  var picker = this;
	  var app = picker.app;
	  var $colEl = $(colEl);
	  var colIndex = $colEl.index();
	  var col = picker.cols[colIndex];
	  if (col.divider) { return; }

	  col.$el = $colEl;
	  col.el = $colEl[0];
	  col.$itemsEl = col.$el.find('.picker-items');
	  col.items = col.$itemsEl.find('.picker-item');

	  var itemHeight;
	  var itemsHeight;
	  var minTranslate;
	  var maxTranslate;
	  var animationFrameId;

	  function updateDuringScroll() {
	    animationFrameId = Utils.requestAnimationFrame(function () {
	      col.updateItems(undefined, undefined, 0);
	      updateDuringScroll();
	    });
	  }

	  col.replaceValues = function replaceColValues(values, displayValues) {
	    col.detachEvents();
	    col.values = values;
	    col.displayValues = displayValues;
	    col.$itemsEl.html(picker.renderColumn(col, true));
	    col.items = col.$itemsEl.find('.picker-item');
	    col.calcSize();
	    col.setValue(col.values[0], 0, true);
	    col.attachEvents();
	  };
	  col.calcSize = function calcColSize() {
	    if (picker.params.rotateEffect) {
	      col.$el.removeClass('picker-column-absolute');
	      if (!col.width) { col.$el.css({ width: '' }); }
	    }
	    var colWidth = 0;
	    var colHeight = col.$el[0].offsetHeight;
	    itemHeight = col.items[0].offsetHeight;
	    itemsHeight = itemHeight * col.items.length;
	    minTranslate = ((colHeight / 2) - itemsHeight) + (itemHeight / 2);
	    maxTranslate = (colHeight / 2) - (itemHeight / 2);
	    if (col.width) {
	      colWidth = col.width;
	      if (parseInt(colWidth, 10) === colWidth) { colWidth += 'px'; }
	      col.$el.css({ width: colWidth });
	    }
	    if (picker.params.rotateEffect) {
	      if (!col.width) {
	        col.items.each(function (index, itemEl) {
	          var item = $(itemEl).children('span');
	          colWidth = Math.max(colWidth, item[0].offsetWidth);
	        });
	        col.$el.css({ width: ((colWidth + 2) + "px") });
	      }
	      col.$el.addClass('picker-column-absolute');
	    }
	  };

	  col.setValue = function setColValue(newValue, transition, valueCallbacks) {
	    if ( transition === void 0 ) transition = '';

	    var newActiveIndex = col.$itemsEl.find((".picker-item[data-picker-value=\"" + newValue + "\"]")).index();
	    if (typeof newActiveIndex === 'undefined' || newActiveIndex === -1) {
	      return;
	    }
	    var newTranslate = (-newActiveIndex * itemHeight) + maxTranslate;
	    // Update wrapper
	    col.$itemsEl.transition(transition);
	    col.$itemsEl.transform(("translate3d(0," + newTranslate + "px,0)"));

	    // Watch items
	    if (picker.params.updateValuesOnMomentum && col.activeIndex && col.activeIndex !== newActiveIndex) {
	      Utils.cancelAnimationFrame(animationFrameId);
	      col.$itemsEl.transitionEnd(function () {
	        Utils.cancelAnimationFrame(animationFrameId);
	      });
	      updateDuringScroll();
	    }

	    // Update items
	    col.updateItems(newActiveIndex, newTranslate, transition, valueCallbacks);
	  };

	  col.updateItems = function updateColItems(activeIndex, translate, transition, valueCallbacks) {
	    if (typeof translate === 'undefined') {
	      // eslint-disable-next-line
	      translate = Utils.getTranslate(col.$itemsEl[0], 'y');
	    }
	    // eslint-disable-next-line
	    if (typeof activeIndex === 'undefined') { activeIndex = -Math.round((translate - maxTranslate) / itemHeight); }
	    // eslint-disable-next-line
	    if (activeIndex < 0) { activeIndex = 0; }
	    // eslint-disable-next-line
	    if (activeIndex >= col.items.length) { activeIndex = col.items.length - 1; }
	    var previousActiveIndex = col.activeIndex;
	    col.activeIndex = activeIndex;
	    col.$itemsEl.find('.picker-item-selected').removeClass('picker-item-selected');

	    col.items.transition(transition);

	    var selectedItem = col.items.eq(activeIndex).addClass('picker-item-selected').transform('');

	    // Set 3D rotate effect
	    if (picker.params.rotateEffect) {
	      col.items.each(function (index, itemEl) {
	        var $itemEl = $(itemEl);
	        var itemOffsetTop = $itemEl.index() * itemHeight;
	        var translateOffset = maxTranslate - translate;
	        var itemOffset = itemOffsetTop - translateOffset;
	        var percentage = itemOffset / itemHeight;
	        var itemsFit = Math.ceil(col.height / itemHeight / 2) + 1;

	        var angle = (-18 * percentage);
	        if (angle > 180) { angle = 180; }
	        if (angle < -180) { angle = -180; }
	        if (Math.abs(percentage) > itemsFit) {
	          $itemEl.addClass('picker-item-far');
	        } else {
	          $itemEl.removeClass('picker-item-far');
	        }
	        $itemEl.transform(("translate3d(0, " + (-translate + maxTranslate) + "px, " + (picker.needsOriginFix ? -110 : 0) + "px) rotateX(" + angle + "deg)"));
	      });
	    }

	    if (valueCallbacks || typeof valueCallbacks === 'undefined') {
	      // Update values
	      col.value = selectedItem.attr('data-picker-value');
	      col.displayValue = col.displayValues ? col.displayValues[activeIndex] : col.value;
	      // On change callback
	      if (previousActiveIndex !== activeIndex) {
	        if (col.onChange) {
	          col.onChange(picker, col.value, col.displayValue);
	        }
	        picker.updateValue();
	      }
	    }
	  };

	  var allowItemClick = true;
	  var isTouched;
	  var isMoved;
	  var touchStartY;
	  var touchCurrentY;
	  var touchStartTime;
	  var touchEndTime;
	  var startTranslate;
	  var returnTo;
	  var currentTranslate;
	  var prevTranslate;
	  var velocityTranslate;
	  function handleTouchStart(e) {
	    if (isMoved || isTouched) { return; }
	    e.preventDefault();
	    isTouched = true;
	    touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	    touchCurrentY = touchStartY;
	    touchStartTime = (new Date()).getTime();

	    allowItemClick = true;
	    startTranslate = Utils.getTranslate(col.$itemsEl[0], 'y');
	    currentTranslate = startTranslate;
	  }
	  function handleTouchMove(e) {
	    if (!isTouched) { return; }
	    e.preventDefault();
	    allowItemClick = false;
	    touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	    if (!isMoved) {
	      // First move
	      Utils.cancelAnimationFrame(animationFrameId);
	      isMoved = true;
	      startTranslate = Utils.getTranslate(col.$itemsEl[0], 'y');
	      currentTranslate = startTranslate;
	      col.$itemsEl.transition(0);
	    }

	    var diff = touchCurrentY - touchStartY;
	    currentTranslate = startTranslate + diff;
	    returnTo = undefined;

	    // Normalize translate
	    if (currentTranslate < minTranslate) {
	      currentTranslate = minTranslate - (Math.pow( (minTranslate - currentTranslate), 0.8 ));
	      returnTo = 'min';
	    }
	    if (currentTranslate > maxTranslate) {
	      currentTranslate = maxTranslate + (Math.pow( (currentTranslate - maxTranslate), 0.8 ));
	      returnTo = 'max';
	    }
	    // Transform wrapper
	    col.$itemsEl.transform(("translate3d(0," + currentTranslate + "px,0)"));

	    // Update items
	    col.updateItems(undefined, currentTranslate, 0, picker.params.updateValuesOnTouchmove);

	    // Calc velocity
	    velocityTranslate = currentTranslate - prevTranslate || currentTranslate;
	    prevTranslate = currentTranslate;
	  }
	  function handleTouchEnd() {
	    if (!isTouched || !isMoved) {
	      isTouched = false;
	      isMoved = false;
	      return;
	    }
	    isTouched = false;
	    isMoved = false;
	    col.$itemsEl.transition('');
	    if (returnTo) {
	      if (returnTo === 'min') {
	        col.$itemsEl.transform(("translate3d(0," + minTranslate + "px,0)"));
	      } else {
	        col.$itemsEl.transform(("translate3d(0," + maxTranslate + "px,0)"));
	      }
	    }
	    touchEndTime = new Date().getTime();
	    var newTranslate;
	    if (touchEndTime - touchStartTime > 300) {
	      newTranslate = currentTranslate;
	    } else {
	      newTranslate = currentTranslate + (velocityTranslate * picker.params.momentumRatio);
	    }

	    newTranslate = Math.max(Math.min(newTranslate, maxTranslate), minTranslate);

	    // Active Index
	    var activeIndex = Math.round(Math.abs(((newTranslate - maxTranslate) / itemHeight)));

	    // Normalize translate
	    if (!picker.params.freeMode) { newTranslate = (-activeIndex * itemHeight) + maxTranslate; }

	    // Transform wrapper
	    col.$itemsEl.transform(("translate3d(0," + (parseInt(newTranslate, 10)) + "px,0)"));

	    // Update items
	    col.updateItems(activeIndex, newTranslate, '', true);

	    // Watch items
	    if (picker.params.updateValuesOnMomentum) {
	      updateDuringScroll();
	      col.$itemsEl.transitionEnd(function () {
	        Utils.cancelAnimationFrame(animationFrameId);
	      });
	    }

	    // Allow click
	    setTimeout(function () {
	      allowItemClick = true;
	    }, 100);
	  }

	  var mousewheelTimeout;
	  function handleMouseWheel(e) {
	    var deltaX = e.deltaX;
	    var deltaY = e.deltaY;
	    if (Math.abs(deltaX) > Math.abs(deltaY)) { return; }
	    clearTimeout(mousewheelTimeout);

	    e.preventDefault();

	    Utils.cancelAnimationFrame(animationFrameId);
	    startTranslate = Utils.getTranslate(col.$itemsEl[0], 'y');
	    col.$itemsEl.transition(0);

	    currentTranslate = startTranslate - deltaY;
	    returnTo = undefined;

	    // Normalize translate
	    if (currentTranslate < minTranslate) {
	      currentTranslate = minTranslate;
	      returnTo = 'min';
	    }
	    if (currentTranslate > maxTranslate) {
	      currentTranslate = maxTranslate;
	      returnTo = 'max';
	    }
	    // Transform wrapper
	    col.$itemsEl.transform(("translate3d(0," + currentTranslate + "px,0)"));

	    // Update items
	    col.updateItems(undefined, currentTranslate, 0, picker.params.updateValuesOnMousewheel);

	    // On end
	    mousewheelTimeout = setTimeout(function () {
	      col.$itemsEl.transition('');
	      if (returnTo) {
	        if (returnTo === 'min') {
	          col.$itemsEl.transform(("translate3d(0," + minTranslate + "px,0)"));
	        } else {
	          col.$itemsEl.transform(("translate3d(0," + maxTranslate + "px,0)"));
	        }
	      }
	      touchEndTime = new Date().getTime();
	      var newTranslate = currentTranslate;
	      newTranslate = Math.max(Math.min(newTranslate, maxTranslate), minTranslate);

	      // Active Index
	      var activeIndex = Math.round(Math.abs(((newTranslate - maxTranslate) / itemHeight)));

	      // Normalize translate
	      if (!picker.params.freeMode) { newTranslate = (-activeIndex * itemHeight) + maxTranslate; }

	      // Transform wrapper
	      col.$itemsEl.transform(("translate3d(0," + (parseInt(newTranslate, 10)) + "px,0)"));

	      // Update items
	      col.updateItems(activeIndex, newTranslate, '', true);
	    }, 200);
	  }

	  function handleClick() {
	    if (!allowItemClick) { return; }
	    Utils.cancelAnimationFrame(animationFrameId);
	    var value = $(this).attr('data-picker-value');
	    col.setValue(value);
	  }

	  var activeListener = app.support.passiveListener ? { passive: false, capture: false } : false;
	  col.attachEvents = function attachColEvents() {
	    col.$el.on(app.touchEvents.start, handleTouchStart, activeListener);
	    app.on('touchmove:active', handleTouchMove);
	    app.on('touchend:passive', handleTouchEnd);
	    if (picker.params.mousewheel) {
	      col.$el.on('wheel', handleMouseWheel);
	    }
	    col.items.on('click', handleClick);
	  };
	  col.detachEvents = function detachColEvents() {
	    col.$el.off(app.touchEvents.start, handleTouchStart, activeListener);
	    app.off('touchmove:active', handleTouchMove);
	    app.off('touchend:passive', handleTouchEnd);
	    if (picker.params.mousewheel) {
	      col.$el.off('wheel', handleMouseWheel);
	    }
	    col.items.off('click', handleClick);
	  };

	  col.init = function initCol() {
	    col.calcSize();
	    col.$itemsEl.transform(("translate3d(0," + maxTranslate + "px,0)")).transition(0);
	    if (colIndex === 0) { col.$el.addClass('picker-column-first'); }
	    if (colIndex === picker.cols.length - 1) { col.$el.addClass('picker-column-last'); }
	    // Update items on init
	    if (updateItems) { col.updateItems(0, maxTranslate, 0); }

	    col.attachEvents();
	  };

	  col.destroy = function destroyCol() {
	    col.detachEvents();
	  };

	  col.init();
	}

	var Picker = /*@__PURE__*/(function (Framework7Class) {
	  function Picker(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class.call(this, params, [app]);
	    var picker = this;
	    picker.params = Utils.extend({}, app.params.picker, params);

	    var $containerEl;
	    if (picker.params.containerEl) {
	      $containerEl = $(picker.params.containerEl);
	      if ($containerEl.length === 0) { return picker; }
	    }

	    var $inputEl;
	    if (picker.params.inputEl) {
	      $inputEl = $(picker.params.inputEl);
	    }

	    var view;
	    if ($inputEl) {
	      view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
	    }
	    if (!view) { view = app.views.main; }

	    Utils.extend(picker, {
	      app: app,
	      $containerEl: $containerEl,
	      containerEl: $containerEl && $containerEl[0],
	      inline: $containerEl && $containerEl.length > 0,
	      needsOriginFix: app.device.ios || ((win.navigator.userAgent.toLowerCase().indexOf('safari') >= 0 && win.navigator.userAgent.toLowerCase().indexOf('chrome') < 0) && !app.device.android),
	      cols: [],
	      $inputEl: $inputEl,
	      inputEl: $inputEl && $inputEl[0],
	      initialized: false,
	      opened: false,
	      url: picker.params.url,
	      view: view,
	    });

	    function onResize() {
	      picker.resizeCols();
	    }
	    function onInputClick() {
	      picker.open();
	    }
	    function onInputFocus(e) {
	      e.preventDefault();
	    }
	    function onHtmlClick(e) {
	      var $targetEl = $(e.target);
	      if (picker.isPopover()) { return; }
	      if (!picker.opened || picker.closing) { return; }
	      if ($targetEl.closest('[class*="backdrop"]').length) { return; }
	      if ($inputEl && $inputEl.length > 0) {
	        if ($targetEl[0] !== $inputEl[0] && $targetEl.closest('.sheet-modal').length === 0) {
	          picker.close();
	        }
	      } else if ($(e.target).closest('.sheet-modal').length === 0) {
	        picker.close();
	      }
	    }

	    // Events
	    Utils.extend(picker, {
	      attachResizeEvent: function attachResizeEvent() {
	        app.on('resize', onResize);
	      },
	      detachResizeEvent: function detachResizeEvent() {
	        app.off('resize', onResize);
	      },
	      attachInputEvents: function attachInputEvents() {
	        picker.$inputEl.on('click', onInputClick);
	        if (picker.params.inputReadOnly) {
	          picker.$inputEl.on('focus mousedown', onInputFocus);
	        }
	      },
	      detachInputEvents: function detachInputEvents() {
	        picker.$inputEl.off('click', onInputClick);
	        if (picker.params.inputReadOnly) {
	          picker.$inputEl.off('focus mousedown', onInputFocus);
	        }
	      },
	      attachHtmlEvents: function attachHtmlEvents() {
	        app.on('click', onHtmlClick);
	      },
	      detachHtmlEvents: function detachHtmlEvents() {
	        app.off('click', onHtmlClick);
	      },
	    });

	    picker.init();

	    return picker;
	  }

	  if ( Framework7Class ) Picker.__proto__ = Framework7Class;
	  Picker.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  Picker.prototype.constructor = Picker;

	  Picker.prototype.initInput = function initInput () {
	    var picker = this;
	    if (!picker.$inputEl) { return; }
	    if (picker.params.inputReadOnly) { picker.$inputEl.prop('readOnly', true); }
	  };

	  Picker.prototype.resizeCols = function resizeCols () {
	    var picker = this;
	    if (!picker.opened) { return; }
	    for (var i = 0; i < picker.cols.length; i += 1) {
	      if (!picker.cols[i].divider) {
	        picker.cols[i].calcSize();
	        picker.cols[i].setValue(picker.cols[i].value, 0, false);
	      }
	    }
	  };

	  Picker.prototype.isPopover = function isPopover () {
	    var picker = this;
	    var app = picker.app;
	    var modal = picker.modal;
	    var params = picker.params;
	    if (params.openIn === 'sheet') { return false; }
	    if (modal && modal.type !== 'popover') { return false; }

	    if (!picker.inline && picker.inputEl) {
	      if (params.openIn === 'popover') { return true; }
	      if (app.device.ios) {
	        return !!app.device.ipad;
	      }
	      if (app.width >= 768) {
	        return true;
	      }
	      if (app.device.desktop && app.theme === 'aurora') {
	        return true;
	      }
	    }
	    return false;
	  };

	  Picker.prototype.formatValue = function formatValue () {
	    var picker = this;
	    var value = picker.value;
	    var displayValue = picker.displayValue;
	    if (picker.params.formatValue) {
	      return picker.params.formatValue.call(picker, value, displayValue);
	    }
	    return value.join(' ');
	  };

	  Picker.prototype.setValue = function setValue (values, transition) {
	    var picker = this;
	    var valueIndex = 0;
	    if (picker.cols.length === 0) {
	      picker.value = values;
	      picker.updateValue(values);
	      return;
	    }
	    for (var i = 0; i < picker.cols.length; i += 1) {
	      if (picker.cols[i] && !picker.cols[i].divider) {
	        picker.cols[i].setValue(values[valueIndex], transition);
	        valueIndex += 1;
	      }
	    }
	  };

	  Picker.prototype.getValue = function getValue () {
	    var picker = this;
	    return picker.value;
	  };

	  Picker.prototype.updateValue = function updateValue (forceValues) {
	    var picker = this;
	    var newValue = forceValues || [];
	    var newDisplayValue = [];
	    var column;
	    if (picker.cols.length === 0) {
	      var noDividerColumns = picker.params.cols.filter(function (c) { return !c.divider; });
	      for (var i = 0; i < noDividerColumns.length; i += 1) {
	        column = noDividerColumns[i];
	        if (column.displayValues !== undefined && column.values !== undefined && column.values.indexOf(newValue[i]) !== -1) {
	          newDisplayValue.push(column.displayValues[column.values.indexOf(newValue[i])]);
	        } else {
	          newDisplayValue.push(newValue[i]);
	        }
	      }
	    } else {
	      for (var i$1 = 0; i$1 < picker.cols.length; i$1 += 1) {
	        if (!picker.cols[i$1].divider) {
	          newValue.push(picker.cols[i$1].value);
	          newDisplayValue.push(picker.cols[i$1].displayValue);
	        }
	      }
	    }

	    if (newValue.indexOf(undefined) >= 0) {
	      return;
	    }
	    picker.value = newValue;
	    picker.displayValue = newDisplayValue;
	    picker.emit('local::change pickerChange', picker, picker.value, picker.displayValue);
	    if (picker.inputEl) {
	      picker.$inputEl.val(picker.formatValue());
	      picker.$inputEl.trigger('change');
	    }
	  };

	  Picker.prototype.initColumn = function initColumn (colEl, updateItems) {
	    var picker = this;
	    pickerColumn.call(picker, colEl, updateItems);
	  };
	  // eslint-disable-next-line
	  Picker.prototype.destroyColumn = function destroyColumn (colEl) {
	    var picker = this;
	    var $colEl = $(colEl);
	    var index = $colEl.index();
	    if (picker.cols[index] && picker.cols[index].destroy) {
	      picker.cols[index].destroy();
	    }
	  };

	  Picker.prototype.renderToolbar = function renderToolbar () {
	    var picker = this;
	    if (picker.params.renderToolbar) { return picker.params.renderToolbar.call(picker, picker); }
	    return ("\n      <div class=\"toolbar toolbar-top no-shadow\">\n        <div class=\"toolbar-inner\">\n          <div class=\"left\"></div>\n          <div class=\"right\">\n            <a class=\"link sheet-close popover-close\">" + (picker.params.toolbarCloseText) + "</a>\n          </div>\n        </div>\n      </div>\n    ").trim();
	  };
	  // eslint-disable-next-line
	  Picker.prototype.renderColumn = function renderColumn (col, onlyItems) {
	    var colClasses = "picker-column " + (col.textAlign ? ("picker-column-" + (col.textAlign)) : '') + " " + (col.cssClass || '');
	    var columnHtml;
	    var columnItemsHtml;

	    if (col.divider) {
	      columnHtml = "\n        <div class=\"" + colClasses + " picker-column-divider\">" + (col.content) + "</div>\n      ";
	    } else {
	      columnItemsHtml = col.values.map(function (value, index) { return ("\n        <div class=\"picker-item\" data-picker-value=\"" + value + "\">\n          <span>" + (col.displayValues ? col.displayValues[index] : value) + "</span>\n        </div>\n      "); }).join('');
	      columnHtml = "\n        <div class=\"" + colClasses + "\">\n          <div class=\"picker-items\">" + columnItemsHtml + "</div>\n        </div>\n      ";
	    }

	    return onlyItems ? columnItemsHtml.trim() : columnHtml.trim();
	  };

	  Picker.prototype.renderInline = function renderInline () {
	    var picker = this;
	    var ref = picker.params;
	    var rotateEffect = ref.rotateEffect;
	    var cssClass = ref.cssClass;
	    var toolbar = ref.toolbar;
	    var inlineHtml = ("\n      <div class=\"picker picker-inline " + (rotateEffect ? 'picker-3d' : '') + " " + (cssClass || '') + "\">\n        " + (toolbar ? picker.renderToolbar() : '') + "\n        <div class=\"picker-columns\">\n          " + (picker.cols.map(function (col) { return picker.renderColumn(col); }).join('')) + "\n          <div class=\"picker-center-highlight\"></div>\n        </div>\n      </div>\n    ").trim();

	    return inlineHtml;
	  };

	  Picker.prototype.renderSheet = function renderSheet () {
	    var picker = this;
	    var ref = picker.params;
	    var rotateEffect = ref.rotateEffect;
	    var cssClass = ref.cssClass;
	    var toolbar = ref.toolbar;
	    var sheetHtml = ("\n      <div class=\"sheet-modal picker picker-sheet " + (rotateEffect ? 'picker-3d' : '') + " " + (cssClass || '') + "\">\n        " + (toolbar ? picker.renderToolbar() : '') + "\n        <div class=\"sheet-modal-inner picker-columns\">\n          " + (picker.cols.map(function (col) { return picker.renderColumn(col); }).join('')) + "\n          <div class=\"picker-center-highlight\"></div>\n        </div>\n      </div>\n    ").trim();

	    return sheetHtml;
	  };

	  Picker.prototype.renderPopover = function renderPopover () {
	    var picker = this;
	    var ref = picker.params;
	    var rotateEffect = ref.rotateEffect;
	    var cssClass = ref.cssClass;
	    var toolbar = ref.toolbar;
	    var popoverHtml = ("\n      <div class=\"popover picker-popover\">\n        <div class=\"popover-inner\">\n          <div class=\"picker " + (rotateEffect ? 'picker-3d' : '') + " " + (cssClass || '') + "\">\n            " + (toolbar ? picker.renderToolbar() : '') + "\n            <div class=\"picker-columns\">\n              " + (picker.cols.map(function (col) { return picker.renderColumn(col); }).join('')) + "\n              <div class=\"picker-center-highlight\"></div>\n            </div>\n          </div>\n        </div>\n      </div>\n    ").trim();

	    return popoverHtml;
	  };

	  Picker.prototype.render = function render () {
	    var picker = this;
	    if (picker.params.render) { return picker.params.render.call(picker); }
	    if (!picker.inline) {
	      if (picker.isPopover()) { return picker.renderPopover(); }
	      return picker.renderSheet();
	    }
	    return picker.renderInline();
	  };

	  Picker.prototype.onOpen = function onOpen () {
	    var picker = this;
	    var initialized = picker.initialized;
	    var $el = picker.$el;
	    var app = picker.app;
	    var $inputEl = picker.$inputEl;
	    var inline = picker.inline;
	    var value = picker.value;
	    var params = picker.params;
	    picker.opened = true;
	    picker.closing = false;
	    picker.opening = true;

	    // Init main events
	    picker.attachResizeEvent();

	    // Init cols
	    $el.find('.picker-column').each(function (index, colEl) {
	      var updateItems = true;
	      if (
	        (!initialized && params.value)
	        || (initialized && value)
	      ) {
	        updateItems = false;
	      }
	      picker.initColumn(colEl, updateItems);
	    });

	    // Set value
	    if (!initialized) {
	      if (value) { picker.setValue(value, 0); }
	      else if (params.value) {
	        picker.setValue(params.value, 0);
	      }
	    } else if (value) {
	      picker.setValue(value, 0);
	    }

	    // Extra focus
	    if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
	      $inputEl.trigger('focus');
	    }

	    picker.initialized = true;

	    // Trigger events
	    if ($el) {
	      $el.trigger('picker:open', picker);
	    }
	    if ($inputEl) {
	      $inputEl.trigger('picker:open', picker);
	    }
	    picker.emit('local::open pickerOpen', picker);
	  };

	  Picker.prototype.onOpened = function onOpened () {
	    var picker = this;
	    picker.opening = false;

	    if (picker.$el) {
	      picker.$el.trigger('picker:opened', picker);
	    }
	    if (picker.$inputEl) {
	      picker.$inputEl.trigger('picker:opened', picker);
	    }
	    picker.emit('local::opened pickerOpened', picker);
	  };

	  Picker.prototype.onClose = function onClose () {
	    var picker = this;
	    var app = picker.app;
	    picker.opening = false;
	    picker.closing = true;

	    // Detach events
	    picker.detachResizeEvent();

	    picker.cols.forEach(function (col) {
	      if (col.destroy) { col.destroy(); }
	    });
	    if (picker.$inputEl && app.theme === 'md') {
	      picker.$inputEl.trigger('blur');
	    }

	    if (picker.$el) {
	      picker.$el.trigger('picker:close', picker);
	    }
	    if (picker.$inputEl) {
	      picker.$inputEl.trigger('picker:close', picker);
	    }
	    picker.emit('local::close pickerClose', picker);
	  };

	  Picker.prototype.onClosed = function onClosed () {
	    var picker = this;
	    picker.opened = false;
	    picker.closing = false;

	    if (!picker.inline) {
	      Utils.nextTick(function () {
	        if (picker.modal && picker.modal.el && picker.modal.destroy) {
	          if (!picker.params.routableModals) {
	            picker.modal.destroy();
	          }
	        }
	        delete picker.modal;
	      });
	    }

	    if (picker.$el) {
	      picker.$el.trigger('picker:closed', picker);
	    }
	    if (picker.$inputEl) {
	      picker.$inputEl.trigger('picker:closed', picker);
	    }
	    picker.emit('local::closed pickerClosed', picker);
	  };

	  Picker.prototype.open = function open () {
	    var obj;

	    var picker = this;
	    var app = picker.app;
	    var opened = picker.opened;
	    var inline = picker.inline;
	    var $inputEl = picker.$inputEl;
	    if (opened) { return; }
	    if (picker.cols.length === 0 && picker.params.cols.length) {
	      picker.params.cols.forEach(function (col) {
	        picker.cols.push(col);
	      });
	    }
	    if (inline) {
	      picker.$el = $(picker.render());
	      picker.$el[0].f7Picker = picker;
	      picker.$containerEl.append(picker.$el);
	      picker.onOpen();
	      picker.onOpened();
	      return;
	    }
	    var isPopover = picker.isPopover();
	    var modalType = isPopover ? 'popover' : 'sheet';
	    var modalParams = {
	      targetEl: $inputEl,
	      scrollToEl: picker.params.scrollToInput ? $inputEl : undefined,
	      content: picker.render(),
	      backdrop: isPopover,
	      on: {
	        open: function open() {
	          var modal = this;
	          picker.modal = modal;
	          picker.$el = isPopover ? modal.$el.find('.picker') : modal.$el;
	          picker.$el[0].f7Picker = picker;
	          picker.onOpen();
	        },
	        opened: function opened() { picker.onOpened(); },
	        close: function close() { picker.onClose(); },
	        closed: function closed() { picker.onClosed(); },
	      },
	    };
	    if (picker.params.routableModals) {
	      picker.view.router.navigate({
	        url: picker.url,
	        route: ( obj = {
	          path: picker.url
	        }, obj[modalType] = modalParams, obj ),
	      });
	    } else {
	      picker.modal = app[modalType].create(modalParams);
	      picker.modal.open();
	    }
	  };

	  Picker.prototype.close = function close () {
	    var picker = this;
	    var opened = picker.opened;
	    var inline = picker.inline;
	    if (!opened) { return; }
	    if (inline) {
	      picker.onClose();
	      picker.onClosed();
	      return;
	    }
	    if (picker.params.routableModals) {
	      picker.view.router.back();
	    } else {
	      picker.modal.close();
	    }
	  };

	  Picker.prototype.init = function init () {
	    var picker = this;

	    picker.initInput();

	    if (picker.inline) {
	      picker.open();
	      picker.emit('local::init pickerInit', picker);
	      return;
	    }

	    if (!picker.initialized && picker.params.value) {
	      picker.setValue(picker.params.value);
	    }

	    // Attach input Events
	    if (picker.$inputEl) {
	      picker.attachInputEvents();
	    }
	    if (picker.params.closeByOutsideClick) {
	      picker.attachHtmlEvents();
	    }
	    picker.emit('local::init pickerInit', picker);
	  };

	  Picker.prototype.destroy = function destroy () {
	    var picker = this;
	    if (picker.destroyed) { return; }
	    var $el = picker.$el;
	    picker.emit('local::beforeDestroy pickerBeforeDestroy', picker);
	    if ($el) { $el.trigger('picker:beforedestroy', picker); }

	    picker.close();

	    // Detach Events
	    if (picker.$inputEl) {
	      picker.detachInputEvents();
	    }
	    if (picker.params.closeByOutsideClick) {
	      picker.detachHtmlEvents();
	    }

	    if ($el && $el.length) { delete picker.$el[0].f7Picker; }
	    Utils.deleteProps(picker);
	    picker.destroyed = true;
	  };

	  return Picker;
	}(Framework7Class));

	var Picker$1 = {
	  name: 'picker',
	  static: {
	    Picker: Picker,
	  },
	  create: function create() {
	    var app = this;
	    app.picker = ConstructorMethods({
	      defaultSelector: '.picker',
	      constructor: Picker,
	      app: app,
	      domProp: 'f7Picker',
	    });
	    app.picker.close = function close(el) {
	      if ( el === void 0 ) el = '.picker';

	      var $el = $(el);
	      if ($el.length === 0) { return; }
	      var picker = $el[0].f7Picker;
	      if (!picker || (picker && !picker.opened)) { return; }
	      picker.close();
	    };
	  },
	  params: {
	    picker: {
	      // Picker settings
	      updateValuesOnMomentum: false,
	      updateValuesOnTouchmove: true,
	      updateValuesOnMousewheel: true,
	      mousewheel: true,
	      rotateEffect: false,
	      momentumRatio: 7,
	      freeMode: false,
	      cols: [],
	      // Common opener settings
	      containerEl: null,
	      openIn: 'auto', // or 'popover' or 'sheet'
	      formatValue: null,
	      inputEl: null,
	      inputReadOnly: true,
	      closeByOutsideClick: true,
	      scrollToInput: true,
	      toolbar: true,
	      toolbarCloseText: 'Done',
	      cssClass: null,
	      routableModals: true,
	      view: null,
	      url: 'select/',
	      // Render functions
	      renderToolbar: null,
	      render: null,
	    },
	  },
	};

	var InfiniteScroll = {
	  handleScroll: function handleScroll(el, e) {
	    var app = this;
	    var $el = $(el);
	    var scrollTop = $el[0].scrollTop;
	    var scrollHeight = $el[0].scrollHeight;
	    var height = $el[0].offsetHeight;
	    var distance = $el[0].getAttribute('data-infinite-distance');

	    var virtualListContainer = $el.find('.virtual-list');
	    var virtualList;

	    var onTop = $el.hasClass('infinite-scroll-top');
	    if (!distance) { distance = 50; }
	    if (typeof distance === 'string' && distance.indexOf('%') >= 0) {
	      distance = (parseInt(distance, 10) / 100) * height;
	    }
	    if (distance > height) { distance = height; }
	    if (onTop) {
	      if (scrollTop < distance) {
	        $el.trigger('infinite', e);
	        app.emit('infinite', $el[0], e);
	      }
	    } else if (scrollTop + height >= scrollHeight - distance) {
	      if (virtualListContainer.length > 0) {
	        virtualList = virtualListContainer.eq(-1)[0].f7VirtualList;
	        if (virtualList && !virtualList.reachEnd && !virtualList.params.updatableScroll) {
	          return;
	        }
	      }
	      $el.trigger('infinite', e);
	      app.emit('infinite', $el[0], e);
	    }
	  },
	  create: function create(el) {
	    var $el = $(el);
	    var app = this;
	    $el.on('scroll', function handle(e) {
	      app.infiniteScroll.handle(this, e);
	    });
	  },
	  destroy: function destroy(el) {
	    var $el = $(el);
	    $el.off('scroll');
	  },
	};
	var InfiniteScroll$1 = {
	  name: 'infiniteScroll',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      infiniteScroll: {
	        handle: InfiniteScroll.handleScroll.bind(app),
	        create: InfiniteScroll.create.bind(app),
	        destroy: InfiniteScroll.destroy.bind(app),
	      },
	    });
	  },
	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      var $tabEl = $(tabEl);
	      $tabEl.find('.infinite-scroll-content').each(function (index, el) {
	        app.infiniteScroll.create(el);
	      });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var $tabEl = $(tabEl);
	      var app = this;
	      $tabEl.find('.infinite-scroll-content').each(function (index, el) {
	        app.infiniteScroll.destroy(el);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.infinite-scroll-content').each(function (index, el) {
	        app.infiniteScroll.create(el);
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.infinite-scroll-content').each(function (index, el) {
	        app.infiniteScroll.destroy(el);
	      });
	    },
	  },
	};

	var PullToRefresh = /*@__PURE__*/(function (Framework7Class) {
	  function PullToRefresh(app, el) {
	    Framework7Class.call(this, {}, [app]);
	    var ptr = this;
	    var $el = $(el);
	    var $preloaderEl = $el.find('.ptr-preloader');

	    ptr.$el = $el;
	    ptr.el = $el[0];
	    ptr.app = app;

	    ptr.bottom = ptr.$el.hasClass('ptr-bottom');

	    // Extend defaults with modules params
	    ptr.useModulesParams({});

	    var isMaterial = app.theme === 'md';
	    var isIos = app.theme === 'ios';
	    var isAurora = app.theme === 'aurora';

	    // Done
	    ptr.done = function done() {
	      var $transitionTarget = isMaterial ? $preloaderEl : $el;
	      $transitionTarget.transitionEnd(function () {
	        $el.removeClass('ptr-transitioning ptr-pull-up ptr-pull-down');
	        $el.trigger('ptr:done');
	        ptr.emit('local::done ptrDone', $el[0]);
	      });
	      $el.removeClass('ptr-refreshing').addClass('ptr-transitioning');
	      return ptr;
	    };

	    ptr.refresh = function refresh() {
	      if ($el.hasClass('ptr-refreshing')) { return ptr; }
	      $el.addClass('ptr-transitioning ptr-refreshing');
	      $el.trigger('ptr:refresh', ptr.done);
	      ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
	      return ptr;
	    };

	    // Mousewheel
	    ptr.mousewheel = $el.attr('data-ptr-mousewheel') === 'true';

	    // Events handling
	    var touchId;
	    var isTouched;
	    var isMoved;
	    var touchesStart = {};
	    var isScrolling;
	    var touchesDiff;
	    var refresh = false;
	    var useTranslate = false;
	    var forceUseTranslate = false;
	    var startTranslate = 0;
	    var translate;
	    var scrollTop;
	    var wasScrolled;
	    var triggerDistance;
	    var dynamicTriggerDistance;
	    var pullStarted;
	    var hasNavbar = false;
	    var scrollHeight;
	    var offsetHeight;
	    var maxScrollTop;
	    var $pageEl = $el.parents('.page');

	    if ($pageEl.find('.navbar').length > 0 || $pageEl.parents('.view').children('.navbar').length > 0) { hasNavbar = true; }
	    if ($pageEl.hasClass('no-navbar')) { hasNavbar = false; }
	    if (!hasNavbar && !ptr.bottom) { $el.addClass('ptr-no-navbar'); }

	    // Define trigger distance
	    if ($el.attr('data-ptr-distance')) {
	      dynamicTriggerDistance = true;
	    } else if (isMaterial) {
	      triggerDistance = 66;
	    } else if (isIos) {
	      triggerDistance = 44;
	    } else if (isAurora) {
	      triggerDistance = 38;
	    }

	    function handleTouchStart(e) {
	      if (isTouched) {
	        if (Device.os === 'android') {
	          if ('targetTouches' in e && e.targetTouches.length > 1) { return; }
	        } else { return; }
	      }

	      if ($el.hasClass('ptr-refreshing')) {
	        return;
	      }
	      if ($(e.target).closest('.sortable-handler, .ptr-ignore, .card-expandable.card-opened').length) { return; }

	      isMoved = false;
	      pullStarted = false;
	      isTouched = true;
	      isScrolling = undefined;
	      wasScrolled = undefined;
	      if (e.type === 'touchstart') { touchId = e.targetTouches[0].identifier; }
	      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	    }

	    function handleTouchMove(e) {
	      if (!isTouched) { return; }
	      var pageX;
	      var pageY;
	      var touch;
	      if (e.type === 'touchmove') {
	        if (touchId && e.touches) {
	          for (var i = 0; i < e.touches.length; i += 1) {
	            if (e.touches[i].identifier === touchId) {
	              touch = e.touches[i];
	            }
	          }
	        }
	        if (!touch) { touch = e.targetTouches[0]; }
	        pageX = touch.pageX;
	        pageY = touch.pageY;
	      } else {
	        pageX = e.pageX;
	        pageY = e.pageY;
	      }
	      if (!pageX || !pageY) { return; }


	      if (typeof isScrolling === 'undefined') {
	        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
	      }
	      if (!isScrolling) {
	        isTouched = false;
	        return;
	      }

	      scrollTop = $el[0].scrollTop;

	      if (!isMoved) {
	        $el.removeClass('ptr-transitioning');
	        var targetIsScrollable;
	        scrollHeight = $el[0].scrollHeight;
	        offsetHeight = $el[0].offsetHeight;
	        if (ptr.bottom) {
	          maxScrollTop = scrollHeight - offsetHeight;
	        }
	        if (scrollTop > scrollHeight) {
	          isTouched = false;
	          return;
	        }
	        var $ptrWatchScrollable = $(e.target).closest('.ptr-watch-scroll');
	        if ($ptrWatchScrollable.length) {
	          $ptrWatchScrollable.each(function (ptrScrollableIndex, ptrScrollableEl) {
	            if (ptrScrollableEl === el) { return; }
	            if (
	              (ptrScrollableEl.scrollHeight > ptrScrollableEl.offsetHeight)
	              && $(ptrScrollableEl).css('overflow') === 'auto'
	              && (
	                (!ptr.bottom && ptrScrollableEl.scrollTop > 0)
	                || (ptr.bottom && ptrScrollableEl.scrollTop < ptrScrollableEl.scrollHeight - ptrScrollableEl.offsetHeight)
	              )
	            ) {
	              targetIsScrollable = true;
	            }
	          });
	        }
	        if (targetIsScrollable) {
	          isTouched = false;
	          return;
	        }
	        if (dynamicTriggerDistance) {
	          triggerDistance = $el.attr('data-ptr-distance');
	          if (triggerDistance.indexOf('%') >= 0) { triggerDistance = (scrollHeight * parseInt(triggerDistance, 10)) / 100; }
	        }
	        startTranslate = $el.hasClass('ptr-refreshing') ? triggerDistance : 0;
	        if (scrollHeight === offsetHeight || Device.os !== 'ios' || isMaterial) {
	          useTranslate = true;
	        } else {
	          useTranslate = false;
	        }
	        forceUseTranslate = false;
	      }
	      isMoved = true;
	      touchesDiff = pageY - touchesStart.y;

	      if (typeof wasScrolled === 'undefined' && (ptr.bottom ? scrollTop !== maxScrollTop : scrollTop !== 0)) { wasScrolled = true; }

	      var ptrStarted = ptr.bottom
	        ? (touchesDiff < 0 && scrollTop >= maxScrollTop) || scrollTop > maxScrollTop
	        : (touchesDiff > 0 && scrollTop <= 0) || scrollTop < 0;

	      if (ptrStarted) {
	        // iOS 8 fix
	        if (Device.os === 'ios' && parseInt(Device.osVersion.split('.')[0], 10) > 7) {
	          if (!ptr.bottom && scrollTop === 0 && !wasScrolled) { useTranslate = true; }
	          if (ptr.bottom && scrollTop === maxScrollTop && !wasScrolled) { useTranslate = true; }
	        }

	        if (!useTranslate && ptr.bottom && !isMaterial) {
	          $el.css('-webkit-overflow-scrolling', 'auto');
	          $el.scrollTop(maxScrollTop);
	          forceUseTranslate = true;
	        }

	        if (useTranslate || forceUseTranslate) {
	          if (e.cancelable) {
	            e.preventDefault();
	          }
	          translate = (ptr.bottom ? -1 * (Math.pow( Math.abs(touchesDiff), 0.85 )) : Math.pow( touchesDiff, 0.85 )) + startTranslate;
	          if (isMaterial) {
	            $preloaderEl.transform(("translate3d(0," + translate + "px,0)"))
	              .find('.ptr-arrow').transform(("rotate(" + ((180 * (Math.abs(touchesDiff) / 66)) + 100) + "deg)"));
	          } else {
	            // eslint-disable-next-line
	            if (ptr.bottom) {
	              $el.children().transform(("translate3d(0," + translate + "px,0)"));
	            } else {
	              $el.transform(("translate3d(0," + translate + "px,0)"));
	            }
	          }
	        }

	        if (((useTranslate || forceUseTranslate) && (Math.pow( Math.abs(touchesDiff), 0.85 )) > triggerDistance) || (!useTranslate && Math.abs(touchesDiff) >= triggerDistance * 2)) {
	          refresh = true;
	          $el.addClass('ptr-pull-up').removeClass('ptr-pull-down');
	        } else {
	          refresh = false;
	          $el.removeClass('ptr-pull-up').addClass('ptr-pull-down');
	        }
	        if (!pullStarted) {
	          $el.trigger('ptr:pullstart');
	          ptr.emit('local::pullStart ptrPullStart', $el[0]);
	          pullStarted = true;
	        }
	        $el.trigger('ptr:pullmove', {
	          event: e,
	          scrollTop: scrollTop,
	          translate: translate,
	          touchesDiff: touchesDiff,
	        });
	        ptr.emit('local::pullMove ptrPullMove', $el[0], {
	          event: e,
	          scrollTop: scrollTop,
	          translate: translate,
	          touchesDiff: touchesDiff,
	        });
	      } else {
	        pullStarted = false;
	        $el.removeClass('ptr-pull-up ptr-pull-down');
	        refresh = false;
	      }
	    }
	    function handleTouchEnd(e) {
	      if (e.type === 'touchend' && e.changedTouches && e.changedTouches.length > 0 && touchId) {
	        if (e.changedTouches[0].identifier !== touchId) {
	          isTouched = false;
	          isScrolling = false;
	          isMoved = false;
	          touchId = null;
	          return;
	        }
	      }
	      if (!isTouched || !isMoved) {
	        isTouched = false;
	        isMoved = false;
	        return;
	      }
	      if (translate) {
	        $el.addClass('ptr-transitioning');
	        translate = 0;
	      }
	      if (isMaterial) {
	        $preloaderEl.transform('')
	          .find('.ptr-arrow').transform('');
	      } else {
	        // eslint-disable-next-line
	        if (ptr.bottom) {
	          $el.children().transform('');
	        } else {
	          $el.transform('');
	        }
	      }

	      if (!useTranslate && ptr.bottom && !isMaterial) {
	        $el.css('-webkit-overflow-scrolling', '');
	      }

	      if (refresh) {
	        $el.addClass('ptr-refreshing');
	        $el.trigger('ptr:refresh', ptr.done);
	        ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
	      } else {
	        $el.removeClass('ptr-pull-down');
	      }
	      isTouched = false;
	      isMoved = false;
	      if (pullStarted) {
	        $el.trigger('ptr:pullend');
	        ptr.emit('local::pullEnd ptrPullEnd', $el[0]);
	      }
	    }

	    var mousewheelTimeout;
	    var mousewheelMoved;
	    var mousewheelAllow = true;
	    var mousewheelTranslate = 0;

	    function handleMouseWheelRelease() {
	      mousewheelAllow = true;
	      mousewheelMoved = false;
	      mousewheelTranslate = 0;
	      if (translate) {
	        $el.addClass('ptr-transitioning');
	        translate = 0;
	      }
	      if (isMaterial) {
	        $preloaderEl.transform('')
	          .find('.ptr-arrow').transform('');
	      } else {
	        // eslint-disable-next-line
	        if (ptr.bottom) {
	          $el.children().transform('');
	        } else {
	          $el.transform('');
	        }
	      }

	      if (refresh) {
	        $el.addClass('ptr-refreshing');
	        $el.trigger('ptr:refresh', ptr.done);
	        ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
	      } else {
	        $el.removeClass('ptr-pull-down');
	      }
	      if (pullStarted) {
	        $el.trigger('ptr:pullend');
	        ptr.emit('local::pullEnd ptrPullEnd', $el[0]);
	      }
	    }
	    function handleMouseWheel(e) {
	      if (!mousewheelAllow) { return; }
	      var deltaX = e.deltaX;
	      var deltaY = e.deltaY;
	      if (Math.abs(deltaX) > Math.abs(deltaY)) { return; }
	      if ($el.hasClass('ptr-refreshing')) {
	        return;
	      }
	      if ($(e.target).closest('.sortable-handler, .ptr-ignore, .card-expandable.card-opened').length) { return; }

	      clearTimeout(mousewheelTimeout);

	      scrollTop = $el[0].scrollTop;

	      if (!mousewheelMoved) {
	        $el.removeClass('ptr-transitioning');
	        var targetIsScrollable;
	        scrollHeight = $el[0].scrollHeight;
	        offsetHeight = $el[0].offsetHeight;
	        if (ptr.bottom) {
	          maxScrollTop = scrollHeight - offsetHeight;
	        }
	        if (scrollTop > scrollHeight) {
	          mousewheelAllow = false;
	          return;
	        }
	        var $ptrWatchScrollable = $(e.target).closest('.ptr-watch-scroll');
	        if ($ptrWatchScrollable.length) {
	          $ptrWatchScrollable.each(function (ptrScrollableIndex, ptrScrollableEl) {
	            if (ptrScrollableEl === el) { return; }
	            if (
	              (ptrScrollableEl.scrollHeight > ptrScrollableEl.offsetHeight)
	              && $(ptrScrollableEl).css('overflow') === 'auto'
	              && (
	                (!ptr.bottom && ptrScrollableEl.scrollTop > 0)
	                || (ptr.bottom && ptrScrollableEl.scrollTop < ptrScrollableEl.scrollHeight - ptrScrollableEl.offsetHeight)
	              )
	            ) {
	              targetIsScrollable = true;
	            }
	          });
	        }
	        if (targetIsScrollable) {
	          mousewheelAllow = false;
	          return;
	        }
	        if (dynamicTriggerDistance) {
	          triggerDistance = $el.attr('data-ptr-distance');
	          if (triggerDistance.indexOf('%') >= 0) { triggerDistance = (scrollHeight * parseInt(triggerDistance, 10)) / 100; }
	        }
	      }
	      isMoved = true;
	      mousewheelTranslate -= deltaY;
	      touchesDiff = mousewheelTranslate; // pageY - touchesStart.y;

	      if (typeof wasScrolled === 'undefined' && (ptr.bottom ? scrollTop !== maxScrollTop : scrollTop !== 0)) { wasScrolled = true; }

	      var ptrStarted = ptr.bottom
	        ? (touchesDiff < 0 && scrollTop >= maxScrollTop) || scrollTop > maxScrollTop
	        : (touchesDiff > 0 && scrollTop <= 0) || scrollTop < 0;

	      if (ptrStarted) {
	        if (e.cancelable) {
	          e.preventDefault();
	        }

	        translate = touchesDiff;
	        if (Math.abs(translate) > triggerDistance) {
	          translate = triggerDistance + (Math.pow( (Math.abs(translate) - triggerDistance), 0.7 ));
	          if (ptr.bottom) { translate = -translate; }
	        }

	        if (isMaterial) {
	          $preloaderEl.transform(("translate3d(0," + translate + "px,0)"))
	            .find('.ptr-arrow').transform(("rotate(" + ((180 * (Math.abs(touchesDiff) / 66)) + 100) + "deg)"));
	        } else {
	          // eslint-disable-next-line
	          if (ptr.bottom) {
	            $el.children().transform(("translate3d(0," + translate + "px,0)"));
	          } else {
	            $el.transform(("translate3d(0," + translate + "px,0)"));
	          }
	        }

	        if (Math.abs(translate) > triggerDistance) {
	          refresh = true;
	          $el.addClass('ptr-pull-up').removeClass('ptr-pull-down');
	        } else {
	          refresh = false;
	          $el.removeClass('ptr-pull-up').addClass('ptr-pull-down');
	        }
	        if (!pullStarted) {
	          $el.trigger('ptr:pullstart');
	          ptr.emit('local::pullStart ptrPullStart', $el[0]);
	          pullStarted = true;
	        }
	        $el.trigger('ptr:pullmove', {
	          event: e,
	          scrollTop: scrollTop,
	          translate: translate,
	          touchesDiff: touchesDiff,
	        });
	        ptr.emit('local::pullMove ptrPullMove', $el[0], {
	          event: e,
	          scrollTop: scrollTop,
	          translate: translate,
	          touchesDiff: touchesDiff,
	        });
	      } else {
	        pullStarted = false;
	        $el.removeClass('ptr-pull-up ptr-pull-down');
	        refresh = false;
	      }

	      mousewheelTimeout = setTimeout(handleMouseWheelRelease, 300);
	    }

	    if (!$pageEl.length || !$el.length) { return ptr; }

	    $el[0].f7PullToRefresh = ptr;

	    // Events
	    ptr.attachEvents = function attachEvents() {
	      var passive = Support.passiveListener ? { passive: true } : false;
	      $el.on(app.touchEvents.start, handleTouchStart, passive);
	      app.on('touchmove:active', handleTouchMove);
	      app.on('touchend:passive', handleTouchEnd);
	      if (ptr.mousewheel && !ptr.bottom) {
	        $el.on('wheel', handleMouseWheel);
	      }
	    };
	    ptr.detachEvents = function detachEvents() {
	      var passive = Support.passiveListener ? { passive: true } : false;
	      $el.off(app.touchEvents.start, handleTouchStart, passive);
	      app.off('touchmove:active', handleTouchMove);
	      app.off('touchend:passive', handleTouchEnd);
	      if (ptr.mousewheel && !ptr.bottom) {
	        $el.off('wheel', handleMouseWheel);
	      }
	    };

	    // Install Modules
	    ptr.useModules();

	    // Init
	    ptr.init();

	    return ptr;
	  }

	  if ( Framework7Class ) PullToRefresh.__proto__ = Framework7Class;
	  PullToRefresh.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  PullToRefresh.prototype.constructor = PullToRefresh;

	  PullToRefresh.prototype.init = function init () {
	    var ptr = this;
	    ptr.attachEvents();
	  };

	  PullToRefresh.prototype.destroy = function destroy () {
	    var ptr = this;
	    ptr.emit('local::beforeDestroy ptrBeforeDestroy', ptr);
	    ptr.$el.trigger('ptr:beforedestroy', ptr);
	    delete ptr.el.f7PullToRefresh;
	    ptr.detachEvents();
	    Utils.deleteProps(ptr);
	    ptr = null;
	  };

	  return PullToRefresh;
	}(Framework7Class));

	var PullToRefresh$1 = {
	  name: 'pullToRefresh',
	  create: function create() {
	    var app = this;
	    app.ptr = Utils.extend(
	      ConstructorMethods({
	        defaultSelector: '.ptr-content',
	        constructor: PullToRefresh,
	        app: app,
	        domProp: 'f7PullToRefresh',
	      }),
	      {
	        done: function done(el) {
	          var ptr = app.ptr.get(el);
	          if (ptr) { return ptr.done(); }
	          return undefined;
	        },
	        refresh: function refresh(el) {
	          var ptr = app.ptr.get(el);
	          if (ptr) { return ptr.refresh(); }
	          return undefined;
	        },
	      }
	    );
	  },
	  static: {
	    PullToRefresh: PullToRefresh,
	  },
	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      var $tabEl = $(tabEl);
	      $tabEl.find('.ptr-content').each(function (index, el) {
	        app.ptr.create(el);
	      });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var $tabEl = $(tabEl);
	      var app = this;
	      $tabEl.find('.ptr-content').each(function (index, el) {
	        app.ptr.destroy(el);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.ptr-content').each(function (index, el) {
	        app.ptr.create(el);
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.ptr-content').each(function (index, el) {
	        app.ptr.destroy(el);
	      });
	    },
	  },
	};

	var Lazy = {
	  destroy: function destroy(pageEl) {
	    var $pageEl = $(pageEl).closest('.page');
	    if (!$pageEl.length) { return; }
	    if ($pageEl[0].f7LazyDestroy) {
	      $pageEl[0].f7LazyDestroy();
	    }
	  },
	  create: function create(pageEl) {
	    var app = this;
	    var $pageEl = $(pageEl).closest('.page').eq(0);

	    // Lazy images
	    var $lazyLoadImages = $pageEl.find('.lazy');
	    if ($lazyLoadImages.length === 0 && !$pageEl.hasClass('lazy')) { return; }

	    // Placeholder
	    var placeholderSrc = app.params.lazy.placeholder;

	    if (placeholderSrc !== false) {
	      $lazyLoadImages.each(function (index, lazyEl) {
	        if ($(lazyEl).attr('data-src') && !$(lazyEl).attr('src')) { $(lazyEl).attr('src', placeholderSrc); }
	      });
	    }

	    // load image
	    var imagesSequence = [];
	    var imageIsLoading = false;

	    function onImageComplete(lazyEl) {
	      if (imagesSequence.indexOf(lazyEl) >= 0) {
	        imagesSequence.splice(imagesSequence.indexOf(lazyEl), 1);
	      }
	      imageIsLoading = false;
	      if (app.params.lazy.sequential && imagesSequence.length > 0) {
	        imageIsLoading = true;
	        app.lazy.loadImage(imagesSequence[0], onImageComplete);
	      }
	    }

	    function observerCallback(entries, observer) {
	      entries.forEach(function (entry) {
	        if (entry.isIntersecting) {
	          if (app.params.lazy.sequential && imageIsLoading) {
	            if (imagesSequence.indexOf(entry.target) < 0) { imagesSequence.push(entry.target); }
	            return;
	          }
	          // Load image
	          imageIsLoading = true;
	          app.lazy.loadImage(entry.target, onImageComplete);
	          // Detach
	          observer.unobserve(entry.target);
	        }
	      });
	    }
	    if (app.params.lazy.observer && Support.intersectionObserver) {
	      var observer = $pageEl[0].f7LazyObserver;
	      if (!observer) {
	        observer = new win.IntersectionObserver(observerCallback, {
	          root: $pageEl[0],
	        });
	      }
	      $lazyLoadImages.each(function (index, el) {
	        if (el.f7LazyObserverAdded) { return; }
	        el.f7LazyObserverAdded = true;
	        observer.observe(el);
	      });
	      if (!$pageEl[0].f7LazyDestroy) {
	        $pageEl[0].f7LazyDestroy = function () {
	          observer.disconnect();
	          delete $pageEl[0].f7LazyDestroy;
	          delete $pageEl[0].f7LazyObserver;
	        };
	      }
	      return;
	    }

	    function lazyHandler() {
	      app.lazy.load($pageEl, function (lazyEl) {
	        if (app.params.lazy.sequential && imageIsLoading) {
	          if (imagesSequence.indexOf(lazyEl) < 0) { imagesSequence.push(lazyEl); }
	          return;
	        }
	        imageIsLoading = true;
	        app.lazy.loadImage(lazyEl, onImageComplete);
	      });
	    }

	    function attachEvents() {
	      $pageEl[0].f7LazyAttached = true;
	      $pageEl.on('lazy', lazyHandler);
	      $pageEl.on('scroll', lazyHandler, true);
	      $pageEl.find('.tab').on('tab:mounted tab:show', lazyHandler);
	      app.on('resize', lazyHandler);
	    }
	    function detachEvents() {
	      $pageEl[0].f7LazyAttached = false;
	      delete $pageEl[0].f7LazyAttached;
	      $pageEl.off('lazy', lazyHandler);
	      $pageEl.off('scroll', lazyHandler, true);
	      $pageEl.find('.tab').off('tab:mounted tab:show', lazyHandler);
	      app.off('resize', lazyHandler);
	    }

	    // Store detach function
	    if (!$pageEl[0].f7LazyDestroy) {
	      $pageEl[0].f7LazyDestroy = detachEvents;
	    }

	    // Attach events
	    if (!$pageEl[0].f7LazyAttached) {
	      attachEvents();
	    }

	    // Run loader on page load/init
	    lazyHandler();
	  },
	  isInViewport: function isInViewport(lazyEl) {
	    var app = this;
	    var rect = lazyEl.getBoundingClientRect();
	    var threshold = app.params.lazy.threshold || 0;

	    return (
	      rect.top >= (0 - threshold)
	      && rect.left >= (0 - threshold)
	      && rect.top <= (app.height + threshold)
	      && rect.left <= (app.width + threshold)
	    );
	  },
	  loadImage: function loadImage(imageEl, callback) {
	    var app = this;
	    var $imageEl = $(imageEl);

	    var bg = $imageEl.attr('data-background');
	    var src = bg || $imageEl.attr('data-src');
	    if (!src) { return; }
	    function onLoad() {
	      $imageEl.removeClass('lazy').addClass('lazy-loaded');
	      if (bg) {
	        $imageEl.css('background-image', ("url(" + src + ")"));
	      } else {
	        $imageEl.attr('src', src);
	      }
	      if (callback) { callback(imageEl); }
	      $imageEl.trigger('lazy:loaded');
	      app.emit('lazyLoaded', $imageEl[0]);
	    }

	    function onError() {
	      $imageEl.removeClass('lazy').addClass('lazy-loaded');
	      if (bg) {
	        $imageEl.css('background-image', ("url(" + (app.params.lazy.placeholder || '') + ")"));
	      } else {
	        $imageEl.attr('src', app.params.lazy.placeholder || '');
	      }
	      if (callback) { callback(imageEl); }
	      $imageEl.trigger('lazy:error');
	      app.emit('lazyError', $imageEl[0]);
	    }
	    var image = new win.Image();
	    image.onload = onLoad;
	    image.onerror = onError;
	    image.src = src;

	    $imageEl.removeAttr('data-src').removeAttr('data-background');

	    // Add loaded callback and events
	    $imageEl.trigger('lazy:load');
	    app.emit('lazyLoad', $imageEl[0]);
	  },
	  load: function load(pageEl, callback) {
	    var app = this;
	    var $pageEl = $(pageEl);
	    if (!$pageEl.hasClass('page')) { $pageEl = $pageEl.parents('.page').eq(0); }
	    if ($pageEl.length === 0) {
	      return;
	    }
	    $pageEl.find('.lazy').each(function (index, lazyEl) {
	      var $lazyEl = $(lazyEl);
	      if ($lazyEl.parents('.tab:not(.tab-active)').length > 0) {
	        return;
	      }
	      if (app.lazy.isInViewport(lazyEl)) {
	        if (callback) { callback(lazyEl); }
	        else { app.lazy.loadImage(lazyEl); }
	      }
	    });
	  },

	};
	var Lazy$1 = {
	  name: 'lazy',
	  params: {
	    lazy: {
	      placeholder: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEXCwsK592mkAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==',
	      threshold: 0,
	      sequential: true,
	      observer: true,
	    },
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      lazy: {
	        create: Lazy.create.bind(app),
	        destroy: Lazy.destroy.bind(app),
	        loadImage: Lazy.loadImage.bind(app),
	        load: Lazy.load.bind(app),
	        isInViewport: Lazy.isInViewport.bind(app),
	      },
	    });
	  },
	  on: {
	    pageInit: function pageInit(page) {
	      var app = this;
	      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
	        app.lazy.create(page.$el);
	      }
	    },
	    pageAfterIn: function pageAfterIn(page) {
	      var app = this;
	      if (app.params.lazy.observer && Support.intersectionObserver) { return; }
	      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
	        app.lazy.create(page.$el);
	      }
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
	        app.lazy.destroy(page.$el);
	      }
	    },
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      var $tabEl = $(tabEl);
	      if ($tabEl.find('.lazy').length > 0 || $tabEl.hasClass('lazy')) {
	        app.lazy.create($tabEl);
	      }
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var app = this;
	      if (app.params.lazy.observer && Support.intersectionObserver) { return; }
	      var $tabEl = $(tabEl);
	      if ($tabEl.find('.lazy').length > 0 || $tabEl.hasClass('lazy')) {
	        app.lazy.destroy($tabEl);
	      }
	    },
	  },
	};

	var DataTable = /*@__PURE__*/(function (Framework7Class) {
	  function DataTable(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class.call(this, params, [app]);

	    var table = this;

	    var defaults = {

	    };

	    // Extend defaults with modules params
	    table.useModulesParams(defaults);

	    table.params = Utils.extend(defaults, params);

	    // El
	    var $el = $(table.params.el);
	    if ($el.length === 0) { return undefined; }

	    table.$el = $el;
	    table.el = $el[0];

	    if (table.$el[0].f7DataTable) {
	      var instance = table.$el[0].f7DataTable;
	      table.destroy();
	      return instance;
	    }

	    table.$el[0].f7DataTable = table;

	    Utils.extend(table, {
	      collapsible: $el.hasClass('data-table-collapsible'),
	      // Headers
	      $headerEl: $el.find('.data-table-header'),
	      $headerSelectedEl: $el.find('.data-table-header-selected'),
	    });

	    // Events
	    function handleChange(e) {
	      if (e.detail && e.detail.sentByF7DataTable) {
	        // Scripted event, don't do anything
	        return;
	      }
	      var $inputEl = $(this);
	      var checked = $inputEl[0].checked;
	      var columnIndex = $inputEl.parents('td,th').index();

	      if ($inputEl.parents('thead').length > 0) {
	        if (columnIndex === 0) {
	          $el
	            .find('tbody tr')[checked ? 'addClass' : 'removeClass']('data-table-row-selected');
	        }
	        $el
	          .find(("tbody tr td:nth-child(" + (columnIndex + 1) + ") input"))
	          .prop('checked', checked)
	          .trigger('change', { sentByF7DataTable: true });
	        $inputEl.prop('indeterminate', false);
	      } else {
	        if (columnIndex === 0) {
	          $inputEl.parents('tr')[checked ? 'addClass' : 'removeClass']('data-table-row-selected');
	        }
	        var checkedRows = $el.find(("tbody .checkbox-cell:nth-child(" + (columnIndex + 1) + ") input[type=\"checkbox\"]:checked")).length;
	        var totalRows = $el.find('tbody tr').length;
	        var $headCheckboxEl = $el.find(("thead .checkbox-cell:nth-child(" + (columnIndex + 1) + ") input[type=\"checkbox\"]"));
	        if (!checked) {
	          $headCheckboxEl.prop('checked', false);
	        } else if (checkedRows === totalRows) {
	          $headCheckboxEl.prop('checked', true).trigger('change', { sentByF7DataTable: true });
	        }
	        $headCheckboxEl.prop('indeterminate', checkedRows > 0 && checkedRows < totalRows);
	      }
	      table.checkSelectedHeader();
	    }
	    function handleSortableClick() {
	      var $cellEl = $(this);
	      var isActive = $cellEl.hasClass('sortable-cell-active');
	      var currentSort = $cellEl.hasClass('sortable-desc') ? 'desc' : 'asc';
	      var newSort;
	      if (isActive) {
	        newSort = currentSort === 'desc' ? 'asc' : 'desc';
	        $cellEl.removeClass('sortable-desc sortable-asc').addClass(("sortable-" + newSort));
	      } else {
	        $el.find('thead .sortable-cell-active').removeClass('sortable-cell-active');
	        $cellEl.addClass('sortable-cell-active');
	        newSort = currentSort;
	      }
	      $cellEl.trigger('datatable:sort', newSort);
	      table.emit('local::sort dataTableSort', table, newSort);
	    }
	    table.attachEvents = function attachEvents() {
	      table.$el.on('change', '.checkbox-cell input[type="checkbox"]', handleChange);
	      table.$el.find('thead .sortable-cell').on('click', handleSortableClick);
	    };
	    table.detachEvents = function detachEvents() {
	      table.$el.off('change', '.checkbox-cell input[type="checkbox"]', handleChange);
	      table.$el.find('thead .sortable-cell').off('click', handleSortableClick);
	    };

	    // Install Modules
	    table.useModules();

	    // Init
	    table.init();

	    return table;
	  }

	  if ( Framework7Class ) DataTable.__proto__ = Framework7Class;
	  DataTable.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  DataTable.prototype.constructor = DataTable;

	  DataTable.prototype.setCollapsibleLabels = function setCollapsibleLabels () {
	    var table = this;
	    if (!table.collapsible) { return; }
	    table.$el.find('tbody td:not(.checkbox-cell)').each(function (index, el) {
	      var $el = $(el);
	      var elIndex = $el.index();
	      var collpsibleTitle = $el.attr('data-collapsible-title');
	      if (!collpsibleTitle && collpsibleTitle !== '') {
	        $el.attr('data-collapsible-title', table.$el.find('thead th').eq(elIndex).text());
	      }
	    });
	  };

	  DataTable.prototype.checkSelectedHeader = function checkSelectedHeader () {
	    var table = this;
	    if (table.$headerEl.length > 0 && table.$headerSelectedEl.length > 0) {
	      var checkedItems = table.$el.find('tbody .checkbox-cell input:checked').length;
	      table.$el[checkedItems > 0 ? 'addClass' : 'removeClass']('data-table-has-checked');
	      table.$headerSelectedEl.find('.data-table-selected-count').text(checkedItems);
	    }
	  };

	  DataTable.prototype.init = function init () {
	    var table = this;
	    table.attachEvents();
	    table.setCollapsibleLabels();
	    table.checkSelectedHeader();
	  };

	  DataTable.prototype.destroy = function destroy () {
	    var table = this;

	    table.$el.trigger('datatable:beforedestroy', table);
	    table.emit('local::beforeDestroy dataTableBeforeDestroy', table);

	    table.attachEvents();

	    if (table.$el[0]) {
	      table.$el[0].f7DataTable = null;
	      delete table.$el[0].f7DataTable;
	    }
	    Utils.deleteProps(table);
	    table = null;
	  };

	  return DataTable;
	}(Framework7Class));

	var DataTable$1 = {
	  name: 'dataTable',
	  static: {
	    DataTable: DataTable,
	  },
	  create: function create() {
	    var app = this;
	    app.dataTable = ConstructorMethods({
	      defaultSelector: '.data-table',
	      constructor: DataTable,
	      app: app,
	      domProp: 'f7DataTable',
	    });
	  },
	  on: {
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var app = this;
	      $(tabEl).find('.data-table-init').each(function (index, tableEl) {
	        app.dataTable.destroy(tableEl);
	      });
	    },
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $(tabEl).find('.data-table-init').each(function (index, tableEl) {
	        app.dataTable.create({ el: tableEl });
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.data-table-init').each(function (index, tableEl) {
	        app.dataTable.destroy(tableEl);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.data-table-init').each(function (index, tableEl) {
	        app.dataTable.create({ el: tableEl });
	      });
	    },
	  },
	  vnode: {
	    'data-table-init': {
	      insert: function insert(vnode) {
	        var app = this;
	        var tableEl = vnode.elm;
	        app.dataTable.create({ el: tableEl });
	      },
	      destroy: function destroy(vnode) {
	        var app = this;
	        var tableEl = vnode.elm;
	        app.dataTable.destroy(tableEl);
	      },
	    },
	  },
	};

	var Fab = {
	  morphOpen: function morphOpen(fabEl, targetEl) {
	    var app = this;
	    var $fabEl = $(fabEl);
	    var $targetEl = $(targetEl);
	    if ($targetEl.length === 0) { return; }

	    $targetEl.transition(0).addClass('fab-morph-target-visible');
	    var target = {
	      width: $targetEl[0].offsetWidth,
	      height: $targetEl[0].offsetHeight,
	      offset: $targetEl.offset(),
	      borderRadius: $targetEl.css('border-radius'),
	      zIndex: $targetEl.css('z-index'),
	    };
	    var fab = {
	      width: $fabEl[0].offsetWidth,
	      height: $fabEl[0].offsetHeight,
	      offset: $fabEl.offset(),
	      translateX: Utils.getTranslate($fabEl[0], 'x'),
	      translateY: Utils.getTranslate($fabEl[0], 'y'),
	    };

	    $fabEl[0].f7FabMorphData = {
	      $targetEl: $targetEl,
	      target: target,
	      fab: fab,
	    };

	    var diffX = (fab.offset.left + (fab.width / 2))
	                  - (target.offset.left + (target.width / 2))
	                  - fab.translateX;
	    var diffY = (fab.offset.top + (fab.height / 2))
	                  - (target.offset.top + (target.height / 2))
	                  - fab.translateY;
	    var scaleX = target.width / fab.width;
	    var scaleY = target.height / fab.height;

	    var borderRadius = Math.ceil(parseInt(target.borderRadius, 10) / Math.max(scaleX, scaleY));
	    if (borderRadius > 0) { borderRadius += 2; }

	    $fabEl[0].f7FabMorphResizeHandler = function resizeHandler() {
	      $fabEl.transition(0).transform('');
	      $targetEl.transition(0);
	      target.width = $targetEl[0].offsetWidth;
	      target.height = $targetEl[0].offsetHeight;
	      target.offset = $targetEl.offset();
	      fab.offset = $fabEl.offset();

	      var diffXNew = (fab.offset.left + (fab.width / 2))
	                      - (target.offset.left + (target.width / 2))
	                      - fab.translateX;
	      var diffYNew = (fab.offset.top + (fab.height / 2))
	                      - (target.offset.top + (target.height / 2))
	                      - fab.translateY;
	      var scaleXNew = target.width / fab.width;
	      var scaleYNew = target.height / fab.height;

	      $fabEl.transform(("translate3d(" + (-diffXNew) + "px, " + (-diffYNew) + "px, 0) scale(" + scaleXNew + ", " + scaleYNew + ")"));
	    };

	    $targetEl
	      .css('opacity', 0)
	      .transform(("scale(" + (1 / scaleX) + ", " + (1 / scaleY) + ")"));
	    $fabEl
	      .addClass('fab-opened')
	      .css('z-index', target.zIndex - 1)
	      .transform(("translate3d(" + (-diffX) + "px, " + (-diffY) + "px, 0)"));
	    $fabEl.transitionEnd(function () {
	      $targetEl.transition('');
	      Utils.nextFrame(function () {
	        $targetEl.css('opacity', 1).transform('scale(1,1)');
	        $fabEl
	          .transform(("translate3d(" + (-diffX) + "px, " + (-diffY) + "px, 0) scale(" + scaleX + ", " + scaleY + ")"))
	          .css('border-radius', (borderRadius + "px"))
	          .css('box-shadow', 'none');
	      });
	      app.on('resize', $fabEl[0].f7FabMorphResizeHandler);
	      if ($targetEl.parents('.page-content').length > 0) {
	        $targetEl.parents('.page-content').on('scroll', $fabEl[0].f7FabMorphResizeHandler);
	      }
	    });
	  },
	  morphClose: function morphClose(fabEl) {
	    var app = this;
	    var $fabEl = $(fabEl);
	    var morphData = $fabEl[0].f7FabMorphData;
	    if (!morphData) { return; }
	    var $targetEl = morphData.$targetEl;
	    var target = morphData.target;
	    var fab = morphData.fab;
	    if ($targetEl.length === 0) { return; }

	    var diffX = (fab.offset.left + (fab.width / 2))
	                  - (target.offset.left + (target.width / 2))
	                  - fab.translateX;
	    var diffY = (fab.offset.top + (fab.height / 2))
	                  - (target.offset.top + (target.height / 2))
	                  - fab.translateY;
	    var scaleX = target.width / fab.width;
	    var scaleY = target.height / fab.height;

	    app.off('resize', $fabEl[0].f7FabMorphResizeHandler);
	    if ($targetEl.parents('.page-content').length > 0) {
	      $targetEl.parents('.page-content').off('scroll', $fabEl[0].f7FabMorphResizeHandler);
	    }

	    $targetEl
	      .css('opacity', 0)
	      .transform(("scale(" + (1 / scaleX) + ", " + (1 / scaleY) + ")"));
	    $fabEl
	      .transition('')
	      .css('box-shadow', '')
	      .css('border-radius', '')
	      .transform(("translate3d(" + (-diffX) + "px, " + (-diffY) + "px, 0)"));
	    $fabEl.transitionEnd(function () {
	      $fabEl
	        .css('z-index', '')
	        .removeClass('fab-opened')
	        .transform('');
	      Utils.nextFrame(function () {
	        $fabEl.transitionEnd(function () {
	          $targetEl
	            .removeClass('fab-morph-target-visible')
	            .css('opacity', '')
	            .transform('')
	            .transition('');
	        });
	      });
	    });
	  },
	  open: function open(fabEl, targetEl) {
	    var app = this;
	    var $fabEl = $(fabEl).eq(0);
	    var $buttonsEl = $fabEl.find('.fab-buttons');
	    if (!$fabEl.length) { return; }
	    if ($fabEl.hasClass('fab-opened')) { return; }
	    if (!$buttonsEl.length && !$fabEl.hasClass('fab-morph')) { return; }

	    if (app.fab.openedEl) {
	      if (app.fab.openedEl === $fabEl[0]) { return; }
	      app.fab.close(app.fab.openedEl);
	    }
	    app.fab.openedEl = $fabEl[0];
	    if ($fabEl.hasClass('fab-morph')) {
	      app.fab.morphOpen($fabEl, targetEl || $fabEl.attr('data-morph-to'));
	    } else {
	      $fabEl.addClass('fab-opened');
	    }
	    $fabEl.trigger('fab:open');
	  },
	  close: function close(fabEl) {
	    if ( fabEl === void 0 ) fabEl = '.fab-opened';

	    var app = this;
	    var $fabEl = $(fabEl).eq(0);
	    var $buttonsEl = $fabEl.find('.fab-buttons');
	    if (!$fabEl.length) { return; }
	    if (!$fabEl.hasClass('fab-opened')) { return; }
	    if (!$buttonsEl.length && !$fabEl.hasClass('fab-morph')) { return; }
	    app.fab.openedEl = null;
	    if ($fabEl.hasClass('fab-morph')) {
	      app.fab.morphClose($fabEl);
	    } else {
	      $fabEl.removeClass('fab-opened');
	    }
	    $fabEl.trigger('fab:close');
	  },
	  toggle: function toggle(fabEl) {
	    var app = this;
	    var $fabEl = $(fabEl);
	    if (!$fabEl.hasClass('fab-opened')) { app.fab.open(fabEl); }
	    else { app.fab.close(fabEl); }
	  },
	};

	var Fab$1 = {
	  name: 'fab',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      fab: {
	        openedEl: null,
	        morphOpen: Fab.morphOpen.bind(app),
	        morphClose: Fab.morphClose.bind(app),
	        open: Fab.open.bind(app),
	        close: Fab.close.bind(app),
	        toggle: Fab.toggle.bind(app),
	      },
	    });
	  },
	  clicks: {
	    '.fab > a': function open($clickedEl) {
	      var app = this;
	      app.fab.toggle($clickedEl.parents('.fab'));
	    },
	    '.fab-open': function open($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.fab.open(data.fab);
	    },
	    '.fab-close': function close($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.fab.close(data.fab);
	    },
	  },
	};

	var Searchbar = /*@__PURE__*/(function (FrameworkClass) {
	  function Searchbar(app, params) {
	    if ( params === void 0 ) params = {};

	    FrameworkClass.call(this, params, [app]);

	    var sb = this;

	    var defaults = {
	      el: undefined,
	      inputEl: undefined,
	      inputEvents: 'change input compositionend',
	      disableButton: true,
	      disableButtonEl: undefined,
	      backdropEl: undefined,
	      searchContainer: undefined, // container to search, HTMLElement or CSS selector
	      searchItem: 'li', // single item selector, CSS selector
	      searchIn: undefined, // where to search in item, CSS selector
	      searchGroup: '.list-group',
	      searchGroupTitle: '.item-divider, .list-group-title',
	      ignore: '.searchbar-ignore',
	      foundEl: '.searchbar-found',
	      notFoundEl: '.searchbar-not-found',
	      hideOnEnableEl: '.searchbar-hide-on-enable',
	      hideOnSearchEl: '.searchbar-hide-on-search',
	      backdrop: undefined,
	      removeDiacritics: true,
	      customSearch: false,
	      hideDividers: true,
	      hideGroups: true,
	      disableOnBackdropClick: true,
	      expandable: false,
	      inline: false,
	    };

	    // Extend defaults with modules params
	    sb.useModulesParams(defaults);

	    sb.params = Utils.extend(defaults, params);

	    var $el = $(sb.params.el);
	    if ($el.length === 0) { return sb; }

	    if ($el[0].f7Searchbar) { return $el[0].f7Searchbar; }

	    $el[0].f7Searchbar = sb;

	    var $pageEl;
	    var $navbarEl = $el.parents('.navbar-inner');
	    if ($el.parents('.page').length > 0) {
	      $pageEl = $el.parents('.page');
	    } else if ($navbarEl.length > 0) {
	      $pageEl = $(app.navbar.getPageByEl($navbarEl[0]));
	      if (!$pageEl.length) {
	        var $currentPageEl = $el.parents('.view').find('.page-current');
	        if ($currentPageEl[0] && $currentPageEl[0].f7Page && $currentPageEl[0].f7Page.navbarEl === $navbarEl[0]) {
	          $pageEl = $currentPageEl;
	        }
	      }
	    }

	    var $foundEl;
	    if (params.foundEl) {
	      $foundEl = $(params.foundEl);
	    } else if (typeof sb.params.foundEl === 'string' && $pageEl) {
	      $foundEl = $pageEl.find(sb.params.foundEl);
	    }

	    var $notFoundEl;
	    if (params.notFoundEl) {
	      $notFoundEl = $(params.notFoundEl);
	    } else if (typeof sb.params.notFoundEl === 'string' && $pageEl) {
	      $notFoundEl = $pageEl.find(sb.params.notFoundEl);
	    }

	    var $hideOnEnableEl;
	    if (params.hideOnEnableEl) {
	      $hideOnEnableEl = $(params.hideOnEnableEl);
	    } else if (typeof sb.params.hideOnEnableEl === 'string' && $pageEl) {
	      $hideOnEnableEl = $pageEl.find(sb.params.hideOnEnableEl);
	    }

	    var $hideOnSearchEl;
	    if (params.hideOnSearchEl) {
	      $hideOnSearchEl = $(params.hideOnSearchEl);
	    } else if (typeof sb.params.hideOnSearchEl === 'string' && $pageEl) {
	      $hideOnSearchEl = $pageEl.find(sb.params.hideOnSearchEl);
	    }


	    var expandable = sb.params.expandable || $el.hasClass('searchbar-expandable');
	    var inline = sb.params.inline || $el.hasClass('searchbar-inline');

	    if (typeof sb.params.backdrop === 'undefined') {
	      if (!inline) { sb.params.backdrop = app.theme !== 'aurora'; }
	      else { sb.params.backdrop = false; }
	    }

	    var $backdropEl;
	    if (sb.params.backdrop) {
	      if (sb.params.backdropEl) {
	        $backdropEl = $(sb.params.backdropEl);
	      } else if ($pageEl && $pageEl.length > 0) {
	        $backdropEl = $pageEl.find('.searchbar-backdrop');
	      } else {
	        $backdropEl = $el.siblings('.searchbar-backdrop');
	      }
	      if ($backdropEl.length === 0) {
	        $backdropEl = $('<div class="searchbar-backdrop"></div>');
	        if ($pageEl && $pageEl.length) {
	          if ($el.parents($pageEl).length > 0 && $navbarEl && $el.parents($navbarEl).length === 0) {
	            $backdropEl.insertBefore($el);
	          } else {
	            $backdropEl.insertBefore($pageEl.find('.page-content').eq(0));
	          }
	        } else {
	          $backdropEl.insertBefore($el);
	        }
	      }
	    }

	    var $searchContainer;
	    if (sb.params.searchContainer) {
	      $searchContainer = $(sb.params.searchContainer);
	    }

	    var $inputEl;
	    if (sb.params.inputEl) {
	      $inputEl = $(sb.params.inputEl);
	    } else {
	      $inputEl = $el.find('input[type="search"]').eq(0);
	    }

	    var $disableButtonEl;
	    if (sb.params.disableButton) {
	      if (sb.params.disableButtonEl) {
	        $disableButtonEl = $(sb.params.disableButtonEl);
	      } else {
	        $disableButtonEl = $el.find('.searchbar-disable-button');
	      }
	    }

	    Utils.extend(sb, {
	      app: app,
	      view: app.views.get($el.parents('.view')),
	      $el: $el,
	      el: $el[0],
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl && $backdropEl[0],
	      $searchContainer: $searchContainer,
	      searchContainer: $searchContainer && $searchContainer[0],
	      $inputEl: $inputEl,
	      inputEl: $inputEl[0],
	      $disableButtonEl: $disableButtonEl,
	      disableButtonEl: $disableButtonEl && $disableButtonEl[0],
	      disableButtonHasMargin: false,
	      $pageEl: $pageEl,
	      pageEl: $pageEl && $pageEl[0],
	      $navbarEl: $navbarEl,
	      navbarEl: $navbarEl && $navbarEl[0],
	      $foundEl: $foundEl,
	      foundEl: $foundEl && $foundEl[0],
	      $notFoundEl: $notFoundEl,
	      notFoundEl: $notFoundEl && $notFoundEl[0],
	      $hideOnEnableEl: $hideOnEnableEl,
	      hideOnEnableEl: $hideOnEnableEl && $hideOnEnableEl[0],
	      $hideOnSearchEl: $hideOnSearchEl,
	      hideOnSearchEl: $hideOnSearchEl && $hideOnSearchEl[0],
	      previousQuery: '',
	      query: '',
	      isVirtualList: $searchContainer && $searchContainer.hasClass('virtual-list'),
	      virtualList: undefined,
	      enabled: false,
	      expandable: expandable,
	      inline: inline,
	    });

	    // Events
	    function preventSubmit(e) {
	      e.preventDefault();
	    }
	    function onInputFocus(e) {
	      sb.enable(e);
	      sb.$el.addClass('searchbar-focused');
	    }
	    function onInputBlur() {
	      sb.$el.removeClass('searchbar-focused');
	      if (app.theme === 'aurora' && (!$disableButtonEl || !$disableButtonEl.length || !sb.params.disableButton) && !sb.query) {
	        sb.disable();
	      }
	    }
	    function onInputChange() {
	      var value = sb.$inputEl.val().trim();
	      if (
	        (
	          (sb.$searchContainer && sb.$searchContainer.length > 0)
	          && (sb.params.searchIn || sb.isVirtualList || sb.params.searchIn === sb.params.searchItem)
	        )
	        || sb.params.customSearch
	      ) {
	        sb.search(value, true);
	      }
	    }
	    function onInputClear(e, previousValue) {
	      sb.$el.trigger('searchbar:clear', previousValue);
	      sb.emit('local::clear searchbarClear', sb, previousValue);
	    }
	    function disableOnClick(e) {
	      sb.disable(e);
	    }
	    function onPageBeforeOut() {
	      if (!sb || (sb && !sb.$el)) { return; }
	      if (sb.enabled) {
	        sb.$el.removeClass('searchbar-enabled');
	        if (sb.expandable) {
	          sb.$el.parents('.navbar-inner').removeClass('with-searchbar-expandable-enabled');
	        }
	      }
	    }
	    function onPageBeforeIn() {
	      if (!sb || (sb && !sb.$el)) { return; }
	      if (sb.enabled) {
	        sb.$el.addClass('searchbar-enabled');
	        if (sb.expandable) {
	          sb.$el.parents('.navbar-inner').addClass('with-searchbar-expandable-enabled');
	        }
	      }
	    }
	    sb.attachEvents = function attachEvents() {
	      $el.on('submit', preventSubmit);
	      if (sb.params.disableButton) {
	        sb.$disableButtonEl.on('click', disableOnClick);
	      }
	      if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
	        sb.$backdropEl.on('click', disableOnClick);
	      }
	      if (sb.expandable && app.theme === 'ios' && sb.view && $navbarEl.length && sb.$pageEl) {
	        sb.$pageEl.on('page:beforeout', onPageBeforeOut);
	        sb.$pageEl.on('page:beforein', onPageBeforeIn);
	      }
	      sb.$inputEl.on('focus', onInputFocus);
	      sb.$inputEl.on('blur', onInputBlur);
	      sb.$inputEl.on(sb.params.inputEvents, onInputChange);
	      sb.$inputEl.on('input:clear', onInputClear);
	    };
	    sb.detachEvents = function detachEvents() {
	      $el.off('submit', preventSubmit);
	      if (sb.params.disableButton) {
	        sb.$disableButtonEl.off('click', disableOnClick);
	      }
	      if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
	        sb.$backdropEl.off('click', disableOnClick);
	      }
	      if (sb.expandable && app.theme === 'ios' && sb.view && $navbarEl.length && sb.$pageEl) {
	        sb.$pageEl.off('page:beforeout', onPageBeforeOut);
	        sb.$pageEl.off('page:beforein', onPageBeforeIn);
	      }
	      sb.$inputEl.off('focus', onInputFocus);
	      sb.$inputEl.off('blur', onInputBlur);
	      sb.$inputEl.off(sb.params.inputEvents, onInputChange);
	      sb.$inputEl.off('input:clear', onInputClear);
	    };

	    // Install Modules
	    sb.useModules();

	    // Init
	    sb.init();

	    return sb;
	  }

	  if ( FrameworkClass ) Searchbar.__proto__ = FrameworkClass;
	  Searchbar.prototype = Object.create( FrameworkClass && FrameworkClass.prototype );
	  Searchbar.prototype.constructor = Searchbar;

	  Searchbar.prototype.clear = function clear (e) {
	    var sb = this;
	    if (!sb.query && e && $(e.target).hasClass('searchbar-clear')) {
	      sb.disable();
	      return sb;
	    }
	    var previousQuery = sb.value;
	    sb.$inputEl.val('').trigger('change').focus();
	    sb.$el.trigger('searchbar:clear', previousQuery);
	    sb.emit('local::clear searchbarClear', sb, previousQuery);
	    return sb;
	  };

	  Searchbar.prototype.setDisableButtonMargin = function setDisableButtonMargin () {
	    var sb = this;
	    if (sb.expandable) { return; }
	    var app = sb.app;
	    sb.$disableButtonEl.transition(0).show();
	    sb.$disableButtonEl.css(("margin-" + (app.rtl ? 'left' : 'right')), ((-sb.disableButtonEl.offsetWidth) + "px"));
	    /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
	    sb._clientLeft = sb.$disableButtonEl[0].clientLeft;
	    sb.$disableButtonEl.transition('');
	    sb.disableButtonHasMargin = true;
	  };

	  Searchbar.prototype.enable = function enable (setFocus) {
	    var sb = this;
	    if (sb.enabled) { return sb; }
	    var app = sb.app;
	    sb.enabled = true;
	    function enable() {
	      if (sb.$backdropEl && ((sb.$searchContainer && sb.$searchContainer.length) || sb.params.customSearch) && !sb.$el.hasClass('searchbar-enabled') && !sb.query) {
	        sb.backdropShow();
	      }
	      sb.$el.addClass('searchbar-enabled');
	      if (!sb.$disableButtonEl || (sb.$disableButtonEl && sb.$disableButtonEl.length === 0)) {
	        sb.$el.addClass('searchbar-enabled-no-disable-button');
	      }
	      if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme !== 'md') {
	        if (!sb.disableButtonHasMargin) {
	          sb.setDisableButtonMargin();
	        }
	        sb.$disableButtonEl.css(("margin-" + (app.rtl ? 'left' : 'right')), '0px');
	      }
	      if (sb.expandable) {
	        if (sb.$el.parents('.navbar-inner').hasClass('navbar-inner-large') && sb.$pageEl) {
	          sb.$pageEl.find('.page-content').addClass('with-searchbar-expandable-enabled');
	        }
	        if (app.theme === 'md' && sb.$el.parent('.navbar-inner').parent('.navbar').length) {
	          sb.$el.parent('.navbar-inner').parent('.navbar').addClass('with-searchbar-expandable-enabled');
	        } else {
	          sb.$el.parent('.navbar-inner').addClass('with-searchbar-expandable-enabled');
	          sb.$el.parent('.navbar-inner-large').addClass('navbar-inner-large-collapsed');
	        }
	      }
	      if (sb.$hideOnEnableEl) { sb.$hideOnEnableEl.addClass('hidden-by-searchbar'); }
	      sb.$el.trigger('searchbar:enable');
	      sb.emit('local::enable searchbarEnable', sb);
	    }
	    var needsFocus = false;
	    if (setFocus === true) {
	      if (doc.activeElement !== sb.inputEl) {
	        needsFocus = true;
	      }
	    }
	    var isIos = app.device.ios && app.theme === 'ios';
	    if (isIos) {
	      if (sb.expandable) {
	        if (needsFocus) { sb.$inputEl.focus(); }
	        enable();
	      } else {
	        if (needsFocus) { sb.$inputEl.focus(); }
	        if (setFocus && (setFocus.type === 'focus' || setFocus === true)) {
	          Utils.nextTick(function () {
	            enable();
	          }, 400);
	        } else {
	          enable();
	        }
	      }
	    } else {
	      if (needsFocus) { sb.$inputEl.focus(); }
	      if (app.theme === 'md' && sb.expandable) {
	        sb.$el.parents('.page, .view, .navbar-inner').scrollLeft(0);
	      }
	      enable();
	    }
	    return sb;
	  };

	  Searchbar.prototype.disable = function disable () {
	    var sb = this;
	    if (!sb.enabled) { return sb; }
	    var app = sb.app;
	    sb.$inputEl.val('').trigger('change');
	    sb.$el.removeClass('searchbar-enabled searchbar-focused searchbar-enabled-no-disable-button');
	    if (sb.expandable) {
	      if (sb.$el.parents('.navbar-inner').hasClass('navbar-inner-large') && sb.$pageEl) {
	        sb.$pageEl.find('.page-content').removeClass('with-searchbar-expandable-enabled');
	      }
	      if (app.theme === 'md' && sb.$el.parent('.navbar-inner').parent('.navbar').length) {
	        sb.$el.parent('.navbar-inner').parent('.navbar').removeClass('with-searchbar-expandable-enabled');
	      } else {
	        sb.$el.parent('.navbar-inner').removeClass('with-searchbar-expandable-enabled');
	        if (sb.$pageEl) {
	          sb.$pageEl.find('.page-content').trigger('scroll');
	        }
	      }
	    }
	    if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme !== 'md') {
	      sb.$disableButtonEl.css(("margin-" + (app.rtl ? 'left' : 'right')), ((-sb.disableButtonEl.offsetWidth) + "px"));
	    }
	    if (sb.$backdropEl && ((sb.$searchContainer && sb.$searchContainer.length) || sb.params.customSearch)) {
	      sb.backdropHide();
	    }

	    sb.enabled = false;

	    sb.$inputEl.blur();

	    if (sb.$hideOnEnableEl) { sb.$hideOnEnableEl.removeClass('hidden-by-searchbar'); }

	    sb.$el.trigger('searchbar:disable');
	    sb.emit('local::disable searchbarDisable', sb);
	    return sb;
	  };

	  Searchbar.prototype.toggle = function toggle () {
	    var sb = this;
	    if (sb.enabled) { sb.disable(); }
	    else { sb.enable(true); }
	    return sb;
	  };

	  Searchbar.prototype.backdropShow = function backdropShow () {
	    var sb = this;
	    if (sb.$backdropEl) {
	      sb.$backdropEl.addClass('searchbar-backdrop-in');
	    }
	    return sb;
	  };

	  Searchbar.prototype.backdropHide = function backdropHide () {
	    var sb = this;
	    if (sb.$backdropEl) {
	      sb.$backdropEl.removeClass('searchbar-backdrop-in');
	    }
	    return sb;
	  };

	  Searchbar.prototype.search = function search (query, internal) {
	    var sb = this;
	    sb.previousQuery = sb.query || '';
	    if (query === sb.previousQuery) { return sb; }

	    if (!internal) {
	      if (!sb.enabled) {
	        sb.enable();
	      }
	      sb.$inputEl.val(query);
	      sb.$inputEl.trigger('input');
	    }
	    sb.query = query;
	    sb.value = query;

	    var $searchContainer = sb.$searchContainer;
	    var $el = sb.$el;
	    var $foundEl = sb.$foundEl;
	    var $notFoundEl = sb.$notFoundEl;
	    var $hideOnSearchEl = sb.$hideOnSearchEl;
	    var isVirtualList = sb.isVirtualList;

	    // Hide on search element
	    if (query.length > 0 && $hideOnSearchEl) {
	      $hideOnSearchEl.addClass('hidden-by-searchbar');
	    } else if ($hideOnSearchEl) {
	      $hideOnSearchEl.removeClass('hidden-by-searchbar');
	    }
	    // Add active/inactive classes on overlay
	    if (
	      ($searchContainer && $searchContainer.length && $el.hasClass('searchbar-enabled'))
	      || (sb.params.customSearch && $el.hasClass('searchbar-enabled'))
	    ) {
	      if (query.length === 0) {
	        sb.backdropShow();
	      } else {
	        sb.backdropHide();
	      }
	    }

	    if (sb.params.customSearch) {
	      $el.trigger('searchbar:search', query, sb.previousQuery);
	      sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery);
	      return sb;
	    }

	    var foundItems = [];
	    var vlQuery;
	    if (isVirtualList) {
	      sb.virtualList = $searchContainer[0].f7VirtualList;
	      if (query.trim() === '') {
	        sb.virtualList.resetFilter();
	        if ($notFoundEl) { $notFoundEl.hide(); }
	        if ($foundEl) { $foundEl.show(); }
	        $el.trigger('searchbar:search', query, sb.previousQuery);
	        sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery);
	        return sb;
	      }
	      vlQuery = sb.params.removeDiacritics ? Utils.removeDiacritics(query) : query;
	      if (sb.virtualList.params.searchAll) {
	        foundItems = sb.virtualList.params.searchAll(vlQuery, sb.virtualList.items) || [];
	      } else if (sb.virtualList.params.searchByItem) {
	        for (var i = 0; i < sb.virtualList.items.length; i += 1) {
	          if (sb.virtualList.params.searchByItem(vlQuery, sb.virtualList.params.items[i], i)) {
	            foundItems.push(i);
	          }
	        }
	      }
	    } else {
	      var values;
	      if (sb.params.removeDiacritics) { values = Utils.removeDiacritics(query.trim().toLowerCase()).split(' '); }
	      else {
	        values = query.trim().toLowerCase().split(' ');
	      }
	      $searchContainer.find(sb.params.searchItem).removeClass('hidden-by-searchbar').each(function (itemIndex, itemEl) {
	        var $itemEl = $(itemEl);
	        var compareWithText = [];
	        var $searchIn = sb.params.searchIn ? $itemEl.find(sb.params.searchIn) : $itemEl;
	        if (sb.params.searchIn === sb.params.searchItem) {
	          $searchIn = $itemEl;
	        }
	        $searchIn.each(function (searchInIndex, searchInEl) {
	          var itemText = $(searchInEl).text().trim().toLowerCase();
	          if (sb.params.removeDiacritics) { itemText = Utils.removeDiacritics(itemText); }
	          compareWithText.push(itemText);
	        });
	        compareWithText = compareWithText.join(' ');
	        var wordsMatch = 0;
	        for (var i = 0; i < values.length; i += 1) {
	          if (compareWithText.indexOf(values[i]) >= 0) { wordsMatch += 1; }
	        }
	        if (wordsMatch !== values.length && !(sb.params.ignore && $itemEl.is(sb.params.ignore))) {
	          $itemEl.addClass('hidden-by-searchbar');
	        } else {
	          foundItems.push($itemEl[0]);
	        }
	      });

	      if (sb.params.hideDividers) {
	        $searchContainer.find(sb.params.searchGroupTitle).each(function (titleIndex, titleEl) {
	          var $titleEl = $(titleEl);
	          var $nextElements = $titleEl.nextAll(sb.params.searchItem);
	          var hide = true;
	          for (var i = 0; i < $nextElements.length; i += 1) {
	            var $nextEl = $nextElements.eq(i);
	            if ($nextEl.is(sb.params.searchGroupTitle)) { break; }
	            if (!$nextEl.hasClass('hidden-by-searchbar')) {
	              hide = false;
	            }
	          }
	          var ignore = sb.params.ignore && $titleEl.is(sb.params.ignore);
	          if (hide && !ignore) { $titleEl.addClass('hidden-by-searchbar'); }
	          else { $titleEl.removeClass('hidden-by-searchbar'); }
	        });
	      }
	      if (sb.params.hideGroups) {
	        $searchContainer.find(sb.params.searchGroup).each(function (groupIndex, groupEl) {
	          var $groupEl = $(groupEl);
	          var ignore = sb.params.ignore && $groupEl.is(sb.params.ignore);
	          // eslint-disable-next-line
	          var notHidden = $groupEl.find(sb.params.searchItem).filter(function (index, el) {
	            return !$(el).hasClass('hidden-by-searchbar');
	          });
	          if (notHidden.length === 0 && !ignore) {
	            $groupEl.addClass('hidden-by-searchbar');
	          } else {
	            $groupEl.removeClass('hidden-by-searchbar');
	          }
	        });
	      }
	    }

	    if (foundItems.length === 0) {
	      if ($notFoundEl) { $notFoundEl.show(); }
	      if ($foundEl) { $foundEl.hide(); }
	    } else {
	      if ($notFoundEl) { $notFoundEl.hide(); }
	      if ($foundEl) { $foundEl.show(); }
	    }
	    if (isVirtualList && sb.virtualList) {
	      sb.virtualList.filterItems(foundItems);
	    }

	    $el.trigger('searchbar:search', query, sb.previousQuery, foundItems);
	    sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery, foundItems);

	    return sb;
	  };

	  Searchbar.prototype.init = function init () {
	    var sb = this;
	    if (sb.expandable && sb.$el) { sb.$el.addClass('searchbar-expandable'); }
	    if (sb.inline && sb.$el) { sb.$el.addClass('searchbar-inline'); }
	    sb.attachEvents();
	  };

	  Searchbar.prototype.destroy = function destroy () {
	    var sb = this;
	    sb.emit('local::beforeDestroy searchbarBeforeDestroy', sb);
	    sb.$el.trigger('searchbar:beforedestroy', sb);
	    sb.detachEvents();
	    if (sb.$el[0]) {
	      sb.$el[0].f7Searchbar = null;
	      delete sb.$el[0].f7Searchbar;
	    }
	    Utils.deleteProps(sb);
	  };

	  return Searchbar;
	}(Framework7Class));

	var Searchbar$1 = {
	  name: 'searchbar',
	  static: {
	    Searchbar: Searchbar,
	  },
	  create: function create() {
	    var app = this;
	    app.searchbar = ConstructorMethods({
	      defaultSelector: '.searchbar',
	      constructor: Searchbar,
	      app: app,
	      domProp: 'f7Searchbar',
	      addMethods: 'clear enable disable toggle search'.split(' '),
	    });
	  },
	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $(tabEl).find('.searchbar-init').each(function (index, searchbarEl) {
	        var $searchbarEl = $(searchbarEl);
	        app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
	      });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      $(tabEl).find('.searchbar-init').each(function (index, searchbarEl) {
	        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
	          searchbarEl.f7Searchbar.destroy();
	        }
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.searchbar-init').each(function (index, searchbarEl) {
	        var $searchbarEl = $(searchbarEl);
	        app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
	      });
	      if (app.theme === 'ios' && page.view && page.view.router.separateNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
	        page.$navbarEl.find('.searchbar-init').each(function (index, searchbarEl) {
	          var $searchbarEl = $(searchbarEl);
	          app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
	        });
	      }
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.searchbar-init').each(function (index, searchbarEl) {
	        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
	          searchbarEl.f7Searchbar.destroy();
	        }
	      });
	      if (app.theme === 'ios' && page.view && page.view.router.separateNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
	        page.$navbarEl.find('.searchbar-init').each(function (index, searchbarEl) {
	          if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
	            searchbarEl.f7Searchbar.destroy();
	          }
	        });
	      }
	    },
	  },
	  clicks: {
	    '.searchbar-clear': function clear($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var sb = app.searchbar.get(data.searchbar);
	      if (sb) { sb.clear(); }
	    },
	    '.searchbar-enable': function enable($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var sb = app.searchbar.get(data.searchbar);
	      if (sb) { sb.enable(true); }
	    },
	    '.searchbar-disable': function disable($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var sb = app.searchbar.get(data.searchbar);
	      if (sb) { sb.disable(); }
	    },
	    '.searchbar-toggle': function toggle($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var sb = app.searchbar.get(data.searchbar);
	      if (sb) { sb.toggle(); }
	    },
	  },
	  vnode: {
	    'searchbar-init': {
	      insert: function insert(vnode) {
	        var app = this;
	        var searchbarEl = vnode.elm;
	        var $searchbarEl = $(searchbarEl);
	        app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
	      },
	      destroy: function destroy(vnode) {
	        var searchbarEl = vnode.elm;
	        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
	          searchbarEl.f7Searchbar.destroy();
	        }
	      },
	    },
	  },
	};

	var Messages = /*@__PURE__*/(function (Framework7Class) {
	  function Messages(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class.call(this, params, [app]);

	    var m = this;

	    var defaults = {
	      autoLayout: true,
	      messages: [],
	      newMessagesFirst: false,
	      scrollMessages: true,
	      scrollMessagesOnEdge: true,
	      firstMessageRule: undefined,
	      lastMessageRule: undefined,
	      tailMessageRule: undefined,
	      sameNameMessageRule: undefined,
	      sameHeaderMessageRule: undefined,
	      sameFooterMessageRule: undefined,
	      sameAvatarMessageRule: undefined,
	      customClassMessageRule: undefined,
	      renderMessage: undefined,
	    };

	    // Extend defaults with modules params
	    m.useModulesParams(defaults);

	    m.params = Utils.extend(defaults, params);

	    var $el = $(params.el).eq(0);
	    if ($el.length === 0) { return m; }

	    if ($el[0].f7Messages) { return $el[0].f7Messages; }

	    $el[0].f7Messages = m;

	    var $pageContentEl = $el.closest('.page-content').eq(0);

	    Utils.extend(m, {
	      messages: m.params.messages,
	      $el: $el,
	      el: $el[0],
	      $pageContentEl: $pageContentEl,
	      pageContentEl: $pageContentEl[0],

	    });
	    // Install Modules
	    m.useModules();

	    // Init
	    m.init();

	    return m;
	  }

	  if ( Framework7Class ) Messages.__proto__ = Framework7Class;
	  Messages.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  Messages.prototype.constructor = Messages;
	  // eslint-disable-next-line
	  Messages.prototype.getMessageData = function getMessageData (messageEl) {
	    var $messageEl = $(messageEl);
	    var data = {
	      name: $messageEl.find('.message-name').html(),
	      header: $messageEl.find('.message-header').html(),
	      textHeader: $messageEl.find('.message-text-header').html(),
	      textFooter: $messageEl.find('.message-text-footer').html(),
	      footer: $messageEl.find('.message-footer').html(),
	      isTitle: $messageEl.hasClass('messages-title'),
	      type: $messageEl.hasClass('message-sent') ? 'sent' : 'received',
	      text: $messageEl.find('.message-text').html(),
	      image: $messageEl.find('.message-image').html(),
	      imageSrc: $messageEl.find('.message-image img').attr('src'),
	      typing: $messageEl.hasClass('message-typing'),
	    };
	    if (data.isTitle) {
	      data.text = $messageEl.html();
	    }
	    if (data.text && data.textHeader) {
	      data.text = data.text.replace(("<div class=\"message-text-header\">" + (data.textHeader) + "</div>"), '');
	    }
	    if (data.text && data.textFooter) {
	      data.text = data.text.replace(("<div class=\"message-text-footer\">" + (data.textFooter) + "</div>"), '');
	    }
	    var avatar = $messageEl.find('.message-avatar').css('background-image');
	    if (avatar === 'none' || avatar === '') { avatar = undefined; }
	    if (avatar && typeof avatar === 'string') {
	      avatar = avatar.replace('url(', '').replace(')', '').replace(/"/g, '').replace(/'/g, '');
	    } else {
	      avatar = undefined;
	    }
	    data.avatar = avatar;

	    return data;
	  };

	  Messages.prototype.getMessagesData = function getMessagesData () {
	    var m = this;
	    var data = [];
	    m.$el.find('.message, .messages-title').each(function (index, messageEl) {
	      data.push(m.getMessageData(messageEl));
	    });
	    return data;
	  };

	  Messages.prototype.renderMessage = function renderMessage (messageToRender) {
	    var m = this;
	    var message = Utils.extend({
	      type: 'sent',
	      attrs: {},
	    }, messageToRender);
	    if (m.params.renderMessage) {
	      return m.params.renderMessage.call(m, message);
	    }
	    if (message.isTitle) {
	      return ("<div class=\"messages-title\">" + (message.text) + "</div>");
	    }
	    var attrs = Object.keys(message.attrs).map(function (attr) { return (attr + "=\"" + (message.attrs[attr]) + "\""); }).join(' ');
	    return ("\n      <div class=\"message message-" + (message.type) + " " + (message.isTyping ? 'message-typing' : '') + " " + (message.cssClass || '') + "\" " + attrs + ">\n        " + (message.avatar ? ("\n        <div class=\"message-avatar\" style=\"background-image:url(" + (message.avatar) + ")\"></div>\n        ") : '') + "\n        <div class=\"message-content\">\n          " + (message.name ? ("<div class=\"message-name\">" + (message.name) + "</div>") : '') + "\n          " + (message.header ? ("<div class=\"message-header\">" + (message.header) + "</div>") : '') + "\n          <div class=\"message-bubble\">\n            " + (message.textHeader ? ("<div class=\"message-text-header\">" + (message.textHeader) + "</div>") : '') + "\n            " + (message.image ? ("<div class=\"message-image\">" + (message.image) + "</div>") : '') + "\n            " + (message.imageSrc && !message.image ? ("<div class=\"message-image\"><img src=\"" + (message.imageSrc) + "\"></div>") : '') + "\n            " + (message.text || message.isTyping ? ("<div class=\"message-text\">" + (message.text || '') + (message.isTyping ? '<div class="message-typing-indicator"><div></div><div></div><div></div></div>' : '') + "</div>") : '') + "\n            " + (message.textFooter ? ("<div class=\"message-text-footer\">" + (message.textFooter) + "</div>") : '') + "\n          </div>\n          " + (message.footer ? ("<div class=\"message-footer\">" + (message.footer) + "</div>") : '') + "\n        </div>\n      </div>\n    ");
	  };

	  Messages.prototype.renderMessages = function renderMessages (messagesToRender, method) {
	    if ( messagesToRender === void 0 ) messagesToRender = this.messages;
	    if ( method === void 0 ) method = this.params.newMessagesFirst ? 'prepend' : 'append';

	    var m = this;
	    var html = messagesToRender.map(function (message) { return m.renderMessage(message); }).join('');
	    m.$el[method](html);
	  };

	  Messages.prototype.isFirstMessage = function isFirstMessage () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var m = this;
	    if (m.params.firstMessageRule) { return (ref = m.params).firstMessageRule.apply(ref, args); }
	    return false;
	  };

	  Messages.prototype.isLastMessage = function isLastMessage () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var m = this;
	    if (m.params.lastMessageRule) { return (ref = m.params).lastMessageRule.apply(ref, args); }
	    return false;
	  };

	  Messages.prototype.isTailMessage = function isTailMessage () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var m = this;
	    if (m.params.tailMessageRule) { return (ref = m.params).tailMessageRule.apply(ref, args); }
	    return false;
	  };

	  Messages.prototype.isSameNameMessage = function isSameNameMessage () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var m = this;
	    if (m.params.sameNameMessageRule) { return (ref = m.params).sameNameMessageRule.apply(ref, args); }
	    return false;
	  };

	  Messages.prototype.isSameHeaderMessage = function isSameHeaderMessage () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var m = this;
	    if (m.params.sameHeaderMessageRule) { return (ref = m.params).sameHeaderMessageRule.apply(ref, args); }
	    return false;
	  };

	  Messages.prototype.isSameFooterMessage = function isSameFooterMessage () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var m = this;
	    if (m.params.sameFooterMessageRule) { return (ref = m.params).sameFooterMessageRule.apply(ref, args); }
	    return false;
	  };

	  Messages.prototype.isSameAvatarMessage = function isSameAvatarMessage () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var m = this;
	    if (m.params.sameAvatarMessageRule) { return (ref = m.params).sameAvatarMessageRule.apply(ref, args); }
	    return false;
	  };

	  Messages.prototype.isCustomClassMessage = function isCustomClassMessage () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var m = this;
	    if (m.params.customClassMessageRule) { return (ref = m.params).customClassMessageRule.apply(ref, args); }
	    return undefined;
	  };

	  Messages.prototype.layout = function layout () {
	    var m = this;
	    m.$el.find('.message, .messages-title').each(function (index, messageEl) {
	      var $messageEl = $(messageEl);
	      if (!m.messages) {
	        m.messages = m.getMessagesData();
	      }
	      var classes = [];
	      var message = m.messages[index];
	      var previousMessage = m.messages[index - 1];
	      var nextMessage = m.messages[index + 1];
	      if (m.isFirstMessage(message, previousMessage, nextMessage)) {
	        classes.push('message-first');
	      }
	      if (m.isLastMessage(message, previousMessage, nextMessage)) {
	        classes.push('message-last');
	      }
	      if (m.isTailMessage(message, previousMessage, nextMessage)) {
	        classes.push('message-tail');
	      }
	      if (m.isSameNameMessage(message, previousMessage, nextMessage)) {
	        classes.push('message-same-name');
	      }
	      if (m.isSameHeaderMessage(message, previousMessage, nextMessage)) {
	        classes.push('message-same-header');
	      }
	      if (m.isSameFooterMessage(message, previousMessage, nextMessage)) {
	        classes.push('message-same-footer');
	      }
	      if (m.isSameAvatarMessage(message, previousMessage, nextMessage)) {
	        classes.push('message-same-avatar');
	      }
	      var customMessageClasses = m.isCustomClassMessage(message, previousMessage, nextMessage);
	      if (customMessageClasses && customMessageClasses.length) {
	        if (typeof customMessageClasses === 'string') {
	          customMessageClasses = customMessageClasses.split(' ');
	        }
	        customMessageClasses.forEach(function (customClass) {
	          classes.push(customClass);
	        });
	      }
	      $messageEl.removeClass('message-first message-last message-tail message-same-name message-same-header message-same-footer message-same-avatar');
	      classes.forEach(function (className) {
	        $messageEl.addClass(className);
	      });
	    });
	  };

	  Messages.prototype.clear = function clear () {
	    var m = this;
	    m.messages = [];
	    m.$el.html('');
	  };

	  Messages.prototype.removeMessage = function removeMessage (messageToRemove, layout) {
	    if ( layout === void 0 ) layout = true;

	    var m = this;
	    // Index or El
	    var index;
	    var $el;
	    if (typeof messageToRemove === 'number') {
	      index = messageToRemove;
	      $el = m.$el.find('.message, .messages-title').eq(index);
	    } else if (m.messages && m.messages.indexOf(messageToRemove) >= 0) {
	      index = m.messages.indexOf(messageToRemove);
	      $el = m.$el.children().eq(index);
	    } else {
	      $el = $(messageToRemove);
	      index = $el.index();
	    }
	    if ($el.length === 0) {
	      return m;
	    }
	    $el.remove();
	    m.messages.splice(index, 1);
	    if (m.params.autoLayout && layout) { m.layout(); }
	    return m;
	  };

	  Messages.prototype.removeMessages = function removeMessages (messagesToRemove, layout) {
	    if ( layout === void 0 ) layout = true;

	    var m = this;
	    if (Array.isArray(messagesToRemove)) {
	      var messagesToRemoveEls = [];
	      messagesToRemove.forEach(function (messageToRemoveIndex) {
	        messagesToRemoveEls.push(m.$el.find('.message, .messages-title').eq(messageToRemoveIndex));
	      });
	      messagesToRemoveEls.forEach(function (messageToRemove) {
	        m.removeMessage(messageToRemove, false);
	      });
	    } else {
	      $(messagesToRemove).each(function (index, messageToRemove) {
	        m.removeMessage(messageToRemove, false);
	      });
	    }
	    if (m.params.autoLayout && layout) { m.layout(); }
	    return m;
	  };

	  Messages.prototype.addMessage = function addMessage () {
	    var assign, assign$1;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var m = this;
	    var messageToAdd;
	    var animate;
	    var method;
	    if (typeof args[1] === 'boolean') {
	      (assign = args, messageToAdd = assign[0], animate = assign[1], method = assign[2]);
	    } else {
	      (assign$1 = args, messageToAdd = assign$1[0], method = assign$1[1], animate = assign$1[2]);
	    }
	    if (typeof animate === 'undefined') {
	      animate = true;
	    }
	    if (typeof method === 'undefined') {
	      method = m.params.newMessagesFirst ? 'prepend' : 'append';
	    }

	    return m.addMessages([messageToAdd], animate, method);
	  };

	  Messages.prototype.addMessages = function addMessages () {
	    var assign, assign$1;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var m = this;
	    var messagesToAdd;
	    var animate;
	    var method;
	    if (typeof args[1] === 'boolean') {
	      (assign = args, messagesToAdd = assign[0], animate = assign[1], method = assign[2]);
	    } else {
	      (assign$1 = args, messagesToAdd = assign$1[0], method = assign$1[1], animate = assign$1[2]);
	    }
	    if (typeof animate === 'undefined') {
	      animate = true;
	    }
	    if (typeof method === 'undefined') {
	      method = m.params.newMessagesFirst ? 'prepend' : 'append';
	    }

	    // Define scroll positions before new messages added
	    var scrollHeightBefore = m.pageContentEl.scrollHeight;
	    var heightBefore = m.pageContentEl.offsetHeight;
	    var scrollBefore = m.pageContentEl.scrollTop;

	    // Add message to DOM and data
	    var messagesHTML = '';
	    var typingMessage = m.messages.filter(function (el) { return el.isTyping; })[0];
	    messagesToAdd.forEach(function (messageToAdd) {
	      if (typingMessage) {
	        if (method === 'append') {
	          m.messages.splice(m.messages.indexOf(typingMessage), 0, messageToAdd);
	        } else {
	          m.messages.splice(m.messages.indexOf(typingMessage) + 1, 0, messageToAdd);
	        }
	      } else {
	        m.messages[method === 'append' ? 'push' : 'unshift'](messageToAdd);
	      }
	      messagesHTML += m.renderMessage(messageToAdd);
	    });
	    var $messagesEls = $(messagesHTML);
	    if (animate) {
	      if (method === 'append' && !m.params.newMessagesFirst) {
	        $messagesEls.addClass('message-appear-from-bottom');
	      }
	      if (method === 'prepend' && m.params.newMessagesFirst) {
	        $messagesEls.addClass('message-appear-from-top');
	      }
	    }
	    if (typingMessage) {
	      if (method === 'append') {
	        $messagesEls.insertBefore(m.$el.find('.message-typing'));
	      } else {
	        $messagesEls.insertAfter(m.$el.find('.message-typing'));
	      }
	    } else {
	      m.$el[method]($messagesEls);
	    }

	    // Layout
	    if (m.params.autoLayout) { m.layout(); }

	    if (method === 'prepend' && !typingMessage) {
	      m.pageContentEl.scrollTop = scrollBefore + (m.pageContentEl.scrollHeight - scrollHeightBefore);
	    }

	    if (m.params.scrollMessages && ((method === 'append' && !m.params.newMessagesFirst) || (method === 'prepend' && m.params.newMessagesFirst && !typingMessage))) {
	      if (m.params.scrollMessagesOnEdge) {
	        var onEdge = false;
	        if (m.params.newMessagesFirst && scrollBefore === 0) {
	          onEdge = true;
	        }
	        if (!m.params.newMessagesFirst && (scrollBefore - (scrollHeightBefore - heightBefore) >= -10)) {
	          onEdge = true;
	        }
	        if (onEdge) { m.scroll(animate ? undefined : 0); }
	      } else {
	        m.scroll(animate ? undefined : 0);
	      }
	    }

	    return m;
	  };

	  Messages.prototype.showTyping = function showTyping (message) {
	    if ( message === void 0 ) message = {};

	    var m = this;
	    var typingMessage = m.messages.filter(function (el) { return el.isTyping; })[0];
	    if (typingMessage) {
	      m.removeMessage(m.messages.indexOf(typingMessage));
	    }
	    m.addMessage(Utils.extend({
	      type: 'received',
	      isTyping: true,
	    }, message));
	    return m;
	  };

	  Messages.prototype.hideTyping = function hideTyping () {
	    var m = this;
	    var typingMessageIndex;
	    var typingFound;
	    m.messages.forEach(function (message, index) {
	      if (message.isTyping) { typingMessageIndex = index; }
	    });
	    if (typeof typingMessageIndex !== 'undefined') {
	      if (m.$el.find('.message').eq(typingMessageIndex).hasClass('message-typing')) {
	        typingFound = true;
	        m.removeMessage(typingMessageIndex);
	      }
	    }
	    if (!typingFound) {
	      var $typingMessageEl = m.$el.find('.message-typing');
	      if ($typingMessageEl.length) {
	        m.removeMessage($typingMessageEl);
	      }
	    }
	    return m;
	  };

	  Messages.prototype.scroll = function scroll (duration, scrollTop) {
	    if ( duration === void 0 ) duration = 300;

	    var m = this;
	    var currentScroll = m.pageContentEl.scrollTop;
	    var newScrollTop;
	    if (typeof scrollTop !== 'undefined') { newScrollTop = scrollTop; }
	    else {
	      newScrollTop = m.params.newMessagesFirst ? 0 : m.pageContentEl.scrollHeight - m.pageContentEl.offsetHeight;
	      if (newScrollTop === currentScroll) { return m; }
	    }
	    m.$pageContentEl.scrollTop(newScrollTop, duration);
	    return m;
	  };

	  Messages.prototype.init = function init () {
	    var m = this;
	    if (!m.messages || m.messages.length === 0) {
	      m.messages = m.getMessagesData();
	    }
	    if (m.params.messages && m.params.messages.length) {
	      m.renderMessages();
	    }
	    if (m.params.autoLayout) { m.layout(); }
	    if (m.params.scrollMessages) { m.scroll(0); }
	  };

	  Messages.prototype.destroy = function destroy () {
	    var m = this;
	    m.emit('local::beforeDestroy messagesBeforeDestroy', m);
	    m.$el.trigger('messages:beforedestroy', m);
	    if (m.$el[0]) {
	      m.$el[0].f7Messages = null;
	      delete m.$el[0].f7Messages;
	    }
	    Utils.deleteProps(m);
	  };

	  return Messages;
	}(Framework7Class));

	var Messages$1 = {
	  name: 'messages',
	  static: {
	    Messages: Messages,
	  },
	  create: function create() {
	    var app = this;
	    app.messages = ConstructorMethods({
	      defaultSelector: '.messages',
	      constructor: Messages,
	      app: app,
	      domProp: 'f7Messages',
	      addMethods: 'renderMessages layout scroll clear removeMessage removeMessages addMessage addMessages'.split(' '),
	    });
	  },
	  on: {
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var app = this;
	      $(tabEl).find('.messages-init').each(function (index, messagesEl) {
	        app.messages.destroy(messagesEl);
	      });
	    },
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $(tabEl).find('.messages-init').each(function (index, messagesEl) {
	        app.messages.create({ el: messagesEl });
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.messages-init').each(function (index, messagesEl) {
	        app.messages.destroy(messagesEl);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.messages-init').each(function (index, messagesEl) {
	        app.messages.create({ el: messagesEl });
	      });
	    },
	  },
	  vnode: {
	    'messages-init': {
	      insert: function insert(vnode) {
	        var app = this;
	        var messagesEl = vnode.elm;
	        app.messages.create({ el: messagesEl });
	      },
	      destroy: function destroy(vnode) {
	        var app = this;
	        var messagesEl = vnode.elm;
	        app.messages.destroy(messagesEl);
	      },
	    },
	  },
	};

	var Messagebar = /*@__PURE__*/(function (Framework7Class) {
	  function Messagebar(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class.call(this, params, [app]);

	    var messagebar = this;

	    var defaults = {
	      top: false,
	      topOffset: 0,
	      bottomOffset: 0,
	      attachments: [],
	      renderAttachments: undefined,
	      renderAttachment: undefined,
	      maxHeight: null,
	      resizePage: true,
	    };

	    // Extend defaults with modules params
	    messagebar.useModulesParams(defaults);

	    messagebar.params = Utils.extend(defaults, params);

	    // El
	    var $el = $(messagebar.params.el);
	    if ($el.length === 0) { return messagebar; }

	    if ($el[0].f7Messagebar) { return $el[0].f7Messagebar; }

	    $el[0].f7Messagebar = messagebar;

	    // Page and PageContent
	    var $pageEl = $el.parents('.page').eq(0);
	    var $pageContentEl = $pageEl.find('.page-content').eq(0);

	    // Area
	    var $areaEl = $el.find('.messagebar-area');

	    // Textarea
	    var $textareaEl;
	    if (messagebar.params.textareaEl) {
	      $textareaEl = $(messagebar.params.textareaEl);
	    } else {
	      $textareaEl = $el.find('textarea');
	    }

	    // Attachments & Library
	    var $attachmentsEl = $el.find('.messagebar-attachments');
	    var $sheetEl = $el.find('.messagebar-sheet');

	    if (messagebar.params.top) {
	      $el.addClass('messagebar-top');
	    }

	    Utils.extend(messagebar, {
	      $el: $el,
	      el: $el[0],
	      $areaEl: $areaEl,
	      areaEl: $areaEl[0],
	      $textareaEl: $textareaEl,
	      textareaEl: $textareaEl[0],
	      $attachmentsEl: $attachmentsEl,
	      attachmentsEl: $attachmentsEl[0],
	      attachmentsVisible: $attachmentsEl.hasClass('messagebar-attachments-visible'),
	      $sheetEl: $sheetEl,
	      sheetEl: $sheetEl[0],
	      sheetVisible: $sheetEl.hasClass('messagebar-sheet-visible'),
	      $pageEl: $pageEl,
	      pageEl: $pageEl[0],
	      $pageContentEl: $pageContentEl,
	      pageContentEl: $pageContentEl,
	      top: $el.hasClass('messagebar-top') || messagebar.params.top,
	      attachments: [],
	    });

	    // Events
	    function onAppResize() {
	      if (messagebar.params.resizePage) {
	        messagebar.resizePage();
	      }
	    }
	    function onSubmit(e) {
	      e.preventDefault();
	    }
	    function onAttachmentClick(e) {
	      var index = $(this).index();
	      if ($(e.target).closest('.messagebar-attachment-delete').length) {
	        $(this).trigger('messagebar:attachmentdelete', index);
	        messagebar.emit('local::attachmentDelete messagebarAttachmentDelete', messagebar, this, index);
	      } else {
	        $(this).trigger('messagebar:attachmentclick', index);
	        messagebar.emit('local::attachmentClick messagebarAttachmentClick', messagebar, this, index);
	      }
	    }
	    function onTextareaChange() {
	      messagebar.checkEmptyState();
	      messagebar.$el.trigger('messagebar:change');
	      messagebar.emit('local::change messagebarChange', messagebar);
	    }
	    function onTextareaFocus() {
	      messagebar.sheetHide();
	      messagebar.$el.addClass('messagebar-focused');
	      messagebar.$el.trigger('messagebar:focus');
	      messagebar.emit('local::focus messagebarFocus', messagebar);
	    }
	    function onTextareaBlur() {
	      messagebar.$el.removeClass('messagebar-focused');
	      messagebar.$el.trigger('messagebar:blur');
	      messagebar.emit('local::blur messagebarBlur', messagebar);
	    }

	    messagebar.attachEvents = function attachEvents() {
	      $el.on('textarea:resize', onAppResize);
	      $el.on('submit', onSubmit);
	      $el.on('click', '.messagebar-attachment', onAttachmentClick);
	      $textareaEl.on('change input', onTextareaChange);
	      $textareaEl.on('focus', onTextareaFocus);
	      $textareaEl.on('blur', onTextareaBlur);
	      app.on('resize', onAppResize);
	    };
	    messagebar.detachEvents = function detachEvents() {
	      $el.off('textarea:resize', onAppResize);
	      $el.off('submit', onSubmit);
	      $el.off('click', '.messagebar-attachment', onAttachmentClick);
	      $textareaEl.off('change input', onTextareaChange);
	      $textareaEl.off('focus', onTextareaFocus);
	      $textareaEl.off('blur', onTextareaBlur);
	      app.off('resize', onAppResize);
	    };


	    // Install Modules
	    messagebar.useModules();

	    // Init
	    messagebar.init();

	    return messagebar;
	  }

	  if ( Framework7Class ) Messagebar.__proto__ = Framework7Class;
	  Messagebar.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  Messagebar.prototype.constructor = Messagebar;

	  Messagebar.prototype.focus = function focus () {
	    var messagebar = this;
	    messagebar.$textareaEl.focus();
	    return messagebar;
	  };

	  Messagebar.prototype.blur = function blur () {
	    var messagebar = this;
	    messagebar.$textareaEl.blur();
	    return messagebar;
	  };

	  Messagebar.prototype.clear = function clear () {
	    var messagebar = this;
	    messagebar.$textareaEl.val('').trigger('change');
	    return messagebar;
	  };

	  Messagebar.prototype.getValue = function getValue () {
	    var messagebar = this;
	    return messagebar.$textareaEl.val().trim();
	  };

	  Messagebar.prototype.setValue = function setValue (value) {
	    var messagebar = this;
	    messagebar.$textareaEl.val(value).trigger('change');
	    return messagebar;
	  };

	  Messagebar.prototype.setPlaceholder = function setPlaceholder (placeholder) {
	    var messagebar = this;
	    messagebar.$textareaEl.attr('placeholder', placeholder);
	    return messagebar;
	  };

	  Messagebar.prototype.resizePage = function resizePage () {
	    var messagebar = this;
	    var params = messagebar.params;
	    var $el = messagebar.$el;
	    var top = messagebar.top;
	    var $pageEl = messagebar.$pageEl;
	    var $pageContentEl = messagebar.$pageContentEl;
	    var $areaEl = messagebar.$areaEl;
	    var $textareaEl = messagebar.$textareaEl;
	    var $sheetEl = messagebar.$sheetEl;
	    var $attachmentsEl = messagebar.$attachmentsEl;
	    var elHeight = $el[0].offsetHeight;
	    var maxHeight = params.maxHeight;
	    if (top) ; else {
	      var currentPaddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
	      var requiredPaddingBottom = elHeight + params.bottomOffset;
	      if (requiredPaddingBottom !== currentPaddingBottom && $pageContentEl.length) {
	        var currentPaddingTop = parseInt($pageContentEl.css('padding-top'), 10);
	        var pageScrollHeight = $pageContentEl[0].scrollHeight;
	        var pageOffsetHeight = $pageContentEl[0].offsetHeight;
	        var pageScrollTop = $pageContentEl[0].scrollTop;
	        var scrollOnBottom = (pageScrollTop === pageScrollHeight - pageOffsetHeight);
	        if (!maxHeight) {
	          maxHeight = $pageEl[0].offsetHeight - currentPaddingTop - $sheetEl.outerHeight() - $attachmentsEl.outerHeight() - parseInt($areaEl.css('margin-top'), 10) - parseInt($areaEl.css('margin-bottom'), 10);
	        }
	        $textareaEl.css('max-height', (maxHeight + "px"));
	        $pageContentEl.css('padding-bottom', (requiredPaddingBottom + "px"));
	        if (scrollOnBottom) {
	          $pageContentEl.scrollTop($pageContentEl[0].scrollHeight - pageOffsetHeight);
	        }
	        $el.trigger('messagebar:resizepage');
	        messagebar.emit('local::resizePage messagebarResizePage', messagebar);
	      }
	    }
	  };

	  Messagebar.prototype.checkEmptyState = function checkEmptyState () {
	    var messagebar = this;
	    var $el = messagebar.$el;
	    var $textareaEl = messagebar.$textareaEl;
	    var value = $textareaEl.val().trim();
	    if (value && value.length) {
	      $el.addClass('messagebar-with-value');
	    } else {
	      $el.removeClass('messagebar-with-value');
	    }
	  };

	  Messagebar.prototype.attachmentsCreate = function attachmentsCreate (innerHTML) {
	    if ( innerHTML === void 0 ) innerHTML = '';

	    var messagebar = this;
	    var $attachmentsEl = $(("<div class=\"messagebar-attachments\">" + innerHTML + "</div>"));
	    $attachmentsEl.insertBefore(messagebar.$textareaEl);
	    Utils.extend(messagebar, {
	      $attachmentsEl: $attachmentsEl,
	      attachmentsEl: $attachmentsEl[0],
	    });
	    return messagebar;
	  };

	  Messagebar.prototype.attachmentsShow = function attachmentsShow (innerHTML) {
	    if ( innerHTML === void 0 ) innerHTML = '';

	    var messagebar = this;
	    messagebar.$attachmentsEl = messagebar.$el.find('.messagebar-attachments');
	    if (messagebar.$attachmentsEl.length === 0) {
	      messagebar.attachmentsCreate(innerHTML);
	    }
	    messagebar.$el.addClass('messagebar-attachments-visible');
	    messagebar.attachmentsVisible = true;
	    if (messagebar.params.resizePage) {
	      messagebar.resizePage();
	    }
	    return messagebar;
	  };

	  Messagebar.prototype.attachmentsHide = function attachmentsHide () {
	    var messagebar = this;
	    messagebar.$el.removeClass('messagebar-attachments-visible');
	    messagebar.attachmentsVisible = false;
	    if (messagebar.params.resizePage) {
	      messagebar.resizePage();
	    }
	    return messagebar;
	  };

	  Messagebar.prototype.attachmentsToggle = function attachmentsToggle () {
	    var messagebar = this;
	    if (messagebar.attachmentsVisible) {
	      messagebar.attachmentsHide();
	    } else {
	      messagebar.attachmentsShow();
	    }
	    return messagebar;
	  };

	  Messagebar.prototype.renderAttachment = function renderAttachment (attachment) {
	    var messagebar = this;
	    if (messagebar.params.renderAttachment) {
	      return messagebar.params.renderAttachment.call(messagebar, attachment);
	    }
	    return ("\n      <div class=\"messagebar-attachment\">\n        <img src=\"" + attachment + "\">\n        <span class=\"messagebar-attachment-delete\"></span>\n      </div>\n    ");
	  };

	  Messagebar.prototype.renderAttachments = function renderAttachments () {
	    var messagebar = this;
	    var html;
	    if (messagebar.params.renderAttachments) {
	      html = messagebar.params.renderAttachments.call(messagebar, messagebar.attachments);
	    } else {
	      html = "" + (messagebar.attachments.map(function (attachment) { return messagebar.renderAttachment(attachment); }).join(''));
	    }
	    if (messagebar.$attachmentsEl.length === 0) {
	      messagebar.attachmentsCreate(html);
	    } else {
	      messagebar.$attachmentsEl.html(html);
	    }
	  };

	  Messagebar.prototype.sheetCreate = function sheetCreate (innerHTML) {
	    if ( innerHTML === void 0 ) innerHTML = '';

	    var messagebar = this;
	    var $sheetEl = $(("<div class=\"messagebar-sheet\">" + innerHTML + "</div>"));
	    messagebar.$el.append($sheetEl);
	    Utils.extend(messagebar, {
	      $sheetEl: $sheetEl,
	      sheetEl: $sheetEl[0],
	    });
	    return messagebar;
	  };

	  Messagebar.prototype.sheetShow = function sheetShow (innerHTML) {
	    if ( innerHTML === void 0 ) innerHTML = '';

	    var messagebar = this;
	    messagebar.$sheetEl = messagebar.$el.find('.messagebar-sheet');
	    if (messagebar.$sheetEl.length === 0) {
	      messagebar.sheetCreate(innerHTML);
	    }
	    messagebar.$el.addClass('messagebar-sheet-visible');
	    messagebar.sheetVisible = true;
	    if (messagebar.params.resizePage) {
	      messagebar.resizePage();
	    }
	    return messagebar;
	  };

	  Messagebar.prototype.sheetHide = function sheetHide () {
	    var messagebar = this;
	    messagebar.$el.removeClass('messagebar-sheet-visible');
	    messagebar.sheetVisible = false;
	    if (messagebar.params.resizePage) {
	      messagebar.resizePage();
	    }
	    return messagebar;
	  };

	  Messagebar.prototype.sheetToggle = function sheetToggle () {
	    var messagebar = this;
	    if (messagebar.sheetVisible) {
	      messagebar.sheetHide();
	    } else {
	      messagebar.sheetShow();
	    }
	    return messagebar;
	  };

	  Messagebar.prototype.init = function init () {
	    var messagebar = this;
	    messagebar.attachEvents();
	    messagebar.checkEmptyState();
	    return messagebar;
	  };

	  Messagebar.prototype.destroy = function destroy () {
	    var messagebar = this;
	    messagebar.emit('local::beforeDestroy messagebarBeforeDestroy', messagebar);
	    messagebar.$el.trigger('messagebar:beforedestroy', messagebar);
	    messagebar.detachEvents();
	    if (messagebar.$el[0]) {
	      messagebar.$el[0].f7Messagebar = null;
	      delete messagebar.$el[0].f7Messagebar;
	    }
	    Utils.deleteProps(messagebar);
	  };

	  return Messagebar;
	}(Framework7Class));

	var Messagebar$1 = {
	  name: 'messagebar',
	  static: {
	    Messagebar: Messagebar,
	  },
	  create: function create() {
	    var app = this;
	    app.messagebar = ConstructorMethods({
	      defaultSelector: '.messagebar',
	      constructor: Messagebar,
	      app: app,
	      domProp: 'f7Messagebar',
	      addMethods: 'clear getValue setValue setPlaceholder resizePage focus blur attachmentsCreate attachmentsShow attachmentsHide attachmentsToggle renderAttachments sheetCreate sheetShow sheetHide sheetToggle'.split(' '),
	    });
	  },
	  on: {
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var app = this;
	      $(tabEl).find('.messagebar-init').each(function (index, messagebarEl) {
	        app.messagebar.destroy(messagebarEl);
	      });
	    },
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $(tabEl).find('.messagebar-init').each(function (index, messagebarEl) {
	        app.messagebar.create(Utils.extend({ el: messagebarEl }, $(messagebarEl).dataset()));
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.messagebar-init').each(function (index, messagebarEl) {
	        app.messagebar.destroy(messagebarEl);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.messagebar-init').each(function (index, messagebarEl) {
	        app.messagebar.create(Utils.extend({ el: messagebarEl }, $(messagebarEl).dataset()));
	      });
	    },
	  },
	  vnode: {
	    'messagebar-init': {
	      insert: function insert(vnode) {
	        var app = this;
	        var messagebarEl = vnode.elm;
	        app.messagebar.create(Utils.extend({ el: messagebarEl }, $(messagebarEl).dataset()));
	      },
	      destroy: function destroy(vnode) {
	        var app = this;
	        var messagebarEl = vnode.elm;
	        app.messagebar.destroy(messagebarEl);
	      },
	    },
	  },
	};

	var Browser = (function Browser() {
	  function isSafari() {
	    var ua = win.navigator.userAgent.toLowerCase();
	    return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
	  }
	  return {
	    isIE: !!win.navigator.userAgent.match(/Trident/g) || !!win.navigator.userAgent.match(/MSIE/g),
	    isSafari: isSafari(),
	    isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent),
	  };
	}());

	function updateSize () {
	  var swiper = this;
	  var width;
	  var height;
	  var $el = swiper.$el;
	  if (typeof swiper.params.width !== 'undefined') {
	    width = swiper.params.width;
	  } else {
	    width = $el[0].clientWidth;
	  }
	  if (typeof swiper.params.height !== 'undefined') {
	    height = swiper.params.height;
	  } else {
	    height = $el[0].clientHeight;
	  }
	  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
	    return;
	  }

	  // Subtract paddings
	  width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
	  height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);

	  Utils.extend(swiper, {
	    width: width,
	    height: height,
	    size: swiper.isHorizontal() ? width : height,
	  });
	}

	function updateSlides () {
	  var swiper = this;
	  var params = swiper.params;

	  var $wrapperEl = swiper.$wrapperEl;
	  var swiperSize = swiper.size;
	  var rtl = swiper.rtlTranslate;
	  var wrongRTL = swiper.wrongRTL;
	  var isVirtual = swiper.virtual && params.virtual.enabled;
	  var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
	  var slides = $wrapperEl.children(("." + (swiper.params.slideClass)));
	  var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
	  var snapGrid = [];
	  var slidesGrid = [];
	  var slidesSizesGrid = [];

	  var offsetBefore = params.slidesOffsetBefore;
	  if (typeof offsetBefore === 'function') {
	    offsetBefore = params.slidesOffsetBefore.call(swiper);
	  }

	  var offsetAfter = params.slidesOffsetAfter;
	  if (typeof offsetAfter === 'function') {
	    offsetAfter = params.slidesOffsetAfter.call(swiper);
	  }

	  var previousSnapGridLength = swiper.snapGrid.length;
	  var previousSlidesGridLength = swiper.snapGrid.length;

	  var spaceBetween = params.spaceBetween;
	  var slidePosition = -offsetBefore;
	  var prevSlideSize = 0;
	  var index = 0;
	  if (typeof swiperSize === 'undefined') {
	    return;
	  }
	  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
	    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
	  }

	  swiper.virtualSize = -spaceBetween;

	  // reset margins
	  if (rtl) { slides.css({ marginLeft: '', marginTop: '' }); }
	  else { slides.css({ marginRight: '', marginBottom: '' }); }

	  var slidesNumberEvenToRows;
	  if (params.slidesPerColumn > 1) {
	    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
	      slidesNumberEvenToRows = slidesLength;
	    } else {
	      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
	    }
	    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
	      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
	    }
	  }

	  // Calc slides
	  var slideSize;
	  var slidesPerColumn = params.slidesPerColumn;
	  var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
	  var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
	  for (var i = 0; i < slidesLength; i += 1) {
	    slideSize = 0;
	    var slide = slides.eq(i);
	    if (params.slidesPerColumn > 1) {
	      // Set slides order
	      var newSlideOrderIndex = (void 0);
	      var column = (void 0);
	      var row = (void 0);
	      if (params.slidesPerColumnFill === 'column') {
	        column = Math.floor(i / slidesPerColumn);
	        row = i - (column * slidesPerColumn);
	        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
	          row += 1;
	          if (row >= slidesPerColumn) {
	            row = 0;
	            column += 1;
	          }
	        }
	        newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
	        slide
	          .css({
	            '-webkit-box-ordinal-group': newSlideOrderIndex,
	            '-moz-box-ordinal-group': newSlideOrderIndex,
	            '-ms-flex-order': newSlideOrderIndex,
	            '-webkit-order': newSlideOrderIndex,
	            order: newSlideOrderIndex,
	          });
	      } else {
	        row = Math.floor(i / slidesPerRow);
	        column = i - (row * slidesPerRow);
	      }
	      slide
	        .css(
	          ("margin-" + (swiper.isHorizontal() ? 'top' : 'left')),
	          (row !== 0 && params.spaceBetween) && (((params.spaceBetween) + "px"))
	        )
	        .attr('data-swiper-column', column)
	        .attr('data-swiper-row', row);
	    }
	    if (slide.css('display') === 'none') { continue; } // eslint-disable-line

	    if (params.slidesPerView === 'auto') {
	      var slideStyles = win.getComputedStyle(slide[0], null);
	      var currentTransform = slide[0].style.transform;
	      var currentWebKitTransform = slide[0].style.webkitTransform;
	      if (currentTransform) {
	        slide[0].style.transform = 'none';
	      }
	      if (currentWebKitTransform) {
	        slide[0].style.webkitTransform = 'none';
	      }
	      if (params.roundLengths) {
	        slideSize = swiper.isHorizontal()
	          ? slide.outerWidth(true)
	          : slide.outerHeight(true);
	      } else {
	        // eslint-disable-next-line
	        if (swiper.isHorizontal()) {
	          var width = parseFloat(slideStyles.getPropertyValue('width'));
	          var paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
	          var paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
	          var marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
	          var marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
	          var boxSizing = slideStyles.getPropertyValue('box-sizing');
	          if (boxSizing && boxSizing === 'border-box') {
	            slideSize = width + marginLeft + marginRight;
	          } else {
	            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
	          }
	        } else {
	          var height = parseFloat(slideStyles.getPropertyValue('height'));
	          var paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
	          var paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
	          var marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
	          var marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
	          var boxSizing$1 = slideStyles.getPropertyValue('box-sizing');
	          if (boxSizing$1 && boxSizing$1 === 'border-box') {
	            slideSize = height + marginTop + marginBottom;
	          } else {
	            slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
	          }
	        }
	      }
	      if (currentTransform) {
	        slide[0].style.transform = currentTransform;
	      }
	      if (currentWebKitTransform) {
	        slide[0].style.webkitTransform = currentWebKitTransform;
	      }
	      if (params.roundLengths) { slideSize = Math.floor(slideSize); }
	    } else {
	      slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
	      if (params.roundLengths) { slideSize = Math.floor(slideSize); }

	      if (slides[i]) {
	        if (swiper.isHorizontal()) {
	          slides[i].style.width = slideSize + "px";
	        } else {
	          slides[i].style.height = slideSize + "px";
	        }
	      }
	    }
	    if (slides[i]) {
	      slides[i].swiperSlideSize = slideSize;
	    }
	    slidesSizesGrid.push(slideSize);


	    if (params.centeredSlides) {
	      slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
	      if (prevSlideSize === 0 && i !== 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }
	      if (i === 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }
	      if (Math.abs(slidePosition) < 1 / 1000) { slidePosition = 0; }
	      if (params.roundLengths) { slidePosition = Math.floor(slidePosition); }
	      if ((index) % params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }
	      slidesGrid.push(slidePosition);
	    } else {
	      if (params.roundLengths) { slidePosition = Math.floor(slidePosition); }
	      if ((index) % params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }
	      slidesGrid.push(slidePosition);
	      slidePosition = slidePosition + slideSize + spaceBetween;
	    }

	    swiper.virtualSize += slideSize + spaceBetween;

	    prevSlideSize = slideSize;

	    index += 1;
	  }
	  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
	  var newSlidesGrid;

	  if (
	    rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
	    $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") });
	  }
	  if (!Support.flexbox || params.setWrapperSize) {
	    if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
	    else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
	  }

	  if (params.slidesPerColumn > 1) {
	    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
	    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
	    if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
	    else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
	    if (params.centeredSlides) {
	      newSlidesGrid = [];
	      for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {
	        var slidesGridItem = snapGrid[i$1];
	        if (params.roundLengths) { slidesGridItem = Math.floor(slidesGridItem); }
	        if (snapGrid[i$1] < swiper.virtualSize + snapGrid[0]) { newSlidesGrid.push(slidesGridItem); }
	      }
	      snapGrid = newSlidesGrid;
	    }
	  }

	  // Remove last grid elements depending on width
	  if (!params.centeredSlides) {
	    newSlidesGrid = [];
	    for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {
	      var slidesGridItem$1 = snapGrid[i$2];
	      if (params.roundLengths) { slidesGridItem$1 = Math.floor(slidesGridItem$1); }
	      if (snapGrid[i$2] <= swiper.virtualSize - swiperSize) {
	        newSlidesGrid.push(slidesGridItem$1);
	      }
	    }
	    snapGrid = newSlidesGrid;
	    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
	      snapGrid.push(swiper.virtualSize - swiperSize);
	    }
	  }
	  if (snapGrid.length === 0) { snapGrid = [0]; }

	  if (params.spaceBetween !== 0) {
	    if (swiper.isHorizontal()) {
	      if (rtl) { slides.css({ marginLeft: (spaceBetween + "px") }); }
	      else { slides.css({ marginRight: (spaceBetween + "px") }); }
	    } else { slides.css({ marginBottom: (spaceBetween + "px") }); }
	  }

	  if (params.centerInsufficientSlides) {
	    var allSlidesSize = 0;
	    slidesSizesGrid.forEach(function (slideSizeValue) {
	      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
	    });
	    allSlidesSize -= params.spaceBetween;
	    if (allSlidesSize < swiperSize) {
	      var allSlidesOffset = (swiperSize - allSlidesSize) / 2;
	      snapGrid.forEach(function (snap, snapIndex) {
	        snapGrid[snapIndex] = snap - allSlidesOffset;
	      });
	      slidesGrid.forEach(function (snap, snapIndex) {
	        slidesGrid[snapIndex] = snap + allSlidesOffset;
	      });
	    }
	  }

	  Utils.extend(swiper, {
	    slides: slides,
	    snapGrid: snapGrid,
	    slidesGrid: slidesGrid,
	    slidesSizesGrid: slidesSizesGrid,
	  });

	  if (slidesLength !== previousSlidesLength) {
	    swiper.emit('slidesLengthChange');
	  }
	  if (snapGrid.length !== previousSnapGridLength) {
	    if (swiper.params.watchOverflow) { swiper.checkOverflow(); }
	    swiper.emit('snapGridLengthChange');
	  }
	  if (slidesGrid.length !== previousSlidesGridLength) {
	    swiper.emit('slidesGridLengthChange');
	  }

	  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
	    swiper.updateSlidesOffset();
	  }
	}

	function updateAutoHeight (speed) {
	  var swiper = this;
	  var activeSlides = [];
	  var newHeight = 0;
	  var i;
	  if (typeof speed === 'number') {
	    swiper.setTransition(speed);
	  } else if (speed === true) {
	    swiper.setTransition(swiper.params.speed);
	  }
	  // Find slides currently in view
	  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
	    for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
	      var index = swiper.activeIndex + i;
	      if (index > swiper.slides.length) { break; }
	      activeSlides.push(swiper.slides.eq(index)[0]);
	    }
	  } else {
	    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
	  }

	  // Find new height from highest slide in view
	  for (i = 0; i < activeSlides.length; i += 1) {
	    if (typeof activeSlides[i] !== 'undefined') {
	      var height = activeSlides[i].offsetHeight;
	      newHeight = height > newHeight ? height : newHeight;
	    }
	  }

	  // Update Height
	  if (newHeight) { swiper.$wrapperEl.css('height', (newHeight + "px")); }
	}

	function updateSlidesOffset () {
	  var swiper = this;
	  var slides = swiper.slides;
	  for (var i = 0; i < slides.length; i += 1) {
	    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
	  }
	}

	function updateSlidesProgress (translate) {
	  if ( translate === void 0 ) translate = (this && this.translate) || 0;

	  var swiper = this;
	  var params = swiper.params;

	  var slides = swiper.slides;
	  var rtl = swiper.rtlTranslate;

	  if (slides.length === 0) { return; }
	  if (typeof slides[0].swiperSlideOffset === 'undefined') { swiper.updateSlidesOffset(); }

	  var offsetCenter = -translate;
	  if (rtl) { offsetCenter = translate; }

	  // Visible Slides
	  slides.removeClass(params.slideVisibleClass);

	  swiper.visibleSlidesIndexes = [];
	  swiper.visibleSlides = [];

	  for (var i = 0; i < slides.length; i += 1) {
	    var slide = slides[i];
	    var slideProgress = (
	      (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset
	    ) / (slide.swiperSlideSize + params.spaceBetween);
	    if (params.watchSlidesVisibility) {
	      var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
	      var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
	      var isVisible = (slideBefore >= 0 && slideBefore < swiper.size)
	                || (slideAfter > 0 && slideAfter <= swiper.size)
	                || (slideBefore <= 0 && slideAfter >= swiper.size);
	      if (isVisible) {
	        swiper.visibleSlides.push(slide);
	        swiper.visibleSlidesIndexes.push(i);
	        slides.eq(i).addClass(params.slideVisibleClass);
	      }
	    }
	    slide.progress = rtl ? -slideProgress : slideProgress;
	  }
	  swiper.visibleSlides = $(swiper.visibleSlides);
	}

	function updateProgress (translate) {
	  if ( translate === void 0 ) translate = (this && this.translate) || 0;

	  var swiper = this;
	  var params = swiper.params;

	  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
	  var progress = swiper.progress;
	  var isBeginning = swiper.isBeginning;
	  var isEnd = swiper.isEnd;
	  var wasBeginning = isBeginning;
	  var wasEnd = isEnd;
	  if (translatesDiff === 0) {
	    progress = 0;
	    isBeginning = true;
	    isEnd = true;
	  } else {
	    progress = (translate - swiper.minTranslate()) / (translatesDiff);
	    isBeginning = progress <= 0;
	    isEnd = progress >= 1;
	  }
	  Utils.extend(swiper, {
	    progress: progress,
	    isBeginning: isBeginning,
	    isEnd: isEnd,
	  });

	  if (params.watchSlidesProgress || params.watchSlidesVisibility) { swiper.updateSlidesProgress(translate); }

	  if (isBeginning && !wasBeginning) {
	    swiper.emit('reachBeginning toEdge');
	  }
	  if (isEnd && !wasEnd) {
	    swiper.emit('reachEnd toEdge');
	  }
	  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
	    swiper.emit('fromEdge');
	  }

	  swiper.emit('progress', progress);
	}

	function updateSlidesClasses () {
	  var swiper = this;

	  var slides = swiper.slides;
	  var params = swiper.params;
	  var $wrapperEl = swiper.$wrapperEl;
	  var activeIndex = swiper.activeIndex;
	  var realIndex = swiper.realIndex;
	  var isVirtual = swiper.virtual && params.virtual.enabled;

	  slides.removeClass(((params.slideActiveClass) + " " + (params.slideNextClass) + " " + (params.slidePrevClass) + " " + (params.slideDuplicateActiveClass) + " " + (params.slideDuplicateNextClass) + " " + (params.slideDuplicatePrevClass)));

	  var activeSlide;
	  if (isVirtual) {
	    activeSlide = swiper.$wrapperEl.find(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + activeIndex + "\"]"));
	  } else {
	    activeSlide = slides.eq(activeIndex);
	  }

	  // Active classes
	  activeSlide.addClass(params.slideActiveClass);

	  if (params.loop) {
	    // Duplicate to all looped slides
	    if (activeSlide.hasClass(params.slideDuplicateClass)) {
	      $wrapperEl
	        .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + realIndex + "\"]"))
	        .addClass(params.slideDuplicateActiveClass);
	    } else {
	      $wrapperEl
	        .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]"))
	        .addClass(params.slideDuplicateActiveClass);
	    }
	  }
	  // Next Slide
	  var nextSlide = activeSlide.nextAll(("." + (params.slideClass))).eq(0).addClass(params.slideNextClass);
	  if (params.loop && nextSlide.length === 0) {
	    nextSlide = slides.eq(0);
	    nextSlide.addClass(params.slideNextClass);
	  }
	  // Prev Slide
	  var prevSlide = activeSlide.prevAll(("." + (params.slideClass))).eq(0).addClass(params.slidePrevClass);
	  if (params.loop && prevSlide.length === 0) {
	    prevSlide = slides.eq(-1);
	    prevSlide.addClass(params.slidePrevClass);
	  }
	  if (params.loop) {
	    // Duplicate to all looped slides
	    if (nextSlide.hasClass(params.slideDuplicateClass)) {
	      $wrapperEl
	        .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + (nextSlide.attr('data-swiper-slide-index')) + "\"]"))
	        .addClass(params.slideDuplicateNextClass);
	    } else {
	      $wrapperEl
	        .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + (nextSlide.attr('data-swiper-slide-index')) + "\"]"))
	        .addClass(params.slideDuplicateNextClass);
	    }
	    if (prevSlide.hasClass(params.slideDuplicateClass)) {
	      $wrapperEl
	        .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + (prevSlide.attr('data-swiper-slide-index')) + "\"]"))
	        .addClass(params.slideDuplicatePrevClass);
	    } else {
	      $wrapperEl
	        .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + (prevSlide.attr('data-swiper-slide-index')) + "\"]"))
	        .addClass(params.slideDuplicatePrevClass);
	    }
	  }
	}

	function updateActiveIndex (newActiveIndex) {
	  var swiper = this;
	  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
	  var slidesGrid = swiper.slidesGrid;
	  var snapGrid = swiper.snapGrid;
	  var params = swiper.params;
	  var previousIndex = swiper.activeIndex;
	  var previousRealIndex = swiper.realIndex;
	  var previousSnapIndex = swiper.snapIndex;
	  var activeIndex = newActiveIndex;
	  var snapIndex;
	  if (typeof activeIndex === 'undefined') {
	    for (var i = 0; i < slidesGrid.length; i += 1) {
	      if (typeof slidesGrid[i + 1] !== 'undefined') {
	        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
	          activeIndex = i;
	        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
	          activeIndex = i + 1;
	        }
	      } else if (translate >= slidesGrid[i]) {
	        activeIndex = i;
	      }
	    }
	    // Normalize slideIndex
	    if (params.normalizeSlideIndex) {
	      if (activeIndex < 0 || typeof activeIndex === 'undefined') { activeIndex = 0; }
	    }
	  }
	  if (snapGrid.indexOf(translate) >= 0) {
	    snapIndex = snapGrid.indexOf(translate);
	  } else {
	    snapIndex = Math.floor(activeIndex / params.slidesPerGroup);
	  }
	  if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }
	  if (activeIndex === previousIndex) {
	    if (snapIndex !== previousSnapIndex) {
	      swiper.snapIndex = snapIndex;
	      swiper.emit('snapIndexChange');
	    }
	    return;
	  }

	  // Get real index
	  var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);

	  Utils.extend(swiper, {
	    snapIndex: snapIndex,
	    realIndex: realIndex,
	    previousIndex: previousIndex,
	    activeIndex: activeIndex,
	  });
	  swiper.emit('activeIndexChange');
	  swiper.emit('snapIndexChange');
	  if (previousRealIndex !== realIndex) {
	    swiper.emit('realIndexChange');
	  }
	  swiper.emit('slideChange');
	}

	function updateClickedSlide (e) {
	  var swiper = this;
	  var params = swiper.params;
	  var slide = $(e.target).closest(("." + (params.slideClass)))[0];
	  var slideFound = false;
	  if (slide) {
	    for (var i = 0; i < swiper.slides.length; i += 1) {
	      if (swiper.slides[i] === slide) { slideFound = true; }
	    }
	  }

	  if (slide && slideFound) {
	    swiper.clickedSlide = slide;
	    if (swiper.virtual && swiper.params.virtual.enabled) {
	      swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
	    } else {
	      swiper.clickedIndex = $(slide).index();
	    }
	  } else {
	    swiper.clickedSlide = undefined;
	    swiper.clickedIndex = undefined;
	    return;
	  }
	  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
	    swiper.slideToClickedSlide();
	  }
	}

	var update = {
	  updateSize: updateSize,
	  updateSlides: updateSlides,
	  updateAutoHeight: updateAutoHeight,
	  updateSlidesOffset: updateSlidesOffset,
	  updateSlidesProgress: updateSlidesProgress,
	  updateProgress: updateProgress,
	  updateSlidesClasses: updateSlidesClasses,
	  updateActiveIndex: updateActiveIndex,
	  updateClickedSlide: updateClickedSlide,
	};

	function getTranslate (axis) {
	  if ( axis === void 0 ) axis = this.isHorizontal() ? 'x' : 'y';

	  var swiper = this;

	  var params = swiper.params;
	  var rtl = swiper.rtlTranslate;
	  var translate = swiper.translate;
	  var $wrapperEl = swiper.$wrapperEl;

	  if (params.virtualTranslate) {
	    return rtl ? -translate : translate;
	  }

	  var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
	  if (rtl) { currentTranslate = -currentTranslate; }

	  return currentTranslate || 0;
	}

	function setTranslate (translate, byController) {
	  var swiper = this;
	  var rtl = swiper.rtlTranslate;
	  var params = swiper.params;
	  var $wrapperEl = swiper.$wrapperEl;
	  var progress = swiper.progress;
	  var x = 0;
	  var y = 0;
	  var z = 0;

	  if (swiper.isHorizontal()) {
	    x = rtl ? -translate : translate;
	  } else {
	    y = translate;
	  }

	  if (params.roundLengths) {
	    x = Math.floor(x);
	    y = Math.floor(y);
	  }

	  if (!params.virtualTranslate) {
	    if (Support.transforms3d) { $wrapperEl.transform(("translate3d(" + x + "px, " + y + "px, " + z + "px)")); }
	    else { $wrapperEl.transform(("translate(" + x + "px, " + y + "px)")); }
	  }
	  swiper.previousTranslate = swiper.translate;
	  swiper.translate = swiper.isHorizontal() ? x : y;

	  // Check if we need to update progress
	  var newProgress;
	  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
	  if (translatesDiff === 0) {
	    newProgress = 0;
	  } else {
	    newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
	  }
	  if (newProgress !== progress) {
	    swiper.updateProgress(translate);
	  }

	  swiper.emit('setTranslate', swiper.translate, byController);
	}

	function minTranslate () {
	  return (-this.snapGrid[0]);
	}

	function maxTranslate () {
	  return (-this.snapGrid[this.snapGrid.length - 1]);
	}

	var translate = {
	  getTranslate: getTranslate,
	  setTranslate: setTranslate,
	  minTranslate: minTranslate,
	  maxTranslate: maxTranslate,
	};

	function setTransition (duration, byController) {
	  var swiper = this;

	  swiper.$wrapperEl.transition(duration);

	  swiper.emit('setTransition', duration, byController);
	}

	function transitionStart (runCallbacks, direction) {
	  if ( runCallbacks === void 0 ) runCallbacks = true;

	  var swiper = this;
	  var activeIndex = swiper.activeIndex;
	  var params = swiper.params;
	  var previousIndex = swiper.previousIndex;
	  if (params.autoHeight) {
	    swiper.updateAutoHeight();
	  }

	  var dir = direction;
	  if (!dir) {
	    if (activeIndex > previousIndex) { dir = 'next'; }
	    else if (activeIndex < previousIndex) { dir = 'prev'; }
	    else { dir = 'reset'; }
	  }

	  swiper.emit('transitionStart');

	  if (runCallbacks && activeIndex !== previousIndex) {
	    if (dir === 'reset') {
	      swiper.emit('slideResetTransitionStart');
	      return;
	    }
	    swiper.emit('slideChangeTransitionStart');
	    if (dir === 'next') {
	      swiper.emit('slideNextTransitionStart');
	    } else {
	      swiper.emit('slidePrevTransitionStart');
	    }
	  }
	}

	function transitionEnd$1 (runCallbacks, direction) {
	  if ( runCallbacks === void 0 ) runCallbacks = true;

	  var swiper = this;
	  var activeIndex = swiper.activeIndex;
	  var previousIndex = swiper.previousIndex;
	  swiper.animating = false;
	  swiper.setTransition(0);

	  var dir = direction;
	  if (!dir) {
	    if (activeIndex > previousIndex) { dir = 'next'; }
	    else if (activeIndex < previousIndex) { dir = 'prev'; }
	    else { dir = 'reset'; }
	  }

	  swiper.emit('transitionEnd');

	  if (runCallbacks && activeIndex !== previousIndex) {
	    if (dir === 'reset') {
	      swiper.emit('slideResetTransitionEnd');
	      return;
	    }
	    swiper.emit('slideChangeTransitionEnd');
	    if (dir === 'next') {
	      swiper.emit('slideNextTransitionEnd');
	    } else {
	      swiper.emit('slidePrevTransitionEnd');
	    }
	  }
	}

	var transition$1 = {
	  setTransition: setTransition,
	  transitionStart: transitionStart,
	  transitionEnd: transitionEnd$1,
	};

	function slideTo (index, speed, runCallbacks, internal) {
	  if ( index === void 0 ) index = 0;
	  if ( speed === void 0 ) speed = this.params.speed;
	  if ( runCallbacks === void 0 ) runCallbacks = true;

	  var swiper = this;
	  var slideIndex = index;
	  if (slideIndex < 0) { slideIndex = 0; }

	  var params = swiper.params;
	  var snapGrid = swiper.snapGrid;
	  var slidesGrid = swiper.slidesGrid;
	  var previousIndex = swiper.previousIndex;
	  var activeIndex = swiper.activeIndex;
	  var rtl = swiper.rtlTranslate;
	  if (swiper.animating && params.preventInteractionOnTransition) {
	    return false;
	  }

	  var snapIndex = Math.floor(slideIndex / params.slidesPerGroup);
	  if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }

	  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
	    swiper.emit('beforeSlideChangeStart');
	  }

	  var translate = -snapGrid[snapIndex];

	  // Update progress
	  swiper.updateProgress(translate);

	  // Normalize slideIndex
	  if (params.normalizeSlideIndex) {
	    for (var i = 0; i < slidesGrid.length; i += 1) {
	      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
	        slideIndex = i;
	      }
	    }
	  }
	  // Directions locks
	  if (swiper.initialized && slideIndex !== activeIndex) {
	    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
	      return false;
	    }
	    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
	      if ((activeIndex || 0) !== slideIndex) { return false; }
	    }
	  }

	  var direction;
	  if (slideIndex > activeIndex) { direction = 'next'; }
	  else if (slideIndex < activeIndex) { direction = 'prev'; }
	  else { direction = 'reset'; }


	  // Update Index
	  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
	    swiper.updateActiveIndex(slideIndex);
	    // Update Height
	    if (params.autoHeight) {
	      swiper.updateAutoHeight();
	    }
	    swiper.updateSlidesClasses();
	    if (params.effect !== 'slide') {
	      swiper.setTranslate(translate);
	    }
	    if (direction !== 'reset') {
	      swiper.transitionStart(runCallbacks, direction);
	      swiper.transitionEnd(runCallbacks, direction);
	    }
	    return false;
	  }

	  if (speed === 0 || !Support.transition) {
	    swiper.setTransition(0);
	    swiper.setTranslate(translate);
	    swiper.updateActiveIndex(slideIndex);
	    swiper.updateSlidesClasses();
	    swiper.emit('beforeTransitionStart', speed, internal);
	    swiper.transitionStart(runCallbacks, direction);
	    swiper.transitionEnd(runCallbacks, direction);
	  } else {
	    swiper.setTransition(speed);
	    swiper.setTranslate(translate);
	    swiper.updateActiveIndex(slideIndex);
	    swiper.updateSlidesClasses();
	    swiper.emit('beforeTransitionStart', speed, internal);
	    swiper.transitionStart(runCallbacks, direction);
	    if (!swiper.animating) {
	      swiper.animating = true;
	      if (!swiper.onSlideToWrapperTransitionEnd) {
	        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
	          if (!swiper || swiper.destroyed) { return; }
	          if (e.target !== this) { return; }
	          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
	          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
	          swiper.onSlideToWrapperTransitionEnd = null;
	          delete swiper.onSlideToWrapperTransitionEnd;
	          swiper.transitionEnd(runCallbacks, direction);
	        };
	      }
	      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
	      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
	    }
	  }

	  return true;
	}

	function slideToLoop (index, speed, runCallbacks, internal) {
	  if ( index === void 0 ) index = 0;
	  if ( speed === void 0 ) speed = this.params.speed;
	  if ( runCallbacks === void 0 ) runCallbacks = true;

	  var swiper = this;
	  var newIndex = index;
	  if (swiper.params.loop) {
	    newIndex += swiper.loopedSlides;
	  }

	  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideNext (speed, runCallbacks, internal) {
	  if ( speed === void 0 ) speed = this.params.speed;
	  if ( runCallbacks === void 0 ) runCallbacks = true;

	  var swiper = this;
	  var params = swiper.params;
	  var animating = swiper.animating;
	  if (params.loop) {
	    if (animating) { return false; }
	    swiper.loopFix();
	    // eslint-disable-next-line
	    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
	    return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
	  }
	  return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slidePrev (speed, runCallbacks, internal) {
	  if ( speed === void 0 ) speed = this.params.speed;
	  if ( runCallbacks === void 0 ) runCallbacks = true;

	  var swiper = this;
	  var params = swiper.params;
	  var animating = swiper.animating;
	  var snapGrid = swiper.snapGrid;
	  var slidesGrid = swiper.slidesGrid;
	  var rtlTranslate = swiper.rtlTranslate;

	  if (params.loop) {
	    if (animating) { return false; }
	    swiper.loopFix();
	    // eslint-disable-next-line
	    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
	  }
	  var translate = rtlTranslate ? swiper.translate : -swiper.translate;
	  function normalize(val) {
	    if (val < 0) { return -Math.floor(Math.abs(val)); }
	    return Math.floor(val);
	  }
	  var normalizedTranslate = normalize(translate);
	  var normalizedSnapGrid = snapGrid.map(function (val) { return normalize(val); });
	  var normalizedSlidesGrid = slidesGrid.map(function (val) { return normalize(val); });

	  var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
	  var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
	  var prevIndex;
	  if (typeof prevSnap !== 'undefined') {
	    prevIndex = slidesGrid.indexOf(prevSnap);
	    if (prevIndex < 0) { prevIndex = swiper.activeIndex - 1; }
	  }
	  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideReset (speed, runCallbacks, internal) {
	  if ( speed === void 0 ) speed = this.params.speed;
	  if ( runCallbacks === void 0 ) runCallbacks = true;

	  var swiper = this;
	  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideToClosest (speed, runCallbacks, internal) {
	  if ( speed === void 0 ) speed = this.params.speed;
	  if ( runCallbacks === void 0 ) runCallbacks = true;

	  var swiper = this;
	  var index = swiper.activeIndex;
	  var snapIndex = Math.floor(index / swiper.params.slidesPerGroup);

	  if (snapIndex < swiper.snapGrid.length - 1) {
	    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

	    var currentSnap = swiper.snapGrid[snapIndex];
	    var nextSnap = swiper.snapGrid[snapIndex + 1];

	    if ((translate - currentSnap) > (nextSnap - currentSnap) / 2) {
	      index = swiper.params.slidesPerGroup;
	    }
	  }

	  return swiper.slideTo(index, speed, runCallbacks, internal);
	}

	function slideToClickedSlide () {
	  var swiper = this;
	  var params = swiper.params;
	  var $wrapperEl = swiper.$wrapperEl;

	  var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
	  var slideToIndex = swiper.clickedIndex;
	  var realIndex;
	  if (params.loop) {
	    if (swiper.animating) { return; }
	    realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
	    if (params.centeredSlides) {
	      if (
	        (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))
	        || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))
	      ) {
	        swiper.loopFix();
	        slideToIndex = $wrapperEl
	          .children(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + (params.slideDuplicateClass) + ")"))
	          .eq(0)
	          .index();

	        Utils.nextTick(function () {
	          swiper.slideTo(slideToIndex);
	        });
	      } else {
	        swiper.slideTo(slideToIndex);
	      }
	    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
	      swiper.loopFix();
	      slideToIndex = $wrapperEl
	        .children(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + (params.slideDuplicateClass) + ")"))
	        .eq(0)
	        .index();

	      Utils.nextTick(function () {
	        swiper.slideTo(slideToIndex);
	      });
	    } else {
	      swiper.slideTo(slideToIndex);
	    }
	  } else {
	    swiper.slideTo(slideToIndex);
	  }
	}

	var slide = {
	  slideTo: slideTo,
	  slideToLoop: slideToLoop,
	  slideNext: slideNext,
	  slidePrev: slidePrev,
	  slideReset: slideReset,
	  slideToClosest: slideToClosest,
	  slideToClickedSlide: slideToClickedSlide,
	};

	function loopCreate () {
	  var swiper = this;
	  var params = swiper.params;
	  var $wrapperEl = swiper.$wrapperEl;
	  // Remove duplicated slides
	  $wrapperEl.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass))).remove();

	  var slides = $wrapperEl.children(("." + (params.slideClass)));

	  if (params.loopFillGroupWithBlank) {
	    var blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
	    if (blankSlidesNum !== params.slidesPerGroup) {
	      for (var i = 0; i < blankSlidesNum; i += 1) {
	        var blankNode = $(doc.createElement('div')).addClass(((params.slideClass) + " " + (params.slideBlankClass)));
	        $wrapperEl.append(blankNode);
	      }
	      slides = $wrapperEl.children(("." + (params.slideClass)));
	    }
	  }

	  if (params.slidesPerView === 'auto' && !params.loopedSlides) { params.loopedSlides = slides.length; }

	  swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);
	  swiper.loopedSlides += params.loopAdditionalSlides;
	  if (swiper.loopedSlides > slides.length) {
	    swiper.loopedSlides = slides.length;
	  }

	  var prependSlides = [];
	  var appendSlides = [];
	  slides.each(function (index, el) {
	    var slide = $(el);
	    if (index < swiper.loopedSlides) { appendSlides.push(el); }
	    if (index < slides.length && index >= slides.length - swiper.loopedSlides) { prependSlides.push(el); }
	    slide.attr('data-swiper-slide-index', index);
	  });
	  for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) {
	    $wrapperEl.append($(appendSlides[i$1].cloneNode(true)).addClass(params.slideDuplicateClass));
	  }
	  for (var i$2 = prependSlides.length - 1; i$2 >= 0; i$2 -= 1) {
	    $wrapperEl.prepend($(prependSlides[i$2].cloneNode(true)).addClass(params.slideDuplicateClass));
	  }
	}

	function loopFix () {
	  var swiper = this;
	  var params = swiper.params;
	  var activeIndex = swiper.activeIndex;
	  var slides = swiper.slides;
	  var loopedSlides = swiper.loopedSlides;
	  var allowSlidePrev = swiper.allowSlidePrev;
	  var allowSlideNext = swiper.allowSlideNext;
	  var snapGrid = swiper.snapGrid;
	  var rtl = swiper.rtlTranslate;
	  var newIndex;
	  swiper.allowSlidePrev = true;
	  swiper.allowSlideNext = true;

	  var snapTranslate = -snapGrid[activeIndex];
	  var diff = snapTranslate - swiper.getTranslate();


	  // Fix For Negative Oversliding
	  if (activeIndex < loopedSlides) {
	    newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
	    newIndex += loopedSlides;
	    var slideChanged = swiper.slideTo(newIndex, 0, false, true);
	    if (slideChanged && diff !== 0) {
	      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
	    }
	  } else if ((params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2) || (activeIndex >= slides.length - loopedSlides)) {
	    // Fix For Positive Oversliding
	    newIndex = -slides.length + activeIndex + loopedSlides;
	    newIndex += loopedSlides;
	    var slideChanged$1 = swiper.slideTo(newIndex, 0, false, true);
	    if (slideChanged$1 && diff !== 0) {
	      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
	    }
	  }
	  swiper.allowSlidePrev = allowSlidePrev;
	  swiper.allowSlideNext = allowSlideNext;
	}

	function loopDestroy () {
	  var swiper = this;
	  var $wrapperEl = swiper.$wrapperEl;
	  var params = swiper.params;
	  var slides = swiper.slides;
	  $wrapperEl.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + ",." + (params.slideClass) + "." + (params.slideBlankClass))).remove();
	  slides.removeAttr('data-swiper-slide-index');
	}

	var loop = {
	  loopCreate: loopCreate,
	  loopFix: loopFix,
	  loopDestroy: loopDestroy,
	};

	function setGrabCursor (moving) {
	  var swiper = this;
	  if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked)) { return; }
	  var el = swiper.el;
	  el.style.cursor = 'move';
	  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
	  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
	  el.style.cursor = moving ? 'grabbing' : 'grab';
	}

	function unsetGrabCursor () {
	  var swiper = this;
	  if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked)) { return; }
	  swiper.el.style.cursor = '';
	}

	var grabCursor = {
	  setGrabCursor: setGrabCursor,
	  unsetGrabCursor: unsetGrabCursor,
	};

	function appendSlide (slides) {
	  var swiper = this;
	  var $wrapperEl = swiper.$wrapperEl;
	  var params = swiper.params;
	  if (params.loop) {
	    swiper.loopDestroy();
	  }
	  if (typeof slides === 'object' && 'length' in slides) {
	    for (var i = 0; i < slides.length; i += 1) {
	      if (slides[i]) { $wrapperEl.append(slides[i]); }
	    }
	  } else {
	    $wrapperEl.append(slides);
	  }
	  if (params.loop) {
	    swiper.loopCreate();
	  }
	  if (!(params.observer && Support.observer)) {
	    swiper.update();
	  }
	}

	function prependSlide (slides) {
	  var swiper = this;
	  var params = swiper.params;
	  var $wrapperEl = swiper.$wrapperEl;
	  var activeIndex = swiper.activeIndex;

	  if (params.loop) {
	    swiper.loopDestroy();
	  }
	  var newActiveIndex = activeIndex + 1;
	  if (typeof slides === 'object' && 'length' in slides) {
	    for (var i = 0; i < slides.length; i += 1) {
	      if (slides[i]) { $wrapperEl.prepend(slides[i]); }
	    }
	    newActiveIndex = activeIndex + slides.length;
	  } else {
	    $wrapperEl.prepend(slides);
	  }
	  if (params.loop) {
	    swiper.loopCreate();
	  }
	  if (!(params.observer && Support.observer)) {
	    swiper.update();
	  }
	  swiper.slideTo(newActiveIndex, 0, false);
	}

	function addSlide (index, slides) {
	  var swiper = this;
	  var $wrapperEl = swiper.$wrapperEl;
	  var params = swiper.params;
	  var activeIndex = swiper.activeIndex;
	  var activeIndexBuffer = activeIndex;
	  if (params.loop) {
	    activeIndexBuffer -= swiper.loopedSlides;
	    swiper.loopDestroy();
	    swiper.slides = $wrapperEl.children(("." + (params.slideClass)));
	  }
	  var baseLength = swiper.slides.length;
	  if (index <= 0) {
	    swiper.prependSlide(slides);
	    return;
	  }
	  if (index >= baseLength) {
	    swiper.appendSlide(slides);
	    return;
	  }
	  var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;

	  var slidesBuffer = [];
	  for (var i = baseLength - 1; i >= index; i -= 1) {
	    var currentSlide = swiper.slides.eq(i);
	    currentSlide.remove();
	    slidesBuffer.unshift(currentSlide);
	  }

	  if (typeof slides === 'object' && 'length' in slides) {
	    for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
	      if (slides[i$1]) { $wrapperEl.append(slides[i$1]); }
	    }
	    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
	  } else {
	    $wrapperEl.append(slides);
	  }

	  for (var i$2 = 0; i$2 < slidesBuffer.length; i$2 += 1) {
	    $wrapperEl.append(slidesBuffer[i$2]);
	  }

	  if (params.loop) {
	    swiper.loopCreate();
	  }
	  if (!(params.observer && Support.observer)) {
	    swiper.update();
	  }
	  if (params.loop) {
	    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
	  } else {
	    swiper.slideTo(newActiveIndex, 0, false);
	  }
	}

	function removeSlide (slidesIndexes) {
	  var swiper = this;
	  var params = swiper.params;
	  var $wrapperEl = swiper.$wrapperEl;
	  var activeIndex = swiper.activeIndex;

	  var activeIndexBuffer = activeIndex;
	  if (params.loop) {
	    activeIndexBuffer -= swiper.loopedSlides;
	    swiper.loopDestroy();
	    swiper.slides = $wrapperEl.children(("." + (params.slideClass)));
	  }
	  var newActiveIndex = activeIndexBuffer;
	  var indexToRemove;

	  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
	    for (var i = 0; i < slidesIndexes.length; i += 1) {
	      indexToRemove = slidesIndexes[i];
	      if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }
	      if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }
	    }
	    newActiveIndex = Math.max(newActiveIndex, 0);
	  } else {
	    indexToRemove = slidesIndexes;
	    if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }
	    if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }
	    newActiveIndex = Math.max(newActiveIndex, 0);
	  }

	  if (params.loop) {
	    swiper.loopCreate();
	  }

	  if (!(params.observer && Support.observer)) {
	    swiper.update();
	  }
	  if (params.loop) {
	    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
	  } else {
	    swiper.slideTo(newActiveIndex, 0, false);
	  }
	}

	function removeAllSlides () {
	  var swiper = this;

	  var slidesIndexes = [];
	  for (var i = 0; i < swiper.slides.length; i += 1) {
	    slidesIndexes.push(i);
	  }
	  swiper.removeSlide(slidesIndexes);
	}

	var manipulation = {
	  appendSlide: appendSlide,
	  prependSlide: prependSlide,
	  addSlide: addSlide,
	  removeSlide: removeSlide,
	  removeAllSlides: removeAllSlides,
	};

	function onTouchStart (event) {
	  var swiper = this;
	  var data = swiper.touchEventsData;
	  var params = swiper.params;
	  var touches = swiper.touches;
	  if (swiper.animating && params.preventInteractionOnTransition) {
	    return;
	  }
	  var e = event;
	  if (e.originalEvent) { e = e.originalEvent; }
	  data.isTouchEvent = e.type === 'touchstart';
	  if (!data.isTouchEvent && 'which' in e && e.which === 3) { return; }
	  if (!data.isTouchEvent && 'button' in e && e.button > 0) { return; }
	  if (data.isTouched && data.isMoved) { return; }
	  if (params.noSwiping && $(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : ("." + (params.noSwipingClass)))[0]) {
	    swiper.allowClick = true;
	    return;
	  }
	  if (params.swipeHandler) {
	    if (!$(e).closest(params.swipeHandler)[0]) { return; }
	  }

	  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	  var startX = touches.currentX;
	  var startY = touches.currentY;

	  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore

	  var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
	  var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
	  if (
	    edgeSwipeDetection
	    && ((startX <= edgeSwipeThreshold)
	    || (startX >= win.screen.width - edgeSwipeThreshold))
	  ) {
	    return;
	  }

	  Utils.extend(data, {
	    isTouched: true,
	    isMoved: false,
	    allowTouchCallbacks: true,
	    isScrolling: undefined,
	    startMoving: undefined,
	  });

	  touches.startX = startX;
	  touches.startY = startY;
	  data.touchStartTime = Utils.now();
	  swiper.allowClick = true;
	  swiper.updateSize();
	  swiper.swipeDirection = undefined;
	  if (params.threshold > 0) { data.allowThresholdMove = false; }
	  if (e.type !== 'touchstart') {
	    var preventDefault = true;
	    if ($(e.target).is(data.formElements)) { preventDefault = false; }
	    if (
	      doc.activeElement
	      && $(doc.activeElement).is(data.formElements)
	      && doc.activeElement !== e.target
	    ) {
	      doc.activeElement.blur();
	    }

	    var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
	    if (params.touchStartForcePreventDefault || shouldPreventDefault) {
	      e.preventDefault();
	    }
	  }
	  swiper.emit('touchStart', e);
	}

	function onTouchMove (event) {
	  var swiper = this;
	  var data = swiper.touchEventsData;
	  var params = swiper.params;
	  var touches = swiper.touches;
	  var rtl = swiper.rtlTranslate;
	  var e = event;
	  if (e.originalEvent) { e = e.originalEvent; }
	  if (!data.isTouched) {
	    if (data.startMoving && data.isScrolling) {
	      swiper.emit('touchMoveOpposite', e);
	    }
	    return;
	  }
	  if (data.isTouchEvent && e.type === 'mousemove') { return; }
	  var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	  var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	  if (e.preventedByNestedSwiper) {
	    touches.startX = pageX;
	    touches.startY = pageY;
	    return;
	  }
	  if (!swiper.allowTouchMove) {
	    // isMoved = true;
	    swiper.allowClick = false;
	    if (data.isTouched) {
	      Utils.extend(touches, {
	        startX: pageX,
	        startY: pageY,
	        currentX: pageX,
	        currentY: pageY,
	      });
	      data.touchStartTime = Utils.now();
	    }
	    return;
	  }
	  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
	    if (swiper.isVertical()) {
	      // Vertical
	      if (
	        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())
	        || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())
	      ) {
	        data.isTouched = false;
	        data.isMoved = false;
	        return;
	      }
	    } else if (
	      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())
	      || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())
	    ) {
	      return;
	    }
	  }
	  if (data.isTouchEvent && doc.activeElement) {
	    if (e.target === doc.activeElement && $(e.target).is(data.formElements)) {
	      data.isMoved = true;
	      swiper.allowClick = false;
	      return;
	    }
	  }
	  if (data.allowTouchCallbacks) {
	    swiper.emit('touchMove', e);
	  }
	  if (e.targetTouches && e.targetTouches.length > 1) { return; }

	  touches.currentX = pageX;
	  touches.currentY = pageY;

	  var diffX = touches.currentX - touches.startX;
	  var diffY = touches.currentY - touches.startY;
	  if (swiper.params.threshold && Math.sqrt((Math.pow( diffX, 2 )) + (Math.pow( diffY, 2 ))) < swiper.params.threshold) { return; }

	  if (typeof data.isScrolling === 'undefined') {
	    var touchAngle;
	    if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
	      data.isScrolling = false;
	    } else {
	      // eslint-disable-next-line
	      if ((diffX * diffX) + (diffY * diffY) >= 25) {
	        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
	        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
	      }
	    }
	  }
	  if (data.isScrolling) {
	    swiper.emit('touchMoveOpposite', e);
	  }
	  if (typeof data.startMoving === 'undefined') {
	    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
	      data.startMoving = true;
	    }
	  }
	  if (data.isScrolling) {
	    data.isTouched = false;
	    return;
	  }
	  if (!data.startMoving) {
	    return;
	  }
	  swiper.allowClick = false;
	  e.preventDefault();
	  if (params.touchMoveStopPropagation && !params.nested) {
	    e.stopPropagation();
	  }

	  if (!data.isMoved) {
	    if (params.loop) {
	      swiper.loopFix();
	    }
	    data.startTranslate = swiper.getTranslate();
	    swiper.setTransition(0);
	    if (swiper.animating) {
	      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
	    }
	    data.allowMomentumBounce = false;
	    // Grab Cursor
	    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
	      swiper.setGrabCursor(true);
	    }
	    swiper.emit('sliderFirstMove', e);
	  }
	  swiper.emit('sliderMove', e);
	  data.isMoved = true;

	  var diff = swiper.isHorizontal() ? diffX : diffY;
	  touches.diff = diff;

	  diff *= params.touchRatio;
	  if (rtl) { diff = -diff; }

	  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
	  data.currentTranslate = diff + data.startTranslate;

	  var disableParentSwiper = true;
	  var resistanceRatio = params.resistanceRatio;
	  if (params.touchReleaseOnEdges) {
	    resistanceRatio = 0;
	  }
	  if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {
	    disableParentSwiper = false;
	    if (params.resistance) { data.currentTranslate = (swiper.minTranslate() - 1) + (Math.pow( (-swiper.minTranslate() + data.startTranslate + diff), resistanceRatio )); }
	  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
	    disableParentSwiper = false;
	    if (params.resistance) { data.currentTranslate = (swiper.maxTranslate() + 1) - (Math.pow( (swiper.maxTranslate() - data.startTranslate - diff), resistanceRatio )); }
	  }

	  if (disableParentSwiper) {
	    e.preventedByNestedSwiper = true;
	  }

	  // Directions locks
	  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
	    data.currentTranslate = data.startTranslate;
	  }
	  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
	    data.currentTranslate = data.startTranslate;
	  }


	  // Threshold
	  if (params.threshold > 0) {
	    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
	      if (!data.allowThresholdMove) {
	        data.allowThresholdMove = true;
	        touches.startX = touches.currentX;
	        touches.startY = touches.currentY;
	        data.currentTranslate = data.startTranslate;
	        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
	        return;
	      }
	    } else {
	      data.currentTranslate = data.startTranslate;
	      return;
	    }
	  }

	  if (!params.followFinger) { return; }

	  // Update active index in free mode
	  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
	    swiper.updateActiveIndex();
	    swiper.updateSlidesClasses();
	  }
	  if (params.freeMode) {
	    // Velocity
	    if (data.velocities.length === 0) {
	      data.velocities.push({
	        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
	        time: data.touchStartTime,
	      });
	    }
	    data.velocities.push({
	      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
	      time: Utils.now(),
	    });
	  }
	  // Update progress
	  swiper.updateProgress(data.currentTranslate);
	  // Update translate
	  swiper.setTranslate(data.currentTranslate);
	}

	function onTouchEnd (event) {
	  var swiper = this;
	  var data = swiper.touchEventsData;

	  var params = swiper.params;
	  var touches = swiper.touches;
	  var rtl = swiper.rtlTranslate;
	  var $wrapperEl = swiper.$wrapperEl;
	  var slidesGrid = swiper.slidesGrid;
	  var snapGrid = swiper.snapGrid;
	  var e = event;
	  if (e.originalEvent) { e = e.originalEvent; }
	  if (data.allowTouchCallbacks) {
	    swiper.emit('touchEnd', e);
	  }
	  data.allowTouchCallbacks = false;
	  if (!data.isTouched) {
	    if (data.isMoved && params.grabCursor) {
	      swiper.setGrabCursor(false);
	    }
	    data.isMoved = false;
	    data.startMoving = false;
	    return;
	  }
	  // Return Grab Cursor
	  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
	    swiper.setGrabCursor(false);
	  }

	  // Time diff
	  var touchEndTime = Utils.now();
	  var timeDiff = touchEndTime - data.touchStartTime;

	  // Tap, doubleTap, Click
	  if (swiper.allowClick) {
	    swiper.updateClickedSlide(e);
	    swiper.emit('tap', e);
	    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) > 300) {
	      if (data.clickTimeout) { clearTimeout(data.clickTimeout); }
	      data.clickTimeout = Utils.nextTick(function () {
	        if (!swiper || swiper.destroyed) { return; }
	        swiper.emit('click', e);
	      }, 300);
	    }
	    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {
	      if (data.clickTimeout) { clearTimeout(data.clickTimeout); }
	      swiper.emit('doubleTap', e);
	    }
	  }

	  data.lastClickTime = Utils.now();
	  Utils.nextTick(function () {
	    if (!swiper.destroyed) { swiper.allowClick = true; }
	  });

	  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
	    data.isTouched = false;
	    data.isMoved = false;
	    data.startMoving = false;
	    return;
	  }
	  data.isTouched = false;
	  data.isMoved = false;
	  data.startMoving = false;

	  var currentPos;
	  if (params.followFinger) {
	    currentPos = rtl ? swiper.translate : -swiper.translate;
	  } else {
	    currentPos = -data.currentTranslate;
	  }

	  if (params.freeMode) {
	    if (currentPos < -swiper.minTranslate()) {
	      swiper.slideTo(swiper.activeIndex);
	      return;
	    }
	    if (currentPos > -swiper.maxTranslate()) {
	      if (swiper.slides.length < snapGrid.length) {
	        swiper.slideTo(snapGrid.length - 1);
	      } else {
	        swiper.slideTo(swiper.slides.length - 1);
	      }
	      return;
	    }

	    if (params.freeModeMomentum) {
	      if (data.velocities.length > 1) {
	        var lastMoveEvent = data.velocities.pop();
	        var velocityEvent = data.velocities.pop();

	        var distance = lastMoveEvent.position - velocityEvent.position;
	        var time = lastMoveEvent.time - velocityEvent.time;
	        swiper.velocity = distance / time;
	        swiper.velocity /= 2;
	        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
	          swiper.velocity = 0;
	        }
	        // this implies that the user stopped moving a finger then released.
	        // There would be no events with distance zero, so the last event is stale.
	        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
	          swiper.velocity = 0;
	        }
	      } else {
	        swiper.velocity = 0;
	      }
	      swiper.velocity *= params.freeModeMomentumVelocityRatio;

	      data.velocities.length = 0;
	      var momentumDuration = 1000 * params.freeModeMomentumRatio;
	      var momentumDistance = swiper.velocity * momentumDuration;

	      var newPosition = swiper.translate + momentumDistance;
	      if (rtl) { newPosition = -newPosition; }

	      var doBounce = false;
	      var afterBouncePosition;
	      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
	      var needsLoopFix;
	      if (newPosition < swiper.maxTranslate()) {
	        if (params.freeModeMomentumBounce) {
	          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
	            newPosition = swiper.maxTranslate() - bounceAmount;
	          }
	          afterBouncePosition = swiper.maxTranslate();
	          doBounce = true;
	          data.allowMomentumBounce = true;
	        } else {
	          newPosition = swiper.maxTranslate();
	        }
	        if (params.loop && params.centeredSlides) { needsLoopFix = true; }
	      } else if (newPosition > swiper.minTranslate()) {
	        if (params.freeModeMomentumBounce) {
	          if (newPosition - swiper.minTranslate() > bounceAmount) {
	            newPosition = swiper.minTranslate() + bounceAmount;
	          }
	          afterBouncePosition = swiper.minTranslate();
	          doBounce = true;
	          data.allowMomentumBounce = true;
	        } else {
	          newPosition = swiper.minTranslate();
	        }
	        if (params.loop && params.centeredSlides) { needsLoopFix = true; }
	      } else if (params.freeModeSticky) {
	        var nextSlide;
	        for (var j = 0; j < snapGrid.length; j += 1) {
	          if (snapGrid[j] > -newPosition) {
	            nextSlide = j;
	            break;
	          }
	        }

	        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
	          newPosition = snapGrid[nextSlide];
	        } else {
	          newPosition = snapGrid[nextSlide - 1];
	        }
	        newPosition = -newPosition;
	      }
	      if (needsLoopFix) {
	        swiper.once('transitionEnd', function () {
	          swiper.loopFix();
	        });
	      }
	      // Fix duration
	      if (swiper.velocity !== 0) {
	        if (rtl) {
	          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
	        } else {
	          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
	        }
	      } else if (params.freeModeSticky) {
	        swiper.slideToClosest();
	        return;
	      }

	      if (params.freeModeMomentumBounce && doBounce) {
	        swiper.updateProgress(afterBouncePosition);
	        swiper.setTransition(momentumDuration);
	        swiper.setTranslate(newPosition);
	        swiper.transitionStart(true, swiper.swipeDirection);
	        swiper.animating = true;
	        $wrapperEl.transitionEnd(function () {
	          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) { return; }
	          swiper.emit('momentumBounce');

	          swiper.setTransition(params.speed);
	          swiper.setTranslate(afterBouncePosition);
	          $wrapperEl.transitionEnd(function () {
	            if (!swiper || swiper.destroyed) { return; }
	            swiper.transitionEnd();
	          });
	        });
	      } else if (swiper.velocity) {
	        swiper.updateProgress(newPosition);
	        swiper.setTransition(momentumDuration);
	        swiper.setTranslate(newPosition);
	        swiper.transitionStart(true, swiper.swipeDirection);
	        if (!swiper.animating) {
	          swiper.animating = true;
	          $wrapperEl.transitionEnd(function () {
	            if (!swiper || swiper.destroyed) { return; }
	            swiper.transitionEnd();
	          });
	        }
	      } else {
	        swiper.updateProgress(newPosition);
	      }

	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    } else if (params.freeModeSticky) {
	      swiper.slideToClosest();
	      return;
	    }

	    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
	      swiper.updateProgress();
	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    }
	    return;
	  }

	  // Find current slide
	  var stopIndex = 0;
	  var groupSize = swiper.slidesSizesGrid[0];
	  for (var i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {
	    if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {
	      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {
	        stopIndex = i;
	        groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];
	      }
	    } else if (currentPos >= slidesGrid[i]) {
	      stopIndex = i;
	      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
	    }
	  }

	  // Find current slide size
	  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;

	  if (timeDiff > params.longSwipesMs) {
	    // Long touches
	    if (!params.longSwipes) {
	      swiper.slideTo(swiper.activeIndex);
	      return;
	    }
	    if (swiper.swipeDirection === 'next') {
	      if (ratio >= params.longSwipesRatio) { swiper.slideTo(stopIndex + params.slidesPerGroup); }
	      else { swiper.slideTo(stopIndex); }
	    }
	    if (swiper.swipeDirection === 'prev') {
	      if (ratio > (1 - params.longSwipesRatio)) { swiper.slideTo(stopIndex + params.slidesPerGroup); }
	      else { swiper.slideTo(stopIndex); }
	    }
	  } else {
	    // Short swipes
	    if (!params.shortSwipes) {
	      swiper.slideTo(swiper.activeIndex);
	      return;
	    }
	    if (swiper.swipeDirection === 'next') {
	      swiper.slideTo(stopIndex + params.slidesPerGroup);
	    }
	    if (swiper.swipeDirection === 'prev') {
	      swiper.slideTo(stopIndex);
	    }
	  }
	}

	function onResize () {
	  var swiper = this;

	  var params = swiper.params;
	  var el = swiper.el;

	  if (el && el.offsetWidth === 0) { return; }

	  // Breakpoints
	  if (params.breakpoints) {
	    swiper.setBreakpoint();
	  }

	  // Save locks
	  var allowSlideNext = swiper.allowSlideNext;
	  var allowSlidePrev = swiper.allowSlidePrev;
	  var snapGrid = swiper.snapGrid;

	  // Disable locks on resize
	  swiper.allowSlideNext = true;
	  swiper.allowSlidePrev = true;

	  swiper.updateSize();
	  swiper.updateSlides();

	  if (params.freeMode) {
	    var newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
	    swiper.setTranslate(newTranslate);
	    swiper.updateActiveIndex();
	    swiper.updateSlidesClasses();

	    if (params.autoHeight) {
	      swiper.updateAutoHeight();
	    }
	  } else {
	    swiper.updateSlidesClasses();
	    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
	      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
	    } else {
	      swiper.slideTo(swiper.activeIndex, 0, false, true);
	    }
	  }
	  // Return locks after resize
	  swiper.allowSlidePrev = allowSlidePrev;
	  swiper.allowSlideNext = allowSlideNext;

	  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
	    swiper.checkOverflow();
	  }
	}

	function onClick (e) {
	  var swiper = this;
	  if (!swiper.allowClick) {
	    if (swiper.params.preventClicks) { e.preventDefault(); }
	    if (swiper.params.preventClicksPropagation && swiper.animating) {
	      e.stopPropagation();
	      e.stopImmediatePropagation();
	    }
	  }
	}

	function attachEvents() {
	  var swiper = this;
	  var params = swiper.params;
	  var touchEvents = swiper.touchEvents;
	  var el = swiper.el;
	  var wrapperEl = swiper.wrapperEl;

	  {
	    swiper.onTouchStart = onTouchStart.bind(swiper);
	    swiper.onTouchMove = onTouchMove.bind(swiper);
	    swiper.onTouchEnd = onTouchEnd.bind(swiper);
	  }

	  swiper.onClick = onClick.bind(swiper);

	  var target = params.touchEventsTarget === 'container' ? el : wrapperEl;
	  var capture = !!params.nested;

	  // Touch Events
	  {
	    if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	      target.addEventListener(touchEvents.start, swiper.onTouchStart, false);
	      doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
	      doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
	    } else {
	      if (Support.touch) {
	        var passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
	        target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
	        target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture: capture } : capture);
	        target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
	      }
	      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
	        target.addEventListener('mousedown', swiper.onTouchStart, false);
	        doc.addEventListener('mousemove', swiper.onTouchMove, capture);
	        doc.addEventListener('mouseup', swiper.onTouchEnd, false);
	      }
	    }
	    // Prevent Links Clicks
	    if (params.preventClicks || params.preventClicksPropagation) {
	      target.addEventListener('click', swiper.onClick, true);
	    }
	  }

	  // Resize handler
	  swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);
	}

	function detachEvents() {
	  var swiper = this;

	  var params = swiper.params;
	  var touchEvents = swiper.touchEvents;
	  var el = swiper.el;
	  var wrapperEl = swiper.wrapperEl;

	  var target = params.touchEventsTarget === 'container' ? el : wrapperEl;
	  var capture = !!params.nested;

	  // Touch Events
	  {
	    if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	      target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
	      doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
	      doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
	    } else {
	      if (Support.touch) {
	        var passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
	        target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
	        target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
	        target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
	      }
	      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
	        target.removeEventListener('mousedown', swiper.onTouchStart, false);
	        doc.removeEventListener('mousemove', swiper.onTouchMove, capture);
	        doc.removeEventListener('mouseup', swiper.onTouchEnd, false);
	      }
	    }
	    // Prevent Links Clicks
	    if (params.preventClicks || params.preventClicksPropagation) {
	      target.removeEventListener('click', swiper.onClick, true);
	    }
	  }

	  // Resize handler
	  swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);
	}

	var events = {
	  attachEvents: attachEvents,
	  detachEvents: detachEvents,
	};

	function setBreakpoint () {
	  var swiper = this;
	  var activeIndex = swiper.activeIndex;
	  var initialized = swiper.initialized;
	  var loopedSlides = swiper.loopedSlides; if ( loopedSlides === void 0 ) loopedSlides = 0;
	  var params = swiper.params;
	  var breakpoints = params.breakpoints;
	  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) { return; }

	  // Set breakpoint for window width and update parameters
	  var breakpoint = swiper.getBreakpoint(breakpoints);

	  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
	    var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
	    if (breakpointOnlyParams) {
	      ['slidesPerView', 'spaceBetween', 'slidesPerGroup'].forEach(function (param) {
	        var paramValue = breakpointOnlyParams[param];
	        if (typeof paramValue === 'undefined') { return; }
	        if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
	          breakpointOnlyParams[param] = 'auto';
	        } else if (param === 'slidesPerView') {
	          breakpointOnlyParams[param] = parseFloat(paramValue);
	        } else {
	          breakpointOnlyParams[param] = parseInt(paramValue, 10);
	        }
	      });
	    }

	    var breakpointParams = breakpointOnlyParams || swiper.originalParams;
	    var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
	    var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

	    if (directionChanged && initialized) {
	      swiper.changeDirection();
	    }

	    Utils.extend(swiper.params, breakpointParams);

	    Utils.extend(swiper, {
	      allowTouchMove: swiper.params.allowTouchMove,
	      allowSlideNext: swiper.params.allowSlideNext,
	      allowSlidePrev: swiper.params.allowSlidePrev,
	    });

	    swiper.currentBreakpoint = breakpoint;

	    if (needsReLoop && initialized) {
	      swiper.loopDestroy();
	      swiper.loopCreate();
	      swiper.updateSlides();
	      swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
	    }

	    swiper.emit('breakpoint', breakpointParams);
	  }
	}

	function getBreakpoint (breakpoints) {
	  var swiper = this;
	  // Get breakpoint for window width
	  if (!breakpoints) { return undefined; }
	  var breakpoint = false;
	  var points = [];
	  Object.keys(breakpoints).forEach(function (point) {
	    points.push(point);
	  });
	  points.sort(function (a, b) { return parseInt(a, 10) - parseInt(b, 10); });
	  for (var i = 0; i < points.length; i += 1) {
	    var point = points[i];
	    if (swiper.params.breakpointsInverse) {
	      if (point <= win.innerWidth) {
	        breakpoint = point;
	      }
	    } else if (point >= win.innerWidth && !breakpoint) {
	      breakpoint = point;
	    }
	  }
	  return breakpoint || 'max';
	}

	var breakpoints = { setBreakpoint: setBreakpoint, getBreakpoint: getBreakpoint };

	function addClasses () {
	  var swiper = this;
	  var classNames = swiper.classNames;
	  var params = swiper.params;
	  var rtl = swiper.rtl;
	  var $el = swiper.$el;
	  var suffixes = [];

	  suffixes.push('initialized');
	  suffixes.push(params.direction);

	  if (params.freeMode) {
	    suffixes.push('free-mode');
	  }
	  if (!Support.flexbox) {
	    suffixes.push('no-flexbox');
	  }
	  if (params.autoHeight) {
	    suffixes.push('autoheight');
	  }
	  if (rtl) {
	    suffixes.push('rtl');
	  }
	  if (params.slidesPerColumn > 1) {
	    suffixes.push('multirow');
	  }
	  if (Device.android) {
	    suffixes.push('android');
	  }
	  if (Device.ios) {
	    suffixes.push('ios');
	  }
	  // WP8 Touch Events Fix
	  if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	    suffixes.push(("wp8-" + (params.direction)));
	  }

	  suffixes.forEach(function (suffix) {
	    classNames.push(params.containerModifierClass + suffix);
	  });

	  $el.addClass(classNames.join(' '));
	}

	function removeClasses () {
	  var swiper = this;
	  var $el = swiper.$el;
	  var classNames = swiper.classNames;

	  $el.removeClass(classNames.join(' '));
	}

	var classes = { addClasses: addClasses, removeClasses: removeClasses };

	function loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {
	  var image;
	  function onReady() {
	    if (callback) { callback(); }
	  }
	  if (!imageEl.complete || !checkForComplete) {
	    if (src) {
	      image = new win.Image();
	      image.onload = onReady;
	      image.onerror = onReady;
	      if (sizes) {
	        image.sizes = sizes;
	      }
	      if (srcset) {
	        image.srcset = srcset;
	      }
	      if (src) {
	        image.src = src;
	      }
	    } else {
	      onReady();
	    }
	  } else {
	    // image already loaded...
	    onReady();
	  }
	}

	function preloadImages () {
	  var swiper = this;
	  swiper.imagesToLoad = swiper.$el.find('img');
	  function onReady() {
	    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) { return; }
	    if (swiper.imagesLoaded !== undefined) { swiper.imagesLoaded += 1; }
	    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
	      if (swiper.params.updateOnImagesReady) { swiper.update(); }
	      swiper.emit('imagesReady');
	    }
	  }
	  for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
	    var imageEl = swiper.imagesToLoad[i];
	    swiper.loadImage(
	      imageEl,
	      imageEl.currentSrc || imageEl.getAttribute('src'),
	      imageEl.srcset || imageEl.getAttribute('srcset'),
	      imageEl.sizes || imageEl.getAttribute('sizes'),
	      true,
	      onReady
	    );
	  }
	}

	var images = {
	  loadImage: loadImage,
	  preloadImages: preloadImages,
	};

	function checkOverflow() {
	  var swiper = this;
	  var wasLocked = swiper.isLocked;

	  swiper.isLocked = swiper.snapGrid.length === 1;
	  swiper.allowSlideNext = !swiper.isLocked;
	  swiper.allowSlidePrev = !swiper.isLocked;

	  // events
	  if (wasLocked !== swiper.isLocked) { swiper.emit(swiper.isLocked ? 'lock' : 'unlock'); }

	  if (wasLocked && wasLocked !== swiper.isLocked) {
	    swiper.isEnd = false;
	    swiper.navigation.update();
	  }
	}

	var checkOverflow$1 = { checkOverflow: checkOverflow };

	var defaults = {
	  init: true,
	  direction: 'horizontal',
	  touchEventsTarget: 'container',
	  initialSlide: 0,
	  speed: 300,
	  //
	  preventInteractionOnTransition: false,

	  // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
	  edgeSwipeDetection: false,
	  edgeSwipeThreshold: 20,

	  // Free mode
	  freeMode: false,
	  freeModeMomentum: true,
	  freeModeMomentumRatio: 1,
	  freeModeMomentumBounce: true,
	  freeModeMomentumBounceRatio: 1,
	  freeModeMomentumVelocityRatio: 1,
	  freeModeSticky: false,
	  freeModeMinimumVelocity: 0.02,

	  // Autoheight
	  autoHeight: false,

	  // Set wrapper width
	  setWrapperSize: false,

	  // Virtual Translate
	  virtualTranslate: false,

	  // Effects
	  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

	  // Breakpoints
	  breakpoints: undefined,
	  breakpointsInverse: false,

	  // Slides grid
	  spaceBetween: 0,
	  slidesPerView: 1,
	  slidesPerColumn: 1,
	  slidesPerColumnFill: 'column',
	  slidesPerGroup: 1,
	  centeredSlides: false,
	  slidesOffsetBefore: 0, // in px
	  slidesOffsetAfter: 0, // in px
	  normalizeSlideIndex: true,
	  centerInsufficientSlides: false,

	  // Disable swiper and hide navigation when container not overflow
	  watchOverflow: false,

	  // Round length
	  roundLengths: false,

	  // Touches
	  touchRatio: 1,
	  touchAngle: 45,
	  simulateTouch: true,
	  shortSwipes: true,
	  longSwipes: true,
	  longSwipesRatio: 0.5,
	  longSwipesMs: 300,
	  followFinger: true,
	  allowTouchMove: true,
	  threshold: 0,
	  touchMoveStopPropagation: true,
	  touchStartPreventDefault: true,
	  touchStartForcePreventDefault: false,
	  touchReleaseOnEdges: false,

	  // Unique Navigation Elements
	  uniqueNavElements: true,

	  // Resistance
	  resistance: true,
	  resistanceRatio: 0.85,

	  // Progress
	  watchSlidesProgress: false,
	  watchSlidesVisibility: false,

	  // Cursor
	  grabCursor: false,

	  // Clicks
	  preventClicks: true,
	  preventClicksPropagation: true,
	  slideToClickedSlide: false,

	  // Images
	  preloadImages: true,
	  updateOnImagesReady: true,

	  // loop
	  loop: false,
	  loopAdditionalSlides: 0,
	  loopedSlides: null,
	  loopFillGroupWithBlank: false,

	  // Swiping/no swiping
	  allowSlidePrev: true,
	  allowSlideNext: true,
	  swipeHandler: null, // '.swipe-handler',
	  noSwiping: true,
	  noSwipingClass: 'swiper-no-swiping',
	  noSwipingSelector: null,

	  // Passive Listeners
	  passiveListeners: true,

	  // NS
	  containerModifierClass: 'swiper-container-', // NEW
	  slideClass: 'swiper-slide',
	  slideBlankClass: 'swiper-slide-invisible-blank',
	  slideActiveClass: 'swiper-slide-active',
	  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
	  slideVisibleClass: 'swiper-slide-visible',
	  slideDuplicateClass: 'swiper-slide-duplicate',
	  slideNextClass: 'swiper-slide-next',
	  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
	  slidePrevClass: 'swiper-slide-prev',
	  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
	  wrapperClass: 'swiper-wrapper',

	  // Callbacks
	  runCallbacksOnInit: true,
	};

	/* eslint no-param-reassign: "off" */

	var prototypes = {
	  update: update,
	  translate: translate,
	  transition: transition$1,
	  slide: slide,
	  loop: loop,
	  grabCursor: grabCursor,
	  manipulation: manipulation,
	  events: events,
	  breakpoints: breakpoints,
	  checkOverflow: checkOverflow$1,
	  classes: classes,
	  images: images,
	};

	var extendedDefaults = {};

	var Swiper = /*@__PURE__*/(function (SwiperClass) {
	  function Swiper() {
	    var assign;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var el;
	    var params;
	    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
	      params = args[0];
	    } else {
	      (assign = args, el = assign[0], params = assign[1]);
	    }
	    if (!params) { params = {}; }

	    params = Utils.extend({}, params);
	    if (el && !params.el) { params.el = el; }

	    SwiperClass.call(this, params);

	    Object.keys(prototypes).forEach(function (prototypeGroup) {
	      Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
	        if (!Swiper.prototype[protoMethod]) {
	          Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
	        }
	      });
	    });

	    // Swiper Instance
	    var swiper = this;
	    if (typeof swiper.modules === 'undefined') {
	      swiper.modules = {};
	    }
	    Object.keys(swiper.modules).forEach(function (moduleName) {
	      var module = swiper.modules[moduleName];
	      if (module.params) {
	        var moduleParamName = Object.keys(module.params)[0];
	        var moduleParams = module.params[moduleParamName];
	        if (typeof moduleParams !== 'object' || moduleParams === null) { return; }
	        if (!(moduleParamName in params && 'enabled' in moduleParams)) { return; }
	        if (params[moduleParamName] === true) {
	          params[moduleParamName] = { enabled: true };
	        }
	        if (
	          typeof params[moduleParamName] === 'object'
	          && !('enabled' in params[moduleParamName])
	        ) {
	          params[moduleParamName].enabled = true;
	        }
	        if (!params[moduleParamName]) { params[moduleParamName] = { enabled: false }; }
	      }
	    });

	    // Extend defaults with modules params
	    var swiperParams = Utils.extend({}, defaults);
	    swiper.useModulesParams(swiperParams);

	    // Extend defaults with passed params
	    swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
	    swiper.originalParams = Utils.extend({}, swiper.params);
	    swiper.passedParams = Utils.extend({}, params);

	    // Save Dom lib
	    swiper.$ = $;

	    // Find el
	    var $el = $(swiper.params.el);
	    el = $el[0];

	    if (!el) {
	      return undefined;
	    }

	    if ($el.length > 1) {
	      var swipers = [];
	      $el.each(function (index, containerEl) {
	        var newParams = Utils.extend({}, params, { el: containerEl });
	        swipers.push(new Swiper(newParams));
	      });
	      return swipers;
	    }

	    el.swiper = swiper;
	    $el.data('swiper', swiper);

	    // Find Wrapper
	    var $wrapperEl = $el.children(("." + (swiper.params.wrapperClass)));

	    // Extend Swiper
	    Utils.extend(swiper, {
	      $el: $el,
	      el: el,
	      $wrapperEl: $wrapperEl,
	      wrapperEl: $wrapperEl[0],

	      // Classes
	      classNames: [],

	      // Slides
	      slides: $(),
	      slidesGrid: [],
	      snapGrid: [],
	      slidesSizesGrid: [],

	      // isDirection
	      isHorizontal: function isHorizontal() {
	        return swiper.params.direction === 'horizontal';
	      },
	      isVertical: function isVertical() {
	        return swiper.params.direction === 'vertical';
	      },
	      // RTL
	      rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
	      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
	      wrongRTL: $wrapperEl.css('display') === '-webkit-box',

	      // Indexes
	      activeIndex: 0,
	      realIndex: 0,

	      //
	      isBeginning: true,
	      isEnd: false,

	      // Props
	      translate: 0,
	      previousTranslate: 0,
	      progress: 0,
	      velocity: 0,
	      animating: false,

	      // Locks
	      allowSlideNext: swiper.params.allowSlideNext,
	      allowSlidePrev: swiper.params.allowSlidePrev,

	      // Touch Events
	      touchEvents: (function touchEvents() {
	        var touch = ['touchstart', 'touchmove', 'touchend'];
	        var desktop = ['mousedown', 'mousemove', 'mouseup'];
	        if (Support.pointerEvents) {
	          desktop = ['pointerdown', 'pointermove', 'pointerup'];
	        } else if (Support.prefixedPointerEvents) {
	          desktop = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
	        }
	        swiper.touchEventsTouch = {
	          start: touch[0],
	          move: touch[1],
	          end: touch[2],
	        };
	        swiper.touchEventsDesktop = {
	          start: desktop[0],
	          move: desktop[1],
	          end: desktop[2],
	        };
	        return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
	      }()),
	      touchEventsData: {
	        isTouched: undefined,
	        isMoved: undefined,
	        allowTouchCallbacks: undefined,
	        touchStartTime: undefined,
	        isScrolling: undefined,
	        currentTranslate: undefined,
	        startTranslate: undefined,
	        allowThresholdMove: undefined,
	        // Form elements to match
	        formElements: 'input, select, option, textarea, button, video',
	        // Last click time
	        lastClickTime: Utils.now(),
	        clickTimeout: undefined,
	        // Velocities
	        velocities: [],
	        allowMomentumBounce: undefined,
	        isTouchEvent: undefined,
	        startMoving: undefined,
	      },

	      // Clicks
	      allowClick: true,

	      // Touches
	      allowTouchMove: swiper.params.allowTouchMove,

	      touches: {
	        startX: 0,
	        startY: 0,
	        currentX: 0,
	        currentY: 0,
	        diff: 0,
	      },

	      // Images
	      imagesToLoad: [],
	      imagesLoaded: 0,

	    });

	    // Install Modules
	    swiper.useModules();

	    // Init
	    if (swiper.params.init) {
	      swiper.init();
	    }

	    // Return app instance
	    return swiper;
	  }

	  if ( SwiperClass ) Swiper.__proto__ = SwiperClass;
	  Swiper.prototype = Object.create( SwiperClass && SwiperClass.prototype );
	  Swiper.prototype.constructor = Swiper;

	  var staticAccessors = { extendedDefaults: { configurable: true },defaults: { configurable: true },Class: { configurable: true },$: { configurable: true } };

	  Swiper.prototype.slidesPerViewDynamic = function slidesPerViewDynamic () {
	    var swiper = this;
	    var params = swiper.params;
	    var slides = swiper.slides;
	    var slidesGrid = swiper.slidesGrid;
	    var swiperSize = swiper.size;
	    var activeIndex = swiper.activeIndex;
	    var spv = 1;
	    if (params.centeredSlides) {
	      var slideSize = slides[activeIndex].swiperSlideSize;
	      var breakLoop;
	      for (var i = activeIndex + 1; i < slides.length; i += 1) {
	        if (slides[i] && !breakLoop) {
	          slideSize += slides[i].swiperSlideSize;
	          spv += 1;
	          if (slideSize > swiperSize) { breakLoop = true; }
	        }
	      }
	      for (var i$1 = activeIndex - 1; i$1 >= 0; i$1 -= 1) {
	        if (slides[i$1] && !breakLoop) {
	          slideSize += slides[i$1].swiperSlideSize;
	          spv += 1;
	          if (slideSize > swiperSize) { breakLoop = true; }
	        }
	      }
	    } else {
	      for (var i$2 = activeIndex + 1; i$2 < slides.length; i$2 += 1) {
	        if (slidesGrid[i$2] - slidesGrid[activeIndex] < swiperSize) {
	          spv += 1;
	        }
	      }
	    }
	    return spv;
	  };

	  Swiper.prototype.update = function update () {
	    var swiper = this;
	    if (!swiper || swiper.destroyed) { return; }
	    var snapGrid = swiper.snapGrid;
	    var params = swiper.params;
	    // Breakpoints
	    if (params.breakpoints) {
	      swiper.setBreakpoint();
	    }
	    swiper.updateSize();
	    swiper.updateSlides();
	    swiper.updateProgress();
	    swiper.updateSlidesClasses();

	    function setTranslate() {
	      var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
	      var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
	      swiper.setTranslate(newTranslate);
	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    }
	    var translated;
	    if (swiper.params.freeMode) {
	      setTranslate();
	      if (swiper.params.autoHeight) {
	        swiper.updateAutoHeight();
	      }
	    } else {
	      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
	        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
	      } else {
	        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
	      }
	      if (!translated) {
	        setTranslate();
	      }
	    }
	    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
	      swiper.checkOverflow();
	    }
	    swiper.emit('update');
	  };

	  Swiper.prototype.changeDirection = function changeDirection (newDirection, needUpdate) {
	    if ( needUpdate === void 0 ) needUpdate = true;

	    var swiper = this;
	    var currentDirection = swiper.params.direction;
	    if (!newDirection) {
	      // eslint-disable-next-line
	      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
	    }
	    if ((newDirection === currentDirection) || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {
	      return swiper;
	    }

	    if (currentDirection === 'vertical') {
	      swiper.$el
	        .removeClass(((swiper.params.containerModifierClass) + "vertical wp8-vertical"))
	        .addClass(("" + (swiper.params.containerModifierClass) + newDirection));

	      if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	        swiper.$el.addClass(((swiper.params.containerModifierClass) + "wp8-" + newDirection));
	      }
	    }
	    if (currentDirection === 'horizontal') {
	      swiper.$el
	        .removeClass(((swiper.params.containerModifierClass) + "horizontal wp8-horizontal"))
	        .addClass(("" + (swiper.params.containerModifierClass) + newDirection));

	      if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	        swiper.$el.addClass(((swiper.params.containerModifierClass) + "wp8-" + newDirection));
	      }
	    }

	    swiper.params.direction = newDirection;

	    swiper.slides.each(function (slideIndex, slideEl) {
	      if (newDirection === 'vertical') {
	        slideEl.style.width = '';
	      } else {
	        slideEl.style.height = '';
	      }
	    });

	    swiper.emit('changeDirection');
	    if (needUpdate) { swiper.update(); }

	    return swiper;
	  };

	  Swiper.prototype.init = function init () {
	    var swiper = this;
	    if (swiper.initialized) { return; }

	    swiper.emit('beforeInit');

	    // Set breakpoint
	    if (swiper.params.breakpoints) {
	      swiper.setBreakpoint();
	    }

	    // Add Classes
	    swiper.addClasses();

	    // Create loop
	    if (swiper.params.loop) {
	      swiper.loopCreate();
	    }

	    // Update size
	    swiper.updateSize();

	    // Update slides
	    swiper.updateSlides();

	    if (swiper.params.watchOverflow) {
	      swiper.checkOverflow();
	    }

	    // Set Grab Cursor
	    if (swiper.params.grabCursor) {
	      swiper.setGrabCursor();
	    }

	    if (swiper.params.preloadImages) {
	      swiper.preloadImages();
	    }

	    // Slide To Initial Slide
	    if (swiper.params.loop) {
	      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
	    } else {
	      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
	    }

	    // Attach events
	    swiper.attachEvents();

	    // Init Flag
	    swiper.initialized = true;

	    // Emit
	    swiper.emit('init');
	  };

	  Swiper.prototype.destroy = function destroy (deleteInstance, cleanStyles) {
	    if ( deleteInstance === void 0 ) deleteInstance = true;
	    if ( cleanStyles === void 0 ) cleanStyles = true;

	    var swiper = this;
	    var params = swiper.params;
	    var $el = swiper.$el;
	    var $wrapperEl = swiper.$wrapperEl;
	    var slides = swiper.slides;

	    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
	      return null;
	    }

	    swiper.emit('beforeDestroy');

	    // Init Flag
	    swiper.initialized = false;

	    // Detach events
	    swiper.detachEvents();

	    // Destroy loop
	    if (params.loop) {
	      swiper.loopDestroy();
	    }

	    // Cleanup styles
	    if (cleanStyles) {
	      swiper.removeClasses();
	      $el.removeAttr('style');
	      $wrapperEl.removeAttr('style');
	      if (slides && slides.length) {
	        slides
	          .removeClass([
	            params.slideVisibleClass,
	            params.slideActiveClass,
	            params.slideNextClass,
	            params.slidePrevClass ].join(' '))
	          .removeAttr('style')
	          .removeAttr('data-swiper-slide-index')
	          .removeAttr('data-swiper-column')
	          .removeAttr('data-swiper-row');
	      }
	    }

	    swiper.emit('destroy');

	    // Detach emitter events
	    Object.keys(swiper.eventsListeners).forEach(function (eventName) {
	      swiper.off(eventName);
	    });

	    if (deleteInstance !== false) {
	      swiper.$el[0].swiper = null;
	      swiper.$el.data('swiper', null);
	      Utils.deleteProps(swiper);
	    }
	    swiper.destroyed = true;

	    return null;
	  };

	  Swiper.extendDefaults = function extendDefaults (newDefaults) {
	    Utils.extend(extendedDefaults, newDefaults);
	  };

	  staticAccessors.extendedDefaults.get = function () {
	    return extendedDefaults;
	  };

	  staticAccessors.defaults.get = function () {
	    return defaults;
	  };

	  staticAccessors.Class.get = function () {
	    return SwiperClass;
	  };

	  staticAccessors.$.get = function () {
	    return $;
	  };

	  Object.defineProperties( Swiper, staticAccessors );

	  return Swiper;
	}(Framework7Class));

	var Device$1 = {
	  name: 'device',
	  proto: {
	    device: Device,
	  },
	  static: {
	    device: Device,
	  },
	};

	var Support$1 = {
	  name: 'support',
	  proto: {
	    support: Support,
	  },
	  static: {
	    support: Support,
	  },
	};

	var Browser$1 = {
	  name: 'browser',
	  proto: {
	    browser: Browser,
	  },
	  static: {
	    browser: Browser,
	  },
	};

	var Resize = {
	  name: 'resize',
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      resize: {
	        resizeHandler: function resizeHandler() {
	          if (!swiper || swiper.destroyed || !swiper.initialized) { return; }
	          swiper.emit('beforeResize');
	          swiper.emit('resize');
	        },
	        orientationChangeHandler: function orientationChangeHandler() {
	          if (!swiper || swiper.destroyed || !swiper.initialized) { return; }
	          swiper.emit('orientationchange');
	        },
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      // Emit resize
	      win.addEventListener('resize', swiper.resize.resizeHandler);

	      // Emit orientationchange
	      win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      win.removeEventListener('resize', swiper.resize.resizeHandler);
	      win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
	    },
	  },
	};

	var Observer = {
	  func: win.MutationObserver || win.WebkitMutationObserver,
	  attach: function attach(target, options) {
	    if ( options === void 0 ) options = {};

	    var swiper = this;

	    var ObserverFunc = Observer.func;
	    var observer = new ObserverFunc(function (mutations) {
	      // The observerUpdate event should only be triggered
	      // once despite the number of mutations.  Additional
	      // triggers are redundant and are very costly
	      if (mutations.length === 1) {
	        swiper.emit('observerUpdate', mutations[0]);
	        return;
	      }
	      var observerUpdate = function observerUpdate() {
	        swiper.emit('observerUpdate', mutations[0]);
	      };

	      if (win.requestAnimationFrame) {
	        win.requestAnimationFrame(observerUpdate);
	      } else {
	        win.setTimeout(observerUpdate, 0);
	      }
	    });

	    observer.observe(target, {
	      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
	      childList: typeof options.childList === 'undefined' ? true : options.childList,
	      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
	    });

	    swiper.observer.observers.push(observer);
	  },
	  init: function init() {
	    var swiper = this;
	    if (!Support.observer || !swiper.params.observer) { return; }
	    if (swiper.params.observeParents) {
	      var containerParents = swiper.$el.parents();
	      for (var i = 0; i < containerParents.length; i += 1) {
	        swiper.observer.attach(containerParents[i]);
	      }
	    }
	    // Observe container
	    swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });

	    // Observe wrapper
	    swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });
	  },
	  destroy: function destroy() {
	    var swiper = this;
	    swiper.observer.observers.forEach(function (observer) {
	      observer.disconnect();
	    });
	    swiper.observer.observers = [];
	  },
	};

	var Observer$1 = {
	  name: 'observer',
	  params: {
	    observer: false,
	    observeParents: false,
	    observeSlideChildren: false,
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      observer: {
	        init: Observer.init.bind(swiper),
	        attach: Observer.attach.bind(swiper),
	        destroy: Observer.destroy.bind(swiper),
	        observers: [],
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      swiper.observer.init();
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      swiper.observer.destroy();
	    },
	  },
	};

	var Virtual = {
	  update: function update(force) {
	    var swiper = this;
	    var ref = swiper.params;
	    var slidesPerView = ref.slidesPerView;
	    var slidesPerGroup = ref.slidesPerGroup;
	    var centeredSlides = ref.centeredSlides;
	    var ref$1 = swiper.params.virtual;
	    var addSlidesBefore = ref$1.addSlidesBefore;
	    var addSlidesAfter = ref$1.addSlidesAfter;
	    var ref$2 = swiper.virtual;
	    var previousFrom = ref$2.from;
	    var previousTo = ref$2.to;
	    var slides = ref$2.slides;
	    var previousSlidesGrid = ref$2.slidesGrid;
	    var renderSlide = ref$2.renderSlide;
	    var previousOffset = ref$2.offset;
	    swiper.updateActiveIndex();
	    var activeIndex = swiper.activeIndex || 0;

	    var offsetProp;
	    if (swiper.rtlTranslate) { offsetProp = 'right'; }
	    else { offsetProp = swiper.isHorizontal() ? 'left' : 'top'; }

	    var slidesAfter;
	    var slidesBefore;
	    if (centeredSlides) {
	      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
	      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
	    } else {
	      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
	      slidesBefore = slidesPerGroup + addSlidesAfter;
	    }
	    var from = Math.max((activeIndex || 0) - slidesBefore, 0);
	    var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
	    var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);

	    Utils.extend(swiper.virtual, {
	      from: from,
	      to: to,
	      offset: offset,
	      slidesGrid: swiper.slidesGrid,
	    });

	    function onRendered() {
	      swiper.updateSlides();
	      swiper.updateProgress();
	      swiper.updateSlidesClasses();
	      if (swiper.lazy && swiper.params.lazy.enabled) {
	        swiper.lazy.load();
	      }
	    }

	    if (previousFrom === from && previousTo === to && !force) {
	      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
	        swiper.slides.css(offsetProp, (offset + "px"));
	      }
	      swiper.updateProgress();
	      return;
	    }
	    if (swiper.params.virtual.renderExternal) {
	      swiper.params.virtual.renderExternal.call(swiper, {
	        offset: offset,
	        from: from,
	        to: to,
	        slides: (function getSlides() {
	          var slidesToRender = [];
	          for (var i = from; i <= to; i += 1) {
	            slidesToRender.push(slides[i]);
	          }
	          return slidesToRender;
	        }()),
	      });
	      onRendered();
	      return;
	    }
	    var prependIndexes = [];
	    var appendIndexes = [];
	    if (force) {
	      swiper.$wrapperEl.find(("." + (swiper.params.slideClass))).remove();
	    } else {
	      for (var i = previousFrom; i <= previousTo; i += 1) {
	        if (i < from || i > to) {
	          swiper.$wrapperEl.find(("." + (swiper.params.slideClass) + "[data-swiper-slide-index=\"" + i + "\"]")).remove();
	        }
	      }
	    }
	    for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
	      if (i$1 >= from && i$1 <= to) {
	        if (typeof previousTo === 'undefined' || force) {
	          appendIndexes.push(i$1);
	        } else {
	          if (i$1 > previousTo) { appendIndexes.push(i$1); }
	          if (i$1 < previousFrom) { prependIndexes.push(i$1); }
	        }
	      }
	    }
	    appendIndexes.forEach(function (index) {
	      swiper.$wrapperEl.append(renderSlide(slides[index], index));
	    });
	    prependIndexes.sort(function (a, b) { return b - a; }).forEach(function (index) {
	      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
	    });
	    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, (offset + "px"));
	    onRendered();
	  },
	  renderSlide: function renderSlide(slide, index) {
	    var swiper = this;
	    var params = swiper.params.virtual;
	    if (params.cache && swiper.virtual.cache[index]) {
	      return swiper.virtual.cache[index];
	    }
	    var $slideEl = params.renderSlide
	      ? $(params.renderSlide.call(swiper, slide, index))
	      : $(("<div class=\"" + (swiper.params.slideClass) + "\" data-swiper-slide-index=\"" + index + "\">" + slide + "</div>"));
	    if (!$slideEl.attr('data-swiper-slide-index')) { $slideEl.attr('data-swiper-slide-index', index); }
	    if (params.cache) { swiper.virtual.cache[index] = $slideEl; }
	    return $slideEl;
	  },
	  appendSlide: function appendSlide(slides) {
	    var swiper = this;
	    if (typeof slides === 'object' && 'length' in slides) {
	      for (var i = 0; i < slides.length; i += 1) {
	        if (slides[i]) { swiper.virtual.slides.push(slides[i]); }
	      }
	    } else {
	      swiper.virtual.slides.push(slides);
	    }
	    swiper.virtual.update(true);
	  },
	  prependSlide: function prependSlide(slides) {
	    var swiper = this;
	    var activeIndex = swiper.activeIndex;
	    var newActiveIndex = activeIndex + 1;
	    var numberOfNewSlides = 1;

	    if (Array.isArray(slides)) {
	      for (var i = 0; i < slides.length; i += 1) {
	        if (slides[i]) { swiper.virtual.slides.unshift(slides[i]); }
	      }
	      newActiveIndex = activeIndex + slides.length;
	      numberOfNewSlides = slides.length;
	    } else {
	      swiper.virtual.slides.unshift(slides);
	    }
	    if (swiper.params.virtual.cache) {
	      var cache = swiper.virtual.cache;
	      var newCache = {};
	      Object.keys(cache).forEach(function (cachedIndex) {
	        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cache[cachedIndex];
	      });
	      swiper.virtual.cache = newCache;
	    }
	    swiper.virtual.update(true);
	    swiper.slideTo(newActiveIndex, 0);
	  },
	  removeSlide: function removeSlide(slidesIndexes) {
	    var swiper = this;
	    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) { return; }
	    var activeIndex = swiper.activeIndex;
	    if (Array.isArray(slidesIndexes)) {
	      for (var i = slidesIndexes.length - 1; i >= 0; i -= 1) {
	        swiper.virtual.slides.splice(slidesIndexes[i], 1);
	        if (swiper.params.virtual.cache) {
	          delete swiper.virtual.cache[slidesIndexes[i]];
	        }
	        if (slidesIndexes[i] < activeIndex) { activeIndex -= 1; }
	        activeIndex = Math.max(activeIndex, 0);
	      }
	    } else {
	      swiper.virtual.slides.splice(slidesIndexes, 1);
	      if (swiper.params.virtual.cache) {
	        delete swiper.virtual.cache[slidesIndexes];
	      }
	      if (slidesIndexes < activeIndex) { activeIndex -= 1; }
	      activeIndex = Math.max(activeIndex, 0);
	    }
	    swiper.virtual.update(true);
	    swiper.slideTo(activeIndex, 0);
	  },
	  removeAllSlides: function removeAllSlides() {
	    var swiper = this;
	    swiper.virtual.slides = [];
	    if (swiper.params.virtual.cache) {
	      swiper.virtual.cache = {};
	    }
	    swiper.virtual.update(true);
	    swiper.slideTo(0, 0);
	  },
	};

	var Virtual$1 = {
	  name: 'virtual',
	  params: {
	    virtual: {
	      enabled: false,
	      slides: [],
	      cache: true,
	      renderSlide: null,
	      renderExternal: null,
	      addSlidesBefore: 0,
	      addSlidesAfter: 0,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      virtual: {
	        update: Virtual.update.bind(swiper),
	        appendSlide: Virtual.appendSlide.bind(swiper),
	        prependSlide: Virtual.prependSlide.bind(swiper),
	        removeSlide: Virtual.removeSlide.bind(swiper),
	        removeAllSlides: Virtual.removeAllSlides.bind(swiper),
	        renderSlide: Virtual.renderSlide.bind(swiper),
	        slides: swiper.params.virtual.slides,
	        cache: {},
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      if (!swiper.params.virtual.enabled) { return; }
	      swiper.classNames.push(((swiper.params.containerModifierClass) + "virtual"));
	      var overwriteParams = {
	        watchSlidesProgress: true,
	      };
	      Utils.extend(swiper.params, overwriteParams);
	      Utils.extend(swiper.originalParams, overwriteParams);

	      if (!swiper.params.initialSlide) {
	        swiper.virtual.update();
	      }
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      if (!swiper.params.virtual.enabled) { return; }
	      swiper.virtual.update();
	    },
	  },
	};

	var Navigation = {
	  update: function update() {
	    // Update Navigation Buttons
	    var swiper = this;
	    var params = swiper.params.navigation;

	    if (swiper.params.loop) { return; }
	    var ref = swiper.navigation;
	    var $nextEl = ref.$nextEl;
	    var $prevEl = ref.$prevEl;

	    if ($prevEl && $prevEl.length > 0) {
	      if (swiper.isBeginning) {
	        $prevEl.addClass(params.disabledClass);
	      } else {
	        $prevEl.removeClass(params.disabledClass);
	      }
	      $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
	    }
	    if ($nextEl && $nextEl.length > 0) {
	      if (swiper.isEnd) {
	        $nextEl.addClass(params.disabledClass);
	      } else {
	        $nextEl.removeClass(params.disabledClass);
	      }
	      $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
	    }
	  },
	  onPrevClick: function onPrevClick(e) {
	    var swiper = this;
	    e.preventDefault();
	    if (swiper.isBeginning && !swiper.params.loop) { return; }
	    swiper.slidePrev();
	  },
	  onNextClick: function onNextClick(e) {
	    var swiper = this;
	    e.preventDefault();
	    if (swiper.isEnd && !swiper.params.loop) { return; }
	    swiper.slideNext();
	  },
	  init: function init() {
	    var swiper = this;
	    var params = swiper.params.navigation;
	    if (!(params.nextEl || params.prevEl)) { return; }

	    var $nextEl;
	    var $prevEl;
	    if (params.nextEl) {
	      $nextEl = $(params.nextEl);
	      if (
	        swiper.params.uniqueNavElements
	        && typeof params.nextEl === 'string'
	        && $nextEl.length > 1
	        && swiper.$el.find(params.nextEl).length === 1
	      ) {
	        $nextEl = swiper.$el.find(params.nextEl);
	      }
	    }
	    if (params.prevEl) {
	      $prevEl = $(params.prevEl);
	      if (
	        swiper.params.uniqueNavElements
	        && typeof params.prevEl === 'string'
	        && $prevEl.length > 1
	        && swiper.$el.find(params.prevEl).length === 1
	      ) {
	        $prevEl = swiper.$el.find(params.prevEl);
	      }
	    }

	    if ($nextEl && $nextEl.length > 0) {
	      $nextEl.on('click', swiper.navigation.onNextClick);
	    }
	    if ($prevEl && $prevEl.length > 0) {
	      $prevEl.on('click', swiper.navigation.onPrevClick);
	    }

	    Utils.extend(swiper.navigation, {
	      $nextEl: $nextEl,
	      nextEl: $nextEl && $nextEl[0],
	      $prevEl: $prevEl,
	      prevEl: $prevEl && $prevEl[0],
	    });
	  },
	  destroy: function destroy() {
	    var swiper = this;
	    var ref = swiper.navigation;
	    var $nextEl = ref.$nextEl;
	    var $prevEl = ref.$prevEl;
	    if ($nextEl && $nextEl.length) {
	      $nextEl.off('click', swiper.navigation.onNextClick);
	      $nextEl.removeClass(swiper.params.navigation.disabledClass);
	    }
	    if ($prevEl && $prevEl.length) {
	      $prevEl.off('click', swiper.navigation.onPrevClick);
	      $prevEl.removeClass(swiper.params.navigation.disabledClass);
	    }
	  },
	};

	var Navigation$1 = {
	  name: 'navigation',
	  params: {
	    navigation: {
	      nextEl: null,
	      prevEl: null,

	      hideOnClick: false,
	      disabledClass: 'swiper-button-disabled',
	      hiddenClass: 'swiper-button-hidden',
	      lockClass: 'swiper-button-lock',
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      navigation: {
	        init: Navigation.init.bind(swiper),
	        update: Navigation.update.bind(swiper),
	        destroy: Navigation.destroy.bind(swiper),
	        onNextClick: Navigation.onNextClick.bind(swiper),
	        onPrevClick: Navigation.onPrevClick.bind(swiper),
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      swiper.navigation.init();
	      swiper.navigation.update();
	    },
	    toEdge: function toEdge() {
	      var swiper = this;
	      swiper.navigation.update();
	    },
	    fromEdge: function fromEdge() {
	      var swiper = this;
	      swiper.navigation.update();
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      swiper.navigation.destroy();
	    },
	    click: function click(e) {
	      var swiper = this;
	      var ref = swiper.navigation;
	      var $nextEl = ref.$nextEl;
	      var $prevEl = ref.$prevEl;
	      if (
	        swiper.params.navigation.hideOnClick
	        && !$(e.target).is($prevEl)
	        && !$(e.target).is($nextEl)
	      ) {
	        var isHidden;
	        if ($nextEl) {
	          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
	        } else if ($prevEl) {
	          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
	        }
	        if (isHidden === true) {
	          swiper.emit('navigationShow', swiper);
	        } else {
	          swiper.emit('navigationHide', swiper);
	        }
	        if ($nextEl) {
	          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
	        }
	        if ($prevEl) {
	          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
	        }
	      }
	    },
	  },
	};

	var Pagination = {
	  update: function update() {
	    // Render || Update Pagination bullets/items
	    var swiper = this;
	    var rtl = swiper.rtl;
	    var params = swiper.params.pagination;
	    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
	    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
	    var $el = swiper.pagination.$el;
	    // Current/Total
	    var current;
	    var total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
	    if (swiper.params.loop) {
	      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
	      if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
	        current -= (slidesLength - (swiper.loopedSlides * 2));
	      }
	      if (current > total - 1) { current -= total; }
	      if (current < 0 && swiper.params.paginationType !== 'bullets') { current = total + current; }
	    } else if (typeof swiper.snapIndex !== 'undefined') {
	      current = swiper.snapIndex;
	    } else {
	      current = swiper.activeIndex || 0;
	    }
	    // Types
	    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
	      var bullets = swiper.pagination.bullets;
	      var firstIndex;
	      var lastIndex;
	      var midIndex;
	      if (params.dynamicBullets) {
	        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
	        $el.css(swiper.isHorizontal() ? 'width' : 'height', ((swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)) + "px"));
	        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
	          swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);
	          if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {
	            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
	          } else if (swiper.pagination.dynamicBulletIndex < 0) {
	            swiper.pagination.dynamicBulletIndex = 0;
	          }
	        }
	        firstIndex = current - swiper.pagination.dynamicBulletIndex;
	        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
	        midIndex = (lastIndex + firstIndex) / 2;
	      }
	      bullets.removeClass(((params.bulletActiveClass) + " " + (params.bulletActiveClass) + "-next " + (params.bulletActiveClass) + "-next-next " + (params.bulletActiveClass) + "-prev " + (params.bulletActiveClass) + "-prev-prev " + (params.bulletActiveClass) + "-main"));
	      if ($el.length > 1) {
	        bullets.each(function (index, bullet) {
	          var $bullet = $(bullet);
	          var bulletIndex = $bullet.index();
	          if (bulletIndex === current) {
	            $bullet.addClass(params.bulletActiveClass);
	          }
	          if (params.dynamicBullets) {
	            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
	              $bullet.addClass(((params.bulletActiveClass) + "-main"));
	            }
	            if (bulletIndex === firstIndex) {
	              $bullet
	                .prev()
	                .addClass(((params.bulletActiveClass) + "-prev"))
	                .prev()
	                .addClass(((params.bulletActiveClass) + "-prev-prev"));
	            }
	            if (bulletIndex === lastIndex) {
	              $bullet
	                .next()
	                .addClass(((params.bulletActiveClass) + "-next"))
	                .next()
	                .addClass(((params.bulletActiveClass) + "-next-next"));
	            }
	          }
	        });
	      } else {
	        var $bullet = bullets.eq(current);
	        $bullet.addClass(params.bulletActiveClass);
	        if (params.dynamicBullets) {
	          var $firstDisplayedBullet = bullets.eq(firstIndex);
	          var $lastDisplayedBullet = bullets.eq(lastIndex);
	          for (var i = firstIndex; i <= lastIndex; i += 1) {
	            bullets.eq(i).addClass(((params.bulletActiveClass) + "-main"));
	          }
	          $firstDisplayedBullet
	            .prev()
	            .addClass(((params.bulletActiveClass) + "-prev"))
	            .prev()
	            .addClass(((params.bulletActiveClass) + "-prev-prev"));
	          $lastDisplayedBullet
	            .next()
	            .addClass(((params.bulletActiveClass) + "-next"))
	            .next()
	            .addClass(((params.bulletActiveClass) + "-next-next"));
	        }
	      }
	      if (params.dynamicBullets) {
	        var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
	        var bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);
	        var offsetProp = rtl ? 'right' : 'left';
	        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', (bulletsOffset + "px"));
	      }
	    }
	    if (params.type === 'fraction') {
	      $el.find(("." + (params.currentClass))).text(params.formatFractionCurrent(current + 1));
	      $el.find(("." + (params.totalClass))).text(params.formatFractionTotal(total));
	    }
	    if (params.type === 'progressbar') {
	      var progressbarDirection;
	      if (params.progressbarOpposite) {
	        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
	      } else {
	        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
	      }
	      var scale = (current + 1) / total;
	      var scaleX = 1;
	      var scaleY = 1;
	      if (progressbarDirection === 'horizontal') {
	        scaleX = scale;
	      } else {
	        scaleY = scale;
	      }
	      $el.find(("." + (params.progressbarFillClass))).transform(("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")")).transition(swiper.params.speed);
	    }
	    if (params.type === 'custom' && params.renderCustom) {
	      $el.html(params.renderCustom(swiper, current + 1, total));
	      swiper.emit('paginationRender', swiper, $el[0]);
	    } else {
	      swiper.emit('paginationUpdate', swiper, $el[0]);
	    }
	    $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
	  },
	  render: function render() {
	    // Render Container
	    var swiper = this;
	    var params = swiper.params.pagination;
	    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
	    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;

	    var $el = swiper.pagination.$el;
	    var paginationHTML = '';
	    if (params.type === 'bullets') {
	      var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
	      for (var i = 0; i < numberOfBullets; i += 1) {
	        if (params.renderBullet) {
	          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
	        } else {
	          paginationHTML += "<" + (params.bulletElement) + " class=\"" + (params.bulletClass) + "\"></" + (params.bulletElement) + ">";
	        }
	      }
	      $el.html(paginationHTML);
	      swiper.pagination.bullets = $el.find(("." + (params.bulletClass)));
	    }
	    if (params.type === 'fraction') {
	      if (params.renderFraction) {
	        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
	      } else {
	        paginationHTML = "<span class=\"" + (params.currentClass) + "\"></span>"
	        + ' / '
	        + "<span class=\"" + (params.totalClass) + "\"></span>";
	      }
	      $el.html(paginationHTML);
	    }
	    if (params.type === 'progressbar') {
	      if (params.renderProgressbar) {
	        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
	      } else {
	        paginationHTML = "<span class=\"" + (params.progressbarFillClass) + "\"></span>";
	      }
	      $el.html(paginationHTML);
	    }
	    if (params.type !== 'custom') {
	      swiper.emit('paginationRender', swiper.pagination.$el[0]);
	    }
	  },
	  init: function init() {
	    var swiper = this;
	    var params = swiper.params.pagination;
	    if (!params.el) { return; }

	    var $el = $(params.el);
	    if ($el.length === 0) { return; }

	    if (
	      swiper.params.uniqueNavElements
	      && typeof params.el === 'string'
	      && $el.length > 1
	      && swiper.$el.find(params.el).length === 1
	    ) {
	      $el = swiper.$el.find(params.el);
	    }

	    if (params.type === 'bullets' && params.clickable) {
	      $el.addClass(params.clickableClass);
	    }

	    $el.addClass(params.modifierClass + params.type);

	    if (params.type === 'bullets' && params.dynamicBullets) {
	      $el.addClass(("" + (params.modifierClass) + (params.type) + "-dynamic"));
	      swiper.pagination.dynamicBulletIndex = 0;
	      if (params.dynamicMainBullets < 1) {
	        params.dynamicMainBullets = 1;
	      }
	    }
	    if (params.type === 'progressbar' && params.progressbarOpposite) {
	      $el.addClass(params.progressbarOppositeClass);
	    }

	    if (params.clickable) {
	      $el.on('click', ("." + (params.bulletClass)), function onClick(e) {
	        e.preventDefault();
	        var index = $(this).index() * swiper.params.slidesPerGroup;
	        if (swiper.params.loop) { index += swiper.loopedSlides; }
	        swiper.slideTo(index);
	      });
	    }

	    Utils.extend(swiper.pagination, {
	      $el: $el,
	      el: $el[0],
	    });
	  },
	  destroy: function destroy() {
	    var swiper = this;
	    var params = swiper.params.pagination;
	    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
	    var $el = swiper.pagination.$el;

	    $el.removeClass(params.hiddenClass);
	    $el.removeClass(params.modifierClass + params.type);
	    if (swiper.pagination.bullets) { swiper.pagination.bullets.removeClass(params.bulletActiveClass); }
	    if (params.clickable) {
	      $el.off('click', ("." + (params.bulletClass)));
	    }
	  },
	};

	var Pagination$1 = {
	  name: 'pagination',
	  params: {
	    pagination: {
	      el: null,
	      bulletElement: 'span',
	      clickable: false,
	      hideOnClick: false,
	      renderBullet: null,
	      renderProgressbar: null,
	      renderFraction: null,
	      renderCustom: null,
	      progressbarOpposite: false,
	      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
	      dynamicBullets: false,
	      dynamicMainBullets: 1,
	      formatFractionCurrent: function (number) { return number; },
	      formatFractionTotal: function (number) { return number; },
	      bulletClass: 'swiper-pagination-bullet',
	      bulletActiveClass: 'swiper-pagination-bullet-active',
	      modifierClass: 'swiper-pagination-', // NEW
	      currentClass: 'swiper-pagination-current',
	      totalClass: 'swiper-pagination-total',
	      hiddenClass: 'swiper-pagination-hidden',
	      progressbarFillClass: 'swiper-pagination-progressbar-fill',
	      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
	      clickableClass: 'swiper-pagination-clickable', // NEW
	      lockClass: 'swiper-pagination-lock',
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      pagination: {
	        init: Pagination.init.bind(swiper),
	        render: Pagination.render.bind(swiper),
	        update: Pagination.update.bind(swiper),
	        destroy: Pagination.destroy.bind(swiper),
	        dynamicBulletIndex: 0,
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      swiper.pagination.init();
	      swiper.pagination.render();
	      swiper.pagination.update();
	    },
	    activeIndexChange: function activeIndexChange() {
	      var swiper = this;
	      if (swiper.params.loop) {
	        swiper.pagination.update();
	      } else if (typeof swiper.snapIndex === 'undefined') {
	        swiper.pagination.update();
	      }
	    },
	    snapIndexChange: function snapIndexChange() {
	      var swiper = this;
	      if (!swiper.params.loop) {
	        swiper.pagination.update();
	      }
	    },
	    slidesLengthChange: function slidesLengthChange() {
	      var swiper = this;
	      if (swiper.params.loop) {
	        swiper.pagination.render();
	        swiper.pagination.update();
	      }
	    },
	    snapGridLengthChange: function snapGridLengthChange() {
	      var swiper = this;
	      if (!swiper.params.loop) {
	        swiper.pagination.render();
	        swiper.pagination.update();
	      }
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      swiper.pagination.destroy();
	    },
	    click: function click(e) {
	      var swiper = this;
	      if (
	        swiper.params.pagination.el
	        && swiper.params.pagination.hideOnClick
	        && swiper.pagination.$el.length > 0
	        && !$(e.target).hasClass(swiper.params.pagination.bulletClass)
	      ) {
	        var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
	        if (isHidden === true) {
	          swiper.emit('paginationShow', swiper);
	        } else {
	          swiper.emit('paginationHide', swiper);
	        }
	        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
	      }
	    },
	  },
	};

	var Scrollbar = {
	  setTranslate: function setTranslate() {
	    var swiper = this;
	    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }
	    var scrollbar = swiper.scrollbar;
	    var rtl = swiper.rtlTranslate;
	    var progress = swiper.progress;
	    var dragSize = scrollbar.dragSize;
	    var trackSize = scrollbar.trackSize;
	    var $dragEl = scrollbar.$dragEl;
	    var $el = scrollbar.$el;
	    var params = swiper.params.scrollbar;

	    var newSize = dragSize;
	    var newPos = (trackSize - dragSize) * progress;
	    if (rtl) {
	      newPos = -newPos;
	      if (newPos > 0) {
	        newSize = dragSize - newPos;
	        newPos = 0;
	      } else if (-newPos + dragSize > trackSize) {
	        newSize = trackSize + newPos;
	      }
	    } else if (newPos < 0) {
	      newSize = dragSize + newPos;
	      newPos = 0;
	    } else if (newPos + dragSize > trackSize) {
	      newSize = trackSize - newPos;
	    }
	    if (swiper.isHorizontal()) {
	      if (Support.transforms3d) {
	        $dragEl.transform(("translate3d(" + newPos + "px, 0, 0)"));
	      } else {
	        $dragEl.transform(("translateX(" + newPos + "px)"));
	      }
	      $dragEl[0].style.width = newSize + "px";
	    } else {
	      if (Support.transforms3d) {
	        $dragEl.transform(("translate3d(0px, " + newPos + "px, 0)"));
	      } else {
	        $dragEl.transform(("translateY(" + newPos + "px)"));
	      }
	      $dragEl[0].style.height = newSize + "px";
	    }
	    if (params.hide) {
	      clearTimeout(swiper.scrollbar.timeout);
	      $el[0].style.opacity = 1;
	      swiper.scrollbar.timeout = setTimeout(function () {
	        $el[0].style.opacity = 0;
	        $el.transition(400);
	      }, 1000);
	    }
	  },
	  setTransition: function setTransition(duration) {
	    var swiper = this;
	    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }
	    swiper.scrollbar.$dragEl.transition(duration);
	  },
	  updateSize: function updateSize() {
	    var swiper = this;
	    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }

	    var scrollbar = swiper.scrollbar;
	    var $dragEl = scrollbar.$dragEl;
	    var $el = scrollbar.$el;

	    $dragEl[0].style.width = '';
	    $dragEl[0].style.height = '';
	    var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;

	    var divider = swiper.size / swiper.virtualSize;
	    var moveDivider = divider * (trackSize / swiper.size);
	    var dragSize;
	    if (swiper.params.scrollbar.dragSize === 'auto') {
	      dragSize = trackSize * divider;
	    } else {
	      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
	    }

	    if (swiper.isHorizontal()) {
	      $dragEl[0].style.width = dragSize + "px";
	    } else {
	      $dragEl[0].style.height = dragSize + "px";
	    }

	    if (divider >= 1) {
	      $el[0].style.display = 'none';
	    } else {
	      $el[0].style.display = '';
	    }
	    if (swiper.params.scrollbar.hide) {
	      $el[0].style.opacity = 0;
	    }
	    Utils.extend(scrollbar, {
	      trackSize: trackSize,
	      divider: divider,
	      moveDivider: moveDivider,
	      dragSize: dragSize,
	    });
	    scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
	  },
	  setDragPosition: function setDragPosition(e) {
	    var swiper = this;
	    var scrollbar = swiper.scrollbar;
	    var rtl = swiper.rtlTranslate;
	    var $el = scrollbar.$el;
	    var dragSize = scrollbar.dragSize;
	    var trackSize = scrollbar.trackSize;

	    var pointerPosition;
	    if (swiper.isHorizontal()) {
	      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX);
	    } else {
	      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);
	    }
	    var positionRatio;
	    positionRatio = ((pointerPosition) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragSize / 2)) / (trackSize - dragSize);
	    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
	    if (rtl) {
	      positionRatio = 1 - positionRatio;
	    }

	    var position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);

	    swiper.updateProgress(position);
	    swiper.setTranslate(position);
	    swiper.updateActiveIndex();
	    swiper.updateSlidesClasses();
	  },
	  onDragStart: function onDragStart(e) {
	    var swiper = this;
	    var params = swiper.params.scrollbar;
	    var scrollbar = swiper.scrollbar;
	    var $wrapperEl = swiper.$wrapperEl;
	    var $el = scrollbar.$el;
	    var $dragEl = scrollbar.$dragEl;
	    swiper.scrollbar.isTouched = true;
	    e.preventDefault();
	    e.stopPropagation();

	    $wrapperEl.transition(100);
	    $dragEl.transition(100);
	    scrollbar.setDragPosition(e);

	    clearTimeout(swiper.scrollbar.dragTimeout);

	    $el.transition(0);
	    if (params.hide) {
	      $el.css('opacity', 1);
	    }
	    swiper.emit('scrollbarDragStart', e);
	  },
	  onDragMove: function onDragMove(e) {
	    var swiper = this;
	    var scrollbar = swiper.scrollbar;
	    var $wrapperEl = swiper.$wrapperEl;
	    var $el = scrollbar.$el;
	    var $dragEl = scrollbar.$dragEl;

	    if (!swiper.scrollbar.isTouched) { return; }
	    if (e.preventDefault) { e.preventDefault(); }
	    else { e.returnValue = false; }
	    scrollbar.setDragPosition(e);
	    $wrapperEl.transition(0);
	    $el.transition(0);
	    $dragEl.transition(0);
	    swiper.emit('scrollbarDragMove', e);
	  },
	  onDragEnd: function onDragEnd(e) {
	    var swiper = this;

	    var params = swiper.params.scrollbar;
	    var scrollbar = swiper.scrollbar;
	    var $el = scrollbar.$el;

	    if (!swiper.scrollbar.isTouched) { return; }
	    swiper.scrollbar.isTouched = false;
	    if (params.hide) {
	      clearTimeout(swiper.scrollbar.dragTimeout);
	      swiper.scrollbar.dragTimeout = Utils.nextTick(function () {
	        $el.css('opacity', 0);
	        $el.transition(400);
	      }, 1000);
	    }
	    swiper.emit('scrollbarDragEnd', e);
	    if (params.snapOnRelease) {
	      swiper.slideToClosest();
	    }
	  },
	  enableDraggable: function enableDraggable() {
	    var swiper = this;
	    if (!swiper.params.scrollbar.el) { return; }
	    var scrollbar = swiper.scrollbar;
	    var touchEventsTouch = swiper.touchEventsTouch;
	    var touchEventsDesktop = swiper.touchEventsDesktop;
	    var params = swiper.params;
	    var $el = scrollbar.$el;
	    var target = $el[0];
	    var activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
	    var passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
	    if (!Support.touch) {
	      target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
	      doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
	      doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
	    } else {
	      target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
	      target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
	      target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
	    }
	  },
	  disableDraggable: function disableDraggable() {
	    var swiper = this;
	    if (!swiper.params.scrollbar.el) { return; }
	    var scrollbar = swiper.scrollbar;
	    var touchEventsTouch = swiper.touchEventsTouch;
	    var touchEventsDesktop = swiper.touchEventsDesktop;
	    var params = swiper.params;
	    var $el = scrollbar.$el;
	    var target = $el[0];
	    var activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
	    var passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
	    if (!Support.touch) {
	      target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
	      doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
	      doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
	    } else {
	      target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
	      target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
	      target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
	    }
	  },
	  init: function init() {
	    var swiper = this;
	    if (!swiper.params.scrollbar.el) { return; }
	    var scrollbar = swiper.scrollbar;
	    var $swiperEl = swiper.$el;
	    var params = swiper.params.scrollbar;

	    var $el = $(params.el);
	    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
	      $el = $swiperEl.find(params.el);
	    }

	    var $dragEl = $el.find(("." + (swiper.params.scrollbar.dragClass)));
	    if ($dragEl.length === 0) {
	      $dragEl = $(("<div class=\"" + (swiper.params.scrollbar.dragClass) + "\"></div>"));
	      $el.append($dragEl);
	    }

	    Utils.extend(scrollbar, {
	      $el: $el,
	      el: $el[0],
	      $dragEl: $dragEl,
	      dragEl: $dragEl[0],
	    });

	    if (params.draggable) {
	      scrollbar.enableDraggable();
	    }
	  },
	  destroy: function destroy() {
	    var swiper = this;
	    swiper.scrollbar.disableDraggable();
	  },
	};

	var Scrollbar$1 = {
	  name: 'scrollbar',
	  params: {
	    scrollbar: {
	      el: null,
	      dragSize: 'auto',
	      hide: false,
	      draggable: false,
	      snapOnRelease: true,
	      lockClass: 'swiper-scrollbar-lock',
	      dragClass: 'swiper-scrollbar-drag',
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      scrollbar: {
	        init: Scrollbar.init.bind(swiper),
	        destroy: Scrollbar.destroy.bind(swiper),
	        updateSize: Scrollbar.updateSize.bind(swiper),
	        setTranslate: Scrollbar.setTranslate.bind(swiper),
	        setTransition: Scrollbar.setTransition.bind(swiper),
	        enableDraggable: Scrollbar.enableDraggable.bind(swiper),
	        disableDraggable: Scrollbar.disableDraggable.bind(swiper),
	        setDragPosition: Scrollbar.setDragPosition.bind(swiper),
	        onDragStart: Scrollbar.onDragStart.bind(swiper),
	        onDragMove: Scrollbar.onDragMove.bind(swiper),
	        onDragEnd: Scrollbar.onDragEnd.bind(swiper),
	        isTouched: false,
	        timeout: null,
	        dragTimeout: null,
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      swiper.scrollbar.init();
	      swiper.scrollbar.updateSize();
	      swiper.scrollbar.setTranslate();
	    },
	    update: function update() {
	      var swiper = this;
	      swiper.scrollbar.updateSize();
	    },
	    resize: function resize() {
	      var swiper = this;
	      swiper.scrollbar.updateSize();
	    },
	    observerUpdate: function observerUpdate() {
	      var swiper = this;
	      swiper.scrollbar.updateSize();
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      swiper.scrollbar.setTranslate();
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      swiper.scrollbar.setTransition(duration);
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      swiper.scrollbar.destroy();
	    },
	  },
	};

	var Parallax = {
	  setTransform: function setTransform(el, progress) {
	    var swiper = this;
	    var rtl = swiper.rtl;

	    var $el = $(el);
	    var rtlFactor = rtl ? -1 : 1;

	    var p = $el.attr('data-swiper-parallax') || '0';
	    var x = $el.attr('data-swiper-parallax-x');
	    var y = $el.attr('data-swiper-parallax-y');
	    var scale = $el.attr('data-swiper-parallax-scale');
	    var opacity = $el.attr('data-swiper-parallax-opacity');

	    if (x || y) {
	      x = x || '0';
	      y = y || '0';
	    } else if (swiper.isHorizontal()) {
	      x = p;
	      y = '0';
	    } else {
	      y = p;
	      x = '0';
	    }

	    if ((x).indexOf('%') >= 0) {
	      x = (parseInt(x, 10) * progress * rtlFactor) + "%";
	    } else {
	      x = (x * progress * rtlFactor) + "px";
	    }
	    if ((y).indexOf('%') >= 0) {
	      y = (parseInt(y, 10) * progress) + "%";
	    } else {
	      y = (y * progress) + "px";
	    }

	    if (typeof opacity !== 'undefined' && opacity !== null) {
	      var currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
	      $el[0].style.opacity = currentOpacity;
	    }
	    if (typeof scale === 'undefined' || scale === null) {
	      $el.transform(("translate3d(" + x + ", " + y + ", 0px)"));
	    } else {
	      var currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
	      $el.transform(("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")"));
	    }
	  },
	  setTranslate: function setTranslate() {
	    var swiper = this;
	    var $el = swiper.$el;
	    var slides = swiper.slides;
	    var progress = swiper.progress;
	    var snapGrid = swiper.snapGrid;
	    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
	      .each(function (index, el) {
	        swiper.parallax.setTransform(el, progress);
	      });
	    slides.each(function (slideIndex, slideEl) {
	      var slideProgress = slideEl.progress;
	      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
	        slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));
	      }
	      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
	      $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
	        .each(function (index, el) {
	          swiper.parallax.setTransform(el, slideProgress);
	        });
	    });
	  },
	  setTransition: function setTransition(duration) {
	    if ( duration === void 0 ) duration = this.params.speed;

	    var swiper = this;
	    var $el = swiper.$el;
	    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
	      .each(function (index, parallaxEl) {
	        var $parallaxEl = $(parallaxEl);
	        var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
	        if (duration === 0) { parallaxDuration = 0; }
	        $parallaxEl.transition(parallaxDuration);
	      });
	  },
	};

	var Parallax$1 = {
	  name: 'parallax',
	  params: {
	    parallax: {
	      enabled: false,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      parallax: {
	        setTransform: Parallax.setTransform.bind(swiper),
	        setTranslate: Parallax.setTranslate.bind(swiper),
	        setTransition: Parallax.setTransition.bind(swiper),
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      if (!swiper.params.parallax.enabled) { return; }
	      swiper.params.watchSlidesProgress = true;
	      swiper.originalParams.watchSlidesProgress = true;
	    },
	    init: function init() {
	      var swiper = this;
	      if (!swiper.params.parallax.enabled) { return; }
	      swiper.parallax.setTranslate();
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      if (!swiper.params.parallax.enabled) { return; }
	      swiper.parallax.setTranslate();
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      if (!swiper.params.parallax.enabled) { return; }
	      swiper.parallax.setTransition(duration);
	    },
	  },
	};

	var Zoom = {
	  // Calc Scale From Multi-touches
	  getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
	    if (e.targetTouches.length < 2) { return 1; }
	    var x1 = e.targetTouches[0].pageX;
	    var y1 = e.targetTouches[0].pageY;
	    var x2 = e.targetTouches[1].pageX;
	    var y2 = e.targetTouches[1].pageY;
	    var distance = Math.sqrt((Math.pow( (x2 - x1), 2 )) + (Math.pow( (y2 - y1), 2 )));
	    return distance;
	  },
	  // Events
	  onGestureStart: function onGestureStart(e) {
	    var swiper = this;
	    var params = swiper.params.zoom;
	    var zoom = swiper.zoom;
	    var gesture = zoom.gesture;
	    zoom.fakeGestureTouched = false;
	    zoom.fakeGestureMoved = false;
	    if (!Support.gestures) {
	      if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
	        return;
	      }
	      zoom.fakeGestureTouched = true;
	      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
	    }
	    if (!gesture.$slideEl || !gesture.$slideEl.length) {
	      gesture.$slideEl = $(e.target).closest('.swiper-slide');
	      if (gesture.$slideEl.length === 0) { gesture.$slideEl = swiper.slides.eq(swiper.activeIndex); }
	      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
	      gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
	      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
	      if (gesture.$imageWrapEl.length === 0) {
	        gesture.$imageEl = undefined;
	        return;
	      }
	    }
	    gesture.$imageEl.transition(0);
	    swiper.zoom.isScaling = true;
	  },
	  onGestureChange: function onGestureChange(e) {
	    var swiper = this;
	    var params = swiper.params.zoom;
	    var zoom = swiper.zoom;
	    var gesture = zoom.gesture;
	    if (!Support.gestures) {
	      if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
	        return;
	      }
	      zoom.fakeGestureMoved = true;
	      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
	    }
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	    if (Support.gestures) {
	      zoom.scale = e.scale * zoom.currentScale;
	    } else {
	      zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
	    }
	    if (zoom.scale > gesture.maxRatio) {
	      zoom.scale = (gesture.maxRatio - 1) + (Math.pow( ((zoom.scale - gesture.maxRatio) + 1), 0.5 ));
	    }
	    if (zoom.scale < params.minRatio) {
	      zoom.scale = (params.minRatio + 1) - (Math.pow( ((params.minRatio - zoom.scale) + 1), 0.5 ));
	    }
	    gesture.$imageEl.transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
	  },
	  onGestureEnd: function onGestureEnd(e) {
	    var swiper = this;
	    var params = swiper.params.zoom;
	    var zoom = swiper.zoom;
	    var gesture = zoom.gesture;
	    if (!Support.gestures) {
	      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
	        return;
	      }
	      if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {
	        return;
	      }
	      zoom.fakeGestureTouched = false;
	      zoom.fakeGestureMoved = false;
	    }
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
	    gesture.$imageEl.transition(swiper.params.speed).transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
	    zoom.currentScale = zoom.scale;
	    zoom.isScaling = false;
	    if (zoom.scale === 1) { gesture.$slideEl = undefined; }
	  },
	  onTouchStart: function onTouchStart(e) {
	    var swiper = this;
	    var zoom = swiper.zoom;
	    var gesture = zoom.gesture;
	    var image = zoom.image;
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	    if (image.isTouched) { return; }
	    if (Device.android) { e.preventDefault(); }
	    image.isTouched = true;
	    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	  },
	  onTouchMove: function onTouchMove(e) {
	    var swiper = this;
	    var zoom = swiper.zoom;
	    var gesture = zoom.gesture;
	    var image = zoom.image;
	    var velocity = zoom.velocity;
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	    swiper.allowClick = false;
	    if (!image.isTouched || !gesture.$slideEl) { return; }

	    if (!image.isMoved) {
	      image.width = gesture.$imageEl[0].offsetWidth;
	      image.height = gesture.$imageEl[0].offsetHeight;
	      image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
	      image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
	      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
	      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
	      gesture.$imageWrapEl.transition(0);
	      if (swiper.rtl) {
	        image.startX = -image.startX;
	        image.startY = -image.startY;
	      }
	    }
	    // Define if we need image drag
	    var scaledWidth = image.width * zoom.scale;
	    var scaledHeight = image.height * zoom.scale;

	    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) { return; }

	    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
	    image.maxX = -image.minX;
	    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
	    image.maxY = -image.minY;

	    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

	    if (!image.isMoved && !zoom.isScaling) {
	      if (
	        swiper.isHorizontal()
	        && (
	          (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)
	          || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)
	        )
	      ) {
	        image.isTouched = false;
	        return;
	      } if (
	        !swiper.isHorizontal()
	        && (
	          (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)
	          || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)
	        )
	      ) {
	        image.isTouched = false;
	        return;
	      }
	    }
	    e.preventDefault();
	    e.stopPropagation();

	    image.isMoved = true;
	    image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
	    image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;

	    if (image.currentX < image.minX) {
	      image.currentX = (image.minX + 1) - (Math.pow( ((image.minX - image.currentX) + 1), 0.8 ));
	    }
	    if (image.currentX > image.maxX) {
	      image.currentX = (image.maxX - 1) + (Math.pow( ((image.currentX - image.maxX) + 1), 0.8 ));
	    }

	    if (image.currentY < image.minY) {
	      image.currentY = (image.minY + 1) - (Math.pow( ((image.minY - image.currentY) + 1), 0.8 ));
	    }
	    if (image.currentY > image.maxY) {
	      image.currentY = (image.maxY - 1) + (Math.pow( ((image.currentY - image.maxY) + 1), 0.8 ));
	    }

	    // Velocity
	    if (!velocity.prevPositionX) { velocity.prevPositionX = image.touchesCurrent.x; }
	    if (!velocity.prevPositionY) { velocity.prevPositionY = image.touchesCurrent.y; }
	    if (!velocity.prevTime) { velocity.prevTime = Date.now(); }
	    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
	    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
	    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) { velocity.x = 0; }
	    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) { velocity.y = 0; }
	    velocity.prevPositionX = image.touchesCurrent.x;
	    velocity.prevPositionY = image.touchesCurrent.y;
	    velocity.prevTime = Date.now();

	    gesture.$imageWrapEl.transform(("translate3d(" + (image.currentX) + "px, " + (image.currentY) + "px,0)"));
	  },
	  onTouchEnd: function onTouchEnd() {
	    var swiper = this;
	    var zoom = swiper.zoom;
	    var gesture = zoom.gesture;
	    var image = zoom.image;
	    var velocity = zoom.velocity;
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	    if (!image.isTouched || !image.isMoved) {
	      image.isTouched = false;
	      image.isMoved = false;
	      return;
	    }
	    image.isTouched = false;
	    image.isMoved = false;
	    var momentumDurationX = 300;
	    var momentumDurationY = 300;
	    var momentumDistanceX = velocity.x * momentumDurationX;
	    var newPositionX = image.currentX + momentumDistanceX;
	    var momentumDistanceY = velocity.y * momentumDurationY;
	    var newPositionY = image.currentY + momentumDistanceY;

	    // Fix duration
	    if (velocity.x !== 0) { momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x); }
	    if (velocity.y !== 0) { momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y); }
	    var momentumDuration = Math.max(momentumDurationX, momentumDurationY);

	    image.currentX = newPositionX;
	    image.currentY = newPositionY;

	    // Define if we need image drag
	    var scaledWidth = image.width * zoom.scale;
	    var scaledHeight = image.height * zoom.scale;
	    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
	    image.maxX = -image.minX;
	    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
	    image.maxY = -image.minY;
	    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
	    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);

	    gesture.$imageWrapEl.transition(momentumDuration).transform(("translate3d(" + (image.currentX) + "px, " + (image.currentY) + "px,0)"));
	  },
	  onTransitionEnd: function onTransitionEnd() {
	    var swiper = this;
	    var zoom = swiper.zoom;
	    var gesture = zoom.gesture;
	    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
	      gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
	      gesture.$imageWrapEl.transform('translate3d(0,0,0)');

	      zoom.scale = 1;
	      zoom.currentScale = 1;

	      gesture.$slideEl = undefined;
	      gesture.$imageEl = undefined;
	      gesture.$imageWrapEl = undefined;
	    }
	  },
	  // Toggle Zoom
	  toggle: function toggle(e) {
	    var swiper = this;
	    var zoom = swiper.zoom;

	    if (zoom.scale && zoom.scale !== 1) {
	      // Zoom Out
	      zoom.out();
	    } else {
	      // Zoom In
	      zoom.in(e);
	    }
	  },
	  in: function in$1(e) {
	    var swiper = this;

	    var zoom = swiper.zoom;
	    var params = swiper.params.zoom;
	    var gesture = zoom.gesture;
	    var image = zoom.image;

	    if (!gesture.$slideEl) {
	      gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
	      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
	      gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
	    }
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }

	    gesture.$slideEl.addClass(("" + (params.zoomedSlideClass)));

	    var touchX;
	    var touchY;
	    var offsetX;
	    var offsetY;
	    var diffX;
	    var diffY;
	    var translateX;
	    var translateY;
	    var imageWidth;
	    var imageHeight;
	    var scaledWidth;
	    var scaledHeight;
	    var translateMinX;
	    var translateMinY;
	    var translateMaxX;
	    var translateMaxY;
	    var slideWidth;
	    var slideHeight;

	    if (typeof image.touchesStart.x === 'undefined' && e) {
	      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
	      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
	    } else {
	      touchX = image.touchesStart.x;
	      touchY = image.touchesStart.y;
	    }

	    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
	    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
	    if (e) {
	      slideWidth = gesture.$slideEl[0].offsetWidth;
	      slideHeight = gesture.$slideEl[0].offsetHeight;
	      offsetX = gesture.$slideEl.offset().left;
	      offsetY = gesture.$slideEl.offset().top;
	      diffX = (offsetX + (slideWidth / 2)) - touchX;
	      diffY = (offsetY + (slideHeight / 2)) - touchY;

	      imageWidth = gesture.$imageEl[0].offsetWidth;
	      imageHeight = gesture.$imageEl[0].offsetHeight;
	      scaledWidth = imageWidth * zoom.scale;
	      scaledHeight = imageHeight * zoom.scale;

	      translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
	      translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
	      translateMaxX = -translateMinX;
	      translateMaxY = -translateMinY;

	      translateX = diffX * zoom.scale;
	      translateY = diffY * zoom.scale;

	      if (translateX < translateMinX) {
	        translateX = translateMinX;
	      }
	      if (translateX > translateMaxX) {
	        translateX = translateMaxX;
	      }

	      if (translateY < translateMinY) {
	        translateY = translateMinY;
	      }
	      if (translateY > translateMaxY) {
	        translateY = translateMaxY;
	      }
	    } else {
	      translateX = 0;
	      translateY = 0;
	    }
	    gesture.$imageWrapEl.transition(300).transform(("translate3d(" + translateX + "px, " + translateY + "px,0)"));
	    gesture.$imageEl.transition(300).transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
	  },
	  out: function out() {
	    var swiper = this;

	    var zoom = swiper.zoom;
	    var params = swiper.params.zoom;
	    var gesture = zoom.gesture;

	    if (!gesture.$slideEl) {
	      gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
	      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
	      gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
	    }
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }

	    zoom.scale = 1;
	    zoom.currentScale = 1;
	    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
	    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
	    gesture.$slideEl.removeClass(("" + (params.zoomedSlideClass)));
	    gesture.$slideEl = undefined;
	  },
	  // Attach/Detach Events
	  enable: function enable() {
	    var swiper = this;
	    var zoom = swiper.zoom;
	    if (zoom.enabled) { return; }
	    zoom.enabled = true;

	    var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;

	    // Scale image
	    if (Support.gestures) {
	      swiper.$wrapperEl.on('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
	      swiper.$wrapperEl.on('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
	      swiper.$wrapperEl.on('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
	    } else if (swiper.touchEvents.start === 'touchstart') {
	      swiper.$wrapperEl.on(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
	      swiper.$wrapperEl.on(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
	      swiper.$wrapperEl.on(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
	    }

	    // Move image
	    swiper.$wrapperEl.on(swiper.touchEvents.move, ("." + (swiper.params.zoom.containerClass)), zoom.onTouchMove);
	  },
	  disable: function disable() {
	    var swiper = this;
	    var zoom = swiper.zoom;
	    if (!zoom.enabled) { return; }

	    swiper.zoom.enabled = false;

	    var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;

	    // Scale image
	    if (Support.gestures) {
	      swiper.$wrapperEl.off('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
	      swiper.$wrapperEl.off('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
	      swiper.$wrapperEl.off('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
	    } else if (swiper.touchEvents.start === 'touchstart') {
	      swiper.$wrapperEl.off(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
	      swiper.$wrapperEl.off(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
	      swiper.$wrapperEl.off(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
	    }

	    // Move image
	    swiper.$wrapperEl.off(swiper.touchEvents.move, ("." + (swiper.params.zoom.containerClass)), zoom.onTouchMove);
	  },
	};

	var Zoom$1 = {
	  name: 'zoom',
	  params: {
	    zoom: {
	      enabled: false,
	      maxRatio: 3,
	      minRatio: 1,
	      toggle: true,
	      containerClass: 'swiper-zoom-container',
	      zoomedSlideClass: 'swiper-slide-zoomed',
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    var zoom = {
	      enabled: false,
	      scale: 1,
	      currentScale: 1,
	      isScaling: false,
	      gesture: {
	        $slideEl: undefined,
	        slideWidth: undefined,
	        slideHeight: undefined,
	        $imageEl: undefined,
	        $imageWrapEl: undefined,
	        maxRatio: 3,
	      },
	      image: {
	        isTouched: undefined,
	        isMoved: undefined,
	        currentX: undefined,
	        currentY: undefined,
	        minX: undefined,
	        minY: undefined,
	        maxX: undefined,
	        maxY: undefined,
	        width: undefined,
	        height: undefined,
	        startX: undefined,
	        startY: undefined,
	        touchesStart: {},
	        touchesCurrent: {},
	      },
	      velocity: {
	        x: undefined,
	        y: undefined,
	        prevPositionX: undefined,
	        prevPositionY: undefined,
	        prevTime: undefined,
	      },
	    };

	    ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach(function (methodName) {
	      zoom[methodName] = Zoom[methodName].bind(swiper);
	    });
	    Utils.extend(swiper, {
	      zoom: zoom,
	    });

	    var scale = 1;
	    Object.defineProperty(swiper.zoom, 'scale', {
	      get: function get() {
	        return scale;
	      },
	      set: function set(value) {
	        if (scale !== value) {
	          var imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
	          var slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
	          swiper.emit('zoomChange', value, imageEl, slideEl);
	        }
	        scale = value;
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      if (swiper.params.zoom.enabled) {
	        swiper.zoom.enable();
	      }
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      swiper.zoom.disable();
	    },
	    touchStart: function touchStart(e) {
	      var swiper = this;
	      if (!swiper.zoom.enabled) { return; }
	      swiper.zoom.onTouchStart(e);
	    },
	    touchEnd: function touchEnd(e) {
	      var swiper = this;
	      if (!swiper.zoom.enabled) { return; }
	      swiper.zoom.onTouchEnd(e);
	    },
	    doubleTap: function doubleTap(e) {
	      var swiper = this;
	      if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
	        swiper.zoom.toggle(e);
	      }
	    },
	    transitionEnd: function transitionEnd() {
	      var swiper = this;
	      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
	        swiper.zoom.onTransitionEnd();
	      }
	    },
	  },
	};

	var Lazy$2 = {
	  loadInSlide: function loadInSlide(index, loadInDuplicate) {
	    if ( loadInDuplicate === void 0 ) loadInDuplicate = true;

	    var swiper = this;
	    var params = swiper.params.lazy;
	    if (typeof index === 'undefined') { return; }
	    if (swiper.slides.length === 0) { return; }
	    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;

	    var $slideEl = isVirtual
	      ? swiper.$wrapperEl.children(("." + (swiper.params.slideClass) + "[data-swiper-slide-index=\"" + index + "\"]"))
	      : swiper.slides.eq(index);

	    var $images = $slideEl.find(("." + (params.elementClass) + ":not(." + (params.loadedClass) + "):not(." + (params.loadingClass) + ")"));
	    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
	      $images = $images.add($slideEl[0]);
	    }
	    if ($images.length === 0) { return; }

	    $images.each(function (imageIndex, imageEl) {
	      var $imageEl = $(imageEl);
	      $imageEl.addClass(params.loadingClass);

	      var background = $imageEl.attr('data-background');
	      var src = $imageEl.attr('data-src');
	      var srcset = $imageEl.attr('data-srcset');
	      var sizes = $imageEl.attr('data-sizes');

	      swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, function () {
	        if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) { return; }
	        if (background) {
	          $imageEl.css('background-image', ("url(\"" + background + "\")"));
	          $imageEl.removeAttr('data-background');
	        } else {
	          if (srcset) {
	            $imageEl.attr('srcset', srcset);
	            $imageEl.removeAttr('data-srcset');
	          }
	          if (sizes) {
	            $imageEl.attr('sizes', sizes);
	            $imageEl.removeAttr('data-sizes');
	          }
	          if (src) {
	            $imageEl.attr('src', src);
	            $imageEl.removeAttr('data-src');
	          }
	        }

	        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
	        $slideEl.find(("." + (params.preloaderClass))).remove();
	        if (swiper.params.loop && loadInDuplicate) {
	          var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
	          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
	            var originalSlide = swiper.$wrapperEl.children(("[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]:not(." + (swiper.params.slideDuplicateClass) + ")"));
	            swiper.lazy.loadInSlide(originalSlide.index(), false);
	          } else {
	            var duplicatedSlide = swiper.$wrapperEl.children(("." + (swiper.params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]"));
	            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
	          }
	        }
	        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
	      });

	      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
	    });
	  },
	  load: function load() {
	    var swiper = this;
	    var $wrapperEl = swiper.$wrapperEl;
	    var swiperParams = swiper.params;
	    var slides = swiper.slides;
	    var activeIndex = swiper.activeIndex;
	    var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
	    var params = swiperParams.lazy;

	    var slidesPerView = swiperParams.slidesPerView;
	    if (slidesPerView === 'auto') {
	      slidesPerView = 0;
	    }

	    function slideExist(index) {
	      if (isVirtual) {
	        if ($wrapperEl.children(("." + (swiperParams.slideClass) + "[data-swiper-slide-index=\"" + index + "\"]")).length) {
	          return true;
	        }
	      } else if (slides[index]) { return true; }
	      return false;
	    }
	    function slideIndex(slideEl) {
	      if (isVirtual) {
	        return $(slideEl).attr('data-swiper-slide-index');
	      }
	      return $(slideEl).index();
	    }

	    if (!swiper.lazy.initialImageLoaded) { swiper.lazy.initialImageLoaded = true; }
	    if (swiper.params.watchSlidesVisibility) {
	      $wrapperEl.children(("." + (swiperParams.slideVisibleClass))).each(function (elIndex, slideEl) {
	        var index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
	        swiper.lazy.loadInSlide(index);
	      });
	    } else if (slidesPerView > 1) {
	      for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
	        if (slideExist(i)) { swiper.lazy.loadInSlide(i); }
	      }
	    } else {
	      swiper.lazy.loadInSlide(activeIndex);
	    }
	    if (params.loadPrevNext) {
	      if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
	        var amount = params.loadPrevNextAmount;
	        var spv = slidesPerView;
	        var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
	        var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
	        // Next Slides
	        for (var i$1 = activeIndex + slidesPerView; i$1 < maxIndex; i$1 += 1) {
	          if (slideExist(i$1)) { swiper.lazy.loadInSlide(i$1); }
	        }
	        // Prev Slides
	        for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) {
	          if (slideExist(i$2)) { swiper.lazy.loadInSlide(i$2); }
	        }
	      } else {
	        var nextSlide = $wrapperEl.children(("." + (swiperParams.slideNextClass)));
	        if (nextSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(nextSlide)); }

	        var prevSlide = $wrapperEl.children(("." + (swiperParams.slidePrevClass)));
	        if (prevSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(prevSlide)); }
	      }
	    }
	  },
	};

	var Lazy$3 = {
	  name: 'lazy',
	  params: {
	    lazy: {
	      enabled: false,
	      loadPrevNext: false,
	      loadPrevNextAmount: 1,
	      loadOnTransitionStart: false,

	      elementClass: 'swiper-lazy',
	      loadingClass: 'swiper-lazy-loading',
	      loadedClass: 'swiper-lazy-loaded',
	      preloaderClass: 'swiper-lazy-preloader',
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      lazy: {
	        initialImageLoaded: false,
	        load: Lazy$2.load.bind(swiper),
	        loadInSlide: Lazy$2.loadInSlide.bind(swiper),
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
	        swiper.params.preloadImages = false;
	      }
	    },
	    init: function init() {
	      var swiper = this;
	      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
	        swiper.lazy.load();
	      }
	    },
	    scroll: function scroll() {
	      var swiper = this;
	      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
	        swiper.lazy.load();
	      }
	    },
	    resize: function resize() {
	      var swiper = this;
	      if (swiper.params.lazy.enabled) {
	        swiper.lazy.load();
	      }
	    },
	    scrollbarDragMove: function scrollbarDragMove() {
	      var swiper = this;
	      if (swiper.params.lazy.enabled) {
	        swiper.lazy.load();
	      }
	    },
	    transitionStart: function transitionStart() {
	      var swiper = this;
	      if (swiper.params.lazy.enabled) {
	        if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
	          swiper.lazy.load();
	        }
	      }
	    },
	    transitionEnd: function transitionEnd() {
	      var swiper = this;
	      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
	        swiper.lazy.load();
	      }
	    },
	  },
	};

	/* eslint no-bitwise: ["error", { "allow": [">>"] }] */

	var Controller = {
	  LinearSpline: function LinearSpline(x, y) {
	    var binarySearch = (function search() {
	      var maxIndex;
	      var minIndex;
	      var guess;
	      return function (array, val) {
	        minIndex = -1;
	        maxIndex = array.length;
	        while (maxIndex - minIndex > 1) {
	          guess = maxIndex + minIndex >> 1;
	          if (array[guess] <= val) {
	            minIndex = guess;
	          } else {
	            maxIndex = guess;
	          }
	        }
	        return maxIndex;
	      };
	    }());
	    this.x = x;
	    this.y = y;
	    this.lastIndex = x.length - 1;
	    // Given an x value (x2), return the expected y2 value:
	    // (x1,y1) is the known point before given value,
	    // (x3,y3) is the known point after given value.
	    var i1;
	    var i3;

	    this.interpolate = function interpolate(x2) {
	      if (!x2) { return 0; }

	      // Get the indexes of x1 and x3 (the array indexes before and after given x2):
	      i3 = binarySearch(this.x, x2);
	      i1 = i3 - 1;

	      // We have our indexes i1 & i3, so we can calculate already:
	      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
	      return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
	    };
	    return this;
	  },
	  // xxx: for now i will just save one spline function to to
	  getInterpolateFunction: function getInterpolateFunction(c) {
	    var swiper = this;
	    if (!swiper.controller.spline) {
	      swiper.controller.spline = swiper.params.loop
	        ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)
	        : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
	    }
	  },
	  setTranslate: function setTranslate(setTranslate$1, byController) {
	    var swiper = this;
	    var controlled = swiper.controller.control;
	    var multiplier;
	    var controlledTranslate;
	    function setControlledTranslate(c) {
	      // this will create an Interpolate function based on the snapGrids
	      // x is the Grid of the scrolled scroller and y will be the controlled scroller
	      // it makes sense to create this only once and recall it for the interpolation
	      // the function does a lot of value caching for performance
	      var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
	      if (swiper.params.controller.by === 'slide') {
	        swiper.controller.getInterpolateFunction(c);
	        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
	        // but it did not work out
	        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
	      }

	      if (!controlledTranslate || swiper.params.controller.by === 'container') {
	        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
	        controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
	      }

	      if (swiper.params.controller.inverse) {
	        controlledTranslate = c.maxTranslate() - controlledTranslate;
	      }
	      c.updateProgress(controlledTranslate);
	      c.setTranslate(controlledTranslate, swiper);
	      c.updateActiveIndex();
	      c.updateSlidesClasses();
	    }
	    if (Array.isArray(controlled)) {
	      for (var i = 0; i < controlled.length; i += 1) {
	        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
	          setControlledTranslate(controlled[i]);
	        }
	      }
	    } else if (controlled instanceof Swiper && byController !== controlled) {
	      setControlledTranslate(controlled);
	    }
	  },
	  setTransition: function setTransition(duration, byController) {
	    var swiper = this;
	    var controlled = swiper.controller.control;
	    var i;
	    function setControlledTransition(c) {
	      c.setTransition(duration, swiper);
	      if (duration !== 0) {
	        c.transitionStart();
	        if (c.params.autoHeight) {
	          Utils.nextTick(function () {
	            c.updateAutoHeight();
	          });
	        }
	        c.$wrapperEl.transitionEnd(function () {
	          if (!controlled) { return; }
	          if (c.params.loop && swiper.params.controller.by === 'slide') {
	            c.loopFix();
	          }
	          c.transitionEnd();
	        });
	      }
	    }
	    if (Array.isArray(controlled)) {
	      for (i = 0; i < controlled.length; i += 1) {
	        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
	          setControlledTransition(controlled[i]);
	        }
	      }
	    } else if (controlled instanceof Swiper && byController !== controlled) {
	      setControlledTransition(controlled);
	    }
	  },
	};
	var Controller$1 = {
	  name: 'controller',
	  params: {
	    controller: {
	      control: undefined,
	      inverse: false,
	      by: 'slide', // or 'container'
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      controller: {
	        control: swiper.params.controller.control,
	        getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
	        setTranslate: Controller.setTranslate.bind(swiper),
	        setTransition: Controller.setTransition.bind(swiper),
	      },
	    });
	  },
	  on: {
	    update: function update() {
	      var swiper = this;
	      if (!swiper.controller.control) { return; }
	      if (swiper.controller.spline) {
	        swiper.controller.spline = undefined;
	        delete swiper.controller.spline;
	      }
	    },
	    resize: function resize() {
	      var swiper = this;
	      if (!swiper.controller.control) { return; }
	      if (swiper.controller.spline) {
	        swiper.controller.spline = undefined;
	        delete swiper.controller.spline;
	      }
	    },
	    observerUpdate: function observerUpdate() {
	      var swiper = this;
	      if (!swiper.controller.control) { return; }
	      if (swiper.controller.spline) {
	        swiper.controller.spline = undefined;
	        delete swiper.controller.spline;
	      }
	    },
	    setTranslate: function setTranslate(translate, byController) {
	      var swiper = this;
	      if (!swiper.controller.control) { return; }
	      swiper.controller.setTranslate(translate, byController);
	    },
	    setTransition: function setTransition(duration, byController) {
	      var swiper = this;
	      if (!swiper.controller.control) { return; }
	      swiper.controller.setTransition(duration, byController);
	    },
	  },
	};

	var a11y = {
	  makeElFocusable: function makeElFocusable($el) {
	    $el.attr('tabIndex', '0');
	    return $el;
	  },
	  addElRole: function addElRole($el, role) {
	    $el.attr('role', role);
	    return $el;
	  },
	  addElLabel: function addElLabel($el, label) {
	    $el.attr('aria-label', label);
	    return $el;
	  },
	  disableEl: function disableEl($el) {
	    $el.attr('aria-disabled', true);
	    return $el;
	  },
	  enableEl: function enableEl($el) {
	    $el.attr('aria-disabled', false);
	    return $el;
	  },
	  onEnterKey: function onEnterKey(e) {
	    var swiper = this;
	    var params = swiper.params.a11y;
	    if (e.keyCode !== 13) { return; }
	    var $targetEl = $(e.target);
	    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
	      if (!(swiper.isEnd && !swiper.params.loop)) {
	        swiper.slideNext();
	      }
	      if (swiper.isEnd) {
	        swiper.a11y.notify(params.lastSlideMessage);
	      } else {
	        swiper.a11y.notify(params.nextSlideMessage);
	      }
	    }
	    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
	      if (!(swiper.isBeginning && !swiper.params.loop)) {
	        swiper.slidePrev();
	      }
	      if (swiper.isBeginning) {
	        swiper.a11y.notify(params.firstSlideMessage);
	      } else {
	        swiper.a11y.notify(params.prevSlideMessage);
	      }
	    }
	    if (swiper.pagination && $targetEl.is(("." + (swiper.params.pagination.bulletClass)))) {
	      $targetEl[0].click();
	    }
	  },
	  notify: function notify(message) {
	    var swiper = this;
	    var notification = swiper.a11y.liveRegion;
	    if (notification.length === 0) { return; }
	    notification.html('');
	    notification.html(message);
	  },
	  updateNavigation: function updateNavigation() {
	    var swiper = this;

	    if (swiper.params.loop) { return; }
	    var ref = swiper.navigation;
	    var $nextEl = ref.$nextEl;
	    var $prevEl = ref.$prevEl;

	    if ($prevEl && $prevEl.length > 0) {
	      if (swiper.isBeginning) {
	        swiper.a11y.disableEl($prevEl);
	      } else {
	        swiper.a11y.enableEl($prevEl);
	      }
	    }
	    if ($nextEl && $nextEl.length > 0) {
	      if (swiper.isEnd) {
	        swiper.a11y.disableEl($nextEl);
	      } else {
	        swiper.a11y.enableEl($nextEl);
	      }
	    }
	  },
	  updatePagination: function updatePagination() {
	    var swiper = this;
	    var params = swiper.params.a11y;
	    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
	      swiper.pagination.bullets.each(function (bulletIndex, bulletEl) {
	        var $bulletEl = $(bulletEl);
	        swiper.a11y.makeElFocusable($bulletEl);
	        swiper.a11y.addElRole($bulletEl, 'button');
	        swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
	      });
	    }
	  },
	  init: function init() {
	    var swiper = this;

	    swiper.$el.append(swiper.a11y.liveRegion);

	    // Navigation
	    var params = swiper.params.a11y;
	    var $nextEl;
	    var $prevEl;
	    if (swiper.navigation && swiper.navigation.$nextEl) {
	      $nextEl = swiper.navigation.$nextEl;
	    }
	    if (swiper.navigation && swiper.navigation.$prevEl) {
	      $prevEl = swiper.navigation.$prevEl;
	    }
	    if ($nextEl) {
	      swiper.a11y.makeElFocusable($nextEl);
	      swiper.a11y.addElRole($nextEl, 'button');
	      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
	      $nextEl.on('keydown', swiper.a11y.onEnterKey);
	    }
	    if ($prevEl) {
	      swiper.a11y.makeElFocusable($prevEl);
	      swiper.a11y.addElRole($prevEl, 'button');
	      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
	      $prevEl.on('keydown', swiper.a11y.onEnterKey);
	    }

	    // Pagination
	    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
	      swiper.pagination.$el.on('keydown', ("." + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);
	    }
	  },
	  destroy: function destroy() {
	    var swiper = this;
	    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) { swiper.a11y.liveRegion.remove(); }

	    var $nextEl;
	    var $prevEl;
	    if (swiper.navigation && swiper.navigation.$nextEl) {
	      $nextEl = swiper.navigation.$nextEl;
	    }
	    if (swiper.navigation && swiper.navigation.$prevEl) {
	      $prevEl = swiper.navigation.$prevEl;
	    }
	    if ($nextEl) {
	      $nextEl.off('keydown', swiper.a11y.onEnterKey);
	    }
	    if ($prevEl) {
	      $prevEl.off('keydown', swiper.a11y.onEnterKey);
	    }

	    // Pagination
	    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
	      swiper.pagination.$el.off('keydown', ("." + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);
	    }
	  },
	};
	var A11y = {
	  name: 'a11y',
	  params: {
	    a11y: {
	      enabled: true,
	      notificationClass: 'swiper-notification',
	      prevSlideMessage: 'Previous slide',
	      nextSlideMessage: 'Next slide',
	      firstSlideMessage: 'This is the first slide',
	      lastSlideMessage: 'This is the last slide',
	      paginationBulletMessage: 'Go to slide {{index}}',
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      a11y: {
	        liveRegion: $(("<span class=\"" + (swiper.params.a11y.notificationClass) + "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>")),
	      },
	    });
	    Object.keys(a11y).forEach(function (methodName) {
	      swiper.a11y[methodName] = a11y[methodName].bind(swiper);
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      if (!swiper.params.a11y.enabled) { return; }
	      swiper.a11y.init();
	      swiper.a11y.updateNavigation();
	    },
	    toEdge: function toEdge() {
	      var swiper = this;
	      if (!swiper.params.a11y.enabled) { return; }
	      swiper.a11y.updateNavigation();
	    },
	    fromEdge: function fromEdge() {
	      var swiper = this;
	      if (!swiper.params.a11y.enabled) { return; }
	      swiper.a11y.updateNavigation();
	    },
	    paginationUpdate: function paginationUpdate() {
	      var swiper = this;
	      if (!swiper.params.a11y.enabled) { return; }
	      swiper.a11y.updatePagination();
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      if (!swiper.params.a11y.enabled) { return; }
	      swiper.a11y.destroy();
	    },
	  },
	};

	/* eslint no-underscore-dangle: "off" */

	var Autoplay = {
	  run: function run() {
	    var swiper = this;
	    var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
	    var delay = swiper.params.autoplay.delay;
	    if ($activeSlideEl.attr('data-swiper-autoplay')) {
	      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
	    }
	    swiper.autoplay.timeout = Utils.nextTick(function () {
	      if (swiper.params.autoplay.reverseDirection) {
	        if (swiper.params.loop) {
	          swiper.loopFix();
	          swiper.slidePrev(swiper.params.speed, true, true);
	          swiper.emit('autoplay');
	        } else if (!swiper.isBeginning) {
	          swiper.slidePrev(swiper.params.speed, true, true);
	          swiper.emit('autoplay');
	        } else if (!swiper.params.autoplay.stopOnLastSlide) {
	          swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
	          swiper.emit('autoplay');
	        } else {
	          swiper.autoplay.stop();
	        }
	      } else if (swiper.params.loop) {
	        swiper.loopFix();
	        swiper.slideNext(swiper.params.speed, true, true);
	        swiper.emit('autoplay');
	      } else if (!swiper.isEnd) {
	        swiper.slideNext(swiper.params.speed, true, true);
	        swiper.emit('autoplay');
	      } else if (!swiper.params.autoplay.stopOnLastSlide) {
	        swiper.slideTo(0, swiper.params.speed, true, true);
	        swiper.emit('autoplay');
	      } else {
	        swiper.autoplay.stop();
	      }
	    }, delay);
	  },
	  start: function start() {
	    var swiper = this;
	    if (typeof swiper.autoplay.timeout !== 'undefined') { return false; }
	    if (swiper.autoplay.running) { return false; }
	    swiper.autoplay.running = true;
	    swiper.emit('autoplayStart');
	    swiper.autoplay.run();
	    return true;
	  },
	  stop: function stop() {
	    var swiper = this;
	    if (!swiper.autoplay.running) { return false; }
	    if (typeof swiper.autoplay.timeout === 'undefined') { return false; }

	    if (swiper.autoplay.timeout) {
	      clearTimeout(swiper.autoplay.timeout);
	      swiper.autoplay.timeout = undefined;
	    }
	    swiper.autoplay.running = false;
	    swiper.emit('autoplayStop');
	    return true;
	  },
	  pause: function pause(speed) {
	    var swiper = this;
	    if (!swiper.autoplay.running) { return; }
	    if (swiper.autoplay.paused) { return; }
	    if (swiper.autoplay.timeout) { clearTimeout(swiper.autoplay.timeout); }
	    swiper.autoplay.paused = true;
	    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
	      swiper.autoplay.paused = false;
	      swiper.autoplay.run();
	    } else {
	      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
	      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
	    }
	  },
	};

	var Autoplay$1 = {
	  name: 'autoplay',
	  params: {
	    autoplay: {
	      enabled: false,
	      delay: 3000,
	      waitForTransition: true,
	      disableOnInteraction: true,
	      stopOnLastSlide: false,
	      reverseDirection: false,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      autoplay: {
	        running: false,
	        paused: false,
	        run: Autoplay.run.bind(swiper),
	        start: Autoplay.start.bind(swiper),
	        stop: Autoplay.stop.bind(swiper),
	        pause: Autoplay.pause.bind(swiper),
	        onTransitionEnd: function onTransitionEnd(e) {
	          if (!swiper || swiper.destroyed || !swiper.$wrapperEl) { return; }
	          if (e.target !== this) { return; }
	          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
	          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
	          swiper.autoplay.paused = false;
	          if (!swiper.autoplay.running) {
	            swiper.autoplay.stop();
	          } else {
	            swiper.autoplay.run();
	          }
	        },
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      if (swiper.params.autoplay.enabled) {
	        swiper.autoplay.start();
	      }
	    },
	    beforeTransitionStart: function beforeTransitionStart(speed, internal) {
	      var swiper = this;
	      if (swiper.autoplay.running) {
	        if (internal || !swiper.params.autoplay.disableOnInteraction) {
	          swiper.autoplay.pause(speed);
	        } else {
	          swiper.autoplay.stop();
	        }
	      }
	    },
	    sliderFirstMove: function sliderFirstMove() {
	      var swiper = this;
	      if (swiper.autoplay.running) {
	        if (swiper.params.autoplay.disableOnInteraction) {
	          swiper.autoplay.stop();
	        } else {
	          swiper.autoplay.pause();
	        }
	      }
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      if (swiper.autoplay.running) {
	        swiper.autoplay.stop();
	      }
	    },
	  },
	};

	var Fade = {
	  setTranslate: function setTranslate() {
	    var swiper = this;
	    var slides = swiper.slides;
	    for (var i = 0; i < slides.length; i += 1) {
	      var $slideEl = swiper.slides.eq(i);
	      var offset = $slideEl[0].swiperSlideOffset;
	      var tx = -offset;
	      if (!swiper.params.virtualTranslate) { tx -= swiper.translate; }
	      var ty = 0;
	      if (!swiper.isHorizontal()) {
	        ty = tx;
	        tx = 0;
	      }
	      var slideOpacity = swiper.params.fadeEffect.crossFade
	        ? Math.max(1 - Math.abs($slideEl[0].progress), 0)
	        : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
	      $slideEl
	        .css({
	          opacity: slideOpacity,
	        })
	        .transform(("translate3d(" + tx + "px, " + ty + "px, 0px)"));
	    }
	  },
	  setTransition: function setTransition(duration) {
	    var swiper = this;
	    var slides = swiper.slides;
	    var $wrapperEl = swiper.$wrapperEl;
	    slides.transition(duration);
	    if (swiper.params.virtualTranslate && duration !== 0) {
	      var eventTriggered = false;
	      slides.transitionEnd(function () {
	        if (eventTriggered) { return; }
	        if (!swiper || swiper.destroyed) { return; }
	        eventTriggered = true;
	        swiper.animating = false;
	        var triggerEvents = ['webkitTransitionEnd', 'transitionend'];
	        for (var i = 0; i < triggerEvents.length; i += 1) {
	          $wrapperEl.trigger(triggerEvents[i]);
	        }
	      });
	    }
	  },
	};

	var EffectFade = {
	  name: 'effect-fade',
	  params: {
	    fadeEffect: {
	      crossFade: false,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      fadeEffect: {
	        setTranslate: Fade.setTranslate.bind(swiper),
	        setTransition: Fade.setTransition.bind(swiper),
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      if (swiper.params.effect !== 'fade') { return; }
	      swiper.classNames.push(((swiper.params.containerModifierClass) + "fade"));
	      var overwriteParams = {
	        slidesPerView: 1,
	        slidesPerColumn: 1,
	        slidesPerGroup: 1,
	        watchSlidesProgress: true,
	        spaceBetween: 0,
	        virtualTranslate: true,
	      };
	      Utils.extend(swiper.params, overwriteParams);
	      Utils.extend(swiper.originalParams, overwriteParams);
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      if (swiper.params.effect !== 'fade') { return; }
	      swiper.fadeEffect.setTranslate();
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      if (swiper.params.effect !== 'fade') { return; }
	      swiper.fadeEffect.setTransition(duration);
	    },
	  },
	};

	var Cube = {
	  setTranslate: function setTranslate() {
	    var swiper = this;
	    var $el = swiper.$el;
	    var $wrapperEl = swiper.$wrapperEl;
	    var slides = swiper.slides;
	    var swiperWidth = swiper.width;
	    var swiperHeight = swiper.height;
	    var rtl = swiper.rtlTranslate;
	    var swiperSize = swiper.size;
	    var params = swiper.params.cubeEffect;
	    var isHorizontal = swiper.isHorizontal();
	    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
	    var wrapperRotate = 0;
	    var $cubeShadowEl;
	    if (params.shadow) {
	      if (isHorizontal) {
	        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
	        if ($cubeShadowEl.length === 0) {
	          $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
	          $wrapperEl.append($cubeShadowEl);
	        }
	        $cubeShadowEl.css({ height: (swiperWidth + "px") });
	      } else {
	        $cubeShadowEl = $el.find('.swiper-cube-shadow');
	        if ($cubeShadowEl.length === 0) {
	          $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
	          $el.append($cubeShadowEl);
	        }
	      }
	    }
	    for (var i = 0; i < slides.length; i += 1) {
	      var $slideEl = slides.eq(i);
	      var slideIndex = i;
	      if (isVirtual) {
	        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
	      }
	      var slideAngle = slideIndex * 90;
	      var round = Math.floor(slideAngle / 360);
	      if (rtl) {
	        slideAngle = -slideAngle;
	        round = Math.floor(-slideAngle / 360);
	      }
	      var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
	      var tx = 0;
	      var ty = 0;
	      var tz = 0;
	      if (slideIndex % 4 === 0) {
	        tx = -round * 4 * swiperSize;
	        tz = 0;
	      } else if ((slideIndex - 1) % 4 === 0) {
	        tx = 0;
	        tz = -round * 4 * swiperSize;
	      } else if ((slideIndex - 2) % 4 === 0) {
	        tx = swiperSize + (round * 4 * swiperSize);
	        tz = swiperSize;
	      } else if ((slideIndex - 3) % 4 === 0) {
	        tx = -swiperSize;
	        tz = (3 * swiperSize) + (swiperSize * 4 * round);
	      }
	      if (rtl) {
	        tx = -tx;
	      }

	      if (!isHorizontal) {
	        ty = tx;
	        tx = 0;
	      }

	      var transform = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";
	      if (progress <= 1 && progress > -1) {
	        wrapperRotate = (slideIndex * 90) + (progress * 90);
	        if (rtl) { wrapperRotate = (-slideIndex * 90) - (progress * 90); }
	      }
	      $slideEl.transform(transform);
	      if (params.slideShadows) {
	        // Set shadows
	        var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
	        var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
	        if (shadowBefore.length === 0) {
	          shadowBefore = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>"));
	          $slideEl.append(shadowBefore);
	        }
	        if (shadowAfter.length === 0) {
	          shadowAfter = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>"));
	          $slideEl.append(shadowAfter);
	        }
	        if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }
	        if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }
	      }
	    }
	    $wrapperEl.css({
	      '-webkit-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
	      '-moz-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
	      '-ms-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
	      'transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
	    });

	    if (params.shadow) {
	      if (isHorizontal) {
	        $cubeShadowEl.transform(("translate3d(0px, " + ((swiperWidth / 2) + params.shadowOffset) + "px, " + (-swiperWidth / 2) + "px) rotateX(90deg) rotateZ(0deg) scale(" + (params.shadowScale) + ")"));
	      } else {
	        var shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
	        var multiplier = 1.5 - (
	          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)
	          + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)
	        );
	        var scale1 = params.shadowScale;
	        var scale2 = params.shadowScale / multiplier;
	        var offset = params.shadowOffset;
	        $cubeShadowEl.transform(("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + ((swiperHeight / 2) + offset) + "px, " + (-swiperHeight / 2 / scale2) + "px) rotateX(-90deg)"));
	      }
	    }
	    var zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;
	    $wrapperEl
	      .transform(("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)"));
	  },
	  setTransition: function setTransition(duration) {
	    var swiper = this;
	    var $el = swiper.$el;
	    var slides = swiper.slides;
	    slides
	      .transition(duration)
	      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
	      .transition(duration);
	    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
	      $el.find('.swiper-cube-shadow').transition(duration);
	    }
	  },
	};

	var EffectCube = {
	  name: 'effect-cube',
	  params: {
	    cubeEffect: {
	      slideShadows: true,
	      shadow: true,
	      shadowOffset: 20,
	      shadowScale: 0.94,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      cubeEffect: {
	        setTranslate: Cube.setTranslate.bind(swiper),
	        setTransition: Cube.setTransition.bind(swiper),
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      if (swiper.params.effect !== 'cube') { return; }
	      swiper.classNames.push(((swiper.params.containerModifierClass) + "cube"));
	      swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));
	      var overwriteParams = {
	        slidesPerView: 1,
	        slidesPerColumn: 1,
	        slidesPerGroup: 1,
	        watchSlidesProgress: true,
	        resistanceRatio: 0,
	        spaceBetween: 0,
	        centeredSlides: false,
	        virtualTranslate: true,
	      };
	      Utils.extend(swiper.params, overwriteParams);
	      Utils.extend(swiper.originalParams, overwriteParams);
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      if (swiper.params.effect !== 'cube') { return; }
	      swiper.cubeEffect.setTranslate();
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      if (swiper.params.effect !== 'cube') { return; }
	      swiper.cubeEffect.setTransition(duration);
	    },
	  },
	};

	var Flip = {
	  setTranslate: function setTranslate() {
	    var swiper = this;
	    var slides = swiper.slides;
	    var rtl = swiper.rtlTranslate;
	    for (var i = 0; i < slides.length; i += 1) {
	      var $slideEl = slides.eq(i);
	      var progress = $slideEl[0].progress;
	      if (swiper.params.flipEffect.limitRotation) {
	        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
	      }
	      var offset = $slideEl[0].swiperSlideOffset;
	      var rotate = -180 * progress;
	      var rotateY = rotate;
	      var rotateX = 0;
	      var tx = -offset;
	      var ty = 0;
	      if (!swiper.isHorizontal()) {
	        ty = tx;
	        tx = 0;
	        rotateX = -rotateY;
	        rotateY = 0;
	      } else if (rtl) {
	        rotateY = -rotateY;
	      }

	      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

	      if (swiper.params.flipEffect.slideShadows) {
	        // Set shadows
	        var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
	        var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
	        if (shadowBefore.length === 0) {
	          shadowBefore = $(("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'left' : 'top') + "\"></div>"));
	          $slideEl.append(shadowBefore);
	        }
	        if (shadowAfter.length === 0) {
	          shadowAfter = $(("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'right' : 'bottom') + "\"></div>"));
	          $slideEl.append(shadowAfter);
	        }
	        if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }
	        if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }
	      }
	      $slideEl
	        .transform(("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)"));
	    }
	  },
	  setTransition: function setTransition(duration) {
	    var swiper = this;
	    var slides = swiper.slides;
	    var activeIndex = swiper.activeIndex;
	    var $wrapperEl = swiper.$wrapperEl;
	    slides
	      .transition(duration)
	      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
	      .transition(duration);
	    if (swiper.params.virtualTranslate && duration !== 0) {
	      var eventTriggered = false;
	      // eslint-disable-next-line
	      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
	        if (eventTriggered) { return; }
	        if (!swiper || swiper.destroyed) { return; }
	        // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;
	        eventTriggered = true;
	        swiper.animating = false;
	        var triggerEvents = ['webkitTransitionEnd', 'transitionend'];
	        for (var i = 0; i < triggerEvents.length; i += 1) {
	          $wrapperEl.trigger(triggerEvents[i]);
	        }
	      });
	    }
	  },
	};

	var EffectFlip = {
	  name: 'effect-flip',
	  params: {
	    flipEffect: {
	      slideShadows: true,
	      limitRotation: true,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      flipEffect: {
	        setTranslate: Flip.setTranslate.bind(swiper),
	        setTransition: Flip.setTransition.bind(swiper),
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      if (swiper.params.effect !== 'flip') { return; }
	      swiper.classNames.push(((swiper.params.containerModifierClass) + "flip"));
	      swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));
	      var overwriteParams = {
	        slidesPerView: 1,
	        slidesPerColumn: 1,
	        slidesPerGroup: 1,
	        watchSlidesProgress: true,
	        spaceBetween: 0,
	        virtualTranslate: true,
	      };
	      Utils.extend(swiper.params, overwriteParams);
	      Utils.extend(swiper.originalParams, overwriteParams);
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      if (swiper.params.effect !== 'flip') { return; }
	      swiper.flipEffect.setTranslate();
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      if (swiper.params.effect !== 'flip') { return; }
	      swiper.flipEffect.setTransition(duration);
	    },
	  },
	};

	var Coverflow = {
	  setTranslate: function setTranslate() {
	    var swiper = this;
	    var swiperWidth = swiper.width;
	    var swiperHeight = swiper.height;
	    var slides = swiper.slides;
	    var $wrapperEl = swiper.$wrapperEl;
	    var slidesSizesGrid = swiper.slidesSizesGrid;
	    var params = swiper.params.coverflowEffect;
	    var isHorizontal = swiper.isHorizontal();
	    var transform = swiper.translate;
	    var center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);
	    var rotate = isHorizontal ? params.rotate : -params.rotate;
	    var translate = params.depth;
	    // Each slide offset from center
	    for (var i = 0, length = slides.length; i < length; i += 1) {
	      var $slideEl = slides.eq(i);
	      var slideSize = slidesSizesGrid[i];
	      var slideOffset = $slideEl[0].swiperSlideOffset;
	      var offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;

	      var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
	      var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
	      // var rotateZ = 0
	      var translateZ = -translate * Math.abs(offsetMultiplier);

	      var translateY = isHorizontal ? 0 : params.stretch * (offsetMultiplier);
	      var translateX = isHorizontal ? params.stretch * (offsetMultiplier) : 0;

	      // Fix for ultra small values
	      if (Math.abs(translateX) < 0.001) { translateX = 0; }
	      if (Math.abs(translateY) < 0.001) { translateY = 0; }
	      if (Math.abs(translateZ) < 0.001) { translateZ = 0; }
	      if (Math.abs(rotateY) < 0.001) { rotateY = 0; }
	      if (Math.abs(rotateX) < 0.001) { rotateX = 0; }

	      var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)";

	      $slideEl.transform(slideTransform);
	      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
	      if (params.slideShadows) {
	        // Set shadows
	        var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
	        var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
	        if ($shadowBeforeEl.length === 0) {
	          $shadowBeforeEl = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>"));
	          $slideEl.append($shadowBeforeEl);
	        }
	        if ($shadowAfterEl.length === 0) {
	          $shadowAfterEl = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>"));
	          $slideEl.append($shadowAfterEl);
	        }
	        if ($shadowBeforeEl.length) { $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0; }
	        if ($shadowAfterEl.length) { $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0; }
	      }
	    }

	    // Set correct perspective for IE10
	    if (Support.pointerEvents || Support.prefixedPointerEvents) {
	      var ws = $wrapperEl[0].style;
	      ws.perspectiveOrigin = center + "px 50%";
	    }
	  },
	  setTransition: function setTransition(duration) {
	    var swiper = this;
	    swiper.slides
	      .transition(duration)
	      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
	      .transition(duration);
	  },
	};

	var EffectCoverflow = {
	  name: 'effect-coverflow',
	  params: {
	    coverflowEffect: {
	      rotate: 50,
	      stretch: 0,
	      depth: 100,
	      modifier: 1,
	      slideShadows: true,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      coverflowEffect: {
	        setTranslate: Coverflow.setTranslate.bind(swiper),
	        setTransition: Coverflow.setTransition.bind(swiper),
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      if (swiper.params.effect !== 'coverflow') { return; }

	      swiper.classNames.push(((swiper.params.containerModifierClass) + "coverflow"));
	      swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));

	      swiper.params.watchSlidesProgress = true;
	      swiper.originalParams.watchSlidesProgress = true;
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      if (swiper.params.effect !== 'coverflow') { return; }
	      swiper.coverflowEffect.setTranslate();
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      if (swiper.params.effect !== 'coverflow') { return; }
	      swiper.coverflowEffect.setTransition(duration);
	    },
	  },
	};

	var Thumbs = {
	  init: function init() {
	    var swiper = this;
	    var ref = swiper.params;
	    var thumbsParams = ref.thumbs;
	    var SwiperClass = swiper.constructor;
	    if (thumbsParams.swiper instanceof SwiperClass) {
	      swiper.thumbs.swiper = thumbsParams.swiper;
	      Utils.extend(swiper.thumbs.swiper.originalParams, {
	        watchSlidesProgress: true,
	        slideToClickedSlide: false,
	      });
	      Utils.extend(swiper.thumbs.swiper.params, {
	        watchSlidesProgress: true,
	        slideToClickedSlide: false,
	      });
	    } else if (Utils.isObject(thumbsParams.swiper)) {
	      swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
	        watchSlidesVisibility: true,
	        watchSlidesProgress: true,
	        slideToClickedSlide: false,
	      }));
	      swiper.thumbs.swiperCreated = true;
	    }
	    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
	    swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
	  },
	  onThumbClick: function onThumbClick() {
	    var swiper = this;
	    var thumbsSwiper = swiper.thumbs.swiper;
	    if (!thumbsSwiper) { return; }
	    var clickedIndex = thumbsSwiper.clickedIndex;
	    var clickedSlide = thumbsSwiper.clickedSlide;
	    if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) { return; }
	    if (typeof clickedIndex === 'undefined' || clickedIndex === null) { return; }
	    var slideToIndex;
	    if (thumbsSwiper.params.loop) {
	      slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
	    } else {
	      slideToIndex = clickedIndex;
	    }
	    if (swiper.params.loop) {
	      var currentIndex = swiper.activeIndex;
	      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
	        swiper.loopFix();
	        // eslint-disable-next-line
	        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
	        currentIndex = swiper.activeIndex;
	      }
	      var prevIndex = swiper.slides.eq(currentIndex).prevAll(("[data-swiper-slide-index=\"" + slideToIndex + "\"]")).eq(0).index();
	      var nextIndex = swiper.slides.eq(currentIndex).nextAll(("[data-swiper-slide-index=\"" + slideToIndex + "\"]")).eq(0).index();
	      if (typeof prevIndex === 'undefined') { slideToIndex = nextIndex; }
	      else if (typeof nextIndex === 'undefined') { slideToIndex = prevIndex; }
	      else if (nextIndex - currentIndex < currentIndex - prevIndex) { slideToIndex = nextIndex; }
	      else { slideToIndex = prevIndex; }
	    }
	    swiper.slideTo(slideToIndex);
	  },
	  update: function update(initial) {
	    var swiper = this;
	    var thumbsSwiper = swiper.thumbs.swiper;
	    if (!thumbsSwiper) { return; }

	    var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'
	      ? thumbsSwiper.slidesPerViewDynamic()
	      : thumbsSwiper.params.slidesPerView;

	    if (swiper.realIndex !== thumbsSwiper.realIndex) {
	      var currentThumbsIndex = thumbsSwiper.activeIndex;
	      var newThumbsIndex;
	      if (thumbsSwiper.params.loop) {
	        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
	          thumbsSwiper.loopFix();
	          // eslint-disable-next-line
	          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
	          currentThumbsIndex = thumbsSwiper.activeIndex;
	        }
	        // Find actual thumbs index to slide to
	        var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(("[data-swiper-slide-index=\"" + (swiper.realIndex) + "\"]")).eq(0).index();
	        var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(("[data-swiper-slide-index=\"" + (swiper.realIndex) + "\"]")).eq(0).index();
	        if (typeof prevThumbsIndex === 'undefined') { newThumbsIndex = nextThumbsIndex; }
	        else if (typeof nextThumbsIndex === 'undefined') { newThumbsIndex = prevThumbsIndex; }
	        else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) { newThumbsIndex = currentThumbsIndex; }
	        else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) { newThumbsIndex = nextThumbsIndex; }
	        else { newThumbsIndex = prevThumbsIndex; }
	      } else {
	        newThumbsIndex = swiper.realIndex;
	      }
	      if (thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
	        if (thumbsSwiper.params.centeredSlides) {
	          if (newThumbsIndex > currentThumbsIndex) {
	            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
	          } else {
	            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
	          }
	        } else if (newThumbsIndex > currentThumbsIndex) {
	          newThumbsIndex = newThumbsIndex - slidesPerView + 1;
	        }
	        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
	      }
	    }

	    // Activate thumbs
	    var thumbsToActivate = 1;
	    var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

	    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
	      thumbsToActivate = swiper.params.slidesPerView;
	    }

	    thumbsSwiper.slides.removeClass(thumbActiveClass);
	    if (thumbsSwiper.params.loop) {
	      for (var i = 0; i < thumbsToActivate; i += 1) {
	        thumbsSwiper.$wrapperEl.children(("[data-swiper-slide-index=\"" + (swiper.realIndex + i) + "\"]")).addClass(thumbActiveClass);
	      }
	    } else {
	      for (var i$1 = 0; i$1 < thumbsToActivate; i$1 += 1) {
	        thumbsSwiper.slides.eq(swiper.realIndex + i$1).addClass(thumbActiveClass);
	      }
	    }
	  },
	};
	var Thumbs$1 = {
	  name: 'thumbs',
	  params: {
	    thumbs: {
	      swiper: null,
	      slideThumbActiveClass: 'swiper-slide-thumb-active',
	      thumbsContainerClass: 'swiper-container-thumbs',
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      thumbs: {
	        swiper: null,
	        init: Thumbs.init.bind(swiper),
	        update: Thumbs.update.bind(swiper),
	        onThumbClick: Thumbs.onThumbClick.bind(swiper),
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      var ref = swiper.params;
	      var thumbs = ref.thumbs;
	      if (!thumbs || !thumbs.swiper) { return; }
	      swiper.thumbs.init();
	      swiper.thumbs.update(true);
	    },
	    slideChange: function slideChange() {
	      var swiper = this;
	      if (!swiper.thumbs.swiper) { return; }
	      swiper.thumbs.update();
	    },
	    update: function update() {
	      var swiper = this;
	      if (!swiper.thumbs.swiper) { return; }
	      swiper.thumbs.update();
	    },
	    resize: function resize() {
	      var swiper = this;
	      if (!swiper.thumbs.swiper) { return; }
	      swiper.thumbs.update();
	    },
	    observerUpdate: function observerUpdate() {
	      var swiper = this;
	      if (!swiper.thumbs.swiper) { return; }
	      swiper.thumbs.update();
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      var thumbsSwiper = swiper.thumbs.swiper;
	      if (!thumbsSwiper) { return; }
	      thumbsSwiper.setTransition(duration);
	    },
	    beforeDestroy: function beforeDestroy() {
	      var swiper = this;
	      var thumbsSwiper = swiper.thumbs.swiper;
	      if (!thumbsSwiper) { return; }
	      if (swiper.thumbs.swiperCreated && thumbsSwiper) {
	        thumbsSwiper.destroy();
	      }
	    },
	  },
	};

	// Swiper Class

	Swiper.use([
	  Device$1,
	  Browser$1,
	  Support$1,
	  Resize,
	  Observer$1,
	  Virtual$1,
	  Navigation$1,
	  Pagination$1,
	  Scrollbar$1,
	  Parallax$1,
	  Zoom$1,
	  Lazy$3,
	  Controller$1,
	  A11y,
	  Autoplay$1,
	  EffectFade,
	  EffectCube,
	  EffectFlip,
	  EffectCoverflow,
	  Thumbs$1 ]);

	function initSwiper(swiperEl) {
	  var app = this;
	  var $swiperEl = $(swiperEl);
	  if ($swiperEl.length === 0) { return; }
	  if ($swiperEl[0].swiper) { return; }
	  var initialSlide;
	  var params = {};
	  var isTabs;
	  var isRoutableTabs;
	  if ($swiperEl.hasClass('tabs-swipeable-wrap')) {
	    $swiperEl
	      .addClass('swiper-container')
	      .children('.tabs')
	      .addClass('swiper-wrapper')
	      .children('.tab')
	      .addClass('swiper-slide');
	    initialSlide = $swiperEl.children('.tabs').children('.tab-active').index();
	    isTabs = true;
	    isRoutableTabs = $swiperEl.find('.tabs-routable').length > 0;
	  }
	  if ($swiperEl.attr('data-swiper')) {
	    params = JSON.parse($swiperEl.attr('data-swiper'));
	  } else {
	    params = $swiperEl.dataset();
	    Object.keys(params).forEach(function (key) {
	      var value = params[key];
	      if (typeof value === 'string' && value.indexOf('{') === 0 && value.indexOf('}') > 0) {
	        try {
	          params[key] = JSON.parse(value);
	        } catch (e) {
	          // not JSON
	        }
	      }
	    });
	  }
	  if (typeof params.initialSlide === 'undefined' && typeof initialSlide !== 'undefined') {
	    params.initialSlide = initialSlide;
	  }

	  var swiper = app.swiper.create($swiperEl[0], params);
	  if (isTabs) {
	    swiper.on('slideChange', function () {
	      if (isRoutableTabs) {
	        var view = app.views.get($swiperEl.parents('.view'));
	        if (!view) { view = app.views.main; }
	        var router = view.router;
	        var tabRoute = router.findTabRoute(swiper.slides.eq(swiper.activeIndex)[0]);
	        if (tabRoute) {
	          setTimeout(function () {
	            router.navigate(tabRoute.path);
	          }, 0);
	        }
	      } else {
	        app.tab.show({
	          tabEl: swiper.slides.eq(swiper.activeIndex),
	        });
	      }
	    });
	  }
	}

	var Swiper$1 = {
	  name: 'swiper',
	  static: {
	    Swiper: Swiper,
	  },
	  create: function create() {
	    var app = this;
	    app.swiper = ConstructorMethods({
	      defaultSelector: '.swiper-container',
	      constructor: Swiper,
	      domProp: 'swiper',
	    });
	  },
	  on: {
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each(function (index, swiperEl) {
	        app.swiper.destroy(swiperEl);
	      });
	    },
	    pageMounted: function pageMounted(page) {
	      var app = this;
	      page.$el.find('.tabs-swipeable-wrap').each(function (index, swiperEl) {
	        initSwiper.call(app, swiperEl);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each(function (index, swiperEl) {
	        initSwiper.call(app, swiperEl);
	      });
	    },
	    pageReinit: function pageReinit(page) {
	      var app = this;
	      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each(function (index, swiperEl) {
	        var swiper = app.swiper.get(swiperEl);
	        if (swiper && swiper.update) { swiper.update(); }
	      });
	    },
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each(function (index, swiperEl) {
	        initSwiper.call(app, swiperEl);
	      });
	    },
	    tabShow: function tabShow(tabEl) {
	      var app = this;
	      $(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each(function (index, swiperEl) {
	        var swiper = app.swiper.get(swiperEl);
	        if (swiper && swiper.update) { swiper.update(); }
	      });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var app = this;
	      $(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each(function (index, swiperEl) {
	        app.swiper.destroy(swiperEl);
	      });
	    },
	  },
	  vnode: {
	    'swiper-init': {
	      insert: function insert(vnode) {
	        var app = this;
	        var swiperEl = vnode.elm;
	        initSwiper.call(app, swiperEl);
	      },
	      destroy: function destroy(vnode) {
	        var app = this;
	        var swiperEl = vnode.elm;
	        app.swiper.destroy(swiperEl);
	      },
	    },
	    'tabs-swipeable-wrap': {
	      insert: function insert(vnode) {
	        var app = this;
	        var swiperEl = vnode.elm;
	        initSwiper.call(app, swiperEl);
	      },
	      destroy: function destroy(vnode) {
	        var app = this;
	        var swiperEl = vnode.elm;
	        app.swiper.destroy(swiperEl);
	      },
	    },
	  },
	};

	/* eslint indent: ["off"] */

	var PhotoBrowser = /*@__PURE__*/(function (Framework7Class) {
	  function PhotoBrowser(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class.call(this, params, [app]);

	    var pb = this;
	    pb.app = app;

	    var defaults = Utils.extend({
	      on: {},
	    }, app.params.photoBrowser);

	    // Extend defaults with modules params
	    pb.useModulesParams(defaults);

	    pb.params = Utils.extend(defaults, params);

	    Utils.extend(pb, {
	      exposed: false,
	      opened: false,
	      activeIndex: pb.params.swiper.initialSlide,
	      url: pb.params.url,
	      view: pb.params.view || app.views.main,
	      swipeToClose: {
	        allow: true,
	        isTouched: false,
	        diff: undefined,
	        start: undefined,
	        current: undefined,
	        started: false,
	        activeSlide: undefined,
	        timeStart: undefined,
	      },
	    });

	    // Install Modules
	    pb.useModules();

	    // Init
	    pb.init();
	  }

	  if ( Framework7Class ) PhotoBrowser.__proto__ = Framework7Class;
	  PhotoBrowser.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  PhotoBrowser.prototype.constructor = PhotoBrowser;

	  PhotoBrowser.prototype.onSlideChange = function onSlideChange (swiper) {
	    var pb = this;
	    pb.activeIndex = swiper.activeIndex;

	    var current = swiper.activeIndex + 1;
	    var total = pb.params.virtualSlides ? pb.params.photos.length : swiper.slides.length;
	    if (swiper.params.loop) {
	      total -= 2;
	      current -= swiper.loopedSlides;
	      if (current < 1) { current = total + current; }
	      if (current > total) { current -= total; }
	    }

	    var $activeSlideEl = pb.params.virtualSlides
	      ? swiper.$wrapperEl.find((".swiper-slide[data-swiper-slide-index=\"" + (swiper.activeIndex) + "\"]"))
	      : swiper.slides.eq(swiper.activeIndex);
	    var $previousSlideEl = pb.params.virtualSlides
	      ? swiper.$wrapperEl.find((".swiper-slide[data-swiper-slide-index=\"" + (swiper.previousIndex) + "\"]"))
	      : swiper.slides.eq(swiper.previousIndex);

	    var $currentEl = pb.$el.find('.photo-browser-current');
	    var $totalEl = pb.$el.find('.photo-browser-total');
	    if (pb.params.type === 'page' && pb.params.navbar && $currentEl.length === 0 && pb.app.theme === 'ios') {
	      var navbarEl = pb.app.navbar.getElByPage(pb.$el);
	      if (navbarEl) {
	        $currentEl = $(navbarEl).find('.photo-browser-current');
	        $totalEl = $(navbarEl).find('.photo-browser-total');
	      }
	    }
	    $currentEl.text(current);
	    $totalEl.text(total);

	    // Update captions
	    if (pb.captions.length > 0) {
	      var captionIndex = swiper.params.loop ? $activeSlideEl.attr('data-swiper-slide-index') : pb.activeIndex;
	      pb.$captionsContainerEl.find('.photo-browser-caption-active').removeClass('photo-browser-caption-active');
	      pb.$captionsContainerEl.find(("[data-caption-index=\"" + captionIndex + "\"]")).addClass('photo-browser-caption-active');
	    }

	    // Stop Video
	    var previousSlideVideo = $previousSlideEl.find('video');
	    if (previousSlideVideo.length > 0) {
	      if ('pause' in previousSlideVideo[0]) { previousSlideVideo[0].pause(); }
	    }
	  };

	  PhotoBrowser.prototype.onTouchStart = function onTouchStart () {
	    var pb = this;
	    var swipeToClose = pb.swipeToClose;
	    if (!swipeToClose.allow) { return; }
	    swipeToClose.isTouched = true;
	  };

	  PhotoBrowser.prototype.onTouchMove = function onTouchMove (e) {
	    var pb = this;
	    var swipeToClose = pb.swipeToClose;

	    if (!swipeToClose.isTouched) { return; }
	    if (!swipeToClose.started) {
	      swipeToClose.started = true;
	      swipeToClose.start = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      if (pb.params.virtualSlides) {
	        swipeToClose.activeSlide = pb.swiper.$wrapperEl.children('.swiper-slide-active');
	      } else {
	        swipeToClose.activeSlide = pb.swiper.slides.eq(pb.swiper.activeIndex);
	      }
	      swipeToClose.timeStart = Utils.now();
	    }
	    e.preventDefault();
	    swipeToClose.current = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	    swipeToClose.diff = swipeToClose.start - swipeToClose.current;
	    var opacity = 1 - (Math.abs(swipeToClose.diff) / 300);
	    var color = pb.exposed || pb.params.theme === 'dark' ? 0 : 255;
	    swipeToClose.activeSlide.transform(("translate3d(0," + (-swipeToClose.diff) + "px,0)"));
	    pb.swiper.$el.css('background-color', ("rgba(" + color + ", " + color + ", " + color + ", " + opacity + ")")).transition(0);
	  };

	  PhotoBrowser.prototype.onTouchEnd = function onTouchEnd () {
	    var pb = this;
	    var swipeToClose = pb.swipeToClose;
	    swipeToClose.isTouched = false;
	    if (!swipeToClose.started) {
	      swipeToClose.started = false;
	      return;
	    }
	    swipeToClose.started = false;
	    swipeToClose.allow = false;
	    var diff = Math.abs(swipeToClose.diff);
	    var timeDiff = (new Date()).getTime() - swipeToClose.timeStart;
	    if ((timeDiff < 300 && diff > 20) || (timeDiff >= 300 && diff > 100)) {
	      Utils.nextTick(function () {
	        if (pb.$el) {
	          if (swipeToClose.diff < 0) { pb.$el.addClass('swipe-close-to-bottom'); }
	          else { pb.$el.addClass('swipe-close-to-top'); }
	        }
	        pb.emit('local::swipeToClose', pb);
	        pb.close();
	        swipeToClose.allow = true;
	      });
	      return;
	    }
	    if (diff !== 0) {
	      swipeToClose.activeSlide.addClass('photo-browser-transitioning').transitionEnd(function () {
	        swipeToClose.allow = true;
	        swipeToClose.activeSlide.removeClass('photo-browser-transitioning');
	      });
	    } else {
	      swipeToClose.allow = true;
	    }
	    pb.swiper.$el.transition('').css('background-color', '');
	    swipeToClose.activeSlide.transform('');
	  };

	  // Render Functions
	  PhotoBrowser.prototype.renderNavbar = function renderNavbar () {
	    var pb = this;
	    if (pb.params.renderNavbar) { return pb.params.renderNavbar.call(pb); }

	    var iconsColor = pb.params.iconsColor;
	    if (!pb.params.iconsColor && pb.params.theme === 'dark') { iconsColor = 'white'; }

	    var backLinkText = (pb.app.theme === 'ios' || pb.app.theme === 'aurora') && pb.params.backLinkText ? pb.params.backLinkText : '';

	    var isPopup = pb.params.type !== 'page';
	    var navbarHtml = ("\n      <div class=\"navbar\">\n        <div class=\"navbar-inner sliding\">\n          <div class=\"left\">\n            <a class=\"link " + (isPopup ? 'popup-close' : '') + " " + (!backLinkText ? 'icon-only' : '') + " " + (!isPopup ? 'back' : '') + "\" " + (isPopup ? 'data-popup=".photo-browser-popup"' : '') + ">\n              <i class=\"icon icon-back " + (iconsColor ? ("color-" + iconsColor) : '') + "\"></i>\n              " + (backLinkText ? ("<span>" + backLinkText + "</span>") : '') + "\n            </a>\n          </div>\n          <div class=\"title\">\n            <span class=\"photo-browser-current\"></span>\n            <span class=\"photo-browser-of\">" + (pb.params.navbarOfText) + "</span>\n            <span class=\"photo-browser-total\"></span>\n          </div>\n          <div class=\"right\"></div>\n        </div>\n      </div>\n    ").trim();
	    return navbarHtml;
	  };

	  PhotoBrowser.prototype.renderToolbar = function renderToolbar () {
	    var pb = this;
	    if (pb.params.renderToolbar) { return pb.params.renderToolbar.call(pb); }

	    var iconsColor = pb.params.iconsColor;
	    if (!pb.params.iconsColor && pb.params.theme === 'dark') { iconsColor = 'white'; }

	    var toolbarHtml = ("\n      <div class=\"toolbar toolbar-bottom tabbar\">\n        <div class=\"toolbar-inner\">\n          <a class=\"link photo-browser-prev\">\n            <i class=\"icon icon-back " + (iconsColor ? ("color-" + iconsColor) : '') + "\"></i>\n          </a>\n          <a class=\"link photo-browser-next\">\n            <i class=\"icon icon-forward " + (iconsColor ? ("color-" + iconsColor) : '') + "\"></i>\n          </a>\n        </div>\n      </div>\n    ").trim();
	    return toolbarHtml;
	  };

	  PhotoBrowser.prototype.renderCaption = function renderCaption (caption, index) {
	    var pb = this;
	    if (pb.params.renderCaption) { return pb.params.renderCaption.call(pb, caption, index); }
	    var captionHtml = ("\n      <div class=\"photo-browser-caption\" data-caption-index=\"" + index + "\">\n        " + caption + "\n      </div>\n    ").trim();
	    return captionHtml;
	  };

	  PhotoBrowser.prototype.renderObject = function renderObject (photo, index) {
	    var pb = this;
	    if (pb.params.renderObject) { return pb.params.renderObject.call(pb, photo, index); }
	    var objHtml = "\n      <div class=\"photo-browser-slide photo-browser-object-slide swiper-slide\" data-swiper-slide-index=\"" + index + "\">" + (photo.html ? photo.html : photo) + "</div>\n    ";
	    return objHtml;
	  };

	  PhotoBrowser.prototype.renderLazyPhoto = function renderLazyPhoto (photo, index) {
	    var pb = this;
	    if (pb.params.renderLazyPhoto) { return pb.params.renderLazyPhoto.call(pb, photo, index); }
	    var photoHtml = ("\n      <div class=\"photo-browser-slide photo-browser-slide-lazy swiper-slide\" data-swiper-slide-index=\"" + index + "\">\n          <div class=\"preloader swiper-lazy-preloader " + (pb.params.theme === 'dark' ? 'color-white' : '') + "\">" + (Utils[((pb.app.theme) + "PreloaderContent")] || '') + "</div>\n          <span class=\"swiper-zoom-container\">\n              <img data-src=\"" + (photo.url ? photo.url : photo) + "\" class=\"swiper-lazy\">\n          </span>\n      </div>\n    ").trim();
	    return photoHtml;
	  };

	  PhotoBrowser.prototype.renderPhoto = function renderPhoto (photo, index) {
	    var pb = this;
	    if (pb.params.renderPhoto) { return pb.params.renderPhoto.call(pb, photo, index); }
	    var photoHtml = ("\n      <div class=\"photo-browser-slide swiper-slide\" data-swiper-slide-index=\"" + index + "\">\n        <span class=\"swiper-zoom-container\">\n          <img src=\"" + (photo.url ? photo.url : photo) + "\">\n        </span>\n      </div>\n    ").trim();
	    return photoHtml;
	  };

	  PhotoBrowser.prototype.render = function render () {
	    var pb = this;
	    if (pb.params.render) { return pb.params.render.call(pb, pb.params); }
	    var html = ("\n      <div class=\"photo-browser photo-browser-" + (pb.params.theme) + "\">\n        <div class=\"view\">\n          <div class=\"page photo-browser-page photo-browser-page-" + (pb.params.theme) + " no-toolbar " + (!pb.params.navbar ? 'no-navbar' : '') + "\" data-name=\"photo-browser-page\">\n            " + (pb.params.navbar ? pb.renderNavbar() : '') + "\n            " + (pb.params.toolbar ? pb.renderToolbar() : '') + "\n            <div class=\"photo-browser-captions photo-browser-captions-" + (pb.params.captionsTheme || pb.params.theme) + "\">\n              " + (pb.params.photos.map(function (photo, index) {
	                if (photo.caption) { return pb.renderCaption(photo.caption, index); }
	                return '';
	              }).join(' ')) + "\n            </div>\n            <div class=\"photo-browser-swiper-container swiper-container\">\n              <div class=\"photo-browser-swiper-wrapper swiper-wrapper\">\n                " + (pb.params.virtualSlides ? '' : pb.params.photos.map(function (photo, index) {
	                  if (photo.html || ((typeof photo === 'string' || photo instanceof String) && photo.indexOf('<') >= 0 && photo.indexOf('>') >= 0)) {
	                    return pb.renderObject(photo, index);
	                  }
	                  if (pb.params.swiper.lazy === true || (pb.params.swiper.lazy && pb.params.swiper.lazy.enabled)) {
	                    return pb.renderLazyPhoto(photo, index);
	                  }
	                  return pb.renderPhoto(photo, index);
	                }).join(' ')) + "\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    ").trim();
	    return html;
	  };

	  PhotoBrowser.prototype.renderStandalone = function renderStandalone () {
	    var pb = this;
	    if (pb.params.renderStandalone) { return pb.params.renderStandalone.call(pb); }
	    var standaloneHtml = "<div class=\"popup photo-browser-popup photo-browser-standalone popup-tablet-fullscreen\">" + (pb.render()) + "</div>";
	    return standaloneHtml;
	  };

	  PhotoBrowser.prototype.renderPage = function renderPage () {
	    var pb = this;
	    if (pb.params.renderPage) { return pb.params.renderPage.call(pb); }
	    var pageHtml = pb.render();

	    return pageHtml;
	  };

	  PhotoBrowser.prototype.renderPopup = function renderPopup () {
	    var pb = this;
	    if (pb.params.renderPopup) { return pb.params.renderPopup.call(pb); }
	    var popupHtml = "<div class=\"popup photo-browser-popup\">" + (pb.render()) + "</div>";

	    return popupHtml;
	  };

	  // Callbacks
	  PhotoBrowser.prototype.onOpen = function onOpen (type, el) {
	    var pb = this;
	    var app = pb.app;
	    var $el = $(el);

	    $el[0].f7PhotoBrowser = pb;

	    pb.$el = $el;
	    pb.el = $el[0];
	    pb.openedIn = type;
	    pb.opened = true;

	    pb.$swiperContainerEl = pb.$el.find('.photo-browser-swiper-container');
	    pb.$swiperWrapperEl = pb.$el.find('.photo-browser-swiper-wrapper');
	    pb.slides = pb.$el.find('.photo-browser-slide');
	    pb.$captionsContainerEl = pb.$el.find('.photo-browser-captions');
	    pb.captions = pb.$el.find('.photo-browser-caption');

	    // Init Swiper
	    var swiperParams = Utils.extend({}, pb.params.swiper, {
	      initialSlide: pb.activeIndex,
	      on: {
	        tap: function tap(e) {
	          pb.emit('local::tap', e);
	        },
	        click: function click(e) {
	          if (pb.params.exposition) {
	            pb.expositionToggle();
	          }
	          pb.emit('local::click', e);
	        },
	        doubleTap: function doubleTap(e) {
	          pb.emit('local::doubleTap', e);
	        },
	        slideChange: function slideChange() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          var swiper = this;
	          pb.onSlideChange(swiper);
	          pb.emit.apply(pb, [ 'local::slideChange' ].concat( args ));
	        },
	        transitionStart: function transitionStart() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          pb.emit.apply(pb, [ 'local::transitionStart' ].concat( args ));
	        },
	        transitionEnd: function transitionEnd() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          pb.emit.apply(pb, [ 'local::transitionEnd' ].concat( args ));
	        },
	        slideChangeTransitionStart: function slideChangeTransitionStart() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          pb.emit.apply(pb, [ 'local::slideChangeTransitionStart' ].concat( args ));
	        },
	        slideChangeTransitionEnd: function slideChangeTransitionEnd() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          pb.emit.apply(pb, [ 'local::slideChangeTransitionEnd' ].concat( args ));
	        },
	        lazyImageLoad: function lazyImageLoad() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          pb.emit.apply(pb, [ 'local::lazyImageLoad' ].concat( args ));
	        },
	        lazyImageReady: function lazyImageReady() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          var slideEl = args[0];
	          $(slideEl).removeClass('photo-browser-slide-lazy');
	          pb.emit.apply(pb, [ 'local::lazyImageReady' ].concat( args ));
	        },
	      },
	    });
	    if (pb.params.swipeToClose && pb.params.type !== 'page') {
	      Utils.extend(swiperParams.on, {
	        touchStart: function touchStart(e) {
	          pb.onTouchStart(e);
	          pb.emit('local::touchStart', e);
	        },
	        touchMoveOpposite: function touchMoveOpposite(e) {
	          pb.onTouchMove(e);
	          pb.emit('local::touchMoveOpposite', e);
	        },
	        touchEnd: function touchEnd(e) {
	          pb.onTouchEnd(e);
	          pb.emit('local::touchEnd', e);
	        },
	      });
	    }
	    if (pb.params.virtualSlides) {
	      Utils.extend(swiperParams, {
	        virtual: {
	          slides: pb.params.photos,
	          renderSlide: function renderSlide(photo, index) {
	            if (photo.html || ((typeof photo === 'string' || photo instanceof String) && photo.indexOf('<') >= 0 && photo.indexOf('>') >= 0)) {
	              return pb.renderObject(photo, index);
	            }
	            if (pb.params.swiper.lazy === true || (pb.params.swiper.lazy && pb.params.swiper.lazy.enabled)) {
	              return pb.renderLazyPhoto(photo, index);
	            }
	            return pb.renderPhoto(photo, index);
	          },
	        },
	      });
	    }

	    pb.swiper = app.swiper.create(pb.$swiperContainerEl, swiperParams);

	    if (pb.activeIndex === 0) {
	      pb.onSlideChange(pb.swiper);
	    }
	    if (pb.$el) {
	      pb.$el.trigger('photobrowser:open');
	    }
	    pb.emit('local::open photoBrowserOpen', pb);
	  };

	  PhotoBrowser.prototype.onOpened = function onOpened () {
	    var pb = this;

	    if (pb.$el) {
	      pb.$el.trigger('photobrowser:opened');
	    }
	    pb.emit('local::opened photoBrowserOpened', pb);
	  };

	  PhotoBrowser.prototype.onClose = function onClose () {
	    var pb = this;
	    if (pb.destroyed) { return; }

	    // Destroy Swiper
	    if (pb.swiper && pb.swiper.destroy) {
	      pb.swiper.destroy(true, false);
	      pb.swiper = null;
	      delete pb.swiper;
	    }
	    if (pb.$el) {
	      pb.$el.trigger('photobrowser:close');
	    }
	    pb.emit('local::close photoBrowserClose', pb);
	  };

	  PhotoBrowser.prototype.onClosed = function onClosed () {
	    var pb = this;
	    if (pb.destroyed) { return; }
	    pb.opened = false;
	    pb.$el = null;
	    pb.el = null;
	    delete pb.$el;
	    delete pb.el;
	    if (pb.$el) {
	      pb.$el.trigger('photobrowser:closed');
	    }
	    pb.emit('local::closed photoBrowserClosed', pb);
	  };

	  // Open
	  PhotoBrowser.prototype.openPage = function openPage () {
	    var pb = this;
	    if (pb.opened) { return pb; }

	    var pageHtml = pb.renderPage();

	    pb.view.router.navigate({
	      url: pb.url,
	      route: {
	        content: pageHtml,
	        path: pb.url,
	        on: {
	          pageBeforeIn: function pageBeforeIn(e, page) {
	            pb.view.$el.addClass(("with-photo-browser-page with-photo-browser-page-" + (pb.params.theme)));
	            pb.onOpen('page', page.el);
	          },
	          pageAfterIn: function pageAfterIn(e, page) {
	            pb.onOpened('page', page.el);
	          },
	          pageBeforeOut: function pageBeforeOut(e, page) {
	            pb.view.$el.removeClass(("with-photo-browser-page with-photo-browser-page-exposed with-photo-browser-page-" + (pb.params.theme)));
	            pb.onClose('page', page.el);
	          },
	          pageAfterOut: function pageAfterOut(e, page) {
	            pb.onClosed('page', page.el);
	          },
	        },
	      },
	    });
	    return pb;
	  };

	  PhotoBrowser.prototype.openStandalone = function openStandalone () {
	    var pb = this;
	    if (pb.opened) { return pb; }

	    var standaloneHtml = pb.renderStandalone();

	    var popupParams = {
	      backdrop: false,
	      content: standaloneHtml,
	      on: {
	        popupOpen: function popupOpen(popup) {
	          pb.onOpen('popup', popup.el);
	        },
	        popupOpened: function popupOpened(popup) {
	          pb.onOpened('popup', popup.el);
	        },
	        popupClose: function popupClose(popup) {
	          pb.onClose('popup', popup.el);
	        },
	        popupClosed: function popupClosed(popup) {
	          pb.onClosed('popup', popup.el);
	        },
	      },
	    };

	    if (pb.params.routableModals) {
	      pb.view.router.navigate({
	        url: pb.url,
	        route: {
	          path: pb.url,
	          popup: popupParams,
	        },
	      });
	    } else {
	      pb.modal = pb.app.popup.create(popupParams).open();
	    }
	    return pb;
	  };

	  PhotoBrowser.prototype.openPopup = function openPopup () {
	    var pb = this;
	    if (pb.opened) { return pb; }

	    var popupHtml = pb.renderPopup();

	    var popupParams = {
	      content: popupHtml,
	      on: {
	        popupOpen: function popupOpen(popup) {
	          pb.onOpen('popup', popup.el);
	        },
	        popupOpened: function popupOpened(popup) {
	          pb.onOpened('popup', popup.el);
	        },
	        popupClose: function popupClose(popup) {
	          pb.onClose('popup', popup.el);
	        },
	        popupClosed: function popupClosed(popup) {
	          pb.onClosed('popup', popup.el);
	        },
	      },
	    };

	    if (pb.params.routableModals) {
	      pb.view.router.navigate({
	        url: pb.url,
	        route: {
	          path: pb.url,
	          popup: popupParams,
	        },
	      });
	    } else {
	      pb.modal = pb.app.popup.create(popupParams).open();
	    }
	    return pb;
	  };

	  // Exposition
	  PhotoBrowser.prototype.expositionEnable = function expositionEnable () {
	    var pb = this;
	    if (pb.params.type === 'page') {
	      pb.view.$el.addClass('with-photo-browser-page-exposed');
	    }
	    if (pb.$el) { pb.$el.addClass('photo-browser-exposed'); }
	    if (pb.params.expositionHideCaptions) { pb.$captionsContainerEl.addClass('photo-browser-captions-exposed'); }
	    pb.exposed = true;
	    return pb;
	  };

	  PhotoBrowser.prototype.expositionDisable = function expositionDisable () {
	    var pb = this;
	    if (pb.params.type === 'page') {
	      pb.view.$el.removeClass('with-photo-browser-page-exposed');
	    }
	    if (pb.$el) { pb.$el.removeClass('photo-browser-exposed'); }
	    if (pb.params.expositionHideCaptions) { pb.$captionsContainerEl.removeClass('photo-browser-captions-exposed'); }
	    pb.exposed = false;
	    return pb;
	  };

	  PhotoBrowser.prototype.expositionToggle = function expositionToggle () {
	    var pb = this;
	    if (pb.params.type === 'page') {
	      pb.view.$el.toggleClass('with-photo-browser-page-exposed');
	    }
	    if (pb.$el) { pb.$el.toggleClass('photo-browser-exposed'); }
	    if (pb.params.expositionHideCaptions) { pb.$captionsContainerEl.toggleClass('photo-browser-captions-exposed'); }
	    pb.exposed = !pb.exposed;
	    return pb;
	  };

	  PhotoBrowser.prototype.open = function open (index) {
	    var pb = this;
	    var type = pb.params.type;
	    if (pb.opened) {
	      if (pb.swiper && typeof index !== 'undefined') {
	        pb.swiper.slideTo(parseInt(index, 10));
	      }
	      return pb;
	    }
	    if (typeof index !== 'undefined') {
	      pb.activeIndex = index;
	    }
	    if (type === 'standalone') {
	      pb.openStandalone();
	    }
	    if (type === 'page') {
	      pb.openPage();
	    }
	    if (type === 'popup') {
	      pb.openPopup();
	    }
	    return pb;
	  };

	  PhotoBrowser.prototype.close = function close () {
	    var pb = this;
	    if (!pb.opened) { return pb; }
	    if (pb.params.routableModals || pb.openedIn === 'page') {
	      if (pb.view) { pb.view.router.back(); }
	    } else {
	      pb.modal.once('modalClosed', function () {
	        Utils.nextTick(function () {
	          pb.modal.destroy();
	          delete pb.modal;
	        });
	      });
	      pb.modal.close();
	    }
	    return pb;
	  };
	  // eslint-disable-next-line
	  PhotoBrowser.prototype.init = function init () {};

	  PhotoBrowser.prototype.destroy = function destroy () {
	    var pb = this;
	    pb.emit('local::beforeDestroy photoBrowserBeforeDestroy', pb);
	    if (pb.$el) {
	      pb.$el.trigger('photobrowser:beforedestroy');
	      pb.$el[0].f7PhotoBrowser = null;
	      delete pb.$el[0].f7PhotoBrowser;
	    }
	    Utils.deleteProps(pb);
	    pb = null;
	  };

	  return PhotoBrowser;
	}(Framework7Class));

	var PhotoBrowser$1 = {
	  name: 'photoBrowser',
	  params: {
	    photoBrowser: {
	      photos: [],
	      exposition: true,
	      expositionHideCaptions: false,
	      type: 'standalone',
	      navbar: true,
	      toolbar: true,
	      theme: 'light',
	      captionsTheme: undefined,
	      iconsColor: undefined,
	      swipeToClose: true,
	      backLinkText: 'Close',
	      navbarOfText: 'of',
	      view: undefined,
	      url: 'photos/',
	      routableModals: true,
	      virtualSlides: true,

	      renderNavbar: undefined,
	      renderToolbar: undefined,
	      renderCaption: undefined,
	      renderObject: undefined,
	      renderLazyPhoto: undefined,
	      renderPhoto: undefined,
	      renderPage: undefined,
	      renderPopup: undefined,
	      renderStandalone: undefined,

	      swiper: {
	        initialSlide: 0,
	        spaceBetween: 20,
	        speed: 300,
	        loop: false,
	        preloadImages: true,
	        navigation: {
	          nextEl: '.photo-browser-next',
	          prevEl: '.photo-browser-prev',
	        },
	        zoom: {
	          enabled: true,
	          maxRatio: 3,
	          minRatio: 1,
	        },
	        lazy: {
	          enabled: true,
	        },
	      },
	    },
	  },
	  create: function create() {
	    var app = this;
	    app.photoBrowser = ConstructorMethods({
	      defaultSelector: '.photo-browser',
	      constructor: PhotoBrowser,
	      app: app,
	      domProp: 'f7PhotoBrowser',
	    });
	  },
	  static: {
	    PhotoBrowser: PhotoBrowser,
	  },
	};

	var Notification = /*@__PURE__*/(function (Modal) {
	  function Notification(app, params) {
	    var extendedParams = Utils.extend({
	      on: {},
	    }, app.params.notification, params);

	    // Extends with open/close Modal methods;
	    Modal.call(this, extendedParams, app);

	    var notification = this;

	    notification.app = app;

	    notification.params = extendedParams;

	    var ref = notification.params;
	    var icon = ref.icon;
	    var title = ref.title;
	    var titleRightText = ref.titleRightText;
	    var subtitle = ref.subtitle;
	    var text = ref.text;
	    var closeButton = ref.closeButton;
	    var closeTimeout = ref.closeTimeout;
	    var cssClass = ref.cssClass;
	    var closeOnClick = ref.closeOnClick;

	    var $el;
	    if (!notification.params.el) {
	      // Find Element
	      var notificationHtml = notification.render({
	        icon: icon,
	        title: title,
	        titleRightText: titleRightText,
	        subtitle: subtitle,
	        text: text,
	        closeButton: closeButton,
	        cssClass: cssClass,
	      });

	      $el = $(notificationHtml);
	    } else {
	      $el = $(notification.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el.length === 0) {
	      return notification.destroy();
	    }

	    Utils.extend(notification, {
	      $el: $el,
	      el: $el[0],
	      type: 'notification',
	    });

	    $el[0].f7Modal = notification;

	    if (closeButton) {
	      $el.find('.notification-close-button').on('click', function () {
	        notification.close();
	      });
	    }
	    $el.on('click', function (e) {
	      if (closeButton && $(e.target).closest('.notification-close-button').length) {
	        return;
	      }
	      notification.emit('local::click notificationClick', notification);
	      if (closeOnClick) { notification.close(); }
	    });

	    notification.on('beforeDestroy', function () {
	      $el.off('click');
	    });

	    /* Touch Events */
	    var isTouched;
	    var isMoved;
	    var isScrolling;
	    var touchesDiff;
	    var touchStartTime;
	    var notificationHeight;
	    var touchesStart = {};
	    function handleTouchStart(e) {
	      if (isTouched) { return; }
	      isTouched = true;
	      isMoved = false;
	      isScrolling = undefined;
	      touchStartTime = Utils.now();
	      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	    }
	    function handleTouchMove(e) {
	      if (!isTouched) { return; }
	      var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	      var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      if (typeof isScrolling === 'undefined') {
	        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) < Math.abs(pageX - touchesStart.x));
	      }
	      if (isScrolling) {
	        isTouched = false;
	        return;
	      }
	      e.preventDefault();
	      if (!isMoved) {
	        notification.$el.removeClass('notification-transitioning');
	        notification.$el.transition(0);
	        notificationHeight = notification.$el[0].offsetHeight / 2;
	      }
	      isMoved = true;
	      touchesDiff = (pageY - touchesStart.y);
	      var newTranslate = touchesDiff;
	      if (touchesDiff > 0) {
	        newTranslate = Math.pow( touchesDiff, 0.8 );
	      }
	      notification.$el.transform(("translate3d(0, " + newTranslate + "px, 0)"));
	    }
	    function handleTouchEnd() {
	      if (!isTouched || !isMoved) {
	        isTouched = false;
	        isMoved = false;
	        return;
	      }
	      isTouched = false;
	      isMoved = false;
	      if (touchesDiff === 0) {
	        return;
	      }

	      var timeDiff = Utils.now() - touchStartTime;
	      notification.$el.transition('');
	      notification.$el.addClass('notification-transitioning');
	      notification.$el.transform('');

	      if (
	        (touchesDiff < -10 && timeDiff < 300)
	        || (-touchesDiff >= notificationHeight / 1)
	      ) {
	        notification.close();
	      }
	    }

	    function attachTouchEvents() {
	      {
	        notification.$el.on(app.touchEvents.start, handleTouchStart, { passive: true });
	        app.on('touchmove:active', handleTouchMove);
	        app.on('touchend:passive', handleTouchEnd);
	      }
	    }
	    function detachTouchEvents() {
	      {
	        notification.$el.off(app.touchEvents.start, handleTouchStart, { passive: true });
	        app.off('touchmove:active', handleTouchMove);
	        app.off('touchend:passive', handleTouchEnd);
	      }
	    }

	    var timeoutId;
	    function closeOnTimeout() {
	      timeoutId = Utils.nextTick(function () {
	        if (isTouched && isMoved) {
	          closeOnTimeout();
	          return;
	        }
	        notification.close();
	      }, closeTimeout);
	    }
	    notification.on('open', function () {
	      if (notification.params.swipeToClose) {
	        attachTouchEvents();
	      }
	      $('.notification.modal-in').each(function (index, openedEl) {
	        var notificationInstance = app.notification.get(openedEl);
	        if (openedEl !== notification.el && notificationInstance) {
	          notificationInstance.close();
	        }
	      });
	      if (closeTimeout) {
	        closeOnTimeout();
	      }
	    });
	    notification.on('close beforeDestroy', function () {
	      if (notification.params.swipeToClose) {
	        detachTouchEvents();
	      }
	      win.clearTimeout(timeoutId);
	    });

	    return notification;
	  }

	  if ( Modal ) Notification.__proto__ = Modal;
	  Notification.prototype = Object.create( Modal && Modal.prototype );
	  Notification.prototype.constructor = Notification;

	  Notification.prototype.render = function render () {
	    var notification = this;
	    if (notification.params.render) { return notification.params.render.call(notification, notification); }
	    var ref = notification.params;
	    var icon = ref.icon;
	    var title = ref.title;
	    var titleRightText = ref.titleRightText;
	    var subtitle = ref.subtitle;
	    var text = ref.text;
	    var closeButton = ref.closeButton;
	    var cssClass = ref.cssClass;
	    return ("\n      <div class=\"notification " + (cssClass || '') + "\">\n        <div class=\"notification-header\">\n          " + (icon ? ("<div class=\"notification-icon\">" + icon + "</div>") : '') + "\n          " + (title ? ("<div class=\"notification-title\">" + title + "</div>") : '') + "\n          " + (titleRightText ? ("<div class=\"notification-title-right-text\">" + titleRightText + "</div>") : '') + "\n          " + (closeButton ? '<span class="notification-close-button"></span>' : '') + "\n        </div>\n        <div class=\"notification-content\">\n          " + (subtitle ? ("<div class=\"notification-subtitle\">" + subtitle + "</div>") : '') + "\n          " + (text ? ("<div class=\"notification-text\">" + text + "</div>") : '') + "\n        </div>\n      </div>\n    ").trim();
	  };

	  return Notification;
	}(Modal));

	var Notification$1 = {
	  name: 'notification',
	  static: {
	    Notification: Notification,
	  },
	  create: function create() {
	    var app = this;
	    app.notification = Utils.extend(
	      {},
	      ModalMethods({
	        app: app,
	        constructor: Notification,
	        defaultSelector: '.notification.modal-in',
	      })
	    );
	  },
	  params: {
	    notification: {
	      icon: null,
	      title: null,
	      titleRightText: null,
	      subtitle: null,
	      text: null,
	      closeButton: false,
	      closeTimeout: null,
	      closeOnClick: false,
	      swipeToClose: true,
	      cssClass: null,
	      render: null,
	    },
	  },
	};

	/* eslint "no-useless-escape": "off" */

	var Autocomplete = /*@__PURE__*/(function (Framework7Class) {
	  function Autocomplete(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class.call(this, params, [app]);

	    var ac = this;
	    ac.app = app;

	    var defaults = Utils.extend({
	      on: {},
	    }, app.params.autocomplete);

	    if (typeof defaults.searchbarDisableButton === 'undefined') {
	      defaults.searchbarDisableButton = app.theme !== 'aurora';
	    }

	    // Extend defaults with modules params
	    ac.useModulesParams(defaults);

	    ac.params = Utils.extend(defaults, params);

	    var $openerEl;
	    if (ac.params.openerEl) {
	      $openerEl = $(ac.params.openerEl);
	      if ($openerEl.length) { $openerEl[0].f7Autocomplete = ac; }
	    }

	    var $inputEl;
	    if (ac.params.inputEl) {
	      $inputEl = $(ac.params.inputEl);
	      if ($inputEl.length) { $inputEl[0].f7Autocomplete = ac; }
	    }

	    var view;
	    if (ac.params.view) {
	      view = ac.params.view;
	    } else if ($openerEl || $inputEl) {
	      view = app.views.get($openerEl || $inputEl);
	    }
	    if (!view) { view = app.views.main; }

	    var id = Utils.id();

	    var url = params.url;
	    if (!url && $openerEl && $openerEl.length) {
	      if ($openerEl.attr('href')) { url = $openerEl.attr('href'); }
	      else if ($openerEl.find('a').length > 0) {
	        url = $openerEl.find('a').attr('href');
	      }
	    }
	    if (!url || url === '#' || url === '') { url = ac.params.url; }

	    var inputType = ac.params.multiple ? 'checkbox' : 'radio';

	    Utils.extend(ac, {
	      $openerEl: $openerEl,
	      openerEl: $openerEl && $openerEl[0],
	      $inputEl: $inputEl,
	      inputEl: $inputEl && $inputEl[0],
	      id: id,
	      view: view,
	      url: url,
	      value: ac.params.value || [],
	      inputType: inputType,
	      inputName: (inputType + "-" + id),
	      $modalEl: undefined,
	      $dropdownEl: undefined,
	    });

	    var previousQuery = '';
	    function onInputChange() {
	      var query = ac.$inputEl.val().trim();

	      if (!ac.params.source) { return; }
	      ac.params.source.call(ac, query, function (items) {
	        var itemsHTML = '';
	        var limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
	        ac.items = items;
	        var regExp;
	        if (ac.params.highlightMatches) {
	          query = query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
	          regExp = new RegExp(("(" + query + ")"), 'i');
	        }

	        var firstValue;
	        var firstItem;
	        for (var i = 0; i < limit; i += 1) {
	          var itemValue = typeof items[i] === 'object' ? items[i][ac.params.valueProperty] : items[i];
	          var itemText = typeof items[i] === 'object' ? items[i][ac.params.textProperty] : items[i];
	          if (i === 0) {
	            firstValue = itemValue;
	            firstItem = ac.items[i];
	          }
	          itemsHTML += ac.renderItem({
	            value: itemValue,
	            text: ac.params.highlightMatches ? itemText.replace(regExp, '<b>$1</b>') : itemText,
	          }, i);
	        }
	        if (itemsHTML === '' && query === '' && ac.params.dropdownPlaceholderText) {
	          itemsHTML += ac.renderItem({
	            placeholder: true,
	            text: ac.params.dropdownPlaceholderText,
	          });
	        }
	        ac.$dropdownEl.find('ul').html(itemsHTML);
	        if (ac.params.typeahead) {
	          if (!firstValue || !firstItem) {
	            return;
	          }
	          if (firstValue.toLowerCase().indexOf(query.toLowerCase()) !== 0) {
	            return;
	          }
	          if (previousQuery.toLowerCase() === query.toLowerCase()) {
	            ac.value = [];
	            return;
	          }

	          if (previousQuery.toLowerCase().indexOf(query.toLowerCase()) === 0) {
	            previousQuery = query;
	            ac.value = [];
	            return;
	          }
	          $inputEl.val(firstValue);
	          $inputEl[0].setSelectionRange(query.length, firstValue.length);

	          var previousValue = typeof ac.value[0] === 'object' ? ac.value[0][ac.params.valueProperty] : ac.value[0];
	          if (!previousValue || firstValue.toLowerCase() !== previousValue.toLowerCase()) {
	            ac.value = [firstItem];
	            ac.emit('local::change autocompleteChange', [firstItem]);
	          }
	        }

	        previousQuery = query;
	      });
	    }
	    function onPageInputChange() {
	      var input = this;
	      var value = input.value;
	      var isValues = $(input).parents('.autocomplete-values').length > 0;
	      var item;
	      var itemValue;
	      var aValue;
	      if (isValues) {
	        if (ac.inputType === 'checkbox' && !input.checked) {
	          for (var i = 0; i < ac.value.length; i += 1) {
	            aValue = typeof ac.value[i] === 'string' ? ac.value[i] : ac.value[i][ac.params.valueProperty];
	            if (aValue === value || aValue * 1 === value * 1) {
	              ac.value.splice(i, 1);
	            }
	          }
	          ac.updateValues();
	          ac.emit('local::change autocompleteChange', ac.value);
	        }
	        return;
	      }

	      // Find Related Item
	      for (var i$1 = 0; i$1 < ac.items.length; i$1 += 1) {
	        itemValue = typeof ac.items[i$1] === 'object' ? ac.items[i$1][ac.params.valueProperty] : ac.items[i$1];
	        if (itemValue === value || itemValue * 1 === value * 1) { item = ac.items[i$1]; }
	      }
	      if (ac.inputType === 'radio') {
	        ac.value = [item];
	      } else if (input.checked) {
	        ac.value.push(item);
	      } else {
	        for (var i$2 = 0; i$2 < ac.value.length; i$2 += 1) {
	          aValue = typeof ac.value[i$2] === 'object' ? ac.value[i$2][ac.params.valueProperty] : ac.value[i$2];
	          if (aValue === value || aValue * 1 === value * 1) {
	            ac.value.splice(i$2, 1);
	          }
	        }
	      }

	      // Update Values Block
	      ac.updateValues();

	      // On Select Callback
	      if (((ac.inputType === 'radio' && input.checked) || ac.inputType === 'checkbox')) {
	        ac.emit('local::change autocompleteChange', ac.value);
	      }
	    }
	    function onHtmlClick(e) {
	      var $targetEl = $(e.target);
	      if ($targetEl.is(ac.$inputEl[0]) || (ac.$dropdownEl && $targetEl.closest(ac.$dropdownEl[0]).length)) { return; }
	      ac.close();
	    }
	    function onOpenerClick() {
	      ac.open();
	    }
	    function onInputFocus() {
	      ac.open();
	    }
	    function onInputBlur() {
	      if (ac.$dropdownEl.find('label.active-state').length > 0) { return; }
	      setTimeout(function () {
	        ac.close();
	      }, 0);
	    }
	    function onResize() {
	      ac.positionDropdown();
	    }

	    function onKeyDown(e) {
	      if (!ac.opened) { return; }
	      if (e.keyCode === 27) {
	        // ESC
	        e.preventDefault();
	        ac.$inputEl.blur();
	        return;
	      }
	      if (e.keyCode === 13) {
	        // Enter
	        var $selectedItemLabel = ac.$dropdownEl.find('.autocomplete-dropdown-selected label');
	        if ($selectedItemLabel.length) {
	          e.preventDefault();
	          $selectedItemLabel.trigger('click');
	          ac.$inputEl.blur();
	          return;
	        }
	        if (ac.params.typeahead) {
	          e.preventDefault();
	          ac.$inputEl.blur();
	        }
	        return;
	      }
	      if (e.keyCode !== 40 && e.keyCode !== 38) { return; }
	      e.preventDefault();
	      var $selectedItem = ac.$dropdownEl.find('.autocomplete-dropdown-selected');
	      var $newItem;
	      if ($selectedItem.length) {
	        $newItem = $selectedItem[e.keyCode === 40 ? 'next' : 'prev']('li');
	        if (!$newItem.length) {
	          $newItem = ac.$dropdownEl.find('li').eq(e.keyCode === 40 ? 0 : ac.$dropdownEl.find('li').length - 1);
	        }
	      } else {
	        $newItem = ac.$dropdownEl.find('li').eq(e.keyCode === 40 ? 0 : ac.$dropdownEl.find('li').length - 1);
	      }
	      if ($newItem.hasClass('autocomplete-dropdown-placeholder')) { return; }
	      $selectedItem.removeClass('autocomplete-dropdown-selected');
	      $newItem.addClass('autocomplete-dropdown-selected');
	    }
	    function onDropdownClick() {
	      var $clickedEl = $(this);
	      var clickedItem;
	      for (var i = 0; i < ac.items.length; i += 1) {
	        var itemValue = typeof ac.items[i] === 'object' ? ac.items[i][ac.params.valueProperty] : ac.items[i];
	        var value = $clickedEl.attr('data-value');
	        if (itemValue === value || itemValue * 1 === value * 1) {
	          clickedItem = ac.items[i];
	        }
	      }
	      if (ac.params.updateInputValueOnSelect) {
	        ac.$inputEl.val(typeof clickedItem === 'object' ? clickedItem[ac.params.valueProperty] : clickedItem);
	        ac.$inputEl.trigger('input change');
	      }
	      ac.value = [clickedItem];
	      ac.emit('local::change autocompleteChange', [clickedItem]);
	      ac.close();
	    }

	    ac.attachEvents = function attachEvents() {
	      if (ac.params.openIn !== 'dropdown' && ac.$openerEl) {
	        ac.$openerEl.on('click', onOpenerClick);
	      }
	      if (ac.params.openIn === 'dropdown' && ac.$inputEl) {
	        ac.$inputEl.on('focus', onInputFocus);
	        ac.$inputEl.on(ac.params.inputEvents, onInputChange);
	        if (app.device.android) {
	          $('html').on('click', onHtmlClick);
	        } else {
	          ac.$inputEl.on('blur', onInputBlur);
	        }
	        ac.$inputEl.on('keydown', onKeyDown);
	      }
	    };
	    ac.detachEvents = function attachEvents() {
	      if (ac.params.openIn !== 'dropdown' && ac.$openerEl) {
	        ac.$openerEl.off('click', onOpenerClick);
	      }
	      if (ac.params.openIn === 'dropdown' && ac.$inputEl) {
	        ac.$inputEl.off('focus', onInputFocus);
	        ac.$inputEl.off(ac.params.inputEvents, onInputChange);
	        if (app.device.android) {
	          $('html').off('click', onHtmlClick);
	        } else {
	          ac.$inputEl.off('blur', onInputBlur);
	        }
	        ac.$inputEl.off('keydown', onKeyDown);
	      }
	    };
	    ac.attachDropdownEvents = function attachDropdownEvents() {
	      ac.$dropdownEl.on('click', 'label', onDropdownClick);
	      app.on('resize', onResize);
	    };
	    ac.detachDropdownEvents = function detachDropdownEvents() {
	      ac.$dropdownEl.off('click', 'label', onDropdownClick);
	      app.off('resize', onResize);
	    };

	    ac.attachPageEvents = function attachPageEvents() {
	      ac.$el.on('change', 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
	      if (ac.params.closeOnSelect && !ac.params.multiple) {
	        ac.$el.once('click', '.list label', function () {
	          Utils.nextTick(function () {
	            ac.close();
	          });
	        });
	      }
	    };
	    ac.detachPageEvents = function detachPageEvents() {
	      ac.$el.off('change', 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
	    };

	    // Install Modules
	    ac.useModules();

	    // Init
	    ac.init();

	    return ac;
	  }

	  if ( Framework7Class ) Autocomplete.__proto__ = Framework7Class;
	  Autocomplete.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  Autocomplete.prototype.constructor = Autocomplete;

	  Autocomplete.prototype.positionDropdown = function positionDropdown () {
	    var obj;

	    var ac = this;
	    var $inputEl = ac.$inputEl;
	    var app = ac.app;
	    var $dropdownEl = ac.$dropdownEl;

	    var $pageContentEl = $inputEl.parents('.page-content');
	    if ($pageContentEl.length === 0) { return; }
	    var inputOffset = $inputEl.offset();
	    var inputOffsetWidth = $inputEl[0].offsetWidth;
	    var inputOffsetHeight = $inputEl[0].offsetHeight;
	    var $listEl = $inputEl.parents('.list');

	    var $listParent;
	    $listEl.parents().each(function (index, parentEl) {
	      if ($listParent) { return; }
	      var $parentEl = $(parentEl);
	      if ($parentEl.parent($pageContentEl).length) { $listParent = $parentEl; }
	    });

	    var listOffset = $listEl.offset();
	    var paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
	    var listOffsetLeft = $listEl.length > 0 ? listOffset.left - $pageContentEl.offset().left : 0;
	    var inputOffsetLeft = inputOffset.left - ($listEl.length > 0 ? listOffset.left : 0) - (app.rtl ? 0 : 0);
	    var inputOffsetTop = inputOffset.top - ($pageContentEl.offset().top - $pageContentEl[0].scrollTop);

	    var maxHeight = $pageContentEl[0].scrollHeight - paddingBottom - (inputOffsetTop + $pageContentEl[0].scrollTop) - $inputEl[0].offsetHeight;

	    var paddingProp = app.rtl ? 'padding-right' : 'padding-left';
	    var paddingValue;
	    if ($listEl.length && !ac.params.expandInput) {
	      paddingValue = (app.rtl ? $listEl[0].offsetWidth - inputOffsetLeft - inputOffsetWidth : inputOffsetLeft) - (app.theme === 'md' ? 16 : 15);
	    }

	    $dropdownEl.css({
	      left: (($listEl.length > 0 ? listOffsetLeft : inputOffsetLeft) + "px"),
	      top: ((inputOffsetTop + $pageContentEl[0].scrollTop + inputOffsetHeight) + "px"),
	      width: (($listEl.length > 0 ? $listEl[0].offsetWidth : inputOffsetWidth) + "px"),
	    });
	    $dropdownEl.children('.autocomplete-dropdown-inner').css(( obj = {
	      maxHeight: (maxHeight + "px")
	    }, obj[paddingProp] = $listEl.length > 0 && !ac.params.expandInput ? (paddingValue + "px") : '', obj ));
	  };

	  Autocomplete.prototype.focus = function focus () {
	    var ac = this;
	    ac.$el.find('input[type=search]').focus();
	  };

	  Autocomplete.prototype.source = function source (query) {
	    var ac = this;
	    if (!ac.params.source) { return; }

	    var $el = ac.$el;

	    ac.params.source.call(ac, query, function (items) {
	      var itemsHTML = '';
	      var limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
	      ac.items = items;
	      for (var i = 0; i < limit; i += 1) {
	        var selected = false;
	        var itemValue = typeof items[i] === 'object' ? items[i][ac.params.valueProperty] : items[i];
	        for (var j = 0; j < ac.value.length; j += 1) {
	          var aValue = typeof ac.value[j] === 'object' ? ac.value[j][ac.params.valueProperty] : ac.value[j];
	          if (aValue === itemValue || aValue * 1 === itemValue * 1) { selected = true; }
	        }
	        itemsHTML += ac.renderItem({
	          value: itemValue,
	          text: typeof items[i] === 'object' ? items[i][ac.params.textProperty] : items[i],
	          inputType: ac.inputType,
	          id: ac.id,
	          inputName: ac.inputName,
	          selected: selected,
	        }, i);
	      }
	      $el.find('.autocomplete-found ul').html(itemsHTML);
	      if (items.length === 0) {
	        if (query.length !== 0) {
	          $el.find('.autocomplete-not-found').show();
	          $el.find('.autocomplete-found, .autocomplete-values').hide();
	        } else {
	          $el.find('.autocomplete-values').show();
	          $el.find('.autocomplete-found, .autocomplete-not-found').hide();
	        }
	      } else {
	        $el.find('.autocomplete-found').show();
	        $el.find('.autocomplete-not-found, .autocomplete-values').hide();
	      }
	    });
	  };

	  Autocomplete.prototype.updateValues = function updateValues () {
	    var ac = this;
	    var valuesHTML = '';
	    for (var i = 0; i < ac.value.length; i += 1) {
	      valuesHTML += ac.renderItem({
	        value: typeof ac.value[i] === 'object' ? ac.value[i][ac.params.valueProperty] : ac.value[i],
	        text: typeof ac.value[i] === 'object' ? ac.value[i][ac.params.textProperty] : ac.value[i],
	        inputType: ac.inputType,
	        id: ac.id,
	        inputName: ((ac.inputName) + "-checked}"),
	        selected: true,
	      }, i);
	    }
	    ac.$el.find('.autocomplete-values ul').html(valuesHTML);
	  };

	  Autocomplete.prototype.preloaderHide = function preloaderHide () {
	    var ac = this;
	    if (ac.params.openIn === 'dropdown' && ac.$dropdownEl) {
	      ac.$dropdownEl.find('.autocomplete-preloader').removeClass('autocomplete-preloader-visible');
	    } else {
	      $('.autocomplete-preloader').removeClass('autocomplete-preloader-visible');
	    }
	  };

	  Autocomplete.prototype.preloaderShow = function preloaderShow () {
	    var ac = this;
	    if (ac.params.openIn === 'dropdown' && ac.$dropdownEl) {
	      ac.$dropdownEl.find('.autocomplete-preloader').addClass('autocomplete-preloader-visible');
	    } else {
	      $('.autocomplete-preloader').addClass('autocomplete-preloader-visible');
	    }
	  };

	  Autocomplete.prototype.renderPreloader = function renderPreloader () {
	    var ac = this;
	    return ("\n      <div class=\"autocomplete-preloader preloader " + (ac.params.preloaderColor ? ("color-" + (ac.params.preloaderColor)) : '') + "\">" + (Utils[((ac.app.theme) + "PreloaderContent")] || '') + "</div>\n    ").trim();
	  };

	  Autocomplete.prototype.renderSearchbar = function renderSearchbar () {
	    var ac = this;
	    if (ac.params.renderSearchbar) { return ac.params.renderSearchbar.call(ac); }
	    var searchbarHTML = ("\n      <form class=\"searchbar\">\n        <div class=\"searchbar-inner\">\n          <div class=\"searchbar-input-wrap\">\n            <input type=\"search\" placeholder=\"" + (ac.params.searchbarPlaceholder) + "\"/>\n            <i class=\"searchbar-icon\"></i>\n            <span class=\"input-clear-button\"></span>\n          </div>\n          " + (ac.params.searchbarDisableButton ? ("\n          <span class=\"searchbar-disable-button\">" + (ac.params.searchbarDisableText) + "</span>\n          ") : '') + "\n        </div>\n      </form>\n    ").trim();
	    return searchbarHTML;
	  };

	  Autocomplete.prototype.renderItem = function renderItem (item, index) {
	    var ac = this;
	    if (ac.params.renderItem) { return ac.params.renderItem.call(ac, item, index); }
	    var itemHtml;
	    var itemValue = item.value && typeof item.value === 'string' ? item.value.replace(/"/g, '&quot;') : item.value;
	    if (ac.params.openIn !== 'dropdown') {
	      itemHtml = "\n        <li>\n          <label class=\"item-" + (item.inputType) + " item-content\">\n            <input type=\"" + (item.inputType) + "\" name=\"" + (item.inputName) + "\" value=\"" + itemValue + "\" " + (item.selected ? 'checked' : '') + ">\n            <i class=\"icon icon-" + (item.inputType) + "\"></i>\n            <div class=\"item-inner\">\n              <div class=\"item-title\">" + (item.text) + "</div>\n            </div>\n          </label>\n        </li>\n      ";
	    } else if (!item.placeholder) {
	      // Dropdown
	      itemHtml = "\n        <li>\n          <label class=\"item-radio item-content\" data-value=\"" + itemValue + "\">\n            <div class=\"item-inner\">\n              <div class=\"item-title\">" + (item.text) + "</div>\n            </div>\n          </label>\n        </li>\n      ";
	    } else {
	      // Dropwdown placeholder
	      itemHtml = "\n        <li class=\"autocomplete-dropdown-placeholder\">\n          <label class=\"item-content\">\n            <div class=\"item-inner\">\n              <div class=\"item-title\">" + (item.text) + "</div>\n            </div>\n          </label>\n        </li>\n      ";
	    }
	    return itemHtml.trim();
	  };

	  Autocomplete.prototype.renderNavbar = function renderNavbar () {
	    var ac = this;
	    if (ac.params.renderNavbar) { return ac.params.renderNavbar.call(ac); }
	    var pageTitle = ac.params.pageTitle;
	    if (typeof pageTitle === 'undefined' && ac.$openerEl && ac.$openerEl.length) {
	      pageTitle = ac.$openerEl.find('.item-title').text().trim();
	    }
	    var inPopup = ac.params.openIn === 'popup';
	    var navbarLeft = inPopup
	      ? ("\n        " + (ac.params.preloader ? ("\n        <div class=\"left\">\n          " + (ac.renderPreloader()) + "\n        </div>\n        ") : '') + "\n      ")
	      : ("\n        <div class=\"left sliding\">\n          <a class=\"link back\">\n            <i class=\"icon icon-back\"></i>\n            <span class=\"if-not-md\">" + (ac.params.pageBackLinkText) + "</span>\n          </a>\n        </div>\n      ");
	    var navbarRight = inPopup
	      ? ("\n        <div class=\"right\">\n          <a class=\"link popup-close\" data-popup=\".autocomplete-popup\">\n            " + (ac.params.popupCloseLinkText) + "\n          </a>\n        </div>\n      ")
	      : ("\n        " + (ac.params.preloader ? ("\n        <div class=\"right\">\n          " + (ac.renderPreloader()) + "\n        </div>\n        ") : '') + "\n      ");
	    var navbarHtml = ("\n      <div class=\"navbar " + (ac.params.navbarColorTheme ? ("color-" + (ac.params.navbarColorTheme)) : '') + "\">\n        <div class=\"navbar-inner " + (ac.params.navbarColorTheme ? ("color-" + (ac.params.navbarColorTheme)) : '') + "\">\n          " + navbarLeft + "\n          " + (pageTitle ? ("<div class=\"title sliding\">" + pageTitle + "</div>") : '') + "\n          " + navbarRight + "\n          <div class=\"subnavbar sliding\">" + (ac.renderSearchbar()) + "</div>\n        </div>\n      </div>\n    ").trim();
	    return navbarHtml;
	  };

	  Autocomplete.prototype.renderDropdown = function renderDropdown () {
	    var ac = this;
	    if (ac.params.renderDropdown) { return ac.params.renderDropdown.call(ac, ac.items); }
	    var dropdownHtml = ("\n      <div class=\"autocomplete-dropdown\">\n        <div class=\"autocomplete-dropdown-inner\">\n          <div class=\"list " + (!ac.params.expandInput ? 'no-safe-areas' : '') + "\">\n            <ul></ul>\n          </div>\n        </div>\n        " + (ac.params.preloader ? ac.renderPreloader() : '') + "\n      </div>\n    ").trim();
	    return dropdownHtml;
	  };

	  Autocomplete.prototype.renderPage = function renderPage (inPopup) {
	    var ac = this;
	    if (ac.params.renderPage) { return ac.params.renderPage.call(ac, ac.items); }

	    var pageHtml = ("\n      <div class=\"page page-with-subnavbar autocomplete-page\" data-name=\"autocomplete-page\">\n        " + (ac.renderNavbar(inPopup)) + "\n        <div class=\"searchbar-backdrop\"></div>\n        <div class=\"page-content\">\n          <div class=\"list autocomplete-list autocomplete-found autocomplete-list-" + (ac.id) + " " + (ac.params.formColorTheme ? ("color-" + (ac.params.formColorTheme)) : '') + "\">\n            <ul></ul>\n          </div>\n          <div class=\"list autocomplete-not-found\">\n            <ul>\n              <li class=\"item-content\"><div class=\"item-inner\"><div class=\"item-title\">" + (ac.params.notFoundText) + "</div></div></li>\n            </ul>\n          </div>\n          <div class=\"list autocomplete-values\">\n            <ul></ul>\n          </div>\n        </div>\n      </div>\n    ").trim();
	    return pageHtml;
	  };

	  Autocomplete.prototype.renderPopup = function renderPopup () {
	    var ac = this;
	    if (ac.params.renderPopup) { return ac.params.renderPopup.call(ac, ac.items); }
	    var popupHtml = ("\n      <div class=\"popup autocomplete-popup\">\n        <div class=\"view\">\n          " + (ac.renderPage(true)) + ";\n        </div>\n      </div>\n    ").trim();
	    return popupHtml;
	  };

	  Autocomplete.prototype.onOpen = function onOpen (type, el) {
	    var ac = this;
	    var app = ac.app;
	    var $el = $(el);
	    ac.$el = $el;
	    ac.el = $el[0];
	    ac.openedIn = type;
	    ac.opened = true;

	    if (ac.params.openIn === 'dropdown') {
	      ac.attachDropdownEvents();

	      ac.$dropdownEl.addClass('autocomplete-dropdown-in');
	      ac.$inputEl.trigger('input');
	    } else {
	      // Init SB
	      var $searchbarEl = $el.find('.searchbar');
	      if (ac.params.openIn === 'page' && app.theme === 'ios' && $searchbarEl.length === 0) {
	        $searchbarEl = $(app.navbar.getElByPage($el)).find('.searchbar');
	      }
	      ac.searchbar = app.searchbar.create({
	        el: $searchbarEl,
	        backdropEl: $el.find('.searchbar-backdrop'),
	        customSearch: true,
	        on: {
	          search: function search(sb, query) {
	            if (query.length === 0 && ac.searchbar.enabled) {
	              ac.searchbar.backdropShow();
	            } else {
	              ac.searchbar.backdropHide();
	            }
	            ac.source(query);
	          },
	        },
	      });

	      // Attach page events
	      ac.attachPageEvents();

	      // Update Values On Page Init
	      ac.updateValues();

	      // Source on load
	      if (ac.params.requestSourceOnOpen) { ac.source(''); }
	    }

	    ac.emit('local::open autocompleteOpen', ac);
	  };

	  Autocomplete.prototype.autoFocus = function autoFocus () {
	    var ac = this;
	    if (ac.searchbar && ac.searchbar.$inputEl) {
	      ac.searchbar.$inputEl.focus();
	    }
	    return ac;
	  };

	  Autocomplete.prototype.onOpened = function onOpened () {
	    var ac = this;
	    if (ac.params.openIn !== 'dropdown' && ac.params.autoFocus) {
	      ac.autoFocus();
	    }
	    ac.emit('local::opened autocompleteOpened', ac);
	  };

	  Autocomplete.prototype.onClose = function onClose () {
	    var ac = this;
	    if (ac.destroyed) { return; }

	    // Destroy SB
	    if (ac.searchbar && ac.searchbar.destroy) {
	      ac.searchbar.destroy();
	      ac.searchbar = null;
	      delete ac.searchbar;
	    }

	    if (ac.params.openIn === 'dropdown') {
	      ac.detachDropdownEvents();
	      ac.$dropdownEl.removeClass('autocomplete-dropdown-in').remove();
	      ac.$inputEl.parents('.item-content-dropdown-expanded').removeClass('item-content-dropdown-expanded');
	    } else {
	      ac.detachPageEvents();
	    }

	    ac.emit('local::close autocompleteClose', ac);
	  };

	  Autocomplete.prototype.onClosed = function onClosed () {
	    var ac = this;
	    if (ac.destroyed) { return; }
	    ac.opened = false;
	    ac.$el = null;
	    ac.el = null;
	    delete ac.$el;
	    delete ac.el;

	    ac.emit('local::closed autocompleteClosed', ac);
	  };

	  Autocomplete.prototype.openPage = function openPage () {
	    var ac = this;
	    if (ac.opened) { return ac; }
	    var pageHtml = ac.renderPage();
	    ac.view.router.navigate({
	      url: ac.url,
	      route: {
	        content: pageHtml,
	        path: ac.url,
	        on: {
	          pageBeforeIn: function pageBeforeIn(e, page) {
	            ac.onOpen('page', page.el);
	          },
	          pageAfterIn: function pageAfterIn(e, page) {
	            ac.onOpened('page', page.el);
	          },
	          pageBeforeOut: function pageBeforeOut(e, page) {
	            ac.onClose('page', page.el);
	          },
	          pageAfterOut: function pageAfterOut(e, page) {
	            ac.onClosed('page', page.el);
	          },
	        },
	        options: {
	          animate: ac.params.animate,
	        },
	      },
	    });
	    return ac;
	  };

	  Autocomplete.prototype.openPopup = function openPopup () {
	    var ac = this;
	    if (ac.opened) { return ac; }
	    var popupHtml = ac.renderPopup();

	    var popupParams = {
	      content: popupHtml,
	      animate: ac.params.animate,
	      on: {
	        popupOpen: function popupOpen(popup) {
	          ac.onOpen('popup', popup.el);
	        },
	        popupOpened: function popupOpened(popup) {
	          ac.onOpened('popup', popup.el);
	        },
	        popupClose: function popupClose(popup) {
	          ac.onClose('popup', popup.el);
	        },
	        popupClosed: function popupClosed(popup) {
	          ac.onClosed('popup', popup.el);
	        },
	      },
	    };

	    if (ac.params.routableModals) {
	      ac.view.router.navigate({
	        url: ac.url,
	        route: {
	          path: ac.url,
	          popup: popupParams,
	        },
	      });
	    } else {
	      ac.modal = ac.app.popup.create(popupParams).open(ac.params.animate);
	    }
	    return ac;
	  };

	  Autocomplete.prototype.openDropdown = function openDropdown () {
	    var ac = this;

	    if (!ac.$dropdownEl) {
	      ac.$dropdownEl = $(ac.renderDropdown());
	    }
	    var $listEl = ac.$inputEl.parents('.list');
	    if ($listEl.length && ac.$inputEl.parents('.item-content').length > 0 && ac.params.expandInput) {
	      ac.$inputEl.parents('.item-content').addClass('item-content-dropdown-expanded');
	    }

	    var $pageContentEl = ac.$inputEl.parents('.page-content');
	    if (ac.params.dropdownContainerEl) {
	      $(ac.params.dropdownContainerEl).append(ac.$dropdownEl);
	    } else if ($pageContentEl.length === 0) {
	      ac.$dropdownEl.insertAfter(ac.$inputEl);
	    } else {
	      ac.positionDropdown();
	      $pageContentEl.append(ac.$dropdownEl);
	    }
	    ac.onOpen('dropdown', ac.$dropdownEl);
	    ac.onOpened('dropdown', ac.$dropdownEl);
	  };

	  Autocomplete.prototype.open = function open () {
	    var ac = this;
	    if (ac.opened) { return ac; }
	    var openIn = ac.params.openIn;
	    ac[("open" + (openIn.split('').map(function (el, index) {
	      if (index === 0) { return el.toUpperCase(); }
	      return el;
	    }).join('')))]();
	    return ac;
	  };

	  Autocomplete.prototype.close = function close () {
	    var ac = this;
	    if (!ac.opened) { return ac; }
	    if (ac.params.openIn === 'dropdown') {
	      ac.onClose();
	      ac.onClosed();
	    } else if (ac.params.routableModals || ac.openedIn === 'page') {
	      ac.view.router.back({ animate: ac.params.animate });
	    } else {
	      ac.modal.once('modalClosed', function () {
	        Utils.nextTick(function () {
	          ac.modal.destroy();
	          delete ac.modal;
	        });
	      });
	      ac.modal.close();
	    }
	    return ac;
	  };

	  Autocomplete.prototype.init = function init () {
	    var ac = this;
	    ac.attachEvents();
	  };

	  Autocomplete.prototype.destroy = function destroy () {
	    var ac = this;
	    ac.emit('local::beforeDestroy autocompleteBeforeDestroy', ac);
	    ac.detachEvents();
	    if (ac.$inputEl && ac.$inputEl[0]) {
	      delete ac.$inputEl[0].f7Autocomplete;
	    }
	    if (ac.$openerEl && ac.$openerEl[0]) {
	      delete ac.$openerEl[0].f7Autocomplete;
	    }
	    Utils.deleteProps(ac);
	    ac.destroyed = true;
	  };

	  return Autocomplete;
	}(Framework7Class));

	var Autocomplete$1 = {
	  name: 'autocomplete',
	  params: {
	    autocomplete: {
	      openerEl: undefined,
	      inputEl: undefined,
	      view: undefined,

	      // DropDown
	      dropdownContainerEl: undefined,
	      dropdownPlaceholderText: undefined,
	      typeahead: false,
	      highlightMatches: true,
	      expandInput: false,
	      updateInputValueOnSelect: true,
	      inputEvents: 'input',

	      value: undefined,
	      multiple: false,

	      source: undefined,
	      limit: undefined,
	      valueProperty: 'id',
	      textProperty: 'text',

	      openIn: 'page', // or 'popup' or 'dropdown'
	      pageBackLinkText: 'Back',
	      popupCloseLinkText: 'Close',
	      pageTitle: undefined,
	      searchbarPlaceholder: 'Search...',
	      searchbarDisableText: 'Cancel',
	      searchbarDisableButton: undefined,

	      animate: true,

	      autoFocus: false,
	      closeOnSelect: false,
	      notFoundText: 'Nothing found',
	      requestSourceOnOpen: false,

	      // Preloader
	      preloaderColor: undefined,
	      preloader: false,

	      // Colors
	      formColorTheme: undefined,
	      navbarColorTheme: undefined,

	      // Routing
	      routableModals: true,
	      url: 'select/',

	      // Custom render functions
	      renderDropdown: undefined,
	      renderPage: undefined,
	      renderPopup: undefined,
	      renderItem: undefined,
	      renderSearchbar: undefined,
	      renderNavbar: undefined,

	    },
	  },
	  static: {
	    Autocomplete: Autocomplete,
	  },
	  create: function create() {
	    var app = this;
	    app.autocomplete = Utils.extend(
	      ConstructorMethods({
	        defaultSelector: undefined,
	        constructor: Autocomplete,
	        app: app,
	        domProp: 'f7Autocomplete',
	      }),
	      {
	        open: function open(autocompleteEl) {
	          var ac = app.autocomplete.get(autocompleteEl);
	          if (ac && ac.open) { return ac.open(); }
	          return undefined;
	        },
	        close: function close(autocompleteEl) {
	          var ac = app.autocomplete.get(autocompleteEl);
	          if (ac && ac.close) { return ac.close(); }
	          return undefined;
	        },
	      }
	    );
	  },
	};

	var Tooltip = /*@__PURE__*/(function (Framework7Class) {
	  function Tooltip(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class.call(this, params, app);

	    var tooltip = this;

	    var defaults = Utils.extend({}, app.params.tooltip);

	    // Extend defaults with modules params
	    tooltip.useModulesParams(defaults);

	    tooltip.params = Utils.extend(defaults, params);

	    var ref = tooltip.params;
	    var targetEl = ref.targetEl;
	    if (!targetEl) { return tooltip; }

	    var $targetEl = $(targetEl);
	    if ($targetEl.length === 0) { return tooltip; }

	    if ($targetEl[0].f7Tooltip) { return $targetEl[0].f7Tooltip; }

	    var $el = $(tooltip.render()).eq(0);

	    Utils.extend(tooltip, {
	      app: app,
	      $targetEl: $targetEl,
	      targetEl: $targetEl && $targetEl[0],
	      $el: $el,
	      el: $el && $el[0],
	      text: tooltip.params.text || '',
	      visible: false,
	      opened: false,
	    });

	    $targetEl[0].f7Tooltip = tooltip;

	    var touchesStart = {};
	    var isTouched;
	    function handleTouchStart(e) {
	      if (isTouched) { return; }
	      isTouched = true;
	      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	      tooltip.show(this);
	    }
	    function handleTouchMove(e) {
	      if (!isTouched) { return; }
	      var x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	      var y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      var distance = Math.pow( (
	        (Math.pow( (x - touchesStart.x), 2 ))
	        + (Math.pow( (y - touchesStart.y), 2 ))
	      ), 0.5 );
	      if (distance > 50) {
	        isTouched = false;
	        tooltip.hide();
	      }
	    }
	    function handleTouchEnd() {
	      if (!isTouched) { return; }
	      isTouched = false;
	      tooltip.hide();
	    }
	    function handleMouseEnter() {
	      tooltip.show(this);
	    }
	    function handleMouseLeave() {
	      tooltip.hide();
	    }
	    function handleTransitionEnd() {
	      if (!$el.hasClass('tooltip-in')) {
	        $el.removeClass('tooltip-out').remove();
	      }
	    }

	    tooltip.attachEvents = function attachEvents() {
	      $el.on('transitionend', handleTransitionEnd);
	      if (Support.touch) {
	        var passive = Support.passiveListener ? { passive: true } : false;
	        $targetEl.on(app.touchEvents.start, handleTouchStart, passive);
	        app.on('touchmove', handleTouchMove);
	        app.on('touchend:passive', handleTouchEnd);
	      } else {
	        $targetEl.on('mouseenter', handleMouseEnter);
	        $targetEl.on('mouseleave', handleMouseLeave);
	      }
	    };
	    tooltip.detachEvents = function detachEvents() {
	      $el.off('transitionend', handleTransitionEnd);
	      if (Support.touch) {
	        var passive = Support.passiveListener ? { passive: true } : false;
	        $targetEl.off(app.touchEvents.start, handleTouchStart, passive);
	        app.off('touchmove', handleTouchMove);
	        app.off('touchend:passive', handleTouchEnd);
	      } else {
	        $targetEl.off('mouseenter', handleMouseEnter);
	        $targetEl.off('mouseleave', handleMouseLeave);
	      }
	    };

	    // Install Modules
	    tooltip.useModules();

	    tooltip.init();

	    return tooltip;
	  }

	  if ( Framework7Class ) Tooltip.__proto__ = Framework7Class;
	  Tooltip.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  Tooltip.prototype.constructor = Tooltip;

	  Tooltip.prototype.position = function position (targetEl) {
	    var tooltip = this;
	    var $el = tooltip.$el;
	    var app = tooltip.app;
	    $el.css({ left: '', top: '' });
	    var $targetEl = $(targetEl || tooltip.targetEl);
	    var ref = [$el.width(), $el.height()];
	    var width = ref[0];
	    var height = ref[1];

	    $el.css({ left: '', top: '' });

	    var targetWidth;
	    var targetHeight;
	    var targetOffsetLeft;
	    var targetOffsetTop;
	    if ($targetEl && $targetEl.length > 0) {
	      targetWidth = $targetEl.outerWidth();
	      targetHeight = $targetEl.outerHeight();

	      var targetOffset = $targetEl.offset();
	      targetOffsetLeft = targetOffset.left - app.left;
	      targetOffsetTop = targetOffset.top - app.top;

	      var targetParentPage = $targetEl.parents('.page');
	      if (targetParentPage.length > 0) {
	        targetOffsetTop -= targetParentPage[0].scrollTop;
	      }
	    }
	    var ref$1 = [0, 0, 0];
	    var left = ref$1[0];
	    var top = ref$1[1];

	    // Top Position
	    var position = 'top';

	    if (height < targetOffsetTop) {
	      // On top
	      top = targetOffsetTop - height;
	    } else if (height < app.height - targetOffsetTop - targetHeight) {
	      // On bottom
	      position = 'bottom';
	      top = targetOffsetTop + targetHeight;
	    } else {
	      // On middle
	      position = 'middle';
	      top = ((targetHeight / 2) + targetOffsetTop) - (height / 2);
	      if (top <= 0) {
	        top = 8;
	      } else if (top + height >= app.height) {
	        top = app.height - height - 8;
	      }
	    }

	    // Horizontal Position
	    if (position === 'top' || position === 'bottom') {
	      left = ((targetWidth / 2) + targetOffsetLeft) - (width / 2);
	      if (left < 8) { left = 8; }
	      if (left + width > app.width) { left = app.width - width - 8; }
	      if (left < 0) { left = 0; }
	    } else if (position === 'middle') {
	      left = targetOffsetLeft - width;
	      if (left < 8 || (left + width > app.width)) {
	        if (left < 8) { left = targetOffsetLeft + targetWidth; }
	        if (left + width > app.width) { left = app.width - width - 8; }
	      }
	    }

	    // Apply Styles
	    $el.css({ top: (top + "px"), left: (left + "px") });
	  };

	  Tooltip.prototype.show = function show (aroundEl) {
	    var tooltip = this;
	    var app = tooltip.app;
	    var $el = tooltip.$el;
	    var $targetEl = tooltip.$targetEl;
	    app.root.append($el);
	    tooltip.position(aroundEl);
	    var $aroundEl = $(aroundEl);
	    tooltip.visible = true;
	    tooltip.opened = true;
	    $targetEl.trigger('tooltip:show', tooltip);
	    $el.trigger('tooltip:show', tooltip);
	    if ($aroundEl.length && $aroundEl[0] !== $targetEl[0]) {
	      $aroundEl.trigger('tooltip:show', tooltip);
	    }
	    tooltip.emit('local::show tooltipShow', tooltip);
	    $el.removeClass('tooltip-out').addClass('tooltip-in');
	    return tooltip;
	  };

	  Tooltip.prototype.hide = function hide () {
	    var tooltip = this;
	    var $el = tooltip.$el;
	    var $targetEl = tooltip.$targetEl;
	    tooltip.visible = false;
	    tooltip.opened = false;
	    $targetEl.trigger('tooltip:hide', tooltip);
	    $el.trigger('tooltip:hide', tooltip);
	    tooltip.emit('local::hide tooltipHide', tooltip);
	    $el.addClass('tooltip-out').removeClass('tooltip-in');
	    return tooltip;
	  };

	  Tooltip.prototype.render = function render () {
	    var tooltip = this;
	    if (tooltip.params.render) { return tooltip.params.render.call(tooltip, tooltip); }
	    var ref = tooltip.params;
	    var cssClass = ref.cssClass;
	    var text = ref.text;
	    return ("\n      <div class=\"tooltip " + (cssClass || '') + "\">\n        <div class=\"tooltip-content\">" + (text || '') + "</div>\n      </div>\n    ").trim();
	  };

	  Tooltip.prototype.setText = function setText (newText) {
	    var tooltip = this;
	    if (typeof newText === 'undefined') {
	      return tooltip;
	    }
	    tooltip.params.text = newText;
	    tooltip.text = newText;
	    if (tooltip.$el) {
	      tooltip.$el.children('.tooltip-content').html(newText);
	    }
	    if (tooltip.opened) {
	      tooltip.position();
	    }
	    return tooltip;
	  };

	  Tooltip.prototype.init = function init () {
	    var tooltip = this;
	    tooltip.attachEvents();
	  };

	  Tooltip.prototype.destroy = function destroy () {
	    var tooltip = this;
	    if (!tooltip.$targetEl || tooltip.destroyed) { return; }
	    tooltip.$targetEl.trigger('tooltip:beforedestroy', tooltip);
	    tooltip.emit('local::beforeDestroy tooltipBeforeDestroy', tooltip);
	    tooltip.$el.remove();
	    delete tooltip.$targetEl[0].f7Tooltip;
	    tooltip.detachEvents();
	    Utils.deleteProps(tooltip);
	    tooltip.destroyed = true;
	  };

	  return Tooltip;
	}(Framework7Class));

	var Tooltip$1 = {
	  name: 'tooltip',
	  static: {
	    Tooltip: Tooltip,
	  },
	  create: function create() {
	    var app = this;
	    app.tooltip = ConstructorMethods({
	      defaultSelector: '.tooltip',
	      constructor: Tooltip,
	      app: app,
	      domProp: 'f7Tooltip',
	    });
	    app.tooltip.show = function show(el) {
	      var $el = $(el);
	      if ($el.length === 0) { return undefined; }
	      var tooltip = $el[0].f7Tooltip;
	      if (!tooltip) { return undefined; }
	      tooltip.show($el[0]);
	      return tooltip;
	    };
	    app.tooltip.hide = function hide(el) {
	      var $el = $(el);
	      if ($el.length === 0) { return undefined; }
	      var tooltip = $el[0].f7Tooltip;
	      if (!tooltip) { return undefined; }
	      tooltip.hide();
	      return tooltip;
	    };
	    app.tooltip.setText = function text(el, newText) {
	      var $el = $(el);
	      if ($el.length === 0) { return undefined; }
	      var tooltip = $el[0].f7Tooltip;
	      if (!tooltip) { return undefined; }
	      tooltip.setText(newText);
	      return tooltip;
	    };
	  },
	  params: {
	    tooltip: {
	      targetEl: null,
	      text: null,
	      cssClass: null,
	      render: null,
	    },
	  },
	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $(tabEl).find('.tooltip-init').each(function (index, el) {
	        var text = $(el).attr('data-tooltip');
	        if (!text) { return; }
	        app.tooltip.create({ targetEl: el, text: text });
	      });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      $(tabEl).find('.tooltip-init').each(function (index, el) {
	        if (el.f7Tooltip) { el.f7Tooltip.destroy(); }
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.tooltip-init').each(function (index, el) {
	        var text = $(el).attr('data-tooltip');
	        if (!text) { return; }
	        app.tooltip.create({ targetEl: el, text: text });
	      });
	      if (app.theme === 'ios' && page.view && page.view.router.separateNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
	        page.$navbarEl.find('.tooltip-init').each(function (index, el) {
	          var text = $(el).attr('data-tooltip');
	          if (!text) { return; }
	          app.tooltip.create({ targetEl: el, text: text });
	        });
	      }
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.tooltip-init').each(function (index, el) {
	        if (el.f7Tooltip) { el.f7Tooltip.destroy(); }
	      });
	      if (app.theme === 'ios' && page.view && page.view.router.separateNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
	        page.$navbarEl.find('.tooltip-init').each(function (index, el) {
	          if (el.f7Tooltip) { el.f7Tooltip.destroy(); }
	        });
	      }
	    },
	  },
	  vnode: {
	    'tooltip-init': {
	      insert: function insert(vnode) {
	        var app = this;
	        var el = vnode.elm;
	        var text = $(el).attr('data-tooltip');
	        if (!text) { return; }
	        app.tooltip.create({ targetEl: el, text: text });
	      },
	      destroy: function destroy(vnode) {
	        var el = vnode.elm;
	        if (el.f7Tooltip) { el.f7Tooltip.destroy(); }
	      },
	    },
	  },
	};

	/* eslint no-nested-ternary: off */

	var Gauge = /*@__PURE__*/(function (Framework7Class) {
	  function Gauge(app, params) {
	    if ( params === void 0 ) params = {};

	    // Extends with open/close Modal methods;
	    Framework7Class.call(this, params, app);

	    var gauge = this;

	    var defaults = Utils.extend({}, app.params.gauge);

	    // Extend defaults with modules params
	    gauge.useModulesParams(defaults);

	    gauge.params = Utils.extend(defaults, params);

	    var ref = gauge.params;
	    var el = ref.el;
	    if (!el) { return gauge; }

	    var $el = $(el);
	    if ($el.length === 0) { return gauge; }

	    if ($el[0].f7Gauge) { return $el[0].f7Gauge; }

	    Utils.extend(gauge, {
	      app: app,
	      $el: $el,
	      el: $el && $el[0],
	    });

	    $el[0].f7Gauge = gauge;

	    // Install Modules
	    gauge.useModules();

	    gauge.init();

	    return gauge;
	  }

	  if ( Framework7Class ) Gauge.__proto__ = Framework7Class;
	  Gauge.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  Gauge.prototype.constructor = Gauge;

	  Gauge.prototype.calcRadius = function calcRadius () {
	    var gauge = this;
	    var ref = gauge.params;
	    var size = ref.size;
	    var borderWidth = ref.borderWidth;
	    return (size / 2) - (borderWidth / 2);
	  };

	  Gauge.prototype.calcBorderLength = function calcBorderLength () {
	    var gauge = this;
	    var radius = gauge.calcRadius();
	    return 2 * Math.PI * radius;
	  };

	  Gauge.prototype.render = function render () {
	    var gauge = this;
	    if (gauge.params.render) { return gauge.params.render.call(gauge, gauge); }

	    var ref = gauge.params;
	    var type = ref.type;
	    var value = ref.value;
	    var size = ref.size;
	    var bgColor = ref.bgColor;
	    var borderBgColor = ref.borderBgColor;
	    var borderColor = ref.borderColor;
	    var borderWidth = ref.borderWidth;
	    var valueText = ref.valueText;
	    var valueTextColor = ref.valueTextColor;
	    var valueFontSize = ref.valueFontSize;
	    var valueFontWeight = ref.valueFontWeight;
	    var labelText = ref.labelText;
	    var labelTextColor = ref.labelTextColor;
	    var labelFontSize = ref.labelFontSize;
	    var labelFontWeight = ref.labelFontWeight;

	    var semiCircle = type === 'semicircle';
	    var radius = gauge.calcRadius();
	    var length = gauge.calcBorderLength();
	    var progress = Math.max(Math.min(value, 1), 0);

	    return ("\n      <svg class=\"gauge-svg\" width=\"" + size + "px\" height=\"" + (semiCircle ? size / 2 : size) + "px\" viewBox=\"0 0 " + size + " " + (semiCircle ? size / 2 : size) + "\">\n        " + (semiCircle ? ("\n          <path\n            class=\"gauge-back-semi\"\n            d=\"M" + (size - (borderWidth / 2)) + "," + (size / 2) + " a1,1 0 0,0 -" + (size - borderWidth) + ",0\"\n            stroke=\"" + borderBgColor + "\"\n            stroke-width=\"" + borderWidth + "\"\n            fill=\"" + (bgColor || 'none') + "\"\n          />\n          <path\n            class=\"gauge-front-semi\"\n            d=\"M" + (size - (borderWidth / 2)) + "," + (size / 2) + " a1,1 0 0,0 -" + (size - borderWidth) + ",0\"\n            stroke=\"" + borderColor + "\"\n            stroke-width=\"" + borderWidth + "\"\n            stroke-dasharray=\"" + (length / 2) + "\"\n            stroke-dashoffset=\"" + ((length / 2) * (1 + progress)) + "\"\n            fill=\"" + (borderBgColor ? 'none' : (bgColor || 'none')) + "\"\n          />\n        ") : ("\n          " + (borderBgColor ? ("\n            <circle\n              class=\"gauge-back-circle\"\n              stroke=\"" + borderBgColor + "\"\n              stroke-width=\"" + borderWidth + "\"\n              fill=\"" + (bgColor || 'none') + "\"\n              cx=\"" + (size / 2) + "\"\n              cy=\"" + (size / 2) + "\"\n              r=\"" + radius + "\"\n            ></circle>\n          ") : '') + "\n          <circle\n            class=\"gauge-front-circle\"\n            transform=\"" + ("rotate(-90 " + (size / 2) + " " + (size / 2) + ")") + "\"\n            stroke=\"" + borderColor + "\"\n            stroke-width=\"" + borderWidth + "\"\n            stroke-dasharray=\"" + length + "\"\n            stroke-dashoffset=\"" + (length * (1 - progress)) + "\"\n            fill=\"" + (borderBgColor ? 'none' : bgColor || 'none') + "\"\n            cx=\"" + (size / 2) + "\"\n            cy=\"" + (size / 2) + "\"\n            r=\"" + radius + "\"\n          ></circle>\n        ")) + "\n        " + (valueText ? ("\n          <text\n            class=\"gauge-value-text\"\n            x=\"50%\"\n            y=\"" + (semiCircle ? '100%' : '50%') + "\"\n            font-weight=\"" + valueFontWeight + "\"\n            font-size=\"" + valueFontSize + "\"\n            fill=\"" + valueTextColor + "\"\n            dy=\"" + (semiCircle ? (labelText ? -labelFontSize - 15 : -5) : 0) + "\"\n            text-anchor=\"middle\"\n            dominant-baseline=\"" + (!semiCircle && 'middle') + "\"\n          >" + valueText + "</text>\n        ") : '') + "\n        " + (labelText ? ("\n          <text\n            class=\"gauge-label-text\"\n            x=\"50%\"\n            y=\"" + (semiCircle ? '100%' : '50%') + "\"\n            font-weight=\"" + labelFontWeight + "\"\n            font-size=\"" + labelFontSize + "\"\n            fill=\"" + labelTextColor + "\"\n            dy=\"" + (semiCircle ? -5 : (valueText ? ((valueFontSize / 2) + 10) : 0)) + "\"\n            text-anchor=\"middle\"\n            dominant-baseline=\"" + (!semiCircle && 'middle') + "\"\n          >" + labelText + "</text>\n        ") : '') + "\n      </svg>\n    ").trim();
	  };

	  Gauge.prototype.update = function update (newParams) {
	    if ( newParams === void 0 ) newParams = {};

	    var gauge = this;
	    var params = gauge.params;
	    var $gaugeSvgEl = gauge.$gaugeSvgEl;

	    Object.keys(newParams).forEach(function (param) {
	      if (typeof newParams[param] !== 'undefined') {
	        params[param] = newParams[param];
	      }
	    });
	    if ($gaugeSvgEl.length === 0) { return gauge; }

	    var value = params.value;
	    var size = params.size;
	    var bgColor = params.bgColor;
	    var borderBgColor = params.borderBgColor;
	    var borderColor = params.borderColor;
	    var borderWidth = params.borderWidth;
	    var valueText = params.valueText;
	    var valueTextColor = params.valueTextColor;
	    var valueFontSize = params.valueFontSize;
	    var valueFontWeight = params.valueFontWeight;
	    var labelText = params.labelText;
	    var labelTextColor = params.labelTextColor;
	    var labelFontSize = params.labelFontSize;
	    var labelFontWeight = params.labelFontWeight;

	    var length = gauge.calcBorderLength();
	    var progress = Math.max(Math.min(value, 1), 0);
	    var radius = gauge.calcRadius();
	    var semiCircle = params.type === 'semicircle';

	    var svgAttrs = {
	      width: (size + "px"),
	      height: ((semiCircle ? size / 2 : size) + "px"),
	      viewBox: ("0 0 " + size + " " + (semiCircle ? size / 2 : size)),
	    };
	    Object.keys(svgAttrs).forEach(function (attr) {
	      $gaugeSvgEl.attr(attr, svgAttrs[attr]);
	    });
	    if (semiCircle) {
	      var backAttrs = {
	        d: ("M" + (size - (borderWidth / 2)) + "," + (size / 2) + " a1,1 0 0,0 -" + (size - borderWidth) + ",0"),
	        stroke: borderBgColor,
	        'stroke-width': borderWidth,
	        fill: bgColor || 'none',
	      };
	      var frontAttrs = {
	        d: ("M" + (size - (borderWidth / 2)) + "," + (size / 2) + " a1,1 0 0,0 -" + (size - borderWidth) + ",0"),
	        stroke: borderColor,
	        'stroke-width': borderWidth,
	        'stroke-dasharray': length / 2,
	        'stroke-dashoffset': (length / 2) * (progress - 1),
	        fill: borderBgColor ? 'none' : (bgColor || 'none'),
	      };
	      Object.keys(backAttrs).forEach(function (attr) {
	        $gaugeSvgEl.find('.gauge-back-semi').attr(attr, backAttrs[attr]);
	      });
	      Object.keys(frontAttrs).forEach(function (attr) {
	        $gaugeSvgEl.find('.gauge-front-semi').attr(attr, frontAttrs[attr]);
	      });
	    } else {
	      var backAttrs$1 = {
	        stroke: borderBgColor,
	        'stroke-width': borderWidth,
	        fill: bgColor || 'none',
	        cx: size / 2,
	        cy: size / 2,
	        r: radius,
	      };
	      var frontAttrs$1 = {
	        transform: ("rotate(-90 " + (size / 2) + " " + (size / 2) + ")"),
	        stroke: borderColor,
	        'stroke-width': borderWidth,
	        'stroke-dasharray': length,
	        'stroke-dashoffset': length * (1 - progress),
	        fill: borderBgColor ? 'none' : bgColor || 'none',
	        cx: size / 2,
	        cy: size / 2,
	        r: radius,
	      };
	      Object.keys(backAttrs$1).forEach(function (attr) {
	        $gaugeSvgEl.find('.gauge-back-circle').attr(attr, backAttrs$1[attr]);
	      });
	      Object.keys(frontAttrs$1).forEach(function (attr) {
	        $gaugeSvgEl.find('.gauge-front-circle').attr(attr, frontAttrs$1[attr]);
	      });
	    }
	    if (valueText) {
	      if (!$gaugeSvgEl.find('.gauge-value-text').length) {
	        $gaugeSvgEl.append('<text class="gauge-value-text"></text>');
	      }
	      var textAttrs = {
	        x: '50%',
	        y: semiCircle ? '100%' : '50%',
	        'font-weight': valueFontWeight,
	        'font-size': valueFontSize,
	        fill: valueTextColor,
	        dy: semiCircle ? (labelText ? -labelFontSize - 15 : -5) : 0,
	        'text-anchor': 'middle',
	        'dominant-baseline': !semiCircle && 'middle',
	      };
	      Object.keys(textAttrs).forEach(function (attr) {
	        $gaugeSvgEl.find('.gauge-value-text').attr(attr, textAttrs[attr]);
	      });
	      $gaugeSvgEl.find('.gauge-value-text').text(valueText);
	    } else {
	      $gaugeSvgEl.find('.gauge-value-text').remove();
	    }
	    if (labelText) {
	      if (!$gaugeSvgEl.find('.gauge-label-text').length) {
	        $gaugeSvgEl.append('<text class="gauge-label-text"></text>');
	      }
	      var labelAttrs = {
	        x: '50%',
	        y: semiCircle ? '100%' : '50%',
	        'font-weight': labelFontWeight,
	        'font-size': labelFontSize,
	        fill: labelTextColor,
	        dy: semiCircle ? -5 : (valueText ? ((valueFontSize / 2) + 10) : 0),
	        'text-anchor': 'middle',
	        'dominant-baseline': !semiCircle && 'middle',
	      };
	      Object.keys(labelAttrs).forEach(function (attr) {
	        $gaugeSvgEl.find('.gauge-label-text').attr(attr, labelAttrs[attr]);
	      });
	      $gaugeSvgEl.find('.gauge-label-text').text(labelText);
	    } else {
	      $gaugeSvgEl.find('.gauge-label-text').remove();
	    }
	    return gauge;
	  };

	  Gauge.prototype.init = function init () {
	    var gauge = this;
	    var $gaugeSvgEl = $(gauge.render()).eq(0);
	    $gaugeSvgEl.f7Gauge = gauge;
	    Utils.extend(gauge, {
	      $gaugeSvgEl: $gaugeSvgEl,
	      gaugeSvgEl: $gaugeSvgEl && $gaugeSvgEl[0],
	    });
	    gauge.$el.append($gaugeSvgEl);
	    return gauge;
	  };

	  Gauge.prototype.destroy = function destroy () {
	    var gauge = this;
	    if (!gauge.$el || gauge.destroyed) { return; }
	    gauge.$el.trigger('gauge:beforedestroy', gauge);
	    gauge.emit('local::beforeDestroy gaugeBeforeDestroy', gauge);
	    gauge.$gaugeSvgEl.remove();
	    delete gauge.$el[0].f7Gauge;
	    Utils.deleteProps(gauge);
	    gauge.destroyed = true;
	  };

	  return Gauge;
	}(Framework7Class));

	var Gauge$1 = {
	  name: 'gauge',
	  static: {
	    Gauge: Gauge,
	  },
	  create: function create() {
	    var app = this;
	    app.gauge = ConstructorMethods({
	      defaultSelector: '.gauge',
	      constructor: Gauge,
	      app: app,
	      domProp: 'f7Gauge',
	    });
	    app.gauge.update = function update(el, newParams) {
	      var $el = $(el);
	      if ($el.length === 0) { return undefined; }
	      var gauge = app.gauge.get(el);
	      if (!gauge) { return undefined; }
	      gauge.update(newParams);
	      return gauge;
	    };
	  },
	  params: {
	    gauge: {
	      el: null,
	      type: 'circle',
	      value: 0,
	      size: 200,
	      bgColor: 'transparent',
	      borderBgColor: '#eeeeee',
	      borderColor: '#000000',
	      borderWidth: 10,
	      valueText: null,
	      valueTextColor: '#000000',
	      valueFontSize: 31,
	      valueFontWeight: 500,
	      labelText: null,
	      labelTextColor: '#888888',
	      labelFontSize: 14,
	      labelFontWeight: 400,
	    },
	  },
	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $(tabEl).find('.gauge-init').each(function (index, el) {
	        app.gauge.create(Utils.extend({ el: el }, $(el).dataset() || {}));
	      });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      $(tabEl).find('.gauge-init').each(function (index, el) {
	        if (el.f7Gauge) { el.f7Gauge.destroy(); }
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.gauge-init').each(function (index, el) {
	        app.gauge.create(Utils.extend({ el: el }, $(el).dataset() || {}));
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      page.$el.find('.gauge-init').each(function (index, el) {
	        if (el.f7Gauge) { el.f7Gauge.destroy(); }
	      });
	    },
	  },
	  vnode: {
	    'gauge-init': {
	      insert: function insert(vnode) {
	        var app = this;
	        var el = vnode.elm;
	        app.gauge.create(Utils.extend({ el: el }, $(el).dataset() || {}));
	      },
	      destroy: function destroy(vnode) {
	        var el = vnode.elm;
	        if (el.f7Gauge) { el.f7Gauge.destroy(); }
	      },
	    },
	  },
	};

	var Skeleton = {
	  name: 'skeleton',
	};

	var Menu = {
	  open: function open(el) {
	    if ( el === void 0 ) el = '.menu-item-dropdown';

	    var app = this;
	    if (!el) { return; }
	    var $el = $(el).closest('.menu-item-dropdown');
	    if (!$el.length) { return; }
	    var $menuEl = $el.closest('.menu').eq(0);
	    if ($menuEl.length) {
	      var zIndex = $menuEl.css('z-index');
	      var originalZIndex = $menuEl[0].style.zIndex;
	      $menuEl.css('z-index', parseInt(zIndex || 0, 0) + 1);
	      $menuEl[0].f7MenuZIndex = originalZIndex;
	    }
	    $el.eq(0).addClass('menu-item-dropdown-opened').trigger('menu:opened');
	    app.emit('menuOpened', $el.eq(0)[0]);
	  },
	  close: function close(el) {
	    if ( el === void 0 ) el = '.menu-item-dropdown-opened';

	    var app = this;
	    if (!el) { return; }
	    var $el = $(el).closest('.menu-item-dropdown-opened');
	    if (!$el.length) { return; }
	    var $menuEl = $el.closest('.menu').eq(0);
	    if ($menuEl.length) {
	      var zIndex = $menuEl[0].f7MenuZIndex;
	      $menuEl.css('z-index', zIndex);
	      delete $menuEl[0].f7MenuZIndex;
	    }
	    $el.eq(0).removeClass('menu-item-dropdown-opened').trigger('menu:closed');
	    app.emit('menuClosed', $el.eq(0)[0]);
	  },
	};

	var Menu$1 = {
	  name: 'menu',
	  create: function create() {
	    var app = this;
	    app.menu = {
	      open: Menu.open.bind(app),
	      close: Menu.close.bind(app),
	    };
	  },
	  on: {
	    click: function click(e) {
	      var app = this;
	      var openedMenus = $('.menu-item-dropdown-opened');
	      if (!openedMenus.length) { return; }
	      openedMenus.each(function (index, el) {
	        if (!$(e.target).closest('.menu-item-dropdown-opened').length) {
	          app.menu.close(el);
	        }
	      });
	    },
	  },
	  clicks: {
	    '.menu-item-dropdown': function onClick($clickedEl, dataset, e) {
	      var app = this;
	      if ($clickedEl.hasClass('menu-item-dropdown-opened')) {
	        if ($(e.target).closest('.menu-dropdown').length) { return; }
	        app.menu.close($clickedEl);
	      } else {
	        app.menu.open($clickedEl);
	      }
	    },
	    '.menu-close': function onClick() {
	      var app = this;
	      app.menu.close();
	    },
	  },
	};

	var moduleAlphaSlider = {
	  render: function render(self) {
	    var ref = self.params;
	    var sliderLabel = ref.sliderLabel;
	    var sliderValue = ref.sliderValue;
	    var sliderValueEditable = ref.sliderValueEditable;
	    var alphaLabelText = ref.alphaLabelText;
	    return ("\n      <div class=\"color-picker-module color-picker-module-alpha-slider\">\n        <div class=\"color-picker-slider-wrap\">\n          " + (sliderLabel ? ("\n            <div class=\"color-picker-slider-label\">" + alphaLabelText + "</div>\n          ") : '') + "\n          <div class=\"range-slider color-picker-slider color-picker-slider-alpha\"></div>\n          " + (sliderValue ? ("\n            <div class=\"color-picker-slider-value\">\n              " + (sliderValueEditable ? "\n                <input type=\"number\" step=\"0.01\" min=\"0\" max=\"1\" class=\"color-picker-value-alpha\">\n              " : "\n                <span class=\"color-picker-value-alpha\"></span>\n              ") + "\n            </div>\n          ") : '') + "\n        </div>\n      </div>\n    ");
	  },
	  init: function init(self) {
	    self.alphaRangeSlider = self.app.range.create({
	      el: self.$el.find('.color-picker-slider-alpha'),
	      min: 0,
	      max: 1,
	      step: 0.01,
	      value: 1,
	      on: {
	        change: function change(range, value) {
	          var alpha = Math.floor(value * 100) / 100;
	          self.setValue({ alpha: alpha });
	        },
	      },
	    });
	    function handleInputChange(e) {
	      var alpha = self.value.alpha;
	      var value = parseFloat(e.target.value);
	      if (Number.isNaN(value)) {
	        e.target.value = alpha;
	        return;
	      }
	      value = Math.max(0, Math.min(1, value));
	      self.setValue({ alpha: value });
	    }

	    self.$el.on('change', '.color-picker-module-alpha-slider input', handleInputChange);

	    self.destroyAlphaSliderEvents = function destroyAlphaSliderEvents() {
	      self.$el.off('change', '.color-picker-module-alpha-slider input', handleInputChange);
	    };
	  },
	  update: function update(self) {
	    var value = self.value;
	    var ref = self.params;
	    var sliderValue = ref.sliderValue;
	    var sliderValueEditable = ref.sliderValueEditable;

	    var alpha = value.alpha;
	    self.alphaRangeSlider.value = alpha;
	    self.alphaRangeSlider.layout();
	    if (sliderValue && sliderValueEditable) {
	      self.$el.find('input.color-picker-value-alpha').val(alpha);
	    } else {
	      self.$el.find('span.color-picker-value-alpha').text(alpha);
	    }
	  },
	  destroy: function destroy(self) {
	    if (self.alphaRangeSlider && self.alphaRangeSlider.destroy) {
	      self.alphaRangeSlider.destroy();
	    }
	    delete self.alphaRangeSlider;

	    if (self.destroyAlphaSliderEvents) { self.destroyAlphaSliderEvents(); }
	    delete self.destroyAlphaSliderEvents;
	  },
	};

	var moduleCurrentColor = {
	  render: function render() {
	    return "\n      <div class=\"color-picker-module color-picker-module-current-color\">\n        <div class=\"color-picker-current-color\"></div>\n      </div>\n    ";
	  },
	  update: function update(self) {
	    self.$el.find('.color-picker-module-current-color .color-picker-current-color').css(
	      'background-color',
	      self.value.hex
	    );
	  },
	};

	var moduleHex = {
	  render: function render(self) {
	    var ref = self.params;
	    var hexLabel = ref.hexLabel;
	    var hexLabelText = ref.hexLabelText;
	    var hexValueEditable = ref.hexValueEditable;
	    return ("\n      <div class=\"color-picker-module color-picker-module-hex\">\n        <div class=\"color-picker-hex-wrap\">\n          " + (hexLabel ? ("\n            <div class=\"color-picker-hex-label\">" + hexLabelText + "</div>\n          ") : '') + "\n          <div class=\"color-picker-hex-value\">\n            " + (hexValueEditable ? "\n              <input type=\"text\" class=\"color-picker-value-hex\">\n            " : "\n              <span class=\"color-picker-value-hex\"></span>\n            ") + "\n          </div>\n        </div>\n      </div>\n    ");
	  },
	  init: function init(self) {
	    function handleInputChange(e) {
	      var hex = self.value.hex;
	      var value = e.target.value.replace(/#/g, '');
	      if (Number.isNaN(value) || !value || (value.length !== 3 && value.length !== 6)) {
	        e.target.value = hex;
	        return;
	      }
	      var min = 0;
	      var current = parseInt(value, 16);
	      var max = parseInt('ffffff', 16); // eslint-disable-line
	      if (current > max) {
	        value = 'fff';
	      }
	      if (current < min) {
	        value = '000';
	      }
	      self.setValue({ hex: value });
	    }

	    self.$el.on('change', '.color-picker-module-hex input', handleInputChange);

	    self.destroyHexEvents = function destroyHexEvents() {
	      self.$el.off('change', '.color-picker-module-hex input', handleInputChange);
	    };
	  },
	  update: function update(self) {
	    var value = self.value;

	    var ref = self.params;
	    var hexValueEditable = ref.hexValueEditable;

	    var hex = value.hex;
	    if (hexValueEditable) {
	      self.$el.find('input.color-picker-value-hex').val(hex);
	    } else {
	      self.$el.find('span.color-picker-value-hex').text(hex);
	    }
	  },
	  destroy: function destroy(self) {
	    if (self.destroyHexEvents) { self.destroyHexEvents(); }
	    delete self.destroyHexEvents;
	  },
	};

	var moduleHsbSliders = {
	  render: function render(self) {
	    var ref = self.params;
	    var sliderLabel = ref.sliderLabel;
	    var sliderValue = ref.sliderValue;
	    var sliderValueEditable = ref.sliderValueEditable;
	    var hueLabelText = ref.hueLabelText;
	    var saturationLabelText = ref.saturationLabelText;
	    var brightnessLabelText = ref.brightnessLabelText;
	    return ("\n      <div class=\"color-picker-module color-picker-module-hsb-sliders\">\n        <div class=\"color-picker-slider-wrap\">\n          " + (sliderLabel ? ("\n            <div class=\"color-picker-slider-label\">" + hueLabelText + "</div>\n          ") : '') + "\n          <div class=\"range-slider color-picker-slider color-picker-slider-hue\"></div>\n          " + (sliderValue ? ("\n            <div class=\"color-picker-slider-value\">\n              " + (sliderValueEditable ? "\n                <input type=\"number\" step=\"0.1\" min=\"0\" max=\"360\" class=\"color-picker-value-hue\" data-color-index=\"0\">\n              " : "\n                <span class=\"color-picker-value-hue\"></span>\n              ") + "\n            </div>\n          ") : '') + "\n        </div>\n        <div class=\"color-picker-slider-wrap\">\n          " + (sliderLabel ? ("\n            <div class=\"color-picker-slider-label\">" + saturationLabelText + "</div>\n          ") : '') + "\n          <div class=\"range-slider color-picker-slider color-picker-slider-saturation\"></div>\n          " + (sliderValue ? ("\n            <div class=\"color-picker-slider-value\">\n              " + (sliderValueEditable ? "\n                <input type=\"number\" step=\"0.1\" min=\"0\" max=\"100\" class=\"color-picker-value-saturation\" data-color-index=\"1\">\n              " : "\n                <span class=\"color-picker-value-saturation\"></span>\n              ") + "\n            </div>\n          ") : '') + "\n        </div>\n        <div class=\"color-picker-slider-wrap\">\n          " + (sliderLabel ? ("\n            <div class=\"color-picker-slider-label\">" + brightnessLabelText + "</div>\n          ") : '') + "\n          <div class=\"range-slider color-picker-slider color-picker-slider-brightness\"></div>\n          " + (sliderValue ? ("\n            <div class=\"color-picker-slider-value\">\n              " + (sliderValueEditable ? "\n                <input type=\"number\" step=\"0.1\" min=\"0\" max=\"100\" class=\"color-picker-value-brightness\" data-color-index=\"2\">\n              " : "\n                <span class=\"color-picker-value-brightness\"></span>\n              ") + "\n            </div>\n          ") : '') + "\n        </div>\n      </div>\n    ");
	  },
	  init: function init(self) {
	    self.hueRangeSlider = self.app.range.create({
	      el: self.$el.find('.color-picker-slider-hue'),
	      min: 0,
	      max: 360,
	      step: 0.1,
	      value: 0,
	      on: {
	        change: function change(range, value) {
	          self.setValue({ hue: value });
	        },
	      },
	    });
	    self.saturationRangeSlider = self.app.range.create({
	      el: self.$el.find('.color-picker-slider-saturation'),
	      min: 0,
	      max: 1,
	      step: 0.001,
	      value: 0,
	      on: {
	        change: function change(range, value) {
	          var s = Math.floor(value * 1000) / 1000;
	          self.setValue({ hsb: [self.value.hsb[0], s, self.value.hsb[2]] });
	        },
	      },
	    });
	    self.brightnessRangeSlider = self.app.range.create({
	      el: self.$el.find('.color-picker-slider-brightness'),
	      min: 0,
	      max: 1,
	      step: 0.001,
	      value: 0,
	      on: {
	        change: function change(range, value) {
	          var b = Math.floor(value * 1000) / 1000;
	          self.setValue({ hsb: [self.value.hsb[0], self.value.hsb[1], b] });
	        },
	      },
	    });

	    function handleInputChange(e) {
	      var hsb = [].concat( self.value.hsb );
	      var index = parseInt($(e.target).attr('data-color-index'), 10);
	      var value = parseFloat(e.target.value);
	      if (Number.isNaN(value)) {
	        e.target.value = hsb[index];
	        return;
	      }
	      if (index === 0) {
	        value = Math.max(0, Math.min(360, value));
	      } else {
	        value = Math.max(0, Math.min(100, value)) / 100;
	      }

	      hsb[index] = value;
	      self.setValue({ hsb: hsb });
	    }

	    self.$el.on('change', '.color-picker-module-hsb-sliders input', handleInputChange);

	    self.destroyHsbSlidersEvents = function destroyHsbSlidersEvents() {
	      self.$el.off('change', '.color-picker-module-hsb-sliders input', handleInputChange);
	    };
	  },
	  update: function update(self) {
	    var app = self.app;
	    var value = self.value;
	    var ref = self.params;
	    var sliderValue = ref.sliderValue;
	    var sliderValueEditable = ref.sliderValueEditable;

	    var hsb = value.hsb;
	    var hue = value.hue;

	    self.hueRangeSlider.value = hue;
	    self.saturationRangeSlider.value = hsb[1];
	    self.brightnessRangeSlider.value = hsb[2];

	    self.hueRangeSlider.layout();
	    self.saturationRangeSlider.layout();
	    self.brightnessRangeSlider.layout();

	    var hslCurrent = Utils.colorHsbToHsl(hsb[0], hsb[1], 1);
	    var hslLeft = Utils.colorHsbToHsl(hsb[0], 0, 1);
	    var hslRight = Utils.colorHsbToHsl(hsb[0], 1, 1);
	    var brightness = hsb[2];

	    self.hueRangeSlider.$el[0].style.setProperty(
	      '--f7-range-knob-color',
	      ("hsl(" + hue + ", 100%, 50%)")
	    );
	    self.saturationRangeSlider.$el[0].style.setProperty(
	      '--f7-range-knob-color',
	      ("hsl(" + (hslCurrent[0]) + ", " + (hslCurrent[1] * 100) + "%, " + (hslCurrent[2] * 100) + "%)")
	    );
	    self.brightnessRangeSlider.$el[0].style.setProperty(
	      '--f7-range-knob-color',
	      ("rgb(" + (brightness * 255) + ", " + (brightness * 255) + ", " + (brightness * 255) + ")")
	    );
	    self.saturationRangeSlider.$el.find('.range-bar').css(
	      'background-image',
	      ("linear-gradient(" + (app.rtl ? 'to left' : 'to right') + ", hsl(" + (hslLeft[0]) + ", " + (hslLeft[1] * 100) + "%, " + (hslLeft[2] * 100) + "%), hsl(" + (hslRight[0]) + ", " + (hslRight[1] * 100) + "%, " + (hslRight[2] * 100) + "%))")
	    );

	    if (sliderValue && sliderValueEditable) {
	      self.$el.find('input.color-picker-value-hue').val(("" + hue));
	      self.$el.find('input.color-picker-value-saturation').val(("" + (hsb[1] * 1000 / 10)));
	      self.$el.find('input.color-picker-value-brightness').val(("" + (hsb[2] * 1000 / 10)));
	    } else if (sliderValue) {
	      self.$el.find('span.color-picker-value-hue').text(("" + hue));
	      self.$el.find('span.color-picker-value-saturation').text(("" + (hsb[1] * 1000 / 10)));
	      self.$el.find('span.color-picker-value-brightness').text(("" + (hsb[2] * 1000 / 10)));
	    }
	  },
	  destroy: function destroy(self) {
	    if (self.hueRangeSlider && self.hueRangeSlider.destroy) {
	      self.hueRangeSlider.destroy();
	    }
	    if (self.saturationRangeSlider && self.saturationRangeSlider.destroy) {
	      self.saturationRangeSlider.destroy();
	    }
	    if (self.brightnessRangeSlider && self.brightnessRangeSlider.destroy) {
	      self.brightnessRangeSlider.destroy();
	    }

	    delete self.hueRangeSlider;
	    delete self.saturationRangeSlider;
	    delete self.brightnessRangeSlider;

	    if (self.destroyHsbSlidersEvents) { self.destroyHsbSlidersEvents(); }
	    delete self.destroyHsbSlidersEvents;
	  },
	};

	var moduleHueSlider = {
	  render: function render(self) {
	    var ref = self.params;
	    var sliderLabel = ref.sliderLabel;
	    var sliderValue = ref.sliderValue;
	    var sliderValueEditable = ref.sliderValueEditable;
	    var hueLabelText = ref.hueLabelText;
	    return ("\n      <div class=\"color-picker-module color-picker-module-hue-slider\">\n        <div class=\"color-picker-slider-wrap\">\n          " + (sliderLabel ? ("\n            <div class=\"color-picker-slider-label\">" + hueLabelText + "</div>\n          ") : '') + "\n          <div class=\"range-slider color-picker-slider color-picker-slider-hue\"></div>\n          " + (sliderValue ? ("\n            <div class=\"color-picker-slider-value\">\n              " + (sliderValueEditable ? "\n                <input type=\"number\" step=\"0.1\" min=\"0\" max=\"360\" class=\"color-picker-value-hue\">\n              " : "\n                <span class=\"color-picker-value-hue\"></span>\n              ") + "\n            </div>\n          ") : '') + "\n        </div>\n      </div>\n    ");
	  },
	  init: function init(self) {
	    self.hueRangeSlider = self.app.range.create({
	      el: self.$el.find('.color-picker-slider-hue'),
	      min: 0,
	      max: 360,
	      step: 0.1,
	      value: 0,
	      on: {
	        change: function change(range, value) {
	          self.setValue({ hue: value });
	        },
	      },
	    });
	  },
	  update: function update(self) {
	    var value = self.value;
	    var ref = self.params;
	    var sliderValue = ref.sliderValue;
	    var sliderValueEditable = ref.sliderValueEditable;

	    var hue = value.hue;

	    self.hueRangeSlider.value = hue;
	    self.hueRangeSlider.layout();
	    self.hueRangeSlider.$el[0].style.setProperty(
	      '--f7-range-knob-color',
	      ("hsl(" + hue + ", 100%, 50%)")
	    );
	    if (sliderValue && sliderValueEditable) {
	      self.$el.find('input.color-picker-value-hue').val(("" + hue));
	    } else if (sliderValue) {
	      self.$el.find('span.color-picker-value-hue').text(("" + hue));
	    }
	  },
	  destroy: function destroy(self) {
	    if (self.hueRangeSlider && self.hueRangeSlider.destroy) {
	      self.hueRangeSlider.destroy();
	    }
	    delete self.hueRangeSlider;
	  },
	};

	var moduleBrightnessSlider = {
	  render: function render(self) {
	    var ref = self.params;
	    var sliderLabel = ref.sliderLabel;
	    var sliderValue = ref.sliderValue;
	    var sliderValueEditable = ref.sliderValueEditable;
	    var brightnessLabelText = ref.brightnessLabelText;
	    return ("\n      <div class=\"color-picker-module color-picker-module-brightness-slider\">\n        <div class=\"color-picker-slider-wrap\">\n          " + (sliderLabel ? ("\n            <div class=\"color-picker-slider-label\">" + brightnessLabelText + "</div>\n          ") : '') + "\n          <div class=\"range-slider color-picker-slider color-picker-slider-brightness\"></div>\n          " + (sliderValue ? ("\n            <div class=\"color-picker-slider-value\">\n              " + (sliderValueEditable ? "\n                <input type=\"number\" step=\"0.1\" min=\"0\" max=\"100\" class=\"color-picker-value-brightness\">\n              " : "\n                <span class=\"color-picker-value-brightness\"></span>\n              ") + "\n            </div>\n          ") : '') + "\n        </div>\n      </div>\n    ");
	  },
	  init: function init(self) {
	    self.brightnessRangeSlider = self.app.range.create({
	      el: self.$el.find('.color-picker-slider-brightness'),
	      min: 0,
	      max: 1,
	      step: 0.001,
	      value: 0,
	      on: {
	        change: function change(range, value) {
	          var b = Math.floor(value * 1000) / 1000;
	          self.setValue({ hsb: [self.value.hsb[0], self.value.hsb[1], b] });
	        },
	      },
	    });
	  },
	  update: function update(self) {
	    var value = self.value;
	    var app = self.app;
	    var ref = self.params;
	    var sliderValue = ref.sliderValue;
	    var sliderValueEditable = ref.sliderValueEditable;

	    var hsb = value.hsb;

	    self.brightnessRangeSlider.value = hsb[2];
	    self.brightnessRangeSlider.layout();

	    var hslCurrent = Utils.colorHsbToHsl(hsb[0], hsb[1], hsb[2]);
	    var hslLeft = Utils.colorHsbToHsl(hsb[0], hsb[1], 0);
	    var hslRight = Utils.colorHsbToHsl(hsb[0], hsb[1], 1);

	    self.brightnessRangeSlider.$el[0].style.setProperty(
	      '--f7-range-knob-color',
	      ("hsl(" + (hslCurrent[0]) + ", " + (hslCurrent[1] * 100) + "%, " + (hslCurrent[2] * 100) + "%)")
	    );
	    self.brightnessRangeSlider.$el.find('.range-bar').css(
	      'background-image',
	      ("linear-gradient(" + (app.rtl ? 'to left' : 'to right') + ", hsl(" + (hslLeft[0]) + ", " + (hslLeft[1] * 100) + "%, " + (hslLeft[2] * 100) + "%), hsl(" + (hslRight[0]) + ", " + (hslRight[1] * 100) + "%, " + (hslRight[2] * 100) + "%))")
	    );
	    if (sliderValue && sliderValueEditable) {
	      self.$el.find('input.color-picker-value-brightness').val(("" + (hsb[2] * 1000 / 10)));
	    } else if (sliderValue) {
	      self.$el.find('span.color-picker-value-brightness').text(("" + (hsb[2] * 1000 / 10)));
	    }
	  },
	  destroy: function destroy(self) {
	    if (self.brightnessRangeSlider && self.brightnessRangeSlider.destroy) {
	      self.brightnessRangeSlider.destroy();
	    }
	    delete self.brightnessRangeSlider;
	  },
	};

	/* eslint indent: ["off"] */

	var modulePalette = {
	  render: function render(self) {
	    return ("\n      <div class=\"color-picker-module color-picker-module-palette\">\n        <div class=\"color-picker-palette\">\n          " + (self.params.palette.map(function (p) {
	            if (Array.isArray(p)) {
	              var row = '<div class="color-picker-palette-row">';
	              row += p.map(function (c) { return ("\n                <div class=\"color-picker-palette-value\" data-palette-color=\"" + c + "\" style=\"background-color: " + c + "\"></div>\n              "); }).join('');
	              row += '</div>';
	              return row;
	            }
	            return ("\n              <div class=\"color-picker-palette-value\" data-palette-color=\"" + p + "\" style=\"background-color: " + p + "\"></div>\n            ");
	          }).join('')) + "\n        </div>\n      </div>\n    ");
	  },
	  init: function init(self) {
	    function handlePaletteClick(e) {
	      var hex = $(e.target).attr('data-palette-color');
	      self.setValue({
	        hex: hex,
	      });
	    }

	    self.$el.on('click', '.color-picker-module-palette .color-picker-palette-value', handlePaletteClick);

	    self.destroyPaletteEvents = function destroyPaletteEvents() {
	      self.$el.off('click', '.color-picker-module-hex input', handlePaletteClick);
	    };
	  },
	  destroy: function destroy(self) {
	    if (self.destroyPaletteEvents) {
	      self.destroyPaletteEvents();
	    }
	    delete self.destroyPaletteEvents;
	  },
	};

	var moduleInitialCurrentColors = {
	  render: function render() {
	    return "\n      <div class=\"color-picker-module color-picker-module-initial-current-colors\">\n        <div class=\"color-picker-initial-current-colors\">\n          <div class=\"color-picker-initial-color\"></div>\n          <div class=\"color-picker-current-color\"></div>\n        </div>\n      </div>\n    ";
	  },
	  init: function init(self) {
	    function handleInitialColorClick() {
	      if (self.initialValue) {
	        var ref = self.initialValue;
	        var hex = ref.hex;
	        var alpha = ref.alpha;
	        self.setValue({
	          hex: hex,
	          alpha: alpha,
	        });
	      }
	    }
	    self.$el.on('click', '.color-picker-initial-color', handleInitialColorClick);
	    self.destroyInitialCurrentEvents = function destroyInitialCurrentEvents() {
	      self.$el.off('click', '.color-picker-initial-color', handleInitialColorClick);
	    };
	  },
	  update: function update(self) {
	    self.$el.find('.color-picker-module-initial-current-colors .color-picker-initial-color').css(
	      'background-color',
	      self.initialValue.hex
	    );
	    self.$el.find('.color-picker-module-initial-current-colors .color-picker-current-color').css(
	      'background-color',
	      self.value.hex
	    );
	  },
	  destroy: function destroy(self) {
	    if (self.destroyInitialCurrentEvents) {
	      self.destroyInitialCurrentEvents();
	    }
	    delete self.destroyInitialCurrentEvents;
	  },
	};

	var moduleRgbBars = {
	  render: function render(self) {
	    var ref = self.params;
	    var barLabel = ref.barLabel;
	    var barValue = ref.barValue;
	    var barValueEditable = ref.barValueEditable;
	    var redLabelText = ref.redLabelText;
	    var greenLabelText = ref.greenLabelText;
	    var blueLabelText = ref.blueLabelText;
	    return ("\n      <div class=\"color-picker-module color-picker-module-rgb-bars\">\n        <div class=\"color-picker-bar-wrap\">\n          " + (barLabel ? ("\n            <div class=\"color-picker-bar-label\">" + redLabelText + "</div>\n          ") : '') + "\n          <div class=\"range-slider color-picker-bar color-picker-bar-red\"></div>\n          " + (barValue ? ("\n            <div class=\"color-picker-bar-value\">\n              " + (barValueEditable ? "\n                <input type=\"number\" step=\"1\" min=\"0\" max=\"255\" class=\"color-picker-value-bar-red\" data-color-index=\"0\">\n              " : "\n                <span class=\"color-picker-value-bar-red\"></span>\n              ") + "\n            </div>\n          ") : '') + "\n        </div>\n        <div class=\"color-picker-bar-wrap\">\n          " + (barLabel ? ("\n            <div class=\"color-picker-bar-label\">" + greenLabelText + "</div>\n          ") : '') + "\n          <div class=\"range-slider color-picker-bar color-picker-bar-green\"></div>\n          " + (barValue ? ("\n            <div class=\"color-picker-bar-value\">\n              " + (barValueEditable ? "\n                <input type=\"number\" step=\"1\" min=\"0\" max=\"255\" class=\"color-picker-value-bar-green\" data-color-index=\"1\">\n              " : "\n                <span class=\"color-picker-value-bar-green\"></span>\n              ") + "\n            </div>\n          ") : '') + "\n        </div>\n        <div class=\"color-picker-bar-wrap\">\n          " + (barLabel ? ("\n            <div class=\"color-picker-bar-label\">" + blueLabelText + "</div>\n          ") : '') + "\n          <div class=\"range-slider color-picker-bar color-picker-bar-blue\"></div>\n          " + (barValue ? ("\n            <div class=\"color-picker-bar-value\">\n              " + (barValueEditable ? "\n                <input type=\"number\" step=\"1\" min=\"0\" max=\"255\" class=\"color-picker-value-bar-blue\" data-color-index=\"2\">\n              " : "\n                <span class=\"color-picker-value-bar-blue\"></span>\n              ") + "\n            </div>\n          ") : '') + "\n        </div>\n      </div>\n    ");
	  },
	  init: function init(self) {
	    self.redBar = self.app.range.create({
	      el: self.$el.find('.color-picker-bar-red'),
	      min: 0,
	      max: 255,
	      step: 1,
	      value: 0,
	      vertical: true,
	      on: {
	        change: function change(range, value) {
	          self.setValue({ rgb: [value, self.value.rgb[1], self.value.rgb[2]] });
	        },
	      },
	    });
	    self.greenBar = self.app.range.create({
	      el: self.$el.find('.color-picker-bar-green'),
	      min: 0,
	      max: 255,
	      step: 1,
	      value: 0,
	      vertical: true,
	      on: {
	        change: function change(range, value) {
	          self.setValue({ rgb: [self.value.rgb[0], value, self.value.rgb[2]] });
	        },
	      },
	    });
	    self.blueBar = self.app.range.create({
	      el: self.$el.find('.color-picker-bar-blue'),
	      min: 0,
	      max: 255,
	      step: 1,
	      value: 0,
	      vertical: true,
	      on: {
	        change: function change(range, value) {
	          self.setValue({ rgb: [self.value.rgb[0], self.value.rgb[1], value] });
	        },
	      },
	    });

	    function handleInputChange(e) {
	      var rgb = [].concat( self.value.rgb );
	      var index = parseInt($(e.target).attr('data-color-index'), 10);
	      var value = parseInt(e.target.value, 10);
	      if (Number.isNaN(value)) {
	        e.target.value = rgb[index];
	        return;
	      }
	      value = Math.max(0, Math.min(255, value));
	      rgb[index] = value;
	      self.setValue({ rgb: rgb });
	    }

	    self.$el.on('change', '.color-picker-module-rgb-bars input', handleInputChange);

	    self.destroyRgbBarsEvents = function destroyRgbBarsEvents() {
	      self.$el.off('change', '.color-picker-module-rgb-bars input', handleInputChange);
	    };
	  },
	  update: function update(self) {
	    var value = self.value;
	    var redBar = self.redBar;
	    var greenBar = self.greenBar;
	    var blueBar = self.blueBar;

	    var ref = self.params;
	    var barValue = ref.barValue;
	    var barValueEditable = ref.barValueEditable;

	    var rgb = value.rgb;

	    redBar.value = rgb[0];
	    greenBar.value = rgb[1];
	    blueBar.value = rgb[2];

	    redBar.layout();
	    greenBar.layout();
	    blueBar.layout();

	    redBar.$el.find('.range-bar').css('background-image', ("linear-gradient(to top, rgb(0, " + (rgb[1]) + ", " + (rgb[2]) + "), rgb(255, " + (rgb[1]) + ", " + (rgb[2]) + "))"));
	    greenBar.$el.find('.range-bar').css('background-image', ("linear-gradient(to top, rgb(" + (rgb[0]) + ", 0, " + (rgb[2]) + "), rgb(" + (rgb[0]) + ", 255, " + (rgb[2]) + "))"));
	    blueBar.$el.find('.range-bar').css('background-image', ("linear-gradient(to top, rgb(" + (rgb[0]) + ", " + (rgb[1]) + ", 0), rgb(" + (rgb[0]) + ", " + (rgb[1]) + ", 255))"));

	    if (barValue && barValueEditable) {
	      self.$el.find('input.color-picker-value-bar-red').val(rgb[0]);
	      self.$el.find('input.color-picker-value-bar-green').val(rgb[1]);
	      self.$el.find('input.color-picker-value-bar-blue').val(rgb[2]);
	    } else if (barValue) {
	      self.$el.find('span.color-picker-value-bar-red').text(rgb[0]);
	      self.$el.find('span.color-picker-value-bar-green').text(rgb[1]);
	      self.$el.find('span.color-picker-value-bar-blue').text(rgb[2]);
	    }
	  },
	  destroy: function destroy(self) {
	    if (self.redBar && self.redBar.destroy) {
	      self.redBar.destroy();
	    }
	    if (self.greenBar && self.greenBar.destroy) {
	      self.greenBar.destroy();
	    }
	    if (self.blueBar && self.blueBar.destroy) {
	      self.blueBar.destroy();
	    }

	    delete self.redBar;
	    delete self.greenBar;
	    delete self.blueBar;

	    if (self.destroyRgbBarsEvents) { self.destroyRgbBarsEvents(); }
	    delete self.destroyRgbBarsEvents;
	  },
	};

	var moduleRgbSliders = {
	  render: function render(self) {
	    var ref = self.params;
	    var sliderLabel = ref.sliderLabel;
	    var sliderValue = ref.sliderValue;
	    var sliderValueEditable = ref.sliderValueEditable;
	    var redLabelText = ref.redLabelText;
	    var greenLabelText = ref.greenLabelText;
	    var blueLabelText = ref.blueLabelText;
	    return ("\n      <div class=\"color-picker-module color-picker-module-rgb-sliders\">\n        <div class=\"color-picker-slider-wrap\">\n          " + (sliderLabel ? ("\n            <div class=\"color-picker-slider-label\">" + redLabelText + "</div>\n          ") : '') + "\n          <div class=\"range-slider color-picker-slider color-picker-slider-red\"></div>\n          " + (sliderValue ? ("\n            <div class=\"color-picker-slider-value\">\n              " + (sliderValueEditable ? "\n                <input type=\"number\" step=\"1\" min=\"0\" max=\"255\" class=\"color-picker-value-red\" data-color-index=\"0\">\n              " : "\n                <span class=\"color-picker-value-red\"></span>\n              ") + "\n            </div>\n          ") : '') + "\n        </div>\n        <div class=\"color-picker-slider-wrap\">\n          " + (sliderLabel ? ("\n            <div class=\"color-picker-slider-label\">" + greenLabelText + "</div>\n          ") : '') + "\n          <div class=\"range-slider color-picker-slider color-picker-slider-green\"></div>\n          " + (sliderValue ? ("\n            <div class=\"color-picker-slider-value\">\n              " + (sliderValueEditable ? "\n                <input type=\"number\" step=\"1\" min=\"0\" max=\"255\" class=\"color-picker-value-green\" data-color-index=\"1\">\n              " : "\n                <span class=\"color-picker-value-green\"></span>\n              ") + "\n            </div>\n          ") : '') + "\n        </div>\n        <div class=\"color-picker-slider-wrap\">\n          " + (sliderLabel ? ("\n            <div class=\"color-picker-slider-label\">" + blueLabelText + "</div>\n          ") : '') + "\n          <div class=\"range-slider color-picker-slider color-picker-slider-blue\"></div>\n          " + (sliderValue ? ("\n            <div class=\"color-picker-slider-value\">\n              " + (sliderValueEditable ? "\n                <input type=\"number\" step=\"1\" min=\"0\" max=\"255\" class=\"color-picker-value-blue\" data-color-index=\"2\">\n              " : "\n                <span class=\"color-picker-value-blue\"></span>\n              ") + "\n            </div>\n          ") : '') + "\n        </div>\n      </div>\n    ");
	  },
	  init: function init(self) {
	    self.redRangeSlider = self.app.range.create({
	      el: self.$el.find('.color-picker-slider-red'),
	      min: 0,
	      max: 255,
	      step: 1,
	      value: 0,
	      on: {
	        change: function change(range, value) {
	          self.setValue({ rgb: [value, self.value.rgb[1], self.value.rgb[2]] });
	        },
	      },
	    });
	    self.greenRangeSlider = self.app.range.create({
	      el: self.$el.find('.color-picker-slider-green'),
	      min: 0,
	      max: 255,
	      step: 1,
	      value: 0,
	      on: {
	        change: function change(range, value) {
	          self.setValue({ rgb: [self.value.rgb[0], value, self.value.rgb[2]] });
	        },
	      },
	    });
	    self.blueRangeSlider = self.app.range.create({
	      el: self.$el.find('.color-picker-slider-blue'),
	      min: 0,
	      max: 255,
	      step: 1,
	      value: 0,
	      on: {
	        change: function change(range, value) {
	          self.setValue({ rgb: [self.value.rgb[0], self.value.rgb[1], value] });
	        },
	      },
	    });

	    function handleInputChange(e) {
	      var rgb = [].concat( self.value.rgb );
	      var index = parseInt($(e.target).attr('data-color-index'), 10);
	      var value = parseInt(e.target.value, 10);
	      if (Number.isNaN(value)) {
	        e.target.value = rgb[index];
	        return;
	      }
	      value = Math.max(0, Math.min(255, value));
	      rgb[index] = value;
	      self.setValue({ rgb: rgb });
	    }

	    self.$el.on('change', '.color-picker-module-rgb-sliders input', handleInputChange);

	    self.destroyRgbSlidersEvents = function destroyRgbSlidersEvents() {
	      self.$el.off('change', '.color-picker-module-rgb-sliders input', handleInputChange);
	    };
	  },
	  update: function update(self) {
	    var app = self.app;
	    var value = self.value;
	    var redRangeSlider = self.redRangeSlider;
	    var greenRangeSlider = self.greenRangeSlider;
	    var blueRangeSlider = self.blueRangeSlider;

	    var ref = self.params;
	    var sliderValue = ref.sliderValue;
	    var sliderValueEditable = ref.sliderValueEditable;

	    var rgb = value.rgb;

	    redRangeSlider.value = rgb[0];
	    greenRangeSlider.value = rgb[1];
	    blueRangeSlider.value = rgb[2];

	    redRangeSlider.layout();
	    greenRangeSlider.layout();
	    blueRangeSlider.layout();

	    redRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', ("rgb(" + (rgb[0]) + ", " + (rgb[1]) + ", " + (rgb[2]) + ")"));
	    greenRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', ("rgb(" + (rgb[0]) + ", " + (rgb[1]) + ", " + (rgb[2]) + ")"));
	    blueRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', ("rgb(" + (rgb[0]) + ", " + (rgb[1]) + ", " + (rgb[2]) + ")"));

	    var direction = app.rtl ? 'to left' : 'to right';

	    redRangeSlider.$el.find('.range-bar').css('background-image', ("linear-gradient(" + direction + ", rgb(0, " + (rgb[1]) + ", " + (rgb[2]) + "), rgb(255, " + (rgb[1]) + ", " + (rgb[2]) + "))"));
	    greenRangeSlider.$el.find('.range-bar').css('background-image', ("linear-gradient(" + direction + ", rgb(" + (rgb[0]) + ", 0, " + (rgb[2]) + "), rgb(" + (rgb[0]) + ", 255, " + (rgb[2]) + "))"));
	    blueRangeSlider.$el.find('.range-bar').css('background-image', ("linear-gradient(" + direction + ", rgb(" + (rgb[0]) + ", " + (rgb[1]) + ", 0), rgb(" + (rgb[0]) + ", " + (rgb[1]) + ", 255))"));

	    if (sliderValue && sliderValueEditable) {
	      self.$el.find('input.color-picker-value-red').val(rgb[0]);
	      self.$el.find('input.color-picker-value-green').val(rgb[1]);
	      self.$el.find('input.color-picker-value-blue').val(rgb[2]);
	    } else if (sliderValue) {
	      self.$el.find('span.color-picker-value-red').text(rgb[0]);
	      self.$el.find('span.color-picker-value-green').text(rgb[1]);
	      self.$el.find('span.color-picker-value-blue').text(rgb[2]);
	    }
	  },
	  destroy: function destroy(self) {
	    if (self.redRangeSlider && self.redRangeSlider.destroy) {
	      self.redRangeSlider.destroy();
	    }
	    if (self.greenRangeSlider && self.greenRangeSlider.destroy) {
	      self.greenRangeSlider.destroy();
	    }
	    if (self.blueRangeSlider && self.blueRangeSlider.destroy) {
	      self.blueRangeSlider.destroy();
	    }

	    delete self.redRangeSlider;
	    delete self.greenRangeSlider;
	    delete self.blueRangeSlider;

	    if (self.destroyRgbSlidersEvents) { self.destroyRgbSlidersEvents(); }
	    delete self.destroyRgbSlidersEvents;
	  },
	};

	var moduleSbSpectrum = {
	  render: function render() {
	    return "\n      <div class=\"color-picker-module color-picker-module-sb-spectrum\">\n        <div class=\"color-picker-sb-spectrum\" style=\"background-color: hsl(0, 100%, 50%)\">\n          <div class=\"color-picker-sb-spectrum-handle\"></div>\n        </div>\n      </div>\n    ";
	  },
	  init: function init(self) {
	    var app = self.app;

	    var isTouched;
	    var isMoved;
	    var touchStartX;
	    var touchStartY;
	    var touchCurrentX;
	    var touchCurrentY;

	    var specterRect;
	    var specterIsTouched;
	    var specterHandleIsTouched;

	    var $el = self.$el;

	    function setSBFromSpecterCoords(x, y) {
	      var s = (x - specterRect.left) / specterRect.width;
	      var b = (y - specterRect.top) / specterRect.height;
	      s = Math.max(0, Math.min(1, s));
	      b = 1 - Math.max(0, Math.min(1, b));

	      self.setValue({ hsb: [self.value.hue, s, b] });
	    }

	    function handleTouchStart(e) {
	      if (isMoved || isTouched) { return; }
	      touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchCurrentX = touchStartX;
	      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	      touchCurrentY = touchStartY;
	      var $targetEl = $(e.target);
	      specterHandleIsTouched = $targetEl.closest('.color-picker-sb-spectrum-handle').length > 0;
	      if (!specterHandleIsTouched) {
	        specterIsTouched = $targetEl.closest('.color-picker-sb-spectrum').length > 0;
	      }
	      if (specterIsTouched) {
	        specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
	        setSBFromSpecterCoords(touchStartX, touchStartY);
	      }
	      if (specterHandleIsTouched || specterIsTouched) {
	        $el.find('.color-picker-sb-spectrum-handle').addClass('color-picker-sb-spectrum-handle-pressed');
	      }
	    }
	    function handleTouchMove(e) {
	      if (!(specterIsTouched || specterHandleIsTouched)) { return; }
	      touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	      touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      e.preventDefault();
	      if (!isMoved) {
	        // First move
	        isMoved = true;
	        if (specterHandleIsTouched) {
	          specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
	        }
	      }
	      if (specterIsTouched || specterHandleIsTouched) {
	        setSBFromSpecterCoords(touchCurrentX, touchCurrentY);
	      }
	    }
	    function handleTouchEnd() {
	      isMoved = false;
	      if (specterIsTouched || specterHandleIsTouched) {
	        $el.find('.color-picker-sb-spectrum-handle').removeClass('color-picker-sb-spectrum-handle-pressed');
	      }
	      specterIsTouched = false;
	      specterHandleIsTouched = false;
	    }

	    function handleResize() {
	      self.modules['sb-spectrum'].update(self);
	    }

	    var passiveListener = app.touchEvents.start === 'touchstart' && app.support.passiveListener ? { passive: true, capture: false } : false;

	    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
	    app.on('touchmove:active', handleTouchMove);
	    app.on('touchend:passive', handleTouchEnd);
	    app.on('resize', handleResize);

	    self.destroySpectrumEvents = function destroySpectrumEvents() {
	      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
	      app.off('touchmove:active', handleTouchMove);
	      app.off('touchend:passive', handleTouchEnd);
	      app.off('resize', handleResize);
	    };
	  },
	  update: function update(self) {
	    var value = self.value;

	    var hsl = value.hsl;
	    var hsb = value.hsb;

	    var specterWidth = self.$el.find('.color-picker-sb-spectrum')[0].offsetWidth;
	    var specterHeight = self.$el.find('.color-picker-sb-spectrum')[0].offsetHeight;

	    self.$el.find('.color-picker-sb-spectrum')
	      .css('background-color', ("hsl(" + (hsl[0]) + ", 100%, 50%)"));

	    self.$el.find('.color-picker-sb-spectrum-handle')
	      .css('background-color', ("hsl(" + (hsl[0]) + ", " + (hsl[1] * 100) + "%, " + (hsl[2] * 100) + "%)"))
	      .transform(("translate(" + (specterWidth * hsb[1]) + "px, " + (specterHeight * (1 - hsb[2])) + "px)"));
	  },
	  destroy: function destroy(self) {
	    if (self.destroySpectrumEvents) { self.destroySpectrumEvents(); }
	    delete self.destroySpectrumEvents;
	  },
	};

	var moduleHsSpectrum = {
	  render: function render() {
	    return "\n      <div class=\"color-picker-module color-picker-module-hs-spectrum\">\n        <div class=\"color-picker-hs-spectrum\">\n          <div class=\"color-picker-hs-spectrum-handle\"></div>\n        </div>\n      </div>\n    ";
	  },
	  init: function init(self) {
	    var app = self.app;

	    var isTouched;
	    var isMoved;
	    var touchStartX;
	    var touchStartY;
	    var touchCurrentX;
	    var touchCurrentY;

	    var specterRect;
	    var specterIsTouched;
	    var specterHandleIsTouched;

	    var $el = self.$el;

	    function setHSFromSpecterCoords(x, y) {
	      var h = (x - specterRect.left) / specterRect.width * 360;
	      var s = (y - specterRect.top) / specterRect.height;
	      h = Math.max(0, Math.min(360, h));
	      s = 1 - Math.max(0, Math.min(1, s));

	      self.setValue({ hsb: [h, s, self.value.hsb[2]] });
	    }

	    function handleTouchStart(e) {
	      if (isMoved || isTouched) { return; }
	      touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchCurrentX = touchStartX;
	      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	      touchCurrentY = touchStartY;
	      var $targetEl = $(e.target);
	      specterHandleIsTouched = $targetEl.closest('.color-picker-hs-spectrum-handle').length > 0;
	      if (!specterHandleIsTouched) {
	        specterIsTouched = $targetEl.closest('.color-picker-hs-spectrum').length > 0;
	      }
	      if (specterIsTouched) {
	        specterRect = $el.find('.color-picker-hs-spectrum')[0].getBoundingClientRect();
	        setHSFromSpecterCoords(touchStartX, touchStartY);
	      }
	      if (specterHandleIsTouched || specterIsTouched) {
	        $el.find('.color-picker-hs-spectrum-handle').addClass('color-picker-hs-spectrum-handle-pressed');
	      }
	    }
	    function handleTouchMove(e) {
	      if (!(specterIsTouched || specterHandleIsTouched)) { return; }
	      touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	      touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      e.preventDefault();
	      if (!isMoved) {
	        // First move
	        isMoved = true;
	        if (specterHandleIsTouched) {
	          specterRect = $el.find('.color-picker-hs-spectrum')[0].getBoundingClientRect();
	        }
	      }
	      if (specterIsTouched || specterHandleIsTouched) {
	        setHSFromSpecterCoords(touchCurrentX, touchCurrentY);
	      }
	    }
	    function handleTouchEnd() {
	      isMoved = false;
	      if (specterIsTouched || specterHandleIsTouched) {
	        $el.find('.color-picker-hs-spectrum-handle').removeClass('color-picker-hs-spectrum-handle-pressed');
	      }
	      specterIsTouched = false;
	      specterHandleIsTouched = false;
	    }

	    function handleResize() {
	      self.modules['hs-spectrum'].update(self);
	    }

	    var passiveListener = app.touchEvents.start === 'touchstart' && app.support.passiveListener ? { passive: true, capture: false } : false;

	    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
	    app.on('touchmove:active', handleTouchMove);
	    app.on('touchend:passive', handleTouchEnd);
	    app.on('resize', handleResize);

	    self.destroySpectrumEvents = function destroySpectrumEvents() {
	      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
	      app.off('touchmove:active', handleTouchMove);
	      app.off('touchend:passive', handleTouchEnd);
	      app.off('resize', handleResize);
	    };
	  },
	  update: function update(self) {
	    var value = self.value;

	    var hsb = value.hsb;

	    var specterWidth = self.$el.find('.color-picker-hs-spectrum')[0].offsetWidth;
	    var specterHeight = self.$el.find('.color-picker-hs-spectrum')[0].offsetHeight;

	    var hslBright = Utils.colorHsbToHsl(hsb[0], hsb[1], 1);

	    self.$el.find('.color-picker-hs-spectrum-handle')
	      .css('background-color', ("hsl(" + (hslBright[0]) + ", " + (hslBright[1] * 100) + "%, " + (hslBright[2] * 100) + "%)"))
	      .transform(("translate(" + (specterWidth * (hsb[0] / 360)) + "px, " + (specterHeight * (1 - hsb[1])) + "px)"));
	  },
	  destroy: function destroy(self) {
	    if (self.destroySpectrumEvents) { self.destroySpectrumEvents(); }
	    delete self.destroySpectrumEvents;
	  },
	};

	function svgWheelCircles() {
	  var total = 256;
	  var circles = '';
	  for (var i = total; i > 0; i -= 1) {
	    var angle = i * Math.PI / (total / 2);
	    var hue = 360 / total * i;
	    circles += "<circle cx=\"" + (150 - Math.sin(angle) * 125) + "\" cy=\"" + (150 - Math.cos(angle) * 125) + "\" r=\"25\" fill=\"hsl(" + hue + ", 100%, 50%)\"></circle>";
	  }
	  return circles;
	}
	var moduleWheel = {
	  render: function render() {
	    return ("\n      <div class=\"color-picker-module color-picker-module-wheel\">\n        <div class=\"color-picker-wheel\">\n          <svg viewBox=\"0 0 300 300\" width=\"300\" height=\"300\">" + (svgWheelCircles()) + "</svg>\n          <div class=\"color-picker-wheel-handle\"></div>\n          <div class=\"color-picker-sb-spectrum\" style=\"background-color: hsl(0, 100%, 50%)\">\n            <div class=\"color-picker-sb-spectrum-handle\"></div>\n          </div>\n        </div>\n      </div>\n    ");
	  },
	  init: function init(self) {
	    var app = self.app;

	    var isTouched;
	    var isMoved;
	    var touchStartX;
	    var touchStartY;
	    var touchCurrentX;
	    var touchCurrentY;

	    var wheelRect;
	    var wheelIsTouched;
	    var wheelHandleIsTouched;
	    var specterRect;
	    var specterIsTouched;
	    var specterHandleIsTouched;

	    var $el = self.$el;

	    function setHueFromWheelCoords(x, y) {
	      var wheelCenterX = wheelRect.left + wheelRect.width / 2;
	      var wheelCenterY = wheelRect.top + wheelRect.height / 2;
	      var angleRad = Math.atan2(y - wheelCenterY, x - wheelCenterX);
	      var angleDeg = angleRad * 180 / Math.PI + 90;
	      if (angleDeg < 0) { angleDeg += 360; }
	      angleDeg = 360 - angleDeg;
	      self.setValue({ hue: angleDeg });
	    }
	    function setSBFromSpecterCoords(x, y) {
	      var s = (x - specterRect.left) / specterRect.width;
	      var b = (y - specterRect.top) / specterRect.height;
	      s = Math.max(0, Math.min(1, s));
	      b = 1 - Math.max(0, Math.min(1, b));

	      self.setValue({ hsb: [self.value.hue, s, b] });
	    }

	    function handleTouchStart(e) {
	      if (isMoved || isTouched) { return; }
	      touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchCurrentX = touchStartX;
	      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	      touchCurrentY = touchStartY;
	      var $targetEl = $(e.target);
	      wheelHandleIsTouched = $targetEl.closest('.color-picker-wheel-handle').length > 0;
	      wheelIsTouched = $targetEl.closest('circle').length > 0;
	      specterHandleIsTouched = $targetEl.closest('.color-picker-sb-spectrum-handle').length > 0;
	      if (!specterHandleIsTouched) {
	        specterIsTouched = $targetEl.closest('.color-picker-sb-spectrum').length > 0;
	      }
	      if (wheelIsTouched) {
	        wheelRect = $el.find('.color-picker-wheel')[0].getBoundingClientRect();
	        setHueFromWheelCoords(touchStartX, touchStartY);
	      }
	      if (specterIsTouched) {
	        specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
	        setSBFromSpecterCoords(touchStartX, touchStartY);
	      }
	      if (specterHandleIsTouched || specterIsTouched) {
	        $el.find('.color-picker-sb-spectrum-handle').addClass('color-picker-sb-spectrum-handle-pressed');
	      }
	    }
	    function handleTouchMove(e) {
	      if (!(wheelIsTouched || wheelHandleIsTouched) && !(specterIsTouched || specterHandleIsTouched)) { return; }
	      touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	      touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      e.preventDefault();
	      if (!isMoved) {
	        // First move
	        isMoved = true;
	        if (wheelHandleIsTouched) {
	          wheelRect = $el.find('.color-picker-wheel')[0].getBoundingClientRect();
	        }
	        if (specterHandleIsTouched) {
	          specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
	        }
	      }
	      if (wheelIsTouched || wheelHandleIsTouched) {
	        setHueFromWheelCoords(touchCurrentX, touchCurrentY);
	      }
	      if (specterIsTouched || specterHandleIsTouched) {
	        setSBFromSpecterCoords(touchCurrentX, touchCurrentY);
	      }
	    }
	    function handleTouchEnd() {
	      isMoved = false;
	      if (specterIsTouched || specterHandleIsTouched) {
	        $el.find('.color-picker-sb-spectrum-handle').removeClass('color-picker-sb-spectrum-handle-pressed');
	      }
	      wheelIsTouched = false;
	      wheelHandleIsTouched = false;
	      specterIsTouched = false;
	      specterHandleIsTouched = false;
	    }

	    function handleResize() {
	      self.modules.wheel.update(self);
	    }

	    var passiveListener = app.touchEvents.start === 'touchstart' && app.support.passiveListener ? { passive: true, capture: false } : false;

	    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
	    app.on('touchmove:active', handleTouchMove);
	    app.on('touchend:passive', handleTouchEnd);
	    app.on('resize', handleResize);

	    self.destroyWheelEvents = function destroyWheelEvents() {
	      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
	      app.off('touchmove:active', handleTouchMove);
	      app.off('touchend:passive', handleTouchEnd);
	      app.off('resize', handleResize);
	    };
	  },
	  update: function update(self) {
	    var value = self.value;

	    var hsl = value.hsl;
	    var hsb = value.hsb;

	    var specterWidth = self.$el.find('.color-picker-sb-spectrum')[0].offsetWidth;
	    var specterHeight = self.$el.find('.color-picker-sb-spectrum')[0].offsetHeight;
	    var wheelSize = self.$el.find('.color-picker-wheel')[0].offsetWidth;
	    var wheelHalfSize = wheelSize / 2;
	    var angleRad = value.hue * Math.PI / 180;
	    var handleSize = wheelSize / 6;
	    var handleHalfSize = handleSize / 2;
	    var tX = wheelHalfSize - Math.sin(angleRad) * (wheelHalfSize - handleHalfSize) - handleHalfSize;
	    var tY = wheelHalfSize - Math.cos(angleRad) * (wheelHalfSize - handleHalfSize) - handleHalfSize;
	    self.$el.find('.color-picker-wheel-handle')
	      .css('background-color', ("hsl(" + (hsl[0]) + ", 100%, 50%)"))
	      .transform(("translate(" + tX + "px, " + tY + "px)"));

	    self.$el.find('.color-picker-sb-spectrum')
	      .css('background-color', ("hsl(" + (hsl[0]) + ", 100%, 50%)"));

	    self.$el.find('.color-picker-sb-spectrum-handle')
	      .css('background-color', ("hsl(" + (hsl[0]) + ", " + (hsl[1] * 100) + "%, " + (hsl[2] * 100) + "%)"))
	      .transform(("translate(" + (specterWidth * hsb[1]) + "px, " + (specterHeight * (1 - hsb[2])) + "px)"));
	  },
	  destroy: function destroy(self) {
	    if (self.destroyWheelEvents) { self.destroyWheelEvents(); }
	    delete self.destroyWheelEvents;
	  },
	};

	var ColorPicker = /*@__PURE__*/(function (Framework7Class) {
	  function ColorPicker(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class.call(this, params, [app]);
	    var self = this;

	    self.params = Utils.extend({}, app.params.colorPicker, params);

	    var $containerEl;
	    if (self.params.containerEl) {
	      $containerEl = $(self.params.containerEl);
	      if ($containerEl.length === 0) { return self; }
	    }

	    var $inputEl;
	    if (self.params.inputEl) {
	      $inputEl = $(self.params.inputEl);
	    }

	    var $targetEl;
	    if (self.params.targetEl) {
	      $targetEl = $(self.params.targetEl);
	    }

	    var view;
	    if ($inputEl) {
	      view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
	    }
	    if (!view && $targetEl) {
	      view = $targetEl.parents('.view').length && $targetEl.parents('.view')[0].f7View;
	    }
	    if (!view) { view = app.views.main; }

	    Utils.extend(self, {
	      app: app,
	      $containerEl: $containerEl,
	      containerEl: $containerEl && $containerEl[0],
	      inline: $containerEl && $containerEl.length > 0,
	      $inputEl: $inputEl,
	      inputEl: $inputEl && $inputEl[0],
	      $targetEl: $targetEl,
	      targetEl: $targetEl && $targetEl[0],
	      initialized: false,
	      opened: false,
	      url: self.params.url,
	      view: view,
	      modules: {
	        'alpha-slider': moduleAlphaSlider,
	        'current-color': moduleCurrentColor,
	        'hex': moduleHex, // eslint-disable-line
	        'hsb-sliders': moduleHsbSliders,
	        'hue-slider': moduleHueSlider,
	        'brightness-slider': moduleBrightnessSlider,
	        'palette': modulePalette, // eslint-disable-line
	        'initial-current-colors': moduleInitialCurrentColors,
	        'rgb-bars': moduleRgbBars,
	        'rgb-sliders': moduleRgbSliders,
	        'sb-spectrum': moduleSbSpectrum,
	        'hs-spectrum': moduleHsSpectrum,
	        'wheel': moduleWheel, // eslint-disable-line
	      },
	    });

	    function onInputClick() {
	      self.open();
	    }
	    function onInputFocus(e) {
	      e.preventDefault();
	    }
	    function onTargetClick() {
	      self.open();
	    }
	    function onHtmlClick(e) {
	      if (self.params.openIn === 'page') { return; }
	      var $clickTargetEl = $(e.target);
	      if (!self.opened || self.closing) { return; }
	      if ($clickTargetEl.closest('[class*="backdrop"]').length) { return; }
	      if ($clickTargetEl.closest('.color-picker-popup, .color-picker-popover').length) { return; }
	      if ($inputEl && $inputEl.length > 0) {
	        if ($clickTargetEl[0] !== $inputEl[0] && $clickTargetEl.closest('.sheet-modal').length === 0) {
	          self.close();
	        }
	      } else if ($(e.target).closest('.sheet-modal').length === 0) {
	        self.close();
	      }
	    }

	    // Events
	    Utils.extend(self, {
	      attachInputEvents: function attachInputEvents() {
	        self.$inputEl.on('click', onInputClick);
	        if (self.params.inputReadOnly) {
	          self.$inputEl.on('focus mousedown', onInputFocus);
	        }
	      },
	      detachInputEvents: function detachInputEvents() {
	        self.$inputEl.off('click', onInputClick);
	        if (self.params.inputReadOnly) {
	          self.$inputEl.off('focus mousedown', onInputFocus);
	        }
	      },
	      attachTargetEvents: function attachTargetEvents() {
	        self.$targetEl.on('click', onTargetClick);
	      },
	      detachTargetEvents: function detachTargetEvents() {
	        self.$targetEl.off('click', onTargetClick);
	      },
	      attachHtmlEvents: function attachHtmlEvents() {
	        app.on('click', onHtmlClick);
	      },
	      detachHtmlEvents: function detachHtmlEvents() {
	        app.off('click', onHtmlClick);
	      },
	    });

	    self.init();

	    return self;
	  }

	  if ( Framework7Class ) ColorPicker.__proto__ = Framework7Class;
	  ColorPicker.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  ColorPicker.prototype.constructor = ColorPicker;

	  ColorPicker.prototype.attachEvents = function attachEvents () {
	    var self = this;
	    self.centerModules = self.centerModules.bind(self);
	    if (self.params.centerModules) {
	      self.app.on('resize', self.centerModules);
	    }
	  };

	  ColorPicker.prototype.detachEvents = function detachEvents () {
	    var self = this;
	    if (self.params.centerModules) {
	      self.app.off('resize', self.centerModules);
	    }
	  };

	  ColorPicker.prototype.centerModules = function centerModules () {
	    var self = this;
	    if (!self.opened || !self.$el || self.inline) { return; }
	    var $pageContentEl = self.$el.find('.page-content');
	    if (!$pageContentEl.length) { return; }
	    var ref = $pageContentEl[0];
	    var scrollHeight = ref.scrollHeight;
	    var offsetHeight = ref.offsetHeight;
	    if (scrollHeight <= offsetHeight) {
	      $pageContentEl.addClass('justify-content-center');
	    } else {
	      $pageContentEl.removeClass('justify-content-center');
	    }
	  };

	  ColorPicker.prototype.initInput = function initInput () {
	    var self = this;
	    if (!self.$inputEl) { return; }
	    if (self.params.inputReadOnly) { self.$inputEl.prop('readOnly', true); }
	  };

	  ColorPicker.prototype.getModalType = function getModalType () {
	    var self = this;
	    var app = self.app;
	    var modal = self.modal;
	    var params = self.params;
	    var openIn = params.openIn;
	    var openInPhone = params.openInPhone;
	    if (modal && modal.type) { return modal.type; }
	    if (openIn !== 'auto') { return openIn; }
	    if (self.inline) { return null; }
	    if (app.device.ios) {
	      return app.device.ipad ? 'popover' : openInPhone;
	    }
	    if (app.width >= 768 || (app.device.desktop && app.theme === 'aurora')) {
	      return 'popover';
	    }

	    return openInPhone;
	  };

	  ColorPicker.prototype.formatValue = function formatValue () {
	    var self = this;
	    var value = self.value;
	    if (self.params.formatValue) {
	      return self.params.formatValue.call(self, value);
	    }
	    return value.hex;
	  };

	  // eslint-disable-next-line
	  ColorPicker.prototype.normalizeHsValues = function normalizeHsValues (arr) {
	    return [
	      Math.floor(arr[0] * 10) / 10,
	      Math.floor(arr[1] * 1000) / 1000,
	      Math.floor(arr[2] * 1000) / 1000 ];
	  };

	  ColorPicker.prototype.setValue = function setValue (value, updateModules) {
	    if ( value === void 0 ) value = {};
	    if ( updateModules === void 0 ) updateModules = true;

	    var self = this;
	    if (typeof value === 'undefined') { return; }

	    var ref = (self.value || {});
	    var hex = ref.hex;
	    var rgb = ref.rgb;
	    var hsl = ref.hsl;
	    var hsb = ref.hsb;
	    var alpha = ref.alpha; if ( alpha === void 0 ) alpha = 1;
	    var hue = ref.hue;
	    var rgba = ref.rgba;
	    var hsla = ref.hsla;

	    var needChangeEvent = self.value || (!self.value && !self.params.value);
	    var valueChanged;
	    Object.keys(value).forEach(function (k) {
	      if (!self.value || typeof self.value[k] === 'undefined') {
	        valueChanged = true;
	        return;
	      }
	      var v = value[k];
	      if (Array.isArray(v)) {
	        v.forEach(function (subV, subIndex) {
	          if (subV !== self.value[k][subIndex]) {
	            valueChanged = true;
	          }
	        });
	      } else if (v !== self.value[k]) {
	        valueChanged = true;
	      }
	    });
	    if (!valueChanged) { return; }

	    if (value.rgb || value.rgba) {
	      var ref$1 = (value.rgb || value.rgba);
	      var r = ref$1[0];
	      var g = ref$1[1];
	      var b = ref$1[2];
	      var a = ref$1[3]; if ( a === void 0 ) a = alpha;
	      rgb = [r, g, b];
	      hex = Utils.colorRgbToHex.apply(Utils, rgb);
	      hsl = Utils.colorRgbToHsl.apply(Utils, rgb);
	      hsb = Utils.colorHslToHsb.apply(Utils, hsl);
	      hsl = self.normalizeHsValues(hsl);
	      hsb = self.normalizeHsValues(hsb);
	      hue = hsb[0];
	      alpha = a;
	      rgba = [rgb[0], rgb[1], rgb[2], a];
	      hsla = [hsl[0], hsl[1], hsl[2], a];
	    }

	    if (value.hsl || value.hsla) {
	      var ref$2 = (value.hsl || value.hsla);
	      var h = ref$2[0];
	      var s = ref$2[1];
	      var l = ref$2[2];
	      var a$1 = ref$2[3]; if ( a$1 === void 0 ) a$1 = alpha;
	      hsl = [h, s, l];
	      rgb = Utils.colorHslToRgb.apply(Utils, hsl);
	      hex = Utils.colorRgbToHex.apply(Utils, rgb);
	      hsb = Utils.colorHslToHsb.apply(Utils, hsl);
	      hsl = self.normalizeHsValues(hsl);
	      hsb = self.normalizeHsValues(hsb);
	      hue = hsb[0];
	      alpha = a$1;
	      rgba = [rgb[0], rgb[1], rgb[2], a$1];
	      hsla = [hsl[0], hsl[1], hsl[2], a$1];
	    }

	    if (value.hsb) {
	      var ref$3 = value.hsb;
	      var h$1 = ref$3[0];
	      var s$1 = ref$3[1];
	      var b$1 = ref$3[2];
	      var a$2 = ref$3[3]; if ( a$2 === void 0 ) a$2 = alpha;
	      hsb = [h$1, s$1, b$1];
	      hsl = Utils.colorHsbToHsl.apply(Utils, hsb);
	      rgb = Utils.colorHslToRgb.apply(Utils, hsl);
	      hex = Utils.colorRgbToHex.apply(Utils, rgb);
	      hsl = self.normalizeHsValues(hsl);
	      hsb = self.normalizeHsValues(hsb);
	      hue = hsb[0];
	      alpha = a$2;
	      rgba = [rgb[0], rgb[1], rgb[2], a$2];
	      hsla = [hsl[0], hsl[1], hsl[2], a$2];
	    }

	    if (value.hex) {
	      rgb = Utils.colorHexToRgb(value.hex);
	      hex = Utils.colorRgbToHex.apply(Utils, rgb);
	      hsl = Utils.colorRgbToHsl.apply(Utils, rgb);
	      hsb = Utils.colorHslToHsb.apply(Utils, hsl);
	      hsl = self.normalizeHsValues(hsl);
	      hsb = self.normalizeHsValues(hsb);
	      hue = hsb[0];
	      rgba = [rgb[0], rgb[1], rgb[2], alpha];
	      hsla = [hsl[0], hsl[1], hsl[2], alpha];
	    }

	    if (typeof value.alpha !== 'undefined') {
	      alpha = value.alpha;
	      if (typeof rgb !== 'undefined') {
	        rgba = [rgb[0], rgb[1], rgb[2], alpha];
	      }
	      if (typeof hsl !== 'undefined') {
	        hsla = [hsl[0], hsl[1], hsl[2], alpha];
	      }
	    }

	    if (typeof value.hue !== 'undefined') {
	      var h$2 = hsl[0];
	      var s$2 = hsl[1];
	      var l$1 = hsl[2]; // eslint-disable-line
	      hsl = [value.hue, s$2, l$1];
	      hsb = Utils.colorHslToHsb.apply(Utils, hsl);
	      rgb = Utils.colorHslToRgb.apply(Utils, hsl);
	      hex = Utils.colorRgbToHex.apply(Utils, rgb);
	      hsl = self.normalizeHsValues(hsl);
	      hsb = self.normalizeHsValues(hsb);
	      hue = hsb[0];
	      rgba = [rgb[0], rgb[1], rgb[2], alpha];
	      hsla = [hsl[0], hsl[1], hsl[2], alpha];
	    }
	    self.value = {
	      hex: hex,
	      alpha: alpha,
	      hue: hue,
	      rgb: rgb,
	      hsl: hsl,
	      hsb: hsb,
	      rgba: rgba,
	      hsla: hsla,
	    };
	    if (!self.initialValue) { self.initialValue = Utils.extend({}, self.value); }
	    self.updateValue(needChangeEvent);
	    if (self.opened && updateModules) {
	      self.updateModules();
	    }
	  };

	  ColorPicker.prototype.getValue = function getValue () {
	    var self = this;
	    return self.value;
	  };

	  ColorPicker.prototype.updateValue = function updateValue (fireEvents) {
	    if ( fireEvents === void 0 ) fireEvents = true;

	    var self = this;
	    var $inputEl = self.$inputEl;
	    var value = self.value;
	    var $targetEl = self.$targetEl;
	    if ($targetEl && self.params.targetElSetBackgroundColor) {
	      var rgba = value.rgba;
	      $targetEl.css('background-color', ("rgba(" + (rgba.join(', ')) + ")"));
	    }
	    if (fireEvents) {
	      self.emit('local::change colorPickerChange', self, value);
	    }

	    if ($inputEl && $inputEl.length) {
	      var inputValue = self.formatValue(value);
	      if ($inputEl && $inputEl.length) {
	        $inputEl.val(inputValue);
	        if (fireEvents) {
	          $inputEl.trigger('change');
	        }
	      }
	    }
	  };

	  ColorPicker.prototype.updateModules = function updateModules () {
	    var self = this;
	    var modules = self.modules;
	    self.params.modules.forEach(function (m) {
	      if (typeof m === 'string' && modules[m] && modules[m].update) {
	        modules[m].update(self);
	      } else if (m && m.update) {
	        m.update(self);
	      }
	    });
	  };

	  ColorPicker.prototype.update = function update () {
	    var self = this;
	    self.updateModules();
	  };

	  ColorPicker.prototype.renderPicker = function renderPicker () {
	    var self = this;
	    var params = self.params;
	    var modules = self.modules;
	    var html = '';

	    params.modules.forEach(function (m) {
	      if (typeof m === 'string' && modules[m] && modules[m].render) {
	        html += modules[m].render(self);
	      } else if (m && m.render) {
	        html += m.render(self);
	      }
	    });

	    return html;
	  };

	  ColorPicker.prototype.renderNavbar = function renderNavbar () {
	    var self = this;
	    if (self.params.renderNavbar) {
	      return self.params.renderNavbar.call(self, self);
	    }
	    var ref = self.params;
	    var openIn = ref.openIn;
	    var navbarTitleText = ref.navbarTitleText;
	    var navbarBackLinkText = ref.navbarBackLinkText;
	    var navbarCloseText = ref.navbarCloseText;
	    return ("\n    <div class=\"navbar\">\n      <div class=\"navbar-inner sliding\">\n        " + (openIn === 'page' ? ("\n        <div class=\"left\">\n          <a class=\"link back\">\n            <i class=\"icon icon-back\"></i>\n            <span class=\"if-not-md\">" + navbarBackLinkText + "</span>\n          </a>\n        </div>\n        ") : '') + "\n        <div class=\"title\">" + navbarTitleText + "</div>\n        " + (openIn !== 'page' ? ("\n        <div class=\"right\">\n          <a class=\"link popup-close\" data-popup=\".color-picker-popup\">" + navbarCloseText + "</a>\n        </div>\n        ") : '') + "\n      </div>\n    </div>\n  ").trim();
	  };

	  ColorPicker.prototype.renderToolbar = function renderToolbar () {
	    var self = this;
	    if (self.params.renderToolbar) {
	      return self.params.renderToolbar.call(self, self);
	    }
	    return ("\n    <div class=\"toolbar toolbar-top no-shadow\">\n      <div class=\"toolbar-inner\">\n        <div class=\"left\"></div>\n        <div class=\"right\">\n          <a class=\"link sheet-close popover-close\" data-sheet=\".color-picker-sheet-modal\" data-popover=\".color-picker-popover\">" + (self.params.toolbarCloseText) + "</a>\n        </div>\n      </div>\n    </div>\n  ").trim();
	  };

	  ColorPicker.prototype.renderInline = function renderInline () {
	    var self = this;
	    var ref = self.params;
	    var cssClass = ref.cssClass;
	    var groupedModules = ref.groupedModules;
	    var inlineHtml = ("\n    <div class=\"color-picker color-picker-inline " + (groupedModules ? 'color-picker-grouped-modules' : '') + " " + (cssClass || '') + "\">\n      " + (self.renderPicker()) + "\n    </div>\n  ").trim();

	    return inlineHtml;
	  };

	  ColorPicker.prototype.renderSheet = function renderSheet () {
	    var self = this;
	    var ref = self.params;
	    var cssClass = ref.cssClass;
	    var toolbarSheet = ref.toolbarSheet;
	    var groupedModules = ref.groupedModules;
	    var sheetHtml = ("\n    <div class=\"sheet-modal color-picker color-picker-sheet-modal " + (groupedModules ? 'color-picker-grouped-modules' : '') + " " + (cssClass || '') + "\">\n      " + (toolbarSheet ? self.renderToolbar() : '') + "\n      <div class=\"sheet-modal-inner\">\n        <div class=\"page-content\">\n          " + (self.renderPicker()) + "\n        </div>\n      </div>\n    </div>\n  ").trim();

	    return sheetHtml;
	  };

	  ColorPicker.prototype.renderPopover = function renderPopover () {
	    var self = this;
	    var ref = self.params;
	    var cssClass = ref.cssClass;
	    var toolbarPopover = ref.toolbarPopover;
	    var groupedModules = ref.groupedModules;
	    var popoverHtml = ("\n    <div class=\"popover color-picker-popover " + (cssClass || '') + "\">\n      <div class=\"popover-inner\">\n        <div class=\"color-picker " + (groupedModules ? 'color-picker-grouped-modules' : '') + "\">\n          " + (toolbarPopover ? self.renderToolbar() : '') + "\n          <div class=\"page-content\">\n            " + (self.renderPicker()) + "\n          </div>\n        </div>\n      </div>\n    </div>\n  ").trim();

	    return popoverHtml;
	  };

	  ColorPicker.prototype.renderPopup = function renderPopup () {
	    var self = this;
	    var ref = self.params;
	    var cssClass = ref.cssClass;
	    var navbarPopup = ref.navbarPopup;
	    var groupedModules = ref.groupedModules;
	    var popupHtml = ("\n    <div class=\"popup color-picker-popup " + (cssClass || '') + "\">\n      <div class=\"page\">\n        " + (navbarPopup ? self.renderNavbar() : '') + "\n        <div class=\"color-picker " + (groupedModules ? 'color-picker-grouped-modules' : '') + "\">\n          <div class=\"page-content\">\n            " + (self.renderPicker()) + "\n          </div>\n        </div>\n      </div>\n    </div>\n  ").trim();

	    return popupHtml;
	  };

	  ColorPicker.prototype.renderPage = function renderPage () {
	    var self = this;
	    var ref = self.params;
	    var cssClass = ref.cssClass;
	    var groupedModules = ref.groupedModules;
	    var pageHtml = ("\n    <div class=\"page color-picker-page " + (cssClass || '') + "\" data-name=\"color-picker-page\">\n      " + (self.renderNavbar()) + "\n      <div class=\"color-picker " + (groupedModules ? 'color-picker-grouped-modules' : '') + "\">\n        <div class=\"page-content\">\n          " + (self.renderPicker()) + "\n        </div>\n      </div>\n    </div>\n  ").trim();
	    return pageHtml;
	  };

	  // eslint-disable-next-line
	  ColorPicker.prototype.render = function render () {
	    var self = this;
	    var params = self.params;
	    if (params.render) { return params.render.call(self); }
	    if (self.inline) { return self.renderInline(); }
	    if (params.openIn === 'page') {
	      return self.renderPage();
	    }

	    var modalType = self.getModalType();
	    if (modalType === 'popover') { return self.renderPopover(); }
	    if (modalType === 'sheet') { return self.renderSheet(); }
	    if (modalType === 'popup') { return self.renderPopup(); }
	  };

	  ColorPicker.prototype.onOpen = function onOpen () {
	    var self = this;
	    var initialized = self.initialized;
	    var $el = self.$el;
	    var app = self.app;
	    var $inputEl = self.$inputEl;
	    var inline = self.inline;
	    var value = self.value;
	    var params = self.params;
	    var modules = self.modules;
	    self.closing = false;
	    self.opened = true;
	    self.opening = true;

	    // Init main events
	    self.attachEvents();

	    params.modules.forEach(function (m) {
	      if (typeof m === 'string' && modules[m] && modules[m].render) {
	        modules[m].init(self);
	      } else if (m && m.init) {
	        m.init(self);
	      }
	    });

	    var updateValue = !value && params.value;

	    // Set value
	    if (!initialized) {
	      if (value) { self.setValue(value); }
	      else if (params.value) {
	        self.setValue(params.value, false);
	      } else if (!params.value) {
	        self.setValue({ hex: '#ff0000' }, false);
	      }
	    } else if (value) {
	      self.initialValue = Utils.extend({}, value);
	      self.setValue(value, false);
	    }

	    // Update input value
	    if (updateValue) { self.updateValue(); }
	    self.updateModules();

	    // Center modules
	    if (params.centerModules) {
	      self.centerModules();
	    }

	    // Extra focus
	    if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
	      $inputEl.trigger('focus');
	    }

	    self.initialized = true;

	    // Trigger events
	    if ($el) {
	      $el.trigger('colorpicker:open', self);
	    }
	    if ($inputEl) {
	      $inputEl.trigger('colorpicker:open', self);
	    }
	    self.emit('local::open colorPickerOpen', self);
	  };

	  ColorPicker.prototype.onOpened = function onOpened () {
	    var self = this;
	    self.opening = false;
	    if (self.$el) {
	      self.$el.trigger('colorpicker:opened', self);
	    }
	    if (self.$inputEl) {
	      self.$inputEl.trigger('colorpicker:opened', self);
	    }
	    self.emit('local::opened colorPickerOpened', self);
	  };

	  ColorPicker.prototype.onClose = function onClose () {
	    var self = this;
	    var app = self.app;
	    var params = self.params;
	    var modules = self.modules;
	    self.opening = false;
	    self.closing = true;

	    // Detach events
	    self.detachEvents();

	    if (self.$inputEl && app.theme === 'md') {
	      self.$inputEl.trigger('blur');
	    }
	    params.modules.forEach(function (m) {
	      if (typeof m === 'string' && modules[m] && modules[m].update) {
	        modules[m].destroy(self);
	      } else if (m && m.destroy) {
	        m.destroy(self);
	      }
	    });

	    if (self.$el) {
	      self.$el.trigger('colorpicker:close', self);
	    }
	    if (self.$inputEl) {
	      self.$inputEl.trigger('colorpicker:close', self);
	    }
	    self.emit('local::close colorPickerClose', self);
	  };

	  ColorPicker.prototype.onClosed = function onClosed () {
	    var self = this;
	    self.opened = false;
	    self.closing = false;

	    if (!self.inline) {
	      Utils.nextTick(function () {
	        if (self.modal && self.modal.el && self.modal.destroy) {
	          if (!self.params.routableModals) {
	            self.modal.destroy();
	          }
	        }
	        delete self.modal;
	      });
	    }
	    if (self.$el) {
	      self.$el.trigger('colorpicker:closed', self);
	    }
	    if (self.$inputEl) {
	      self.$inputEl.trigger('colorpicker:closed', self);
	    }
	    self.emit('local::closed colorPickerClosed', self);
	  };

	  ColorPicker.prototype.open = function open () {
	    var obj;

	    var self = this;
	    var app = self.app;
	    var opened = self.opened;
	    var inline = self.inline;
	    var $inputEl = self.$inputEl;
	    var $targetEl = self.$targetEl;
	    var params = self.params;
	    if (opened) { return; }

	    if (inline) {
	      self.$el = $(self.render());
	      self.$el[0].f7ColorPicker = self;
	      self.$containerEl.append(self.$el);
	      self.onOpen();
	      self.onOpened();
	      return;
	    }

	    var colorPickerContent = self.render();

	    if (params.openIn === 'page') {
	      self.view.router.navigate({
	        url: self.url,
	        route: {
	          content: colorPickerContent,
	          path: self.url,
	          on: {
	            pageBeforeIn: function pageBeforeIn(e, page) {
	              self.$el = page.$el.find('.color-picker');
	              self.$el[0].f7ColorPicker = self;
	              self.onOpen();
	            },
	            pageAfterIn: function pageAfterIn() {
	              self.onOpened();
	            },
	            pageBeforeOut: function pageBeforeOut() {
	              self.onClose();
	            },
	            pageAfterOut: function pageAfterOut() {
	              self.onClosed();
	              if (self.$el && self.$el[0]) {
	                self.$el[0].f7ColorPicker = null;
	                delete self.$el[0].f7ColorPicker;
	              }
	            },
	          },
	        },
	      });
	    } else {
	      var modalType = self.getModalType();
	      var backdrop = params.backdrop;
	      if (backdrop === null || typeof backdrop === 'undefined') {
	        if (modalType === 'popover' && app.params.popover.backdrop !== false) { backdrop = true; }
	        if (modalType === 'popup') { backdrop = true; }
	      }
	      var modalParams = {
	        targetEl: ($targetEl || $inputEl),
	        scrollToEl: params.scrollToInput ? ($targetEl || $inputEl) : undefined,
	        content: colorPickerContent,
	        backdrop: backdrop,
	        closeByBackdropClick: params.closeByBackdropClick,
	        on: {
	          open: function open() {
	            var modal = this;
	            self.modal = modal;
	            self.$el = modalType === 'popover' || modalType === 'popup' ? modal.$el.find('.color-picker') : modal.$el;
	            self.$el[0].f7ColorPicker = self;
	            self.onOpen();
	          },
	          opened: function opened() { self.onOpened(); },
	          close: function close() { self.onClose(); },
	          closed: function closed() {
	            self.onClosed();
	            if (self.$el && self.$el[0]) {
	              self.$el[0].f7ColorPicker = null;
	              delete self.$el[0].f7ColorPicker;
	            }
	          },
	        },
	      };
	      if (params.routableModals) {
	        self.view.router.navigate({
	          url: self.url,
	          route: ( obj = {
	            path: self.url
	          }, obj[modalType] = modalParams, obj ),
	        });
	      } else {
	        self.modal = app[modalType].create(modalParams);
	        self.modal.open();
	      }
	    }
	  };

	  ColorPicker.prototype.close = function close () {
	    var self = this;
	    var opened = self.opened;
	    var inline = self.inline;
	    if (!opened) { return; }
	    if (inline) {
	      self.onClose();
	      self.onClosed();
	      return;
	    }
	    if (self.params.routableModals) {
	      self.view.router.back();
	    } else {
	      self.modal.close();
	    }
	  };

	  ColorPicker.prototype.init = function init () {
	    var self = this;

	    self.initInput();

	    if (self.inline) {
	      self.open();
	      self.emit('local::init colorPickerInit', self);
	      return;
	    }

	    if (!self.initialized && self.params.value) {
	      self.setValue(self.params.value);
	    }

	    // Attach input Events
	    if (self.$inputEl) {
	      self.attachInputEvents();
	    }
	    if (self.$targetEl) {
	      self.attachTargetEvents();
	    }
	    if (self.params.closeByOutsideClick) {
	      self.attachHtmlEvents();
	    }
	    self.emit('local::init colorPickerInit', self);
	  };

	  ColorPicker.prototype.destroy = function destroy () {
	    var self = this;
	    if (self.destroyed) { return; }
	    var $el = self.$el;
	    self.emit('local::beforeDestroy colorPickerBeforeDestroy', self);
	    if ($el) { $el.trigger('colorpicker:beforedestroy', self); }

	    self.close();

	    // Detach Events
	    self.detachEvents();
	    if (self.$inputEl) {
	      self.detachInputEvents();
	    }
	    if (self.$targetEl) {
	      self.detachTargetEvents();
	    }
	    if (self.params.closeByOutsideClick) {
	      self.detachHtmlEvents();
	    }

	    if ($el && $el.length) { delete self.$el[0].f7ColorPicker; }
	    Utils.deleteProps(self);
	    self.destroyed = true;
	  };

	  return ColorPicker;
	}(Framework7Class));

	var ColorPicker$1 = {
	  name: 'colorPicker',
	  static: {
	    ColorPicker: ColorPicker,
	  },
	  create: function create() {
	    var app = this;
	    app.colorPicker = ConstructorMethods({
	      defaultSelector: '.color-picker',
	      constructor: ColorPicker,
	      app: app,
	      domProp: 'f7ColorPicker',
	    });
	    app.colorPicker.close = function close(el) {
	      if ( el === void 0 ) el = '.color-picker';

	      var $el = $(el);
	      if ($el.length === 0) { return; }
	      var colorPicker = $el[0].f7ColorPicker;
	      if (!colorPicker || (colorPicker && !colorPicker.opened)) { return; }
	      colorPicker.close();
	    };
	  },
	  params: {
	    colorPicker: {
	      // Color picker settings
	      value: null,
	      modules: [
	        'wheel' ],
	      palette: [
	        ['#FFEBEE', '#FFCDD2', '#EF9A9A', '#E57373', '#EF5350', '#F44336', '#E53935', '#D32F2F', '#C62828', '#B71C1C'],
	        ['#F3E5F5', '#E1BEE7', '#CE93D8', '#BA68C8', '#AB47BC', '#9C27B0', '#8E24AA', '#7B1FA2', '#6A1B9A', '#4A148C'],
	        ['#E8EAF6', '#C5CAE9', '#9FA8DA', '#7986CB', '#5C6BC0', '#3F51B5', '#3949AB', '#303F9F', '#283593', '#1A237E'],
	        ['#E1F5FE', '#B3E5FC', '#81D4FA', '#4FC3F7', '#29B6F6', '#03A9F4', '#039BE5', '#0288D1', '#0277BD', '#01579B'],
	        ['#E0F2F1', '#B2DFDB', '#80CBC4', '#4DB6AC', '#26A69A', '#009688', '#00897B', '#00796B', '#00695C', '#004D40'],
	        ['#F1F8E9', '#DCEDC8', '#C5E1A5', '#AED581', '#9CCC65', '#8BC34A', '#7CB342', '#689F38', '#558B2F', '#33691E'],
	        ['#FFFDE7', '#FFF9C4', '#FFF59D', '#FFF176', '#FFEE58', '#FFEB3B', '#FDD835', '#FBC02D', '#F9A825', '#F57F17'],
	        ['#FFF3E0', '#FFE0B2', '#FFCC80', '#FFB74D', '#FFA726', '#FF9800', '#FB8C00', '#F57C00', '#EF6C00', '#E65100'] ],
	      groupedModules: false,
	      centerModules: true,

	      sliderLabel: false,
	      sliderValue: false,
	      sliderValueEdiable: false,

	      barLabel: false,
	      barValue: false,
	      barValueEdiable: false,

	      hexLabel: false,
	      hexValueEditable: false,

	      redLabelText: 'R',
	      greenLabelText: 'G',
	      blueLabelText: 'B',
	      hueLabelText: 'H',
	      saturationLabelText: 'S',
	      brightnessLabelText: 'B',
	      hexLabelText: 'HEX',
	      alphaLabelText: 'A',

	      // Common opener settings
	      containerEl: null,
	      openIn: 'popover', // or 'popover' or 'sheet' or 'popup' or 'page' or 'auto'
	      openInPhone: 'popup', // or 'popover' or 'sheet' or 'popup' or 'page'
	      formatValue: null,
	      targetEl: null,
	      targetElSetBackgroundColor: false,
	      inputEl: null,
	      inputReadOnly: true,
	      closeByOutsideClick: true,
	      scrollToInput: true,
	      toolbarSheet: true,
	      toolbarPopover: false,
	      toolbarCloseText: 'Done',
	      navbarPopup: true,
	      navbarCloseText: 'Done',
	      navbarTitleText: 'Color',
	      navbarBackLinkText: 'Back',
	      cssClass: null,
	      routableModals: true,
	      view: null,
	      url: 'color/',
	      backdrop: null,
	      closeByBackdropClick: true,
	      // Render functions
	      renderToolbar: null,
	      renderNavbar: null,
	      renderInline: null,
	      renderPopover: null,
	      renderSheet: null,
	      renderPopup: null,
	      render: null,
	    },
	  },
	};

	var Treeview = {
	  open: function open(itemEl) {
	    var app = this;
	    var $itemEl = $(itemEl).eq(0);
	    if (!$itemEl.length) { return; }
	    $itemEl.addClass('treeview-item-opened');
	    $itemEl.trigger('treeview:open');
	    app.emit('treeviewOpen', $itemEl[0]);
	    function done() {
	      $itemEl[0].f7TreeviewChildrenLoaded = true;
	      $itemEl.find('.treeview-toggle').removeClass('treeview-toggle-hidden');
	      $itemEl.find('.treeview-preloader').remove();
	    }

	    if ($itemEl.hasClass('treeview-load-children') && !$itemEl[0].f7TreeviewChildrenLoaded) {
	      $itemEl.trigger('treeview:loadchildren', done);
	      app.emit('treeviewLoadChildren', $itemEl[0], done);
	      $itemEl.find('.treeview-toggle').addClass('treeview-toggle-hidden');
	      $itemEl.find('.treeview-item-root').prepend(("<div class=\"preloader treeview-preloader\">" + (Utils[((app.theme) + "PreloaderContent")]) + "</div>"));
	    }
	  },
	  close: function close(itemEl) {
	    var app = this;
	    var $itemEl = $(itemEl).eq(0);
	    if (!$itemEl.length) { return; }
	    $itemEl.removeClass('treeview-item-opened');
	    $itemEl.trigger('treeview:close');
	    app.emit('treeviewClose', $itemEl[0]);
	  },
	  toggle: function toggle(itemEl) {
	    var app = this;
	    var $itemEl = $(itemEl).eq(0);
	    if (!$itemEl.length) { return; }
	    var wasOpened = $itemEl.hasClass('treeview-item-opened');
	    app.treeview[wasOpened ? 'close' : 'open']($itemEl);
	  },
	};

	var Treeview$1 = {
	  name: 'treeview',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      treeview: {
	        open: Treeview.open.bind(app),
	        close: Treeview.close.bind(app),
	        toggle: Treeview.toggle.bind(app),
	      },
	    });
	  },
	  clicks: {
	    '.treeview-toggle': function toggle($clickedEl, clickedData, e) {
	      var app = this;
	      if ($clickedEl.parents('.treeview-item-toggle').length) { return; }
	      var $treeviewItemEl = $clickedEl.parents('.treeview-item').eq(0);
	      if (!$treeviewItemEl.length) { return; }
	      e.preventF7Router = true;
	      app.treeview.toggle($treeviewItemEl[0]);
	    },
	    '.treeview-item-toggle': function toggle($clickedEl, clickedData, e) {
	      var app = this;
	      var $treeviewItemEl = $clickedEl.closest('.treeview-item').eq(0);
	      if (!$treeviewItemEl.length) { return; }
	      e.preventF7Router = true;
	      app.treeview.toggle($treeviewItemEl[0]);
	    },
	  },
	};

	var ViAd = /*@__PURE__*/(function (Framework7Class) {
	  function ViAd(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class.call(this, params, [app]);
	    var vi = this;
	    if (!win.vi) {
	      throw new Error('Framework7: vi SDK not found.');
	    }

	    var orientation;
	    if (typeof win.orientation !== 'undefined') {
	      orientation = win.orientation === -90 || win.orientation === 90 ? 'horizontal' : 'vertical';
	    }
	    var defaults = Utils.extend(
	      {},
	      app.params.vi,
	      {
	        appId: app.id,
	        appVer: app.version,
	        language: app.language,
	        width: app.width,
	        height: app.height,
	        os: Device.os,
	        osVersion: Device.osVersion,
	        orientation: orientation,
	      }
	    );

	    // Extend defaults with modules params
	    vi.useModulesParams(defaults);

	    vi.params = Utils.extend(defaults, params);

	    var adParams = {};
	    var skipParams = ('on autoplay fallbackOverlay fallbackOverlayText enabled').split(' ');
	    Object.keys(vi.params).forEach(function (paramName) {
	      if (skipParams.indexOf(paramName) >= 0) { return; }
	      var paramValue = vi.params[paramName];
	      if ([null, undefined].indexOf(paramValue) >= 0) { return; }
	      adParams[paramName] = paramValue;
	    });

	    if (!vi.params.appId) {
	      throw new Error('Framework7: "app.id" is required to display an ad. Make sure you have specified it on app initialization.');
	    }
	    if (!vi.params.placementId) {
	      throw new Error('Framework7: "placementId" is required to display an ad.');
	    }

	    function onResize() {
	      var $viFrame = $('iframe#viAd');
	      if ($viFrame.length === 0) { return; }
	      $viFrame
	        .css({
	          width: ((app.width) + "px"),
	          height: ((app.height) + "px"),
	        });
	    }

	    function removeOverlay() {
	      if (!vi.$overlayEl) { return; }
	      vi.$overlayEl.off('click touchstart');
	      vi.$overlayEl.remove();
	    }
	    function createOverlay(videoEl) {
	      if (!videoEl) { return; }
	      vi.$overlayEl = $(("\n        <div class=\"vi-overlay no-fastclick\">\n          " + (vi.params.fallbackOverlayText ? ("<div class=\"vi-overlay-text\">" + (vi.params.fallbackOverlayText) + "</div>") : '') + "\n          <div class=\"vi-overlay-play-button\"></div>\n        </div>\n      ").trim());

	      var touchStartTime;
	      vi.$overlayEl.on('touchstart', function () {
	        touchStartTime = Utils.now();
	      });
	      vi.$overlayEl.on('click', function () {
	        var timeDiff = Utils.now() - touchStartTime;
	        if (timeDiff > 300) { return; }
	        if (videoEl) {
	          videoEl.play();
	          removeOverlay();
	          return;
	        }
	        vi.start();
	        removeOverlay();
	      });
	      app.root.append(vi.$overlayEl);
	    }

	    // Create ad
	    vi.ad = new win.vi.Ad(adParams);

	    Utils.extend(vi.ad, {
	      onAdReady: function onAdReady() {
	        app.on('resize', onResize);
	        vi.emit('local::ready');
	        if (vi.params.autoplay) {
	          vi.start();
	        }
	      },
	      onAdStarted: function onAdStarted() {
	        vi.emit('local::started');
	      },
	      onAdClick: function onAdClick(targetUrl) {
	        vi.emit('local::click', targetUrl);
	      },
	      onAdImpression: function onAdImpression() {
	        vi.emit('local::impression');
	      },
	      onAdStopped: function onAdStopped(reason) {
	        app.off('resize', onResize);
	        removeOverlay();

	        vi.emit('local::stopped', reason);
	        if (reason === 'complete') {
	          vi.emit('local::complete');
	          vi.emit('local::completed');
	        }
	        if (reason === 'userexit') {
	          vi.emit('local::userexit');
	        }
	        vi.destroyed = true;
	      },
	      onAutoPlayFailed: function onAutoPlayFailed(reason, videoEl) {
	        vi.emit('local::autoplayFailed', reason, videoEl);
	        if (reason && reason.name && reason.name.indexOf('NotAllowedError') !== -1 && vi.params.fallbackOverlay) {
	          createOverlay(videoEl);
	        }
	      },
	      onAdError: function onAdError(msg) {
	        removeOverlay();
	        app.off('resize', onResize);
	        vi.emit('local::error', msg);
	        vi.destroyed = true;
	      },
	    });

	    vi.init();

	    Utils.extend(vi, {
	      app: app,
	    });
	  }

	  if ( Framework7Class ) ViAd.__proto__ = Framework7Class;
	  ViAd.prototype = Object.create( Framework7Class && Framework7Class.prototype );
	  ViAd.prototype.constructor = ViAd;

	  ViAd.prototype.start = function start () {
	    var vi = this;
	    if (vi.destroyed) { return; }
	    if (vi.ad) { vi.ad.startAd(); }
	  };

	  ViAd.prototype.pause = function pause () {
	    var vi = this;
	    if (vi.destroyed) { return; }
	    if (vi.ad) { vi.ad.pauseAd(); }
	  };

	  ViAd.prototype.resume = function resume () {
	    var vi = this;
	    if (vi.destroyed) { return; }
	    if (vi.ad) { vi.ad.resumeAd(); }
	  };

	  ViAd.prototype.stop = function stop () {
	    var vi = this;
	    if (vi.destroyed) { return; }
	    if (vi.ad) { vi.ad.stopAd(); }
	  };

	  ViAd.prototype.init = function init () {
	    var vi = this;
	    if (vi.destroyed) { return; }
	    if (vi.ad) { vi.ad.initAd(); }
	  };

	  ViAd.prototype.destroy = function destroy () {
	    var vi = this;
	    vi.destroyed = true;
	    vi.emit('local::beforeDestroy');
	    Utils.deleteProps(vi);
	  };

	  return ViAd;
	}(Framework7Class));

	var Vi = {
	  name: 'vi',
	  params: {
	    vi: {
	      enabled: false,
	      autoplay: true,
	      fallbackOverlay: true,
	      fallbackOverlayText: 'Please watch this ad',
	      showMute: true,
	      startMuted: (Device.ios || Device.android) && !Device.cordova,
	      appId: null,
	      appVer: null,
	      language: null,
	      width: null,
	      height: null,
	      placementId: 'pltd4o7ibb9rc653x14',
	      placementType: 'interstitial',
	      videoSlot: null,
	      showProgress: true,
	      showBranding: true,
	      os: null,
	      osVersion: null,
	      orientation: null,
	      age: null,
	      gender: null,
	      advertiserId: null,
	      latitude: null,
	      longitude: null,
	      accuracy: null,
	      storeId: null,
	      ip: null,
	      manufacturer: null,
	      model: null,
	      connectionType: null,
	      connectionProvider: null,
	    },
	  },
	  create: function create() {
	    var app = this;
	    app.vi = {
	      sdkReady: false,
	      createAd: function createAd(adParams) {
	        return new ViAd(app, adParams);
	      },
	      loadSdk: function loadSdk() {
	        if (app.vi.sdkReady) { return; }
	        var script = doc.createElement('script');
	        script.onload = function onload() {
	          app.emit('viSdkReady');
	          app.vi.sdkReady = true;
	        };
	        script.src = 'https://c.vi-serve.com/viadshtml/vi.min.js';
	        $('head').append(script);
	      },
	    };
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      if (app.params.vi.enabled || (app.passedParams.vi && app.passedParams.vi.enabled !== false)) { app.vi.loadSdk(); }
	    },
	  },
	};

	var Elevation = {
	  name: 'elevation',
	};

	var Typography = {
	  name: 'typography',
	};

	/**
	 * Framework7 4.4.0
	 * Full featured mobile HTML framework for building iOS & Android apps
	 * http://framework7.io/
	 *
	 * Copyright 2014-2019 Vladimir Kharlampidi
	 *
	 * Released under the MIT License
	 *
	 * Released on: June 6, 2019
	 */

	// Install Core Modules & Components
	Router.use([
	  RouterTemplateLoaderModule,
	  RouterComponentLoaderModule ]);

	Framework7.use([
	  DeviceModule,
	  SupportModule,
	  UtilsModule,
	  ResizeModule,
	  RequestModule,
	  TouchModule,
	  ClicksModule,
	  RouterModule,
	  HistoryModule,
	  StorageModule,
	  ComponentModule,
	  ServiceWorkerModule,
	  Statusbar$1,
	  View$1,
	  Navbar$1,
	  Toolbar$1,
	  Subnavbar,
	  TouchRipple$1,
	  Modal$1,
	  Appbar,
	  Dialog$1,
	  Popup$1,
	  LoginScreen$1,
	  Popover$1,
	  Actions$1,
	  Sheet$1,
	  Toast$1,
	  Preloader$1,
	  Progressbar$1,
	  Sortable$1,
	  Swipeout$1,
	  Accordion$1,
	  ContactsList,
	  VirtualList$1,
	  ListIndex$1,
	  Timeline,
	  Tabs,
	  Panel$1,
	  Card,
	  Chip,
	  Form,
	  Input$1,
	  Checkbox,
	  Radio,
	  Toggle$1,
	  Range$1,
	  Stepper$1,
	  SmartSelect$1,
	  Grid,
	  Calendar$1,
	  Picker$1,
	  InfiniteScroll$1,
	  PullToRefresh$1,
	  Lazy$1,
	  DataTable$1,
	  Fab$1,
	  Searchbar$1,
	  Messages$1,
	  Messagebar$1,
	  Swiper$1,
	  PhotoBrowser$1,
	  Notification$1,
	  Autocomplete$1,
	  Tooltip$1,
	  Gauge$1,
	  Skeleton,
	  Menu$1,
	  ColorPicker$1,
	  Treeview$1,
	  Vi,
	  Elevation,
	  Typography
	]);

	var Utils$1 = {
	  noUndefinedProps: function noUndefinedProps(obj) {
	    var o = {};
	    Object.keys(obj).forEach(function (key) {
	      if (typeof obj[key] !== 'undefined') { o[key] = obj[key]; }
	    });
	    return o;
	  },
	  isTrueProp: function isTrueProp(val) {
	    return val === true || val === '';
	  },
	  isStringProp: function isStringProp(val) {
	    return typeof val === 'string' && val !== '';
	  },
	  isObject: function isObject(o) {
	    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
	  },
	  now: function now() {
	    return Date.now();
	  },
	  extend: function extend() {
	    var assign, assign$1;

	    var args = [], len$1 = arguments.length;
	    while ( len$1-- ) args[ len$1 ] = arguments[ len$1 ];
	    var deep = true;
	    var to;
	    var from;
	    if (typeof args[0] === 'boolean') {
	      (assign = args, deep = assign[0], to = assign[1]);
	      args.splice(0, 2);
	      from = args;
	    } else {
	      (assign$1 = args, to = assign$1[0]);
	      args.splice(0, 1);
	      from = args;
	    }
	    for (var i = 0; i < from.length; i += 1) {
	      var nextSource = args[i];
	      if (nextSource !== undefined && nextSource !== null) {
	        var keysArray = Object.keys(Object(nextSource));
	        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
	          var nextKey = keysArray[nextIndex];
	          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
	          if (desc !== undefined && desc.enumerable) {
	            if (!deep) {
	              to[nextKey] = nextSource[nextKey];
	            } else if (Utils$1.isObject(to[nextKey]) && Utils$1.isObject(nextSource[nextKey])) {
	              Utils$1.extend(to[nextKey], nextSource[nextKey]);
	            } else if (!Utils$1.isObject(to[nextKey]) && Utils$1.isObject(nextSource[nextKey])) {
	              to[nextKey] = {};
	              Utils$1.extend(to[nextKey], nextSource[nextKey]);
	            } else {
	              to[nextKey] = nextSource[nextKey];
	            }
	          }
	        }
	      }
	    }
	    return to;
	  },
	  flattenArray: function flattenArray() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var arr = [];
	    args.forEach(function (arg) {
	      if (Array.isArray(arg)) { arr.push.apply(arr, Utils$1.flattenArray.apply(Utils$1, arg)); }
	      else { arr.push(arg); }
	    });
	    return arr;
	  },
	  classNames: function classNames() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var classes = [];
	    args.forEach(function (arg) {
	      if (typeof arg === 'object' && arg.constructor === Object) {
	        Object.keys(arg).forEach(function (key) {
	          if (arg[key]) { classes.push(key); }
	        });
	      } else if (arg) { classes.push(arg); }
	    });
	    var uniqueClasses = [];
	    classes.forEach(function (c) {
	      if (uniqueClasses.indexOf(c) < 0) { uniqueClasses.push(c); }
	    });
	    return uniqueClasses.join(' ');
	  },
	  bindMethods: function bindMethods(context, methods) {
	    if ( methods === void 0 ) methods = [];

	    for (var i = 0; i < methods.length; i += 1) {
	      if (context[methods[i]]) { context[methods[i]] = context[methods[i]].bind(context); }
	    }
	  },
	};

	var Mixins = {
	  colorProps: {
	    color: String,
	    colorTheme: String,
	    textColor: String,
	    bgColor: String,
	    borderColor: String,
	    rippleColor: String,
	    themeDark: Boolean,
	  },
	  colorClasses: function colorClasses(props) {
	    var obj;

	    var color = props.color;
	    var colorTheme = props.colorTheme;
	    var textColor = props.textColor;
	    var bgColor = props.bgColor;
	    var borderColor = props.borderColor;
	    var rippleColor = props.rippleColor;
	    var themeDark = props.themeDark;

	    return ( obj = {
	      'theme-dark': themeDark
	    }, obj[("color-" + color)] = color, obj[("color-theme-" + colorTheme)] = colorTheme, obj[("text-color-" + textColor)] = textColor, obj[("bg-color-" + bgColor)] = bgColor, obj[("border-color-" + borderColor)] = borderColor, obj[("ripple-color-" + rippleColor)] = rippleColor, obj );
	  },
	  linkIconProps: {
	    icon: String,
	    iconMaterial: String,
	    iconIon: String,
	    iconFa: String,
	    iconF7: String,
	    iconIos: String,
	    iconMd: String,
	    iconAurora: String,
	    iconColor: String,
	    iconSize: [String, Number],
	  },
	  linkRouterProps: {
	    back: Boolean,
	    external: Boolean,
	    force: Boolean,
	    animate: {
	      type: Boolean,
	      default: undefined,
	    },
	    ignoreCache: Boolean,
	    reloadCurrent: Boolean,
	    reloadAll: Boolean,
	    reloadPrevious: Boolean,
	    reloadDetail: {
	      type: Boolean,
	      default: undefined,
	    },
	    routeTabId: String,
	    view: String,
	    routeProps: Object,
	    preventRouter: Boolean,
	  },
	  linkRouterAttrs: function linkRouterAttrs(props) {
	    var force = props.force;
	    var reloadCurrent = props.reloadCurrent;
	    var reloadPrevious = props.reloadPrevious;
	    var reloadAll = props.reloadAll;
	    var reloadDetail = props.reloadDetail;
	    var animate = props.animate;
	    var ignoreCache = props.ignoreCache;
	    var routeTabId = props.routeTabId;
	    var view = props.view;

	    var dataAnimate;
	    if ('animate' in props && typeof animate !== 'undefined') {
	      dataAnimate = animate.toString();
	    }

	    var dataReloadDetail;
	    if ('reloadDetail' in props && typeof reloadDetail !== 'undefined') {
	      dataReloadDetail = reloadDetail.toString();
	    }

	    return {
	      'data-force': force || undefined,
	      'data-reload-current': reloadCurrent || undefined,
	      'data-reload-all': reloadAll || undefined,
	      'data-reload-previous': reloadPrevious || undefined,
	      'data-reload-detail': dataReloadDetail,
	      'data-animate': dataAnimate,
	      'data-ignore-cache': ignoreCache || undefined,
	      'data-route-tab-id': routeTabId || undefined,
	      'data-view': Utils$1.isStringProp(view) ? view : undefined,
	    };
	  },
	  linkRouterClasses: function linkRouterClasses(props) {
	    var back = props.back;
	    var linkBack = props.linkBack;
	    var external = props.external;
	    var preventRouter = props.preventRouter;

	    return {
	      back: back || linkBack,
	      external: external,
	      'prevent-router': preventRouter,
	    };
	  },
	  linkActionsProps: {
	    searchbarEnable: [Boolean, String],
	    searchbarDisable: [Boolean, String],

	    searchbarClear: [Boolean, String],
	    searchbarToggle: [Boolean, String],

	    // Panel
	    panelOpen: [Boolean, String],
	    panelClose: [Boolean, String],
	    panelToggle: [Boolean, String],

	    // Popup
	    popupOpen: [Boolean, String],
	    popupClose: [Boolean, String],

	    // Actions
	    actionsOpen: [Boolean, String],
	    actionsClose: [Boolean, String],

	    // Popover
	    popoverOpen: [Boolean, String],
	    popoverClose: [Boolean, String],

	    // Login Screen
	    loginScreenOpen: [Boolean, String],
	    loginScreenClose: [Boolean, String],

	    // Picker
	    sheetOpen: [Boolean, String],
	    sheetClose: [Boolean, String],

	    // Sortable
	    sortableEnable: [Boolean, String],
	    sortableDisable: [Boolean, String],
	    sortableToggle: [Boolean, String],

	    // Card
	    cardOpen: [Boolean, String],
	    cardPreventOpen: [Boolean, String],
	    cardClose: [Boolean, String],

	    // Menu
	    menuClose: {
	      type: [Boolean, String],
	      default: undefined,
	    },
	  },
	  linkActionsAttrs: function linkActionsAttrs(props) {
	    var searchbarEnable = props.searchbarEnable;
	    var searchbarDisable = props.searchbarDisable;
	    var searchbarClear = props.searchbarClear;
	    var searchbarToggle = props.searchbarToggle;
	    var panelOpen = props.panelOpen;
	    var panelClose = props.panelClose;
	    var panelToggle = props.panelToggle;
	    var popupOpen = props.popupOpen;
	    var popupClose = props.popupClose;
	    var actionsOpen = props.actionsOpen;
	    var actionsClose = props.actionsClose;
	    var popoverOpen = props.popoverOpen;
	    var popoverClose = props.popoverClose;
	    var loginScreenOpen = props.loginScreenOpen;
	    var loginScreenClose = props.loginScreenClose;
	    var sheetOpen = props.sheetOpen;
	    var sheetClose = props.sheetClose;
	    var sortableEnable = props.sortableEnable;
	    var sortableDisable = props.sortableDisable;
	    var sortableToggle = props.sortableToggle;
	    var cardOpen = props.cardOpen;
	    var cardClose = props.cardClose;

	    return {
	      'data-searchbar': (Utils$1.isStringProp(searchbarEnable) && searchbarEnable)
	                        || (Utils$1.isStringProp(searchbarDisable) && searchbarDisable)
	                        || (Utils$1.isStringProp(searchbarClear) && searchbarClear)
	                        || (Utils$1.isStringProp(searchbarToggle) && searchbarToggle) || undefined,
	      'data-panel': (Utils$1.isStringProp(panelOpen) && panelOpen)
	                    || (Utils$1.isStringProp(panelClose) && panelClose)
	                    || (Utils$1.isStringProp(panelToggle) && panelToggle) || undefined,
	      'data-popup': (Utils$1.isStringProp(popupOpen) && popupOpen)
	                    || (Utils$1.isStringProp(popupClose) && popupClose) || undefined,
	      'data-actions': (Utils$1.isStringProp(actionsOpen) && actionsOpen)
	                    || (Utils$1.isStringProp(actionsClose) && actionsClose) || undefined,
	      'data-popover': (Utils$1.isStringProp(popoverOpen) && popoverOpen)
	                      || (Utils$1.isStringProp(popoverClose) && popoverClose) || undefined,
	      'data-sheet': (Utils$1.isStringProp(sheetOpen) && sheetOpen)
	                    || (Utils$1.isStringProp(sheetClose) && sheetClose) || undefined,
	      'data-login-screen': (Utils$1.isStringProp(loginScreenOpen) && loginScreenOpen)
	                           || (Utils$1.isStringProp(loginScreenClose) && loginScreenClose) || undefined,
	      'data-sortable': (Utils$1.isStringProp(sortableEnable) && sortableEnable)
	                       || (Utils$1.isStringProp(sortableDisable) && sortableDisable)
	                       || (Utils$1.isStringProp(sortableToggle) && sortableToggle) || undefined,
	      'data-card': (Utils$1.isStringProp(cardOpen) && cardOpen)
	                    || (Utils$1.isStringProp(cardClose) && cardClose) || undefined,
	    };
	  },
	  linkActionsClasses: function linkActionsClasses(props) {
	    var searchbarEnable = props.searchbarEnable;
	    var searchbarDisable = props.searchbarDisable;
	    var searchbarClear = props.searchbarClear;
	    var searchbarToggle = props.searchbarToggle;
	    var panelOpen = props.panelOpen;
	    var panelClose = props.panelClose;
	    var panelToggle = props.panelToggle;
	    var popupOpen = props.popupOpen;
	    var popupClose = props.popupClose;
	    var actionsClose = props.actionsClose;
	    var actionsOpen = props.actionsOpen;
	    var popoverOpen = props.popoverOpen;
	    var popoverClose = props.popoverClose;
	    var loginScreenOpen = props.loginScreenOpen;
	    var loginScreenClose = props.loginScreenClose;
	    var sheetOpen = props.sheetOpen;
	    var sheetClose = props.sheetClose;
	    var sortableEnable = props.sortableEnable;
	    var sortableDisable = props.sortableDisable;
	    var sortableToggle = props.sortableToggle;
	    var cardOpen = props.cardOpen;
	    var cardPreventOpen = props.cardPreventOpen;
	    var cardClose = props.cardClose;
	    var menuClose = props.menuClose;

	    return {
	      'searchbar-enable': searchbarEnable || searchbarEnable === '',
	      'searchbar-disable': searchbarDisable || searchbarDisable === '',
	      'searchbar-clear': searchbarClear || searchbarClear === '',
	      'searchbar-toggle': searchbarToggle || searchbarToggle === '',
	      'panel-close': panelClose || panelClose === '',
	      'panel-open': panelOpen || panelOpen === '',
	      'panel-toggle': panelToggle || panelToggle === '',
	      'popup-close': popupClose || popupClose === '',
	      'popup-open': popupOpen || popupOpen === '',
	      'actions-close': actionsClose || actionsClose === '',
	      'actions-open': actionsOpen || actionsOpen === '',
	      'popover-close': popoverClose || popoverClose === '',
	      'popover-open': popoverOpen || popoverOpen === '',
	      'sheet-close': sheetClose || sheetClose === '',
	      'sheet-open': sheetOpen || sheetOpen === '',
	      'login-screen-close': loginScreenClose || loginScreenClose === '',
	      'login-screen-open': loginScreenOpen || loginScreenOpen === '',
	      'sortable-enable': sortableEnable || sortableEnable === '',
	      'sortable-disable': sortableDisable || sortableDisable === '',
	      'sortable-toggle': sortableToggle || sortableToggle === '',
	      'card-close': cardClose || cardClose === '',
	      'card-open': cardOpen || cardOpen === '',
	      'card-prevent-open': cardPreventOpen || cardPreventOpen === '',
	      'menu-close': menuClose || menuClose === '',
	    };
	  },
	};

	function __reactComponentSlots (props) {
	  var slots = {};
	  if (!props) { return slots; }
	  var children = props.children;

	  if (!children || children.length === 0) {
	    return slots;
	  }

	  function addChildToSlot(name, child) {
	    if (!slots[name]) { slots[name] = []; }
	    slots[name].push(child);
	  }

	  if (Array.isArray(children)) {
	    children.forEach(function (child) {
	      if (!child) { return; }
	      var slotName = (child.props && child.props.slot) || 'default';
	      addChildToSlot(slotName, child);
	    });
	  } else {
	    var slotName = 'default';
	    if (children.props && children.props.slot) { slotName = children.props.slot; }
	    addChildToSlot(slotName, children);
	  }

	  return slots;
	}

	var reactIs_development = createCommonjsModule(function (module, exports) {



	{
	  (function() {

	Object.defineProperty(exports, '__esModule', { value: true });

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;

	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;

	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' ||
	  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
	}

	/**
	 * Forked from fbjs/warning:
	 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
	 *
	 * Only change is we use console.warn instead of console.error,
	 * and do nothing when 'console' is not supported.
	 * This really simplifies the code.
	 * ---
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var lowPriorityWarning = function () {};

	{
	  var printWarning = function (format) {
	    var arguments$1 = arguments;

	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments$1[_key];
	    }

	    var argIndex = 0;
	    var message = 'Warning: ' + format.replace(/%s/g, function () {
	      return args[argIndex++];
	    });
	    if (typeof console !== 'undefined') {
	      console.warn(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };

	  lowPriorityWarning = function (condition, format) {
	    var arguments$1 = arguments;

	    if (format === undefined) {
	      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	    if (!condition) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	        args[_key2 - 2] = arguments$1[_key2];
	      }

	      printWarning.apply(undefined, [format].concat(args));
	    }
	  };
	}

	var lowPriorityWarning$1 = lowPriorityWarning;

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;
	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_ASYNC_MODE_TYPE:
	          case REACT_CONCURRENT_MODE_TYPE:
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	            return type;
	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;
	              default:
	                return $$typeof;
	            }
	        }
	      case REACT_LAZY_TYPE:
	      case REACT_MEMO_TYPE:
	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	}

	// AsyncMode is deprecated along with isAsyncMode
	var AsyncMode = REACT_ASYNC_MODE_TYPE;
	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;

	var hasWarnedAboutDeprecatedIsAsyncMode = false;

	// AsyncMode should be deprecated
	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true;
	      lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	    }
	  }
	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	}
	function isConcurrentMode(object) {
	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}

	exports.typeOf = typeOf;
	exports.AsyncMode = AsyncMode;
	exports.ConcurrentMode = ConcurrentMode;
	exports.ContextConsumer = ContextConsumer;
	exports.ContextProvider = ContextProvider;
	exports.Element = Element;
	exports.ForwardRef = ForwardRef;
	exports.Fragment = Fragment;
	exports.Lazy = Lazy;
	exports.Memo = Memo;
	exports.Portal = Portal;
	exports.Profiler = Profiler;
	exports.StrictMode = StrictMode;
	exports.Suspense = Suspense;
	exports.isValidElementType = isValidElementType;
	exports.isAsyncMode = isAsyncMode;
	exports.isConcurrentMode = isConcurrentMode;
	exports.isContextConsumer = isContextConsumer;
	exports.isContextProvider = isContextProvider;
	exports.isElement = isElement;
	exports.isForwardRef = isForwardRef;
	exports.isFragment = isFragment;
	exports.isLazy = isLazy;
	exports.isMemo = isMemo;
	exports.isPortal = isPortal;
	exports.isProfiler = isProfiler;
	exports.isStrictMode = isStrictMode;
	exports.isSuspense = isSuspense;
	  })();
	}
	});

	unwrapExports(reactIs_development);
	var reactIs_development_1 = reactIs_development.typeOf;
	var reactIs_development_2 = reactIs_development.AsyncMode;
	var reactIs_development_3 = reactIs_development.ConcurrentMode;
	var reactIs_development_4 = reactIs_development.ContextConsumer;
	var reactIs_development_5 = reactIs_development.ContextProvider;
	var reactIs_development_6 = reactIs_development.Element;
	var reactIs_development_7 = reactIs_development.ForwardRef;
	var reactIs_development_8 = reactIs_development.Fragment;
	var reactIs_development_9 = reactIs_development.Lazy;
	var reactIs_development_10 = reactIs_development.Memo;
	var reactIs_development_11 = reactIs_development.Portal;
	var reactIs_development_12 = reactIs_development.Profiler;
	var reactIs_development_13 = reactIs_development.StrictMode;
	var reactIs_development_14 = reactIs_development.Suspense;
	var reactIs_development_15 = reactIs_development.isValidElementType;
	var reactIs_development_16 = reactIs_development.isAsyncMode;
	var reactIs_development_17 = reactIs_development.isConcurrentMode;
	var reactIs_development_18 = reactIs_development.isContextConsumer;
	var reactIs_development_19 = reactIs_development.isContextProvider;
	var reactIs_development_20 = reactIs_development.isElement;
	var reactIs_development_21 = reactIs_development.isForwardRef;
	var reactIs_development_22 = reactIs_development.isFragment;
	var reactIs_development_23 = reactIs_development.isLazy;
	var reactIs_development_24 = reactIs_development.isMemo;
	var reactIs_development_25 = reactIs_development.isPortal;
	var reactIs_development_26 = reactIs_development.isProfiler;
	var reactIs_development_27 = reactIs_development.isStrictMode;
	var reactIs_development_28 = reactIs_development.isSuspense;

	var reactIs = createCommonjsModule(function (module) {

	{
	  module.exports = reactIs_development;
	}
	});

	var has$1 = Function.call.bind(Object.prototype.hasOwnProperty);
	var printWarning$1 = function() {};

	{
	  printWarning$1 = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	function emptyFunctionThatReturnsNull() {
	  return null;
	}

	var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),

	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    elementType: createElementTypeTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker,
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message) {
	    this.message = message;
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret_1) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          var err = new Error(
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	          err.name = 'Invariant Violation';
	          throw err;
	        } else if (typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            printWarning$1(
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);

	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);

	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!reactIs.isValidElementType(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      {
	        if (arguments.length > 1) {
	          printWarning$1(
	            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
	            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
	          );
	        } else {
	          printWarning$1('Invalid argument supplied to oneOf, expected an array.');
	        }
	      }
	      return emptyFunctionThatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
	        var type = getPreciseType(value);
	        if (type === 'symbol') {
	          return String(value);
	        }
	        return value;
	      });
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (has$1(propValue, key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      printWarning$1('Invalid argument supplied to oneOfType, expected an instance of array.');
	      return emptyFunctionThatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        printWarning$1(
	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
	          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
	        );
	        return emptyFunctionThatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
	          return null;
	        }
	      }

	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          continue;
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from
	      // props.
	      var allKeys = objectAssign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          return new PropTypeError(
	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
	            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
	          );
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;
	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // falsy value can't be a Symbol
	    if (!propValue) {
	      return false;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes_1;
	  ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};

	var propTypes = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	{
	  var ReactIs = reactIs;

	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
	}
	});

	function __reactComponentSetProps (component, props) {
	  var propType = function (type) {
	    if (type === String) { return propTypes.string; }
	    if (type === Boolean) { return propTypes.bool; }
	    if (type === Function) { return propTypes.func; }
	    if (type === Number) { return propTypes.number; }
	    if (type === Object) { return propTypes.object; }
	    if (type === Array) { return propTypes.array; }
	    if (type === Symbol) { return propTypes.symbol; }
	    if (type.constructor === Function || type === Date) { return propTypes.instanceOf(type); }
	    return propTypes.any;
	  };

	  component.propTypes = {};

	  Object.keys(props).forEach(function (propName) {
	    var prop = props[propName];
	    var required = typeof prop.required !== 'undefined';
	    var type = prop.type || prop;

	    if (Array.isArray(type)) {
	      if (required) {
	        component.propTypes[propName] = propTypes.oneOfType(type.map(propType)).required;
	      } else {
	        component.propTypes[propName] = propTypes.oneOfType(type.map(propType));
	      }
	    } else if (required) {
	      component.propTypes[propName] = propType(type).required;
	    } else {
	      component.propTypes[propName] = propType(type);
	    }

	    if (
	      (typeof prop.default !== 'undefined')
	      || (('default' in prop) && prop.default === undefined)
	    ) {
	      var hasFunctionType = prop.type === Function
	        || (Array.isArray(prop.type) && prop.type.indexOf(Function) >= 0);
	      if (!component.defaultProps) { component.defaultProps = {}; }
	      if (typeof prop.default === 'function' && !hasFunctionType) {
	        component.defaultProps[propName] = prop.default();
	      } else {
	        component.defaultProps[propName] = prop.default;
	      }
	    }
	  });
	}

	var F7AccordionContent = /*@__PURE__*/(function (superclass) {
	  function F7AccordionContent(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7AccordionContent.__proto__ = superclass;
	  F7AccordionContent.prototype = Object.create( superclass && superclass.prototype );
	  F7AccordionContent.prototype.constructor = F7AccordionContent;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7AccordionContent.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'accordion-item-content', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7AccordionContent.prototype, prototypeAccessors );

	  return F7AccordionContent;
	}(react.Component));

	__reactComponentSetProps(F7AccordionContent, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7AccordionContent.displayName = 'f7-accordion-content';

	function __reactComponentDispatchEvent (component, events) {
	  var args = [], len = arguments.length - 2;
	  while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];

	  var self = component;

	  if (!events || !events.trim().length || typeof events !== 'string') { return; }

	  events.trim().split(' ').forEach(function (event) {
	    var ref;

	    var eventName = (event || '').trim();
	    if (!eventName) { return; }
	    eventName = eventName.charAt(0).toUpperCase() + eventName.slice(1);

	    var propName = "on" + eventName;

	    if (self.props[propName]) { (ref = self.props)[propName].apply(ref, args); }
	  });
	}

	var F7AccordionItem = /*@__PURE__*/(function (superclass) {
	  function F7AccordionItem(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, 'onBeforeOpen onOpen onOpened onBeforeClose onClose onClosed'.split(' '));
	    })();
	  }

	  if ( superclass ) F7AccordionItem.__proto__ = superclass;
	  F7AccordionItem.prototype = Object.create( superclass && superclass.prototype );
	  F7AccordionItem.prototype.constructor = F7AccordionItem;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7AccordionItem.prototype.onBeforeOpen = function onBeforeOpen (event) {
	    this.dispatchEvent('accordionBeforeOpen accordion:beforeopen', event, event.detail.prevent);
	  };

	  F7AccordionItem.prototype.onOpen = function onOpen (event) {
	    this.dispatchEvent('accordionOpen accordion:open', event);
	  };

	  F7AccordionItem.prototype.onOpened = function onOpened (event) {
	    this.dispatchEvent('accordionOpened accordion:opened', event);
	  };

	  F7AccordionItem.prototype.onBeforeClose = function onBeforeClose (event) {
	    this.dispatchEvent('accordionBeforeClose accordion:beforeclose', event, event.detail.prevent);
	  };

	  F7AccordionItem.prototype.onClose = function onClose (event) {
	    this.dispatchEvent('accordionClose accordion:close', event);
	  };

	  F7AccordionItem.prototype.onClosed = function onClosed (event) {
	    this.dispatchEvent('accordionClosed accordion:closed', event);
	  };

	  F7AccordionItem.prototype.render = function render () {
	    var this$1 = this;

	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var opened = props.opened;
	    var classes = Utils$1.classNames(className, 'accordion-item', {
	      'accordion-item-opened': opened
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes,
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      }
	    }, this.slots['default']);
	  };

	  F7AccordionItem.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.removeEventListener('accordion:beforeopen', self.onBeforeOpen);
	    el.removeEventListener('accordion:open', self.onOpen);
	    el.removeEventListener('accordion:opened', self.onOpened);
	    el.removeEventListener('accordion:beforeclose', self.onBeforeClose);
	    el.removeEventListener('accordion:close', self.onClose);
	    el.removeEventListener('accordion:closed', self.onClosed);
	  };

	  F7AccordionItem.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.addEventListener('accordion:beforeopen', self.onBeforeOpen);
	    el.addEventListener('accordion:open', self.onOpen);
	    el.addEventListener('accordion:opened', self.onOpened);
	    el.addEventListener('accordion:beforeclose', self.onBeforeClose);
	    el.addEventListener('accordion:close', self.onClose);
	    el.addEventListener('accordion:closed', self.onClosed);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7AccordionItem.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7AccordionItem.prototype, prototypeAccessors );

	  return F7AccordionItem;
	}(react.Component));

	__reactComponentSetProps(F7AccordionItem, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  opened: Boolean
	}, Mixins.colorProps));

	F7AccordionItem.displayName = 'f7-accordion-item';

	var F7AccordionToggle = /*@__PURE__*/(function (superclass) {
	  function F7AccordionToggle(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7AccordionToggle.__proto__ = superclass;
	  F7AccordionToggle.prototype = Object.create( superclass && superclass.prototype );
	  F7AccordionToggle.prototype.constructor = F7AccordionToggle;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7AccordionToggle.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'accordion-item-toggle', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7AccordionToggle.prototype, prototypeAccessors );

	  return F7AccordionToggle;
	}(react.Component));

	__reactComponentSetProps(F7AccordionToggle, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7AccordionToggle.displayName = 'f7-accordion-toggle';

	var F7Accordion = /*@__PURE__*/(function (superclass) {
	  function F7Accordion(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7Accordion.__proto__ = superclass;
	  F7Accordion.prototype = Object.create( superclass && superclass.prototype );
	  F7Accordion.prototype.constructor = F7Accordion;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7Accordion.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'accordion-list', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7Accordion.prototype, prototypeAccessors );

	  return F7Accordion;
	}(react.Component));

	__reactComponentSetProps(F7Accordion, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7Accordion.displayName = 'f7-accordion';

	var F7ActionsButton = /*@__PURE__*/(function (superclass) {
	  function F7ActionsButton(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick']);
	    })();
	  }

	  if ( superclass ) F7ActionsButton.__proto__ = superclass;
	  F7ActionsButton.prototype = Object.create( superclass && superclass.prototype );
	  F7ActionsButton.prototype.constructor = F7ActionsButton;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7ActionsButton.prototype.onClick = function onClick (event) {
	    var self = this;
	    var $$ = self.$$;
	    var el = self.refs.el;

	    if (self.props.close && self.$f7 && el) {
	      self.$f7.actions.close($$(el).parents('.actions-modal'));
	    }

	    self.dispatchEvent('click', event);
	  };

	  F7ActionsButton.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var className = props.className;
	    var style = props.style;
	    var bold = props.bold;
	    var mediaEl;

	    if (self.slots.media && self.slots.media.length) {
	      mediaEl = react.createElement('div', {
	        className: 'actions-button-media'
	      }, this.slots['media']);
	    }

	    var classes = Utils$1.classNames(className, {
	      'actions-button': true,
	      'actions-button-bold': bold
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes,
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      }
	    }, mediaEl, react.createElement('div', {
	      className: 'actions-button-text'
	    }, this.slots['default']));
	  };

	  F7ActionsButton.prototype.componentWillUnmount = function componentWillUnmount () {
	    this.refs.el.removeEventListener('click', this.onClick);
	  };

	  F7ActionsButton.prototype.componentDidMount = function componentDidMount () {
	    this.refs.el.addEventListener('click', this.onClick);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7ActionsButton.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7ActionsButton.prototype, prototypeAccessors );

	  return F7ActionsButton;
	}(react.Component));

	__reactComponentSetProps(F7ActionsButton, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  bold: Boolean,
	  close: {
	    type: Boolean,
	    default: true
	  }
	}, Mixins.colorProps));

	F7ActionsButton.displayName = 'f7-actions-button';

	var F7ActionsGroup = /*@__PURE__*/(function (superclass) {
	  function F7ActionsGroup(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7ActionsGroup.__proto__ = superclass;
	  F7ActionsGroup.prototype = Object.create( superclass && superclass.prototype );
	  F7ActionsGroup.prototype.constructor = F7ActionsGroup;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7ActionsGroup.prototype.render = function render () {
	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'actions-group', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7ActionsGroup.prototype, prototypeAccessors );

	  return F7ActionsGroup;
	}(react.Component));

	__reactComponentSetProps(F7ActionsGroup, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7ActionsGroup.displayName = 'f7-actions-group';

	var F7ActionsLabel = /*@__PURE__*/(function (superclass) {
	  function F7ActionsLabel(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick']);
	    })();
	  }

	  if ( superclass ) F7ActionsLabel.__proto__ = superclass;
	  F7ActionsLabel.prototype = Object.create( superclass && superclass.prototype );
	  F7ActionsLabel.prototype.constructor = F7ActionsLabel;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7ActionsLabel.prototype.onClick = function onClick (event) {
	    this.dispatchEvent('click', event);
	  };

	  F7ActionsLabel.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var bold = props.bold;
	    var classes = Utils$1.classNames(className, 'actions-label', {
	      'actions-button-bold': bold
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes,
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      }
	    }, this.slots['default']);
	  };

	  F7ActionsLabel.prototype.componentWillUnmount = function componentWillUnmount () {
	    this.refs.el.removeEventListener('click', this.onClick);
	  };

	  F7ActionsLabel.prototype.componentDidMount = function componentDidMount () {
	    this.refs.el.addEventListener('click', this.onClick);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7ActionsLabel.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7ActionsLabel.prototype, prototypeAccessors );

	  return F7ActionsLabel;
	}(react.Component));

	__reactComponentSetProps(F7ActionsLabel, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  bold: Boolean
	}, Mixins.colorProps));

	F7ActionsLabel.displayName = 'f7-actions-label';

	function __reactComponentWatch (component, watchFor, prevProps, prevState, callback) {
	  if (!callback) { return; }

	  var newValue;
	  var oldValue;

	  if (watchFor.indexOf('props') === 0) {
	    newValue = component.props;
	    oldValue = prevProps;
	  } else if (watchFor.indexOf('state') === 0) {
	    newValue = component.state;
	    oldValue = prevState;
	  }
	  // state and props has 5 letters
	  watchFor.slice(5).split('.').filter(function (part) { return part; }).forEach(function (part) {
	    if (typeof newValue !== 'undefined' && newValue !== null) {
	      newValue = newValue[part];
	    }
	    if (typeof oldValue !== 'undefined' && oldValue !== null) {
	      oldValue = oldValue[part];
	    }
	  });

	  if (oldValue === newValue) { return; }

	  if (callback) { callback(newValue, oldValue); }
	}

	var F7Actions = /*@__PURE__*/(function (superclass) {
	  function F7Actions(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onOpen', 'onOpened', 'onClose', 'onClosed']);
	    })();
	  }

	  if ( superclass ) F7Actions.__proto__ = superclass;
	  F7Actions.prototype = Object.create( superclass && superclass.prototype );
	  F7Actions.prototype.constructor = F7Actions;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Actions.prototype.onOpen = function onOpen (event) {
	    this.dispatchEvent('actions:open actionsOpen', event);
	  };

	  F7Actions.prototype.onOpened = function onOpened (event) {
	    this.dispatchEvent('actions:opened actionsOpened', event);
	  };

	  F7Actions.prototype.onClose = function onClose (event) {
	    this.dispatchEvent('actions:close actionsClose', event);
	  };

	  F7Actions.prototype.onClosed = function onClosed (event) {
	    this.dispatchEvent('actions:closed actionsClosed', event);
	  };

	  F7Actions.prototype.open = function open (animate) {
	    var self = this;
	    if (!self.$f7) { return undefined; }
	    return self.$f7.actions.open(self.refs.el, animate);
	  };

	  F7Actions.prototype.close = function close (animate) {
	    var self = this;
	    if (!self.$f7) { return undefined; }
	    return self.$f7.actions.close(self.refs.el, animate);
	  };

	  F7Actions.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var grid = props.grid;
	    var classes = Utils$1.classNames(className, 'actions-modal', {
	      'actions-grid': grid
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      className: classes
	    }, this.slots['default']);
	  };

	  F7Actions.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    if (self.f7Actions) { self.f7Actions.destroy(); }
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.removeEventListener('actions:open', self.onOpen);
	    el.removeEventListener('actions:opened', self.onOpened);
	    el.removeEventListener('actions:close', self.onClose);
	    el.removeEventListener('actions:closed', self.onClosed);
	  };

	  F7Actions.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.addEventListener('actions:open', self.onOpen);
	    el.addEventListener('actions:opened', self.onOpened);
	    el.addEventListener('actions:close', self.onClose);
	    el.addEventListener('actions:closed', self.onClosed);
	    var props = self.props;
	    var grid = props.grid;
	    var target = props.target;
	    var convertToPopover = props.convertToPopover;
	    var forceToPopover = props.forceToPopover;
	    var opened = props.opened;
	    var closeByBackdropClick = props.closeByBackdropClick;
	    var closeByOutsideClick = props.closeByOutsideClick;
	    var closeOnEscape = props.closeOnEscape;
	    var backdrop = props.backdrop;
	    var backdropEl = props.backdropEl;
	    var actionsParams = {
	      el: self.refs.el,
	      grid: grid
	    };
	    if (target) { actionsParams.targetEl = target; }
	    {
	      if ('convertToPopover' in props) { actionsParams.convertToPopover = convertToPopover; }
	      if ('forceToPopover' in props) { actionsParams.forceToPopover = forceToPopover; }
	      if ('backdrop' in props) { actionsParams.backdrop = backdrop; }
	      if ('backdropEl' in props) { actionsParams.backdropEl = backdropEl; }
	      if ('closeByBackdropClick' in props) { actionsParams.closeByBackdropClick = closeByBackdropClick; }
	      if ('closeByOutsideClick' in props) { actionsParams.closeByOutsideClick = closeByOutsideClick; }
	      if ('closeOnEscape' in props) { actionsParams.closeOnEscape = closeOnEscape; }
	    }
	    self.$f7ready(function () {
	      self.f7Actions = self.$f7.actions.create(actionsParams);

	      if (opened) {
	        self.f7Actions.open(false);
	      }
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Actions.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  F7Actions.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.opened', prevProps, prevState, function (opened) {
	      var self = this$1;
	      if (!self.f7Actions) { return; }

	      if (opened) {
	        self.f7Actions.open();
	      } else {
	        self.f7Actions.close();
	      }
	    });
	  };

	  Object.defineProperties( F7Actions.prototype, prototypeAccessors );

	  return F7Actions;
	}(react.Component));

	__reactComponentSetProps(F7Actions, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  opened: Boolean,
	  grid: Boolean,
	  convertToPopover: Boolean,
	  forceToPopover: Boolean,
	  target: [String, Object],
	  backdrop: Boolean,
	  backdropEl: [String, Object, window.HTMLElement],
	  closeByBackdropClick: Boolean,
	  closeByOutsideClick: Boolean,
	  closeOnEscape: Boolean
	}, Mixins.colorProps));

	F7Actions.displayName = 'f7-actions';

	var eventsEmitter = {
	  listeners: {},
	  on: function on(events, handler) {
	    events.split(' ').forEach(function (event) {
	      if (!eventsEmitter.listeners[event]) { eventsEmitter.listeners[event] = []; }
	      eventsEmitter.listeners[event].unshift(handler);
	    });
	  },
	  off: function off(events, handler) {
	    events.split(' ').forEach(function (event) {
	      if (!eventsEmitter.listeners[event]) { return; }
	      if (typeof handler === 'undefined') {
	        eventsEmitter.listeners[event] = [];
	      } else {
	        eventsEmitter.listeners[event].forEach(function (eventHandler, index) {
	          if (eventHandler === handler) {
	            eventsEmitter.listeners[event].splice(index, 1);
	          }
	        });
	      }
	    });
	  },
	  once: function once(events, handler) {
	    if (typeof handler !== 'function') { return; }
	    function onceHandler() {
	      var args = [], len = arguments.length;
	      while ( len-- ) args[ len ] = arguments[ len ];

	      handler.apply(void 0, args);
	      eventsEmitter.off(events, onceHandler);
	    }
	    eventsEmitter.on(events, onceHandler);
	  },
	  emit: function emit(events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    events.split(' ').forEach(function (event) {
	      if (eventsEmitter.listeners && eventsEmitter.listeners[event]) {
	        var handlers = [];
	        eventsEmitter.listeners[event].forEach(function (eventHandler) {
	          handlers.push(eventHandler);
	        });
	        handlers.forEach(function (eventHandler) {
	          eventHandler.apply(void 0, args);
	        });
	      }
	    });
	  },
	};

	var f7 = {
	  instance: null,
	  Framework7: null,
	  init: function init(rootEl, params, routes) {
	    if ( params === void 0 ) params = {};

	    var f7Params = Utils$1.extend({}, params, {
	      root: rootEl,
	    });
	    if (routes && routes.length && !f7Params.routes) { f7Params.routes = routes; }

	    var instance = new f7.Framework7(f7Params);
	    if (instance.initialized) {
	      f7.instance = instance;
	      eventsEmitter.emit('ready', f7.instance);
	    } else {
	      instance.on('init', function () {
	        f7.instance = instance;
	        eventsEmitter.emit('ready', f7.instance);
	      });
	    }
	  },
	  ready: function ready(callback) {
	    if (!callback) { return; }
	    if (f7.instance) { callback(f7.instance); }
	    else {
	      eventsEmitter.once('ready', callback);
	    }
	  },
	  routers: {
	    views: [],
	    tabs: [],
	    modals: null,
	  },
	};

	var F7RoutableModals = /*@__PURE__*/(function (superclass) {
	  function F7RoutableModals(props, context) {
	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    this.state = (function () {
	      return {
	        modals: []
	      };
	    })();
	  }

	  if ( superclass ) F7RoutableModals.__proto__ = superclass;
	  F7RoutableModals.prototype = Object.create( superclass && superclass.prototype );
	  F7RoutableModals.prototype.constructor = F7RoutableModals;

	  var prototypeAccessors = { refs: { configurable: true } };

	  F7RoutableModals.prototype.render = function render () {
	    var this$1 = this;

	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      className: 'framework7-modals'
	    }, this.state.modals.map(function (modal) {
	      var ModalComponent = modal.component;
	      {
	        return react.createElement(ModalComponent, Object.assign({
	          key: modal.id
	        }, modal.props));
	      }
	    }));
	  };

	  F7RoutableModals.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    self.setState({
	      modals: []
	    });
	    self.routerData = {
	      el: el,
	      component: self
	    };
	    f7.routers.modals = self.routerData;
	  };

	  F7RoutableModals.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    if (!self.routerData) { return; }
	    f7.routers.modals = null;
	    self.routerData = null;
	    delete self.routerData;
	  };

	  F7RoutableModals.prototype.componentDidUpdate = function componentDidUpdate () {
	    var self = this;
	    if (!self.routerData) { return; }
	    eventsEmitter.emit('modalsRouterDidUpdate', self.routerData);
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7RoutableModals.prototype, prototypeAccessors );

	  return F7RoutableModals;
	}(react.Component));

	F7RoutableModals.displayName = 'f7-routable-modals';

	var F7App = /*@__PURE__*/(function (superclass) {
	  function F7App(props, context) {
	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    this.state = (function () {
	      return {
	        modals: []
	      };
	    })();
	  }

	  if ( superclass ) F7App.__proto__ = superclass;
	  F7App.prototype = Object.create( superclass && superclass.prototype );
	  F7App.prototype.constructor = F7App;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7App.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var style = props.style;
	    var className = props.className;
	    var classes = Utils$1.classNames(className, 'framework7-root', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id || 'framework7-root',
	      style: style,
	      className: classes
	    }, this.slots['default'], react.createElement(F7RoutableModals, null));
	  };

	  F7App.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var ref = self.props;
	    var params = ref.params; if ( params === void 0 ) params = {};
	    var routes = ref.routes;
	    var el = self.refs.el;
	    var parentEl = el.parentNode;

	    if (parentEl && parentEl !== document.body && parentEl.parentNode === document.body) {
	      parentEl.style.height = '100%';
	    }

	    f7.init(el, params, routes);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7App.prototype, prototypeAccessors );

	  return F7App;
	}(react.Component));

	__reactComponentSetProps(F7App, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  params: Object,
	  routes: Array
	}, Mixins.colorProps));

	F7App.displayName = 'f7-app';

	var F7Appbar = /*@__PURE__*/(function (superclass) {
	  function F7Appbar(props, context) {
	    superclass.call(this, props, context);
	    this.__reactRefs = {};
	  }

	  if ( superclass ) F7Appbar.__proto__ = superclass;
	  F7Appbar.prototype = Object.create( superclass && superclass.prototype );
	  F7Appbar.prototype.constructor = F7Appbar;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Appbar.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var inner = props.inner;
	    var innerClass = props.innerClass;
	    var innerClassName = props.innerClassName;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var noShadow = props.noShadow;
	    var noHairline = props.noHairline;
	    var innerEl;

	    if (inner) {
	      innerEl = react.createElement('div', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['inner'] = __reactNode;
	        },
	        className: Utils$1.classNames('appbar-inner', innerClass, innerClassName)
	      }, this.slots['default']);
	    }

	    var classes = Utils$1.classNames(className, 'appbar', {
	      'no-shadow': noShadow,
	      'no-hairline': noHairline
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['before-inner'], innerEl || self.slots.default, this.slots['after-inner']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Appbar.prototype, prototypeAccessors );

	  return F7Appbar;
	}(react.Component));

	__reactComponentSetProps(F7Appbar, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  noShadow: Boolean,
	  noHairline: Boolean,
	  inner: {
	    type: Boolean,
	    default: true
	  },
	  innerClass: String,
	  innerClassName: String
	}, Mixins.colorProps));

	F7Appbar.displayName = 'f7-appbar';

	var F7Badge = /*@__PURE__*/(function (superclass) {
	  function F7Badge(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7Badge.__proto__ = superclass;
	  F7Badge.prototype = Object.create( superclass && superclass.prototype );
	  F7Badge.prototype.constructor = F7Badge;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7Badge.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'badge', Mixins.colorClasses(props));
	    return react.createElement('span', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7Badge.prototype, prototypeAccessors );

	  return F7Badge;
	}(react.Component));

	__reactComponentSetProps(F7Badge, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7Badge.displayName = 'f7-badge';

	var F7BlockFooter = /*@__PURE__*/(function (superclass) {
	  function F7BlockFooter(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7BlockFooter.__proto__ = superclass;
	  F7BlockFooter.prototype = Object.create( superclass && superclass.prototype );
	  F7BlockFooter.prototype.constructor = F7BlockFooter;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7BlockFooter.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'block-footer', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7BlockFooter.prototype, prototypeAccessors );

	  return F7BlockFooter;
	}(react.Component));

	__reactComponentSetProps(F7BlockFooter, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7BlockFooter.displayName = 'f7-block-footer';

	var F7BlockHeader = /*@__PURE__*/(function (superclass) {
	  function F7BlockHeader(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7BlockHeader.__proto__ = superclass;
	  F7BlockHeader.prototype = Object.create( superclass && superclass.prototype );
	  F7BlockHeader.prototype.constructor = F7BlockHeader;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7BlockHeader.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'block-header', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7BlockHeader.prototype, prototypeAccessors );

	  return F7BlockHeader;
	}(react.Component));

	__reactComponentSetProps(F7BlockHeader, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7BlockHeader.displayName = 'f7-block-header';

	var F7BlockTitle = /*@__PURE__*/(function (superclass) {
	  function F7BlockTitle(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7BlockTitle.__proto__ = superclass;
	  F7BlockTitle.prototype = Object.create( superclass && superclass.prototype );
	  F7BlockTitle.prototype.constructor = F7BlockTitle;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7BlockTitle.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var large = props.large;
	    var medium = props.medium;
	    var classes = Utils$1.classNames(className, 'block-title', {
	      'block-title-large': large,
	      'block-title-medium': medium
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7BlockTitle.prototype, prototypeAccessors );

	  return F7BlockTitle;
	}(react.Component));

	__reactComponentSetProps(F7BlockTitle, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  large: Boolean,
	  medium: Boolean
	}, Mixins.colorProps));

	F7BlockTitle.displayName = 'f7-block-title';

	var F7Block = /*@__PURE__*/(function (superclass) {
	  function F7Block(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onTabShow', 'onTabHide']);
	    })();
	  }

	  if ( superclass ) F7Block.__proto__ = superclass;
	  F7Block.prototype = Object.create( superclass && superclass.prototype );
	  F7Block.prototype.constructor = F7Block;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Block.prototype.onTabShow = function onTabShow (event) {
	    this.dispatchEvent('tabShow tab:show', event);
	  };

	  F7Block.prototype.onTabHide = function onTabHide (event) {
	    this.dispatchEvent('tabHide tab:hide', event);
	  };

	  F7Block.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var inset = props.inset;
	    var strong = props.strong;
	    var accordionList = props.accordionList;
	    var tabletInset = props.tabletInset;
	    var tabs = props.tabs;
	    var tab = props.tab;
	    var tabActive = props.tabActive;
	    var noHairlines = props.noHairlines;
	    var noHairlinesIos = props.noHairlinesIos;
	    var noHairlinesMd = props.noHairlinesMd;
	    var noHairlinesAurora = props.noHairlinesAurora;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'block', {
	      inset: inset,
	      'block-strong': strong,
	      'accordion-list': accordionList,
	      'tablet-inset': tabletInset,
	      tabs: tabs,
	      tab: tab,
	      'tab-active': tabActive,
	      'no-hairlines': noHairlines,
	      'no-hairlines-md': noHairlinesMd,
	      'no-hairlines-ios': noHairlinesIos,
	      'no-hairlines-aurora': noHairlinesAurora
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes,
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      }
	    }, this.slots['default']);
	  };

	  F7Block.prototype.componentWillUnmount = function componentWillUnmount () {
	    var el = this.refs.el;
	    if (!el) { return; }
	    el.removeEventListener('tab:show', this.onTabShow);
	    el.removeEventListener('tab:hide', this.onTabHide);
	  };

	  F7Block.prototype.componentDidMount = function componentDidMount () {
	    var el = this.refs.el;
	    if (!el) { return; }
	    el.addEventListener('tab:show', this.onTabShow);
	    el.addEventListener('tab:hide', this.onTabHide);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Block.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Block.prototype, prototypeAccessors );

	  return F7Block;
	}(react.Component));

	__reactComponentSetProps(F7Block, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  inset: Boolean,
	  tabletInset: Boolean,
	  strong: Boolean,
	  tabs: Boolean,
	  tab: Boolean,
	  tabActive: Boolean,
	  accordionList: Boolean,
	  noHairlines: Boolean,
	  noHairlinesMd: Boolean,
	  noHairlinesIos: Boolean,
	  noHairlinesAurora: Boolean
	}, Mixins.colorProps));

	F7Block.displayName = 'f7-block';

	var F7Icon = /*@__PURE__*/(function (superclass) {
	  function F7Icon(props, context) {
	    superclass.call(this, props, context);
	    this.__reactRefs = {};
	  }

	  if ( superclass ) F7Icon.__proto__ = superclass;
	  F7Icon.prototype = Object.create( superclass && superclass.prototype );
	  F7Icon.prototype.constructor = F7Icon;

	  var prototypeAccessors = { sizeComputed: { configurable: true },iconTextComputed: { configurable: true },classes: { configurable: true },slots: { configurable: true },refs: { configurable: true } };

	  prototypeAccessors.sizeComputed.get = function () {
	    var self = this;
	    var size = self.props.size;

	    if (typeof size === 'number' || parseFloat(size) === size * 1) {
	      size = size + "px";
	    }

	    return size;
	  };

	  prototypeAccessors.iconTextComputed.get = function () {
	    var self = this;
	    var ref = self.props;
	    var material = ref.material;
	    var f7 = ref.f7;
	    var md = ref.md;
	    var ios = ref.ios;
	    var aurora = ref.aurora;
	    var text = material || f7;

	    if (md && self.$theme.md && (md.indexOf('material:') >= 0 || md.indexOf('f7:') >= 0)) {
	      text = md.split(':')[1];
	    } else if (ios && self.$theme.ios && (ios.indexOf('material:') >= 0 || ios.indexOf('f7:') >= 0)) {
	      text = ios.split(':')[1];
	    } else if (aurora && self.$theme.aurora && (aurora.indexOf('material:') >= 0 || aurora.indexOf('f7:') >= 0)) {
	      text = aurora.split(':')[1];
	    }

	    return text;
	  };

	  prototypeAccessors.classes.get = function () {
	    var classes = {
	      icon: true
	    };
	    var self = this;
	    var props = self.props;
	    var material = props.material;
	    var f7 = props.f7;
	    var fa = props.fa;
	    var ion = props.ion;
	    var icon = props.icon;
	    var md = props.md;
	    var ios = props.ios;
	    var aurora = props.aurora;
	    var className = props.className;
	    var themeIcon;
	    if (self.$theme.ios) { themeIcon = ios; }else if (self.$theme.md) { themeIcon = md; }else if (self.$theme.aurora) { themeIcon = aurora; }

	    if (themeIcon) {
	      var parts = themeIcon.split(':');
	      var prop = parts[0];
	      var value = parts[1];

	      if (prop === 'material' || prop === 'fa' || prop === 'f7') {
	        classes.fa = prop === 'fa';
	        classes['material-icons'] = prop === 'material';
	        classes['f7-icons'] = prop === 'f7';
	      }

	      if (prop === 'fa' || prop === 'ion') {
	        classes[(prop + "-" + value)] = true;
	      }

	      if (prop === 'icon') {
	        classes[value] = true;
	      }
	    } else {
	      classes = {
	        icon: true,
	        'material-icons': material,
	        'f7-icons': f7,
	        fa: fa
	      };
	      if (ion) { classes[("ion-" + ion)] = true; }
	      if (fa) { classes[("fa-" + fa)] = true; }
	      if (icon) { classes[icon] = true; }
	    }

	    return Utils$1.classNames(className, classes, Mixins.colorClasses(props));
	  };

	  F7Icon.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var style = props.style;
	    return react.createElement('i', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: Utils$1.extend({
	        fontSize: self.sizeComputed
	      }, style),
	      className: self.classes
	    }, self.iconTextComputed, this.slots['default']);
	  };

	  F7Icon.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;

	    if (self.f7Tooltip && self.f7Tooltip.destroy) {
	      self.f7Tooltip.destroy();
	      self.f7Tooltip = null;
	      delete self.f7Tooltip;
	    }
	  };

	  F7Icon.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    if (!el) { return; }
	    var ref = self.props;
	    var tooltip = ref.tooltip;
	    if (!tooltip) { return; }
	    self.$f7ready(function (f7) {
	      self.f7Tooltip = f7.tooltip.create({
	        targetEl: el,
	        text: tooltip
	      });
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  F7Icon.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.tooltip', prevProps, prevState, function (newText) {
	      var self = this$1;
	      if (!newText || !self.f7Tooltip) { return; }
	      self.f7Tooltip.setText(newText);
	    });
	  };

	  Object.defineProperties( F7Icon.prototype, prototypeAccessors );

	  return F7Icon;
	}(react.Component));

	__reactComponentSetProps(F7Icon, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  material: String,
	  f7: String,
	  ion: String,
	  fa: String,
	  icon: String,
	  ios: String,
	  aurora: String,
	  md: String,
	  tooltip: String,
	  size: [String, Number]
	}, Mixins.colorProps));

	F7Icon.displayName = 'f7-icon';

	var F7Button = /*@__PURE__*/(function (superclass) {
	  function F7Button(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick']);
	    })();
	  }

	  if ( superclass ) F7Button.__proto__ = superclass;
	  F7Button.prototype = Object.create( superclass && superclass.prototype );
	  F7Button.prototype.constructor = F7Button;

	  var prototypeAccessors = { attrs: { configurable: true },classes: { configurable: true },slots: { configurable: true },refs: { configurable: true } };

	  F7Button.prototype.onClick = function onClick (event) {
	    this.dispatchEvent('click', event);
	  };

	  prototypeAccessors.attrs.get = function () {
	    var self = this;
	    var props = self.props;
	    var href = props.href;
	    var target = props.target;
	    var tabLink = props.tabLink;
	    var type = props.type;
	    var hrefComputed = href;
	    if (href === true) { hrefComputed = '#'; }
	    if (href === false) { hrefComputed = undefined; }
	    return Utils$1.extend({
	      href: hrefComputed,
	      target: target,
	      type: type,
	      'data-tab': Utils$1.isStringProp(tabLink) && tabLink || undefined
	    }, Mixins.linkRouterAttrs(props), Mixins.linkActionsAttrs(props));
	  };

	  prototypeAccessors.classes.get = function () {
	    var self = this;
	    var props = self.props;
	    var noFastclick = props.noFastclick;
	    var noFastClick = props.noFastClick;
	    var tabLink = props.tabLink;
	    var tabLinkActive = props.tabLinkActive;
	    var round = props.round;
	    var roundIos = props.roundIos;
	    var roundAurora = props.roundAurora;
	    var roundMd = props.roundMd;
	    var fill = props.fill;
	    var fillIos = props.fillIos;
	    var fillAurora = props.fillAurora;
	    var fillMd = props.fillMd;
	    var large = props.large;
	    var largeIos = props.largeIos;
	    var largeAurora = props.largeAurora;
	    var largeMd = props.largeMd;
	    var small = props.small;
	    var smallIos = props.smallIos;
	    var smallAurora = props.smallAurora;
	    var smallMd = props.smallMd;
	    var raised = props.raised;
	    var raisedIos = props.raisedIos;
	    var raisedAurora = props.raisedAurora;
	    var raisedMd = props.raisedMd;
	    var active = props.active;
	    var outline = props.outline;
	    var outlineIos = props.outlineIos;
	    var outlineAurora = props.outlineAurora;
	    var outlineMd = props.outlineMd;
	    var disabled = props.disabled;
	    var className = props.className;
	    return Utils$1.classNames(className, 'button', {
	      'tab-link': tabLink || tabLink === '',
	      'tab-link-active': tabLinkActive,
	      'no-fastclick': noFastclick || noFastClick,
	      'button-round': round,
	      'button-round-ios': roundIos,
	      'button-round-aurora': roundAurora,
	      'button-round-md': roundMd,
	      'button-fill': fill,
	      'button-fill-ios': fillIos,
	      'button-fill-aurora': fillAurora,
	      'button-fill-md': fillMd,
	      'button-large': large,
	      'button-large-ios': largeIos,
	      'button-large-aurora': largeAurora,
	      'button-large-md': largeMd,
	      'button-small': small,
	      'button-small-ios': smallIos,
	      'button-small-aurora': smallAurora,
	      'button-small-md': smallMd,
	      'button-raised': raised,
	      'button-raised-ios': raisedIos,
	      'button-raised-aurora': raisedAurora,
	      'button-raised-md': raisedMd,
	      'button-active': active,
	      'button-outline': outline,
	      'button-outline-ios': outlineIos,
	      'button-outline-aurora': outlineAurora,
	      'button-outline-md': outlineMd,
	      disabled: disabled
	    }, Mixins.colorClasses(props), Mixins.linkRouterClasses(props), Mixins.linkActionsClasses(props));
	  };

	  F7Button.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var iconEl;
	    var textEl;
	    var props = self.props;
	    var text = props.text;
	    var icon = props.icon;
	    var iconMaterial = props.iconMaterial;
	    var iconIon = props.iconIon;
	    var iconFa = props.iconFa;
	    var iconF7 = props.iconF7;
	    var iconMd = props.iconMd;
	    var iconIos = props.iconIos;
	    var iconAurora = props.iconAurora;
	    var iconColor = props.iconColor;
	    var iconSize = props.iconSize;
	    var id = props.id;
	    var style = props.style;
	    var type = props.type;

	    if (text) {
	      textEl = react.createElement('span', null, text);
	    }

	    if (icon || iconMaterial || iconIon || iconFa || iconF7 || iconMd || iconIos || iconAurora) {
	      iconEl = react.createElement(F7Icon, {
	        material: iconMaterial,
	        ion: iconIon,
	        fa: iconFa,
	        f7: iconF7,
	        icon: icon,
	        md: iconMd,
	        ios: iconIos,
	        aurora: iconAurora,
	        color: iconColor,
	        size: iconSize
	      });
	    }

	    var ButtonTag = type === 'submit' || type === 'reset' || type === 'button' ? 'button' : 'a';
	    return react.createElement(ButtonTag, Object.assign({
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: self.classes
	    }, self.attrs), iconEl, textEl, this.slots['default']);
	  };

	  F7Button.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var el = self.refs.el;
	    el.removeEventListener('click', self.onClick);
	    delete el.f7RouteProps;

	    if (self.f7Tooltip && self.f7Tooltip.destroy) {
	      self.f7Tooltip.destroy();
	      self.f7Tooltip = null;
	      delete self.f7Tooltip;
	    }
	  };

	  F7Button.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.tooltip', prevProps, prevState, function (newText) {
	      var self = this$1;
	      if (!newText || !self.f7Tooltip) { return; }
	      self.f7Tooltip.setText(newText);
	    });

	    var self = this;
	    var el = self.refs.el;
	    var ref = self.props;
	    var routeProps = ref.routeProps;

	    if (routeProps) {
	      el.f7RouteProps = routeProps;
	    }
	  };

	  F7Button.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    el.addEventListener('click', self.onClick);
	    var ref = self.props;
	    var tooltip = ref.tooltip;
	    var routeProps = ref.routeProps;

	    if (routeProps) {
	      el.f7RouteProps = routeProps;
	    }

	    if (!tooltip) { return; }
	    self.$f7ready(function (f7) {
	      self.f7Tooltip = f7.tooltip.create({
	        targetEl: el,
	        text: tooltip
	      });
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Button.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Button.prototype, prototypeAccessors );

	  return F7Button;
	}(react.Component));

	__reactComponentSetProps(F7Button, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  noFastclick: Boolean,
	  noFastClick: Boolean,
	  text: String,
	  tabLink: [Boolean, String],
	  tabLinkActive: Boolean,
	  type: String,
	  href: {
	    type: [String, Boolean],
	    default: '#'
	  },
	  target: String,
	  round: Boolean,
	  roundMd: Boolean,
	  roundIos: Boolean,
	  roundAurora: Boolean,
	  fill: Boolean,
	  fillMd: Boolean,
	  fillIos: Boolean,
	  fillAurora: Boolean,
	  large: Boolean,
	  largeMd: Boolean,
	  largeIos: Boolean,
	  largeAurora: Boolean,
	  small: Boolean,
	  smallMd: Boolean,
	  smallIos: Boolean,
	  smallAurora: Boolean,
	  raised: Boolean,
	  raisedMd: Boolean,
	  raisedIos: Boolean,
	  raisedAurora: Boolean,
	  outline: Boolean,
	  outlineMd: Boolean,
	  outlineIos: Boolean,
	  outlineAurora: Boolean,
	  active: Boolean,
	  disabled: Boolean,
	  tooltip: String
	}, Mixins.colorProps, Mixins.linkIconProps, Mixins.linkRouterProps, Mixins.linkActionsProps));

	F7Button.displayName = 'f7-button';

	var F7CardContent = /*@__PURE__*/(function (superclass) {
	  function F7CardContent(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7CardContent.__proto__ = superclass;
	  F7CardContent.prototype = Object.create( superclass && superclass.prototype );
	  F7CardContent.prototype.constructor = F7CardContent;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7CardContent.prototype.render = function render () {
	    var props = this.props;
	    var id = props.id;
	    var className = props.className;
	    var style = props.style;
	    var padding = props.padding;
	    var classes = Utils$1.classNames(className, 'card-content', {
	      'card-content-padding': padding
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7CardContent.prototype, prototypeAccessors );

	  return F7CardContent;
	}(react.Component));

	__reactComponentSetProps(F7CardContent, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  padding: {
	    type: Boolean,
	    default: true
	  }
	}, Mixins.colorProps));

	F7CardContent.displayName = 'f7-card-content';

	var F7CardFooter = /*@__PURE__*/(function (superclass) {
	  function F7CardFooter(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7CardFooter.__proto__ = superclass;
	  F7CardFooter.prototype = Object.create( superclass && superclass.prototype );
	  F7CardFooter.prototype.constructor = F7CardFooter;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7CardFooter.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'card-footer', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7CardFooter.prototype, prototypeAccessors );

	  return F7CardFooter;
	}(react.Component));

	__reactComponentSetProps(F7CardFooter, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7CardFooter.displayName = 'f7-card-footer';

	var F7CardHeader = /*@__PURE__*/(function (superclass) {
	  function F7CardHeader(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7CardHeader.__proto__ = superclass;
	  F7CardHeader.prototype = Object.create( superclass && superclass.prototype );
	  F7CardHeader.prototype.constructor = F7CardHeader;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7CardHeader.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'card-header', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7CardHeader.prototype, prototypeAccessors );

	  return F7CardHeader;
	}(react.Component));

	__reactComponentSetProps(F7CardHeader, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7CardHeader.displayName = 'f7-card-header';

	var F7Card = /*@__PURE__*/(function (superclass) {
	  function F7Card(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, 'onBeforeOpen onOpen onOpened onClose onClosed'.split(' '));
	    })();
	  }

	  if ( superclass ) F7Card.__proto__ = superclass;
	  F7Card.prototype = Object.create( superclass && superclass.prototype );
	  F7Card.prototype.constructor = F7Card;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Card.prototype.open = function open () {
	    var self = this;
	    if (!self.refs.el) { return; }
	    self.$f7.card.open(self.refs.el);
	  };

	  F7Card.prototype.close = function close () {
	    var self = this;
	    if (!self.refs.el) { return; }
	    self.$f7.card.close(self.refs.el);
	  };

	  F7Card.prototype.onBeforeOpen = function onBeforeOpen (e) {
	    this.dispatchEvent('cardBeforeOpen card:beforeopen', e, e.detail.prevent);
	  };

	  F7Card.prototype.onOpen = function onOpen (e) {
	    this.dispatchEvent('cardOpen card:open', e);
	  };

	  F7Card.prototype.onOpened = function onOpened (e) {
	    this.dispatchEvent('cardOpened card:opened', e);
	  };

	  F7Card.prototype.onClose = function onClose (e) {
	    this.dispatchEvent('cardClose card:close', e);
	  };

	  F7Card.prototype.onClosed = function onClosed (e) {
	    this.dispatchEvent('cardClosed card:closed', e);
	  };

	  F7Card.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var title = props.title;
	    var content = props.content;
	    var footer = props.footer;
	    var padding = props.padding;
	    var outline = props.outline;
	    var expandable = props.expandable;
	    var expandableAnimateWidth = props.expandableAnimateWidth;
	    var animate = props.animate;
	    var hideNavbarOnOpen = props.hideNavbarOnOpen;
	    var hideToolbarOnOpen = props.hideToolbarOnOpen;
	    var swipeToClose = props.swipeToClose;
	    var closeByBackdropClick = props.closeByBackdropClick;
	    var backdrop = props.backdrop;
	    var noShadow = props.noShadow;
	    var noBorder = props.noBorder;
	    var headerEl;
	    var contentEl;
	    var footerEl;
	    var classes = Utils$1.classNames(className, 'card', {
	      'card-outline': outline,
	      'card-expandable': expandable,
	      'card-expandable-animate-width': expandableAnimateWidth,
	      'no-shadow': noShadow,
	      'no-border': noBorder
	    }, Mixins.colorClasses(props));

	    if (title || self.slots && self.slots.header) {
	      headerEl = react.createElement(F7CardHeader, null, title, this.slots['header']);
	    }

	    if (content || self.slots && self.slots.content) {
	      contentEl = react.createElement(F7CardContent, {
	        padding: padding
	      }, content, this.slots['content']);
	    }

	    if (footer || self.slots && self.slots.footer) {
	      footerEl = react.createElement(F7CardFooter, null, footer, this.slots['footer']);
	    }

	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes,
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      'data-animate': typeof animate === 'undefined' ? animate : animate.toString(),
	      'data-hide-navbar-on-open': typeof hideNavbarOnOpen === 'undefined' ? hideNavbarOnOpen : hideNavbarOnOpen.toString(),
	      'data-hide-toolbar-on-open': typeof hideToolbarOnOpen === 'undefined' ? hideToolbarOnOpen : hideToolbarOnOpen.toString(),
	      'data-swipe-to-close': typeof swipeToClose === 'undefined' ? swipeToClose : swipeToClose.toString(),
	      'data-close-by-backdrop-click': typeof closeByBackdropClick === 'undefined' ? closeByBackdropClick : closeByBackdropClick.toString(),
	      'data-backdrop': typeof backdrop === 'undefined' ? backdrop : backdrop.toString()
	    }, headerEl, contentEl, footerEl, this.slots['default']);
	  };

	  F7Card.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    if (!self.props.expandable) { return; }
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.removeEventListener('card:beforeopen', self.onBeforeOpen);
	    el.removeEventListener('card:open', self.onOpen);
	    el.removeEventListener('card:opened', self.onOpened);
	    el.removeEventListener('card:close', self.onClose);
	    el.removeEventListener('card:closed', self.onClosed);
	  };

	  F7Card.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    if (!self.props.expandable) { return; }
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.addEventListener('card:beforeopen', self.onBeforeOpen);
	    el.addEventListener('card:open', self.onOpen);
	    el.addEventListener('card:opened', self.onOpened);
	    el.addEventListener('card:close', self.onClose);
	    el.addEventListener('card:closed', self.onClosed);

	    if (self.props.expandable && self.props.expandableOpened) {
	      self.$f7ready(function () {
	        self.$f7.card.open(el, false);
	      });
	    }
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Card.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  F7Card.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.expandableOpened', prevProps, prevState, function (expandableOpened) {
	      var self = this$1;

	      if (expandableOpened) {
	        self.open();
	      } else {
	        self.close();
	      }
	    });
	  };

	  Object.defineProperties( F7Card.prototype, prototypeAccessors );

	  return F7Card;
	}(react.Component));

	__reactComponentSetProps(F7Card, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  title: [String, Number],
	  content: [String, Number],
	  footer: [String, Number],
	  outline: Boolean,
	  expandable: Boolean,
	  expandableAnimateWidth: Boolean,
	  expandableOpened: Boolean,
	  animate: {
	    type: Boolean,
	    default: undefined
	  },
	  hideNavbarOnOpen: {
	    type: Boolean,
	    default: undefined
	  },
	  hideToolbarOnOpen: {
	    type: Boolean,
	    default: undefined
	  },
	  swipeToClose: {
	    type: Boolean,
	    default: undefined
	  },
	  closeByBackdropClick: {
	    type: Boolean,
	    default: undefined
	  },
	  backdrop: {
	    type: Boolean,
	    default: undefined
	  },
	  noShadow: Boolean,
	  noBorder: Boolean,
	  padding: {
	    type: Boolean,
	    default: true
	  }
	}, Mixins.colorProps));

	F7Card.displayName = 'f7-card';

	var F7Checkbox = /*@__PURE__*/(function (superclass) {
	  function F7Checkbox(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onChange']);
	    })();
	  }

	  if ( superclass ) F7Checkbox.__proto__ = superclass;
	  F7Checkbox.prototype = Object.create( superclass && superclass.prototype );
	  F7Checkbox.prototype.constructor = F7Checkbox;

	  var prototypeAccessors = { classes: { configurable: true },slots: { configurable: true },refs: { configurable: true } };

	  F7Checkbox.prototype.onChange = function onChange (event) {
	    this.dispatchEvent('change', event);
	  };

	  prototypeAccessors.classes.get = function () {
	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var disabled = props.disabled;
	    return Utils$1.classNames(className, {
	      checkbox: true,
	      disabled: disabled
	    }, Mixins.colorClasses(props));
	  };

	  F7Checkbox.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var name = props.name;
	    var value = props.value;
	    var disabled = props.disabled;
	    var readonly = props.readonly;
	    var checked = props.checked;
	    var defaultChecked = props.defaultChecked;
	    var id = props.id;
	    var style = props.style;
	    var inputEl;
	    {
	      inputEl = react.createElement('input', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['inputEl'] = __reactNode;
	        },
	        type: 'checkbox',
	        name: name,
	        value: value,
	        disabled: disabled,
	        readOnly: readonly,
	        checked: checked,
	        defaultChecked: defaultChecked,
	        onChange: self.onChange
	      });
	    }
	    var iconEl = react.createElement('i', {
	      className: 'icon-checkbox'
	    });
	    return react.createElement('label', {
	      id: id,
	      style: style,
	      className: self.classes
	    }, inputEl, iconEl, this.slots['default']);
	  };

	  F7Checkbox.prototype.componentDidUpdate = function componentDidUpdate () {
	    var self = this;
	    var ref = self.refs;
	    var inputEl = ref.inputEl;
	    var ref$1 = self.props;
	    var indeterminate = ref$1.indeterminate;

	    if (inputEl) {
	      inputEl.indeterminate = indeterminate;
	    }
	  };

	  F7Checkbox.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var ref = self.refs;
	    var inputEl = ref.inputEl;
	    var ref$1 = self.props;
	    var indeterminate = ref$1.indeterminate;

	    if (indeterminate && inputEl) {
	      inputEl.indeterminate = true;
	    }
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Checkbox.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Checkbox.prototype, prototypeAccessors );

	  return F7Checkbox;
	}(react.Component));

	__reactComponentSetProps(F7Checkbox, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  checked: Boolean,
	  indeterminate: Boolean,
	  name: [Number, String],
	  value: [Number, String, Boolean],
	  disabled: Boolean,
	  readonly: Boolean,
	  defaultChecked: Boolean
	}, Mixins.colorProps));

	F7Checkbox.displayName = 'f7-checkbox';

	var F7Chip = /*@__PURE__*/(function (superclass) {
	  function F7Chip(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick', 'onDeleteClick']);
	    })();
	  }

	  if ( superclass ) F7Chip.__proto__ = superclass;
	  F7Chip.prototype = Object.create( superclass && superclass.prototype );
	  F7Chip.prototype.constructor = F7Chip;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Chip.prototype.onClick = function onClick (event) {
	    this.dispatchEvent('click', event);
	  };

	  F7Chip.prototype.onDeleteClick = function onDeleteClick (event) {
	    this.dispatchEvent('delete', event);
	  };

	  F7Chip.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var media = props.media;
	    var text = props.text;
	    var deleteable = props.deleteable;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var mediaTextColor = props.mediaTextColor;
	    var mediaBgColor = props.mediaBgColor;
	    var outline = props.outline;
	    var mediaEl;
	    var labelEl;
	    var deleteEl;

	    if (media || self.slots && self.slots.media) {
	      var mediaClasses = Utils$1.classNames('chip-media', mediaTextColor && ("text-color-" + mediaTextColor), mediaBgColor && ("bg-color-" + mediaBgColor));
	      mediaEl = react.createElement('div', {
	        className: mediaClasses
	      }, media || this.slots['media']);
	    }

	    if (text || self.slots && self.slots.text) {
	      labelEl = react.createElement('div', {
	        className: 'chip-label'
	      }, text, this.slots['text']);
	    }

	    if (deleteable) {
	      deleteEl = react.createElement('a', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['deleteEl'] = __reactNode;
	        },
	        className: 'chip-delete'
	      });
	    }

	    var classes = Utils$1.classNames(className, 'chip', {
	      'chip-outline': outline
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes
	    }, mediaEl, labelEl, deleteEl);
	  };

	  F7Chip.prototype.componentWillUnmount = function componentWillUnmount () {
	    this.refs.el.removeEventListener('click', this.onClick);

	    if (this.refs.deleteEl) {
	      this.refs.deleteEl.removeEventListener('click', this.onDeleteClick);
	    }
	  };

	  F7Chip.prototype.componentDidMount = function componentDidMount () {
	    this.refs.el.addEventListener('click', this.onClick);

	    if (this.refs.deleteEl) {
	      this.refs.deleteEl.addEventListener('click', this.onDeleteClick);
	    }
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Chip.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Chip.prototype, prototypeAccessors );

	  return F7Chip;
	}(react.Component));

	__reactComponentSetProps(F7Chip, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  media: String,
	  text: [String, Number],
	  deleteable: Boolean,
	  mediaBgColor: String,
	  mediaTextColor: String,
	  outline: Boolean
	}, Mixins.colorProps));

	F7Chip.displayName = 'f7-chip';

	var F7Col = /*@__PURE__*/(function (superclass) {
	  function F7Col(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick']);
	    })();
	  }

	  if ( superclass ) F7Col.__proto__ = superclass;
	  F7Col.prototype = Object.create( superclass && superclass.prototype );
	  F7Col.prototype.constructor = F7Col;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Col.prototype.onClick = function onClick (event) {
	    this.dispatchEvent('click', event);
	  };

	  F7Col.prototype.render = function render () {
	    var this$1 = this;
	    var obj;

	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var tag = props.tag;
	    var width = props.width;
	    var tabletWidth = props.tabletWidth;
	    var desktopWidth = props.desktopWidth;
	    var ColTag = tag;
	    var classes = Utils$1.classNames(className, ( obj = {
	      col: width === 'auto'
	    }, obj[("col-" + width)] = width !== 'auto', obj[("tablet-" + tabletWidth)] = tabletWidth, obj[("desktop-" + desktopWidth)] = desktopWidth, obj ), Mixins.colorClasses(props));
	    return react.createElement(ColTag, {
	      id: id,
	      style: style,
	      className: classes,
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      }
	    }, this.slots['default']);
	  };

	  F7Col.prototype.componentWillUnmount = function componentWillUnmount () {
	    this.refs.el.removeEventListener('click', this.onClick);
	  };

	  F7Col.prototype.componentDidMount = function componentDidMount () {
	    this.refs.el.addEventListener('click', this.onClick);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Col.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Col.prototype, prototypeAccessors );

	  return F7Col;
	}(react.Component));

	__reactComponentSetProps(F7Col, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  tag: {
	    type: String,
	    default: 'div'
	  },
	  width: {
	    type: [Number, String],
	    default: 'auto'
	  },
	  tabletWidth: {
	    type: [Number, String]
	  },
	  desktopWidth: {
	    type: [Number, String]
	  }
	}, Mixins.colorProps));

	F7Col.displayName = 'f7-col';

	var F7FabButton = /*@__PURE__*/(function (superclass) {
	  function F7FabButton(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      this$1.onClick = this$1.onClick.bind(this$1);
	    })();

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick']);
	    })();
	  }

	  if ( superclass ) F7FabButton.__proto__ = superclass;
	  F7FabButton.prototype = Object.create( superclass && superclass.prototype );
	  F7FabButton.prototype.constructor = F7FabButton;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7FabButton.prototype.onClick = function onClick (event) {
	    this.dispatchEvent('click', event);
	  };

	  F7FabButton.prototype.render = function render () {
	    var this$1 = this;

	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var fabClose = props.fabClose;
	    var label = props.label;
	    var target = props.target;
	    var classes = Utils$1.classNames(className, {
	      'fab-close': fabClose,
	      'fab-label-button': label
	    }, Mixins.colorClasses(props));
	    var labelEl;

	    if (label) {
	      labelEl = react.createElement('span', {
	        className: 'fab-label'
	      }, label);
	    }

	    return react.createElement('a', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      target: target,
	      className: classes
	    }, this.slots['default'], labelEl);
	  };

	  F7FabButton.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    self.refs.el.removeEventListener('click', self.onClick);

	    if (self.f7Tooltip && self.f7Tooltip.destroy) {
	      self.f7Tooltip.destroy();
	      self.f7Tooltip = null;
	      delete self.f7Tooltip;
	    }
	  };

	  F7FabButton.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    self.refs.el.addEventListener('click', self.onClick);
	    var ref = self.props;
	    var tooltip = ref.tooltip;
	    if (!tooltip) { return; }
	    self.$f7ready(function (f7) {
	      self.f7Tooltip = f7.tooltip.create({
	        targetEl: self.refs.el,
	        text: tooltip
	      });
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7FabButton.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  F7FabButton.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.tooltip', prevProps, prevState, function (newText) {
	      var self = this$1;
	      if (!newText || !self.f7Tooltip) { return; }
	      self.f7Tooltip.setText(newText);
	    });
	  };

	  Object.defineProperties( F7FabButton.prototype, prototypeAccessors );

	  return F7FabButton;
	}(react.Component));

	__reactComponentSetProps(F7FabButton, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  fabClose: Boolean,
	  label: String,
	  target: String,
	  tooltip: String
	}, Mixins.colorProps));

	F7FabButton.displayName = 'f7-fab-button';

	var F7FabButtons = /*@__PURE__*/(function (superclass) {
	  function F7FabButtons(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7FabButtons.__proto__ = superclass;
	  F7FabButtons.prototype = Object.create( superclass && superclass.prototype );
	  F7FabButtons.prototype.constructor = F7FabButtons;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7FabButtons.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var position = props.position;
	    var classes = Utils$1.classNames(className, 'fab-buttons', ("fab-buttons-" + position), Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7FabButtons.prototype, prototypeAccessors );

	  return F7FabButtons;
	}(react.Component));

	__reactComponentSetProps(F7FabButtons, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  position: {
	    type: String,
	    default: 'top'
	  }
	}, Mixins.colorProps));

	F7FabButtons.displayName = 'f7-fab-buttons';

	var F7Fab = /*@__PURE__*/(function (superclass) {
	  function F7Fab(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick']);
	    })();
	  }

	  if ( superclass ) F7Fab.__proto__ = superclass;
	  F7Fab.prototype = Object.create( superclass && superclass.prototype );
	  F7Fab.prototype.constructor = F7Fab;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Fab.prototype.onClick = function onClick (event) {
	    var self = this;
	    self.dispatchEvent('click', event);
	  };

	  F7Fab.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var morphTo = props.morphTo;
	    var initialHref = props.href;
	    var position = props.position;
	    var text = props.text;
	    var target = props.target;
	    var href = initialHref;
	    if (href === true) { href = '#'; }
	    if (href === false) { href = undefined; }
	    var linkChildren = [];
	    var rootChildren = [];
	    var ref = self.slots;
	    var linkSlots = ref.link;
	    var defaultSlots = ref.default;
	    var rootSlots = ref.root;
	    var textSlots = ref.text;

	    if (defaultSlots) {
	      for (var i = 0; i < defaultSlots.length; i += 1) {
	        var child = defaultSlots[i];
	        var isRoot = (void 0);
	        {
	          var tag = child.type && (child.type.displayName || child.type.name);
	          if (tag === 'F7FabButtons' || tag === 'f7-fab-buttons') { isRoot = true; }
	        }
	        if (isRoot) { rootChildren.push(child); }else { linkChildren.push(child); }
	      }
	    }

	    var textEl;

	    if (text || textSlots && textSlots.length) {
	      textEl = react.createElement('div', {
	        className: 'fab-text'
	      }, text || textSlots);
	    }

	    var linkEl;

	    if (linkChildren.length || linkSlots && linkSlots.length) {
	      linkEl = react.createElement('a', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['linkEl'] = __reactNode;
	        },
	        target: target,
	        href: href,
	        key: 'f7-fab-link'
	      }, linkChildren, textEl, linkSlots);
	    }

	    var classes = Utils$1.classNames(className, 'fab', ("fab-" + position), {
	      'fab-morph': morphTo,
	      'fab-extended': typeof textEl !== 'undefined'
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes,
	      'data-morph-to': morphTo
	    }, linkEl, rootChildren, rootSlots);
	  };

	  F7Fab.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;

	    if (self.refs.linkEl) {
	      self.refs.linkEl.removeEventListener('click', self.onClick);
	    }

	    if (self.f7Tooltip && self.f7Tooltip.destroy) {
	      self.f7Tooltip.destroy();
	      self.f7Tooltip = null;
	      delete self.f7Tooltip;
	    }
	  };

	  F7Fab.prototype.componentDidMount = function componentDidMount () {
	    var self = this;

	    if (self.refs.linkEl) {
	      self.refs.linkEl.addEventListener('click', self.onClick);
	    }

	    var ref = self.props;
	    var tooltip = ref.tooltip;
	    if (!tooltip) { return; }
	    self.$f7ready(function (f7) {
	      self.f7Tooltip = f7.tooltip.create({
	        targetEl: self.refs.el,
	        text: tooltip
	      });
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Fab.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  F7Fab.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.tooltip', prevProps, prevState, function (newText) {
	      var self = this$1;
	      if (!newText || !self.f7Tooltip) { return; }
	      self.f7Tooltip.setText(newText);
	    });
	  };

	  Object.defineProperties( F7Fab.prototype, prototypeAccessors );

	  return F7Fab;
	}(react.Component));

	__reactComponentSetProps(F7Fab, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  morphTo: String,
	  href: [Boolean, String],
	  target: String,
	  text: String,
	  position: {
	    type: String,
	    default: 'right-bottom'
	  },
	  tooltip: String
	}, Mixins.colorProps));

	F7Fab.displayName = 'f7-fab';

	var F7Gauge = /*@__PURE__*/(function (superclass) {
	  function F7Gauge(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7Gauge.__proto__ = superclass;
	  F7Gauge.prototype = Object.create( superclass && superclass.prototype );
	  F7Gauge.prototype.constructor = F7Gauge;

	  F7Gauge.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var type = props.type;
	    var value = props.value;
	    var size = props.size;
	    var bgColor = props.bgColor;
	    var borderBgColor = props.borderBgColor;
	    var borderColor = props.borderColor;
	    var borderWidth = props.borderWidth;
	    var valueText = props.valueText;
	    var valueTextColor = props.valueTextColor;
	    var valueFontSize = props.valueFontSize;
	    var valueFontWeight = props.valueFontWeight;
	    var labelText = props.labelText;
	    var labelTextColor = props.labelTextColor;
	    var labelFontSize = props.labelFontSize;
	    var labelFontWeight = props.labelFontWeight;
	    var classes = Utils$1.classNames(className, 'gauge');
	    var semiCircle = type === 'semicircle';
	    var radius = size / 2 - borderWidth / 2;
	    var length = 2 * Math.PI * radius;
	    var progress = Math.max(Math.min(value, 1), 0);
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, react.createElement('svg', {
	      className: 'gauge-svg',
	      width: (size + "px"),
	      height: ((semiCircle ? size / 2 : size) + "px"),
	      viewBox: ("0 0 " + size + " " + (semiCircle ? size / 2 : size))
	    }, semiCircle && react.createElement('path', {
	      className: 'gauge-back-semi',
	      d: ("M" + (size - borderWidth / 2) + "," + (size / 2) + " a1,1 0 0,0 -" + (size - borderWidth) + ",0"),
	      stroke: borderBgColor,
	      strokeWidth: borderWidth,
	      fill: bgColor || 'none'
	    }), semiCircle && react.createElement('path', {
	      className: 'gauge-front-semi',
	      d: ("M" + (size - borderWidth / 2) + "," + (size / 2) + " a1,1 0 0,0 -" + (size - borderWidth) + ",0"),
	      stroke: borderColor,
	      strokeWidth: borderWidth,
	      strokeDasharray: length / 2,
	      strokeDashoffset: length / 2 * (1 + progress),
	      fill: borderBgColor ? 'none' : bgColor || 'none'
	    }), !semiCircle && borderBgColor && react.createElement('circle', {
	      className: 'gauge-back-circle',
	      stroke: borderBgColor,
	      strokeWidth: borderWidth,
	      fill: bgColor || 'none',
	      cx: size / 2,
	      cy: size / 2,
	      r: radius
	    }), !semiCircle && react.createElement('circle', {
	      className: 'gauge-front-circle',
	      transform: ("rotate(-90 " + (size / 2) + " " + (size / 2) + ")"),
	      stroke: borderColor,
	      strokeWidth: borderWidth,
	      strokeDasharray: length,
	      strokeDashoffset: length * (1 - progress),
	      fill: borderBgColor ? 'none' : bgColor || 'none',
	      cx: size / 2,
	      cy: size / 2,
	      r: radius
	    }), valueText && react.createElement('text', {
	      className: 'gauge-value-text',
	      x: '50%',
	      y: semiCircle ? '100%' : '50%',
	      fontWeight: valueFontWeight,
	      fontSize: valueFontSize,
	      fill: valueTextColor,
	      dy: semiCircle ? labelText ? -labelFontSize - 15 : -5 : 0,
	      textAnchor: 'middle',
	      dominantBaseline: !semiCircle ? 'middle' : null
	    }, valueText), labelText && react.createElement('text', {
	      className: 'gauge-label-text',
	      x: '50%',
	      y: semiCircle ? '100%' : '50%',
	      fontWeight: labelFontWeight,
	      fontSize: labelFontSize,
	      fill: labelTextColor,
	      dy: semiCircle ? -5 : valueText ? valueFontSize / 2 + 10 : 0,
	      textAnchor: 'middle',
	      dominantBaseline: !semiCircle ? 'middle' : null
	    }, labelText)));
	  };

	  return F7Gauge;
	}(react.Component));

	__reactComponentSetProps(F7Gauge, {
	  id: [String, Number],
	  className: String,
	  style: Object,
	  type: {
	    type: String,
	    default: 'circle'
	  },
	  value: {
	    type: [Number, String],
	    default: 0
	  },
	  size: {
	    type: [Number, String],
	    default: 200
	  },
	  bgColor: {
	    type: String,
	    default: 'transparent'
	  },
	  borderBgColor: {
	    type: String,
	    default: '#eeeeee'
	  },
	  borderColor: {
	    type: String,
	    default: '#000000'
	  },
	  borderWidth: {
	    type: [Number, String],
	    default: 10
	  },
	  valueText: [Number, String],
	  valueTextColor: {
	    type: String,
	    default: '#000000'
	  },
	  valueFontSize: {
	    type: [Number, String],
	    default: 31
	  },
	  valueFontWeight: {
	    type: [Number, String],
	    default: 500
	  },
	  labelText: String,
	  labelTextColor: {
	    type: String,
	    default: '#888888'
	  },
	  labelFontSize: {
	    type: [Number, String],
	    default: 14
	  },
	  labelFontWeight: {
	    type: [Number, String],
	    default: 400
	  }
	});

	F7Gauge.displayName = 'f7-gauge';

	var F7Toggle = /*@__PURE__*/(function (superclass) {
	  function F7Toggle(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onChange']);
	    })();
	  }

	  if ( superclass ) F7Toggle.__proto__ = superclass;
	  F7Toggle.prototype = Object.create( superclass && superclass.prototype );
	  F7Toggle.prototype.constructor = F7Toggle;

	  var prototypeAccessors = { refs: { configurable: true } };

	  F7Toggle.prototype.toggle = function toggle () {
	    var self = this;
	    if (self.f7Toggle && self.f7Toggle.toggle) { self.f7Toggle.toggle(); }
	  };

	  F7Toggle.prototype.onChange = function onChange (event) {
	    var self = this;
	    self.dispatchEvent('change', event);
	  };

	  F7Toggle.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var disabled = props.disabled;
	    var id = props.id;
	    var style = props.style;
	    var name = props.name;
	    var readonly = props.readonly;
	    var checked = props.checked;
	    var defaultChecked = props.defaultChecked;
	    var value = props.value;
	    var labelClasses = Utils$1.classNames('toggle', className, {
	      disabled: disabled
	    }, Mixins.colorClasses(props));
	    var inputEl;
	    {
	      inputEl = react.createElement('input', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['inputEl'] = __reactNode;
	        },
	        type: 'checkbox',
	        name: name,
	        disabled: disabled,
	        readOnly: readonly,
	        checked: checked,
	        defaultChecked: defaultChecked,
	        value: value,
	        onChange: self.onChange
	      });
	    }
	    return react.createElement('label', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: labelClasses
	    }, inputEl, react.createElement('span', {
	      className: 'toggle-icon'
	    }));
	  };

	  F7Toggle.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    if (self.f7Toggle && self.f7Toggle.destroy && self.f7Toggle.$el) { self.f7Toggle.destroy(); }
	  };

	  F7Toggle.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    if (!self.props.init) { return; }
	    self.$f7ready(function (f7) {
	      self.f7Toggle = f7.toggle.create({
	        el: self.refs.el,
	        on: {
	          change: function change(toggle) {
	            var checked = toggle.checked;
	            self.dispatchEvent('toggle:change toggleChange', checked);
	          }

	        }
	      });
	    });
	  };

	  F7Toggle.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  F7Toggle.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.checked', prevProps, prevState, function (newValue) {
	      var self = this$1;
	      if (!self.f7Toggle) { return; }
	      self.f7Toggle.checked = newValue;
	    });
	  };

	  Object.defineProperties( F7Toggle.prototype, prototypeAccessors );

	  return F7Toggle;
	}(react.Component));

	__reactComponentSetProps(F7Toggle, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  init: {
	    type: Boolean,
	    default: true
	  },
	  checked: Boolean,
	  defaultChecked: Boolean,
	  disabled: Boolean,
	  readonly: Boolean,
	  name: String,
	  value: [String, Number, Array]
	}, Mixins.colorProps));

	F7Toggle.displayName = 'f7-toggle';

	var F7Range = /*@__PURE__*/(function (superclass) {
	  function F7Range(props, context) {
	    superclass.call(this, props, context);
	    this.__reactRefs = {};
	  }

	  if ( superclass ) F7Range.__proto__ = superclass;
	  F7Range.prototype = Object.create( superclass && superclass.prototype );
	  F7Range.prototype.constructor = F7Range;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Range.prototype.setValue = function setValue (newValue) {
	    var self = this;
	    if (self.f7Range && self.f7Range.setValue) { self.f7Range.setValue(newValue); }
	  };

	  F7Range.prototype.getValue = function getValue () {
	    var self = this;

	    if (self.f7Range && self.f7Range.getValue) {
	      return self.f7Range.getValue();
	    }

	    return undefined;
	  };

	  F7Range.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var ref = self.props;
	    var id = ref.id;
	    var disabled = ref.disabled;
	    var className = ref.className;
	    var style = ref.style;
	    var input = ref.input;
	    var inputId = ref.inputId;
	    var name = ref.name;
	    var vertical = ref.vertical;
	    var verticalReversed = ref.verticalReversed;
	    var classes = Utils$1.classNames(className, 'range-slider', {
	      'range-slider-horizontal': !vertical,
	      'range-slider-vertical': vertical,
	      'range-slider-vertical-reversed': vertical && verticalReversed,
	      disabled: disabled
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes
	    }, input && react.createElement('input', {
	      type: 'range',
	      name: name,
	      id: inputId
	    }), this.slots['default']);
	  };

	  F7Range.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    if (self.f7Range && self.f7Range.destroy) { self.f7Range.destroy(); }
	  };

	  F7Range.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    self.$f7ready(function (f7) {
	      if (!self.props.init) { return; }
	      var props = self.props;
	      var value = props.value;
	      var min = props.min;
	      var max = props.max;
	      var step = props.step;
	      var label = props.label;
	      var dual = props.dual;
	      var draggableBar = props.draggableBar;
	      var vertical = props.vertical;
	      var verticalReversed = props.verticalReversed;
	      var formatLabel = props.formatLabel;
	      var scale = props.scale;
	      var scaleSteps = props.scaleSteps;
	      var scaleSubSteps = props.scaleSubSteps;
	      var formatScaleLabel = props.formatScaleLabel;
	      var limitKnobPosition = props.limitKnobPosition;
	      self.f7Range = f7.range.create(Utils$1.noUndefinedProps({
	        el: self.refs.el,
	        value: value,
	        min: min,
	        max: max,
	        step: step,
	        label: label,
	        dual: dual,
	        draggableBar: draggableBar,
	        vertical: vertical,
	        verticalReversed: verticalReversed,
	        formatLabel: formatLabel,
	        scale: scale,
	        scaleSteps: scaleSteps,
	        scaleSubSteps: scaleSubSteps,
	        formatScaleLabel: formatScaleLabel,
	        limitKnobPosition: limitKnobPosition,
	        on: {
	          change: function change(range, val) {
	            self.dispatchEvent('range:change rangeChange', val);
	          },

	          changed: function changed(range, val) {
	            self.dispatchEvent('range:changed rangeChanged', val);
	          }

	        }
	      }));
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Range.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  F7Range.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.value', prevProps, prevState, function (newValue) {
	      var self = this$1;
	      if (!self.f7Range) { return; }
	      self.f7Range.setValue(newValue);
	    });
	  };

	  Object.defineProperties( F7Range.prototype, prototypeAccessors );

	  return F7Range;
	}(react.Component));

	__reactComponentSetProps(F7Range, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  init: {
	    type: Boolean,
	    default: true
	  },
	  value: {
	    type: [Number, Array, String],
	    default: 0
	  },
	  min: {
	    type: [Number, String],
	    default: 0
	  },
	  max: {
	    type: [Number, String],
	    default: 100
	  },
	  step: {
	    type: [Number, String],
	    default: 1
	  },
	  label: {
	    type: Boolean,
	    default: false
	  },
	  dual: {
	    type: Boolean,
	    default: false
	  },
	  vertical: {
	    type: Boolean,
	    default: false
	  },
	  verticalReversed: {
	    type: Boolean,
	    default: false
	  },
	  draggableBar: {
	    type: Boolean,
	    default: true
	  },
	  formatLabel: Function,
	  scale: {
	    type: Boolean,
	    default: false
	  },
	  scaleSteps: {
	    type: Number,
	    default: 5
	  },
	  scaleSubSteps: {
	    type: Number,
	    default: 0
	  },
	  formatScaleLabel: Function,
	  limitKnobPosition: {
	    type: Boolean,
	    default: undefined
	  },
	  name: String,
	  input: Boolean,
	  inputId: String,
	  disabled: Boolean
	}, Mixins.colorProps));

	F7Range.displayName = 'f7-range';

	var F7Input = /*@__PURE__*/(function (superclass) {
	  function F7Input(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    this.state = (function () {
	      return {
	        inputFocused: false,
	        inputInvalid: false
	      };
	    })();

	    (function () {
	      Utils$1.bindMethods(this$1, 'onFocus onBlur onInput onChange onTextareaResize onInputNotEmpty onInputEmpty onInputClear'.split(' '));
	    })();
	  }

	  if ( superclass ) F7Input.__proto__ = superclass;
	  F7Input.prototype = Object.create( superclass && superclass.prototype );
	  F7Input.prototype.constructor = F7Input;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Input.prototype.domValue = function domValue () {
	    var self = this;
	    var ref = self.refs;
	    var inputEl = ref.inputEl;
	    if (!inputEl) { return undefined; }
	    return inputEl.value;
	  };

	  F7Input.prototype.inputHasValue = function inputHasValue () {
	    var self = this;
	    var ref = self.props;
	    var value = ref.value;
	    var domValue = self.domValue();
	    return typeof value === 'undefined' ? domValue || domValue === 0 : value || value === 0;
	  };

	  F7Input.prototype.validateInput = function validateInput (inputEl) {
	    var self = this;
	    var f7 = self.$f7;
	    if (!f7 || !inputEl) { return; }
	    var validity = inputEl.validity;
	    if (!validity) { return; }

	    if (!validity.valid) {
	      if (self.state.inputInvalid !== true) {
	        self.setState({
	          inputInvalid: true
	        });
	      }
	    } else if (self.state.inputInvalid !== false) {
	      self.setState({
	        inputInvalid: false
	      });
	    }
	  };

	  F7Input.prototype.onTextareaResize = function onTextareaResize (event) {
	    this.dispatchEvent('textarea:resize textareaResize', event);
	  };

	  F7Input.prototype.onInputNotEmpty = function onInputNotEmpty (event) {
	    this.dispatchEvent('input:notempty inputNotEmpty', event);
	  };

	  F7Input.prototype.onInputEmpty = function onInputEmpty (event) {
	    this.dispatchEvent('input:empty inputEmpty', event);
	  };

	  F7Input.prototype.onInputClear = function onInputClear (event) {
	    this.dispatchEvent('input:clear inputClear', event);
	  };

	  F7Input.prototype.onInput = function onInput (event) {
	    var self = this;
	    var ref = self.props;
	    var validate = ref.validate;
	    var validateOnBlur = ref.validateOnBlur;
	    self.dispatchEvent('input', event);

	    if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && self.refs && self.refs.inputEl) {
	      self.validateInput(self.refs.inputEl);
	    }
	  };

	  F7Input.prototype.onFocus = function onFocus (event) {
	    this.dispatchEvent('focus', event);
	    this.setState({
	      inputFocused: true
	    });
	  };

	  F7Input.prototype.onBlur = function onBlur (event) {
	    var self = this;
	    var ref = self.props;
	    var validate = ref.validate;
	    var validateOnBlur = ref.validateOnBlur;
	    self.dispatchEvent('blur', event);

	    if ((validate || validate === '' || validateOnBlur || validateOnBlur === '') && self.refs && self.refs.inputEl) {
	      self.validateInput(self.refs.inputEl);
	    }

	    self.setState({
	      inputFocused: false
	    });
	  };

	  F7Input.prototype.onChange = function onChange (event) {
	    this.dispatchEvent('change', event);
	  };

	  F7Input.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var type = props.type;
	    var name = props.name;
	    var value = props.value;
	    var defaultValue = props.defaultValue;
	    var placeholder = props.placeholder;
	    var id = props.id;
	    var inputId = props.inputId;
	    var size = props.size;
	    var accept = props.accept;
	    var autocomplete = props.autocomplete;
	    var autocorrect = props.autocorrect;
	    var autocapitalize = props.autocapitalize;
	    var spellcheck = props.spellcheck;
	    var autofocus = props.autofocus;
	    var autosave = props.autosave;
	    var checked = props.checked;
	    var disabled = props.disabled;
	    var max = props.max;
	    var min = props.min;
	    var step = props.step;
	    var maxlength = props.maxlength;
	    var minlength = props.minlength;
	    var multiple = props.multiple;
	    var readonly = props.readonly;
	    var required = props.required;
	    var inputStyle = props.inputStyle;
	    var pattern = props.pattern;
	    var validate = props.validate;
	    var validateOnBlur = props.validateOnBlur;
	    var tabindex = props.tabindex;
	    var resizable = props.resizable;
	    var clearButton = props.clearButton;
	    var errorMessage = props.errorMessage;
	    var errorMessageForce = props.errorMessageForce;
	    var info = props.info;
	    var wrap = props.wrap;
	    var dropdown = props.dropdown;
	    var style = props.style;
	    var className = props.className;
	    var noStoreData = props.noStoreData;
	    var noFormStoreData = props.noFormStoreData;
	    var ignoreStoreData = props.ignoreStoreData;
	    var outline = props.outline;
	    var domValue = self.domValue();
	    var inputHasValue = self.inputHasValue();
	    var inputEl;

	    var createInput = function (InputTag, children) {
	      var needsValue = type !== 'file' && type !== 'datepicker' && type !== 'colorpicker';
	      var needsType = InputTag === 'input';
	      var inputType = type;

	      if (inputType === 'datepicker' || inputType === 'colorpicker') {
	        inputType = 'text';
	      }

	      var inputClassName = Utils$1.classNames(!wrap && className, {
	        resizable: inputType === 'textarea' && resizable,
	        'no-store-data': noFormStoreData || noStoreData || ignoreStoreData,
	        'input-invalid': errorMessage && errorMessageForce || self.state.inputInvalid,
	        'input-with-value': inputHasValue,
	        'input-focused': self.state.inputFocused
	      });
	      var input;
	      var inputValue;

	      if (needsValue) {
	        if (typeof value !== 'undefined') { inputValue = value; }else { inputValue = domValue; }
	      }

	      var valueProps = {};

	      if (type !== 'datepicker' && type !== 'colorpicker') {
	        if ('value' in props) { valueProps.value = inputValue; }
	        if ('defaultValue' in props) { valueProps.defaultValue = defaultValue; }
	      }

	      {
	        input = react.createElement(InputTag, Object.assign({
	          ref: function (__reactNode) {
	            this$1.__reactRefs['inputEl'] = __reactNode;
	          },
	          style: inputStyle,
	          name: name,
	          type: needsType ? inputType : undefined,
	          placeholder: placeholder,
	          id: inputId,
	          size: size,
	          accept: accept,
	          autoComplete: autocomplete,
	          autoCorrect: autocorrect,
	          autoCapitalize: autocapitalize,
	          spellCheck: spellcheck,
	          autoFocus: autofocus,
	          autoSave: autosave,
	          checked: checked,
	          disabled: disabled,
	          max: max,
	          maxLength: maxlength,
	          min: min,
	          minLength: minlength,
	          step: step,
	          multiple: multiple,
	          readOnly: readonly,
	          required: required,
	          pattern: pattern,
	          validate: typeof validate === 'string' && validate.length ? validate : undefined,
	          'data-validate': validate === true || validate === '' || validateOnBlur === true || validateOnBlur === '' ? true : undefined,
	          'data-validate-on-blur': validateOnBlur === true || validateOnBlur === '' ? true : undefined,
	          tabIndex: tabindex,
	          'data-error-message': errorMessageForce ? undefined : errorMessage,
	          className: inputClassName,
	          onFocus: self.onFocus,
	          onBlur: self.onBlur,
	          onInput: self.onInput,
	          onChange: self.onChange
	        }, valueProps), children);
	      }
	      return input;
	    };

	    var ref = self.slots;
	    var slotsDefault = ref.default;
	    var slotsInfo = ref.info;

	    if (type === 'select' || type === 'textarea' || type === 'file') {
	      if (type === 'select') {
	        inputEl = createInput('select', slotsDefault);
	      } else if (type === 'file') {
	        inputEl = createInput('input');
	      } else {
	        inputEl = createInput('textarea');
	      }
	    } else if (slotsDefault && slotsDefault.length > 0 || !type) {
	      inputEl = slotsDefault;
	    } else if (type === 'toggle') {
	      inputEl = react.createElement(F7Toggle, {
	        checked: checked,
	        readonly: readonly,
	        name: name,
	        value: value,
	        disabled: disabled,
	        id: inputId,
	        onChange: self.onChange
	      });
	    } else if (type === 'range') {
	      inputEl = react.createElement(F7Range, {
	        value: value,
	        disabled: disabled,
	        min: min,
	        max: max,
	        step: step,
	        name: name,
	        id: inputId,
	        input: true,
	        onRangeChange: self.onChange
	      });
	    } else {
	      inputEl = createInput('input');
	    }

	    if (wrap) {
	      var wrapClasses = Utils$1.classNames(className, 'input', {
	        'input-outline': outline,
	        'input-dropdown': dropdown === 'auto' ? type === 'select' : dropdown
	      }, Mixins.colorClasses(props));
	      return react.createElement('div', {
	        id: id,
	        ref: function (__reactNode) {
	          this$1.__reactRefs['wrapEl'] = __reactNode;
	        },
	        className: wrapClasses,
	        style: style
	      }, inputEl, errorMessage && errorMessageForce && react.createElement('div', {
	        className: 'input-error-message'
	      }, errorMessage), clearButton && react.createElement('span', {
	        className: 'input-clear-button'
	      }), (info || slotsInfo && slotsInfo.length) && react.createElement('div', {
	        className: 'input-info'
	      }, info, this.slots['info']));
	    }

	    return inputEl;
	  };

	  F7Input.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var ref = self.props;
	    var type = ref.type;
	    var resizable = ref.resizable;
	    var clearButton = ref.clearButton;
	    if (type === 'range' || type === 'toggle') { return; }
	    var inputEl = self.refs.inputEl;
	    if (!inputEl) { return; }
	    inputEl.removeEventListener('input:notempty', self.onInputNotEmpty, false);

	    if (type === 'textarea' && resizable) {
	      inputEl.removeEventListener('textarea:resize', self.onTextareaResize, false);
	    }

	    if (clearButton) {
	      inputEl.removeEventListener('input:empty', self.onInputEmpty, false);
	      inputEl.removeEventListener('input:clear', self.onInputClear, false);
	    }

	    if (self.f7Calendar && self.f7Calendar.destroy) {
	      self.f7Calendar.destroy();
	    }

	    if (self.f7ColorPicker && self.f7ColorPicker.destroy) {
	      self.f7ColorPicker.destroy();
	    }

	    delete self.f7Calendar;
	    delete self.f7ColorPicker;
	  };

	  F7Input.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.value', prevProps, prevState, function () {
	      var self = this$1;
	      var ref = self.props;
	      var type = ref.type;
	      if (type === 'range' || type === 'toggle') { return; }
	      if (!self.$f7) { return; }
	      self.updateInputOnDidUpdate = true;

	      if (self.f7Calendar) {
	        self.f7Calendar.setValue(self.props.value);
	      }

	      if (self.f7ColorPicker) {
	        self.f7ColorPicker.setValue(self.props.value);
	      }
	    });

	    var self = this;
	    var ref = self.props;
	    var validate = ref.validate;
	    var validateOnBlur = ref.validateOnBlur;
	    var resizable = ref.resizable;
	    var f7 = self.$f7;
	    if (!f7) { return; }

	    if (self.updateInputOnDidUpdate) {
	      var inputEl = self.refs.inputEl;
	      if (!inputEl) { return; }
	      self.updateInputOnDidUpdate = false;
	      f7.input.checkEmptyState(inputEl);

	      if (validate && !validateOnBlur) {
	        self.validateInput(inputEl);
	      }

	      if (resizable) {
	        f7.input.resizeTextarea(inputEl);
	      }
	    }
	  };

	  F7Input.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    self.$f7ready(function (f7) {
	      var ref = self.props;
	      var validate = ref.validate;
	      var validateOnBlur = ref.validateOnBlur;
	      var resizable = ref.resizable;
	      var type = ref.type;
	      var clearButton = ref.clearButton;
	      var value = ref.value;
	      var defaultValue = ref.defaultValue;
	      var calendarParams = ref.calendarParams;
	      var colorPickerParams = ref.colorPickerParams;
	      if (type === 'range' || type === 'toggle') { return; }
	      var inputEl = self.refs.inputEl;
	      if (!inputEl) { return; }
	      inputEl.addEventListener('input:notempty', self.onInputNotEmpty, false);

	      if (type === 'textarea' && resizable) {
	        inputEl.addEventListener('textarea:resize', self.onTextareaResize, false);
	      }

	      if (clearButton) {
	        inputEl.addEventListener('input:empty', self.onInputEmpty, false);
	        inputEl.addEventListener('input:clear', self.onInputClear, false);
	      }

	      if (type === 'datepicker') {
	        self.f7Calendar = f7.calendar.create(Object.assign({
	          inputEl: inputEl,
	          value: value,
	          on: {
	            change: function change(calendar, calendarValue) {
	              self.dispatchEvent('calendar:change calendarChange', calendarValue);
	            }

	          }
	        }, calendarParams || {}));
	      }

	      if (type === 'colorpicker') {
	        self.f7ColorPicker = f7.colorPicker.create(Object.assign({
	          inputEl: inputEl,
	          value: value,
	          on: {
	            change: function change(colorPicker, colorPickerValue) {
	              self.dispatchEvent('colorpicker:change colorPickerChange', colorPickerValue);
	            }

	          }
	        }, colorPickerParams || {}));
	      }

	      f7.input.checkEmptyState(inputEl);

	      if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && (typeof value !== 'undefined' && value !== null && value !== '' || typeof defaultValue !== 'undefined' && defaultValue !== null && defaultValue !== '')) {
	        setTimeout(function () {
	          self.validateInput(inputEl);
	        }, 0);
	      }

	      if (resizable) {
	        f7.input.resizeTextarea(inputEl);
	      }
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Input.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Input.prototype, prototypeAccessors );

	  return F7Input;
	}(react.Component));

	__reactComponentSetProps(F7Input, Object.assign({
	  type: String,
	  name: String,
	  value: [String, Number, Array, Date, Object],
	  defaultValue: [String, Number, Array],
	  placeholder: String,
	  id: [String, Number],
	  className: String,
	  style: Object,
	  inputId: [String, Number],
	  size: [String, Number],
	  accept: [String, Number],
	  autocomplete: [String],
	  autocorrect: [String],
	  autocapitalize: [String],
	  spellcheck: [String],
	  autofocus: Boolean,
	  autosave: String,
	  checked: Boolean,
	  disabled: Boolean,
	  max: [String, Number],
	  min: [String, Number],
	  step: [String, Number],
	  maxlength: [String, Number],
	  minlength: [String, Number],
	  multiple: Boolean,
	  readonly: Boolean,
	  required: Boolean,
	  inputStyle: Object,
	  pattern: String,
	  validate: [Boolean, String],
	  validateOnBlur: Boolean,
	  tabindex: [String, Number],
	  resizable: Boolean,
	  clearButton: Boolean,
	  noFormStoreData: Boolean,
	  noStoreData: Boolean,
	  ignoreStoreData: Boolean,
	  errorMessage: String,
	  errorMessageForce: Boolean,
	  info: String,
	  outline: Boolean,
	  wrap: {
	    type: Boolean,
	    default: true
	  },
	  dropdown: {
	    type: [String, Boolean],
	    default: 'auto'
	  },
	  calendarParams: Object,
	  colorPickerParams: Object
	}, Mixins.colorProps));

	F7Input.displayName = 'f7-input';

	var F7Link = /*@__PURE__*/(function (superclass) {
	  function F7Link(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    this.state = (function () {
	      return {
	        isTabbarLabel: props.tabbarLabel
	      };
	    })();

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick']);
	    })();
	  }

	  if ( superclass ) F7Link.__proto__ = superclass;
	  F7Link.prototype = Object.create( superclass && superclass.prototype );
	  F7Link.prototype.constructor = F7Link;

	  var prototypeAccessors = { attrs: { configurable: true },classes: { configurable: true },slots: { configurable: true },refs: { configurable: true } };

	  F7Link.prototype.onClick = function onClick (event) {
	    this.dispatchEvent('click', event);
	  };

	  prototypeAccessors.attrs.get = function () {
	    var self = this;
	    var props = self.props;
	    var href = props.href;
	    var target = props.target;
	    var tabLink = props.tabLink;
	    var hrefComputed = href;
	    if (href === true) { hrefComputed = '#'; }
	    if (href === false) { hrefComputed = undefined; }
	    return Utils$1.extend({
	      href: hrefComputed,
	      target: target,
	      'data-tab': Utils$1.isStringProp(tabLink) && tabLink || undefined
	    }, Mixins.linkRouterAttrs(props), Mixins.linkActionsAttrs(props));
	  };

	  prototypeAccessors.classes.get = function () {
	    var self = this;
	    var props = self.props;
	    var noFastclick = props.noFastclick;
	    var noFastClick = props.noFastClick;
	    var tabLink = props.tabLink;
	    var tabLinkActive = props.tabLinkActive;
	    var noLinkClass = props.noLinkClass;
	    var smartSelect = props.smartSelect;
	    var className = props.className;
	    return Utils$1.classNames(className, {
	      link: !(noLinkClass || self.state.isTabbarLabel),
	      'icon-only': self.iconOnlyComputed,
	      'tab-link': tabLink || tabLink === '',
	      'tab-link-active': tabLinkActive,
	      'no-fastclick': noFastclick || noFastClick,
	      'smart-select': smartSelect
	    }, Mixins.colorClasses(props), Mixins.linkRouterClasses(props), Mixins.linkActionsClasses(props));
	  };

	  F7Link.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var text = props.text;
	    var badge = props.badge;
	    var badgeColor = props.badgeColor;
	    var iconOnly = props.iconOnly;
	    var iconBadge = props.iconBadge;
	    var icon = props.icon;
	    var iconColor = props.iconColor;
	    var iconSize = props.iconSize;
	    var iconMaterial = props.iconMaterial;
	    var iconIon = props.iconIon;
	    var iconFa = props.iconFa;
	    var iconF7 = props.iconF7;
	    var iconMd = props.iconMd;
	    var iconIos = props.iconIos;
	    var iconAurora = props.iconAurora;
	    var id = props.id;
	    var style = props.style;
	    var defaultSlots = self.slots.default;
	    var iconEl;
	    var textEl;
	    var badgeEl;
	    var iconBadgeEl;

	    if (text) {
	      if (badge) { badgeEl = react.createElement(F7Badge, {
	        color: badgeColor
	      }, badge); }
	      textEl = react.createElement('span', {
	        className: self.state.isTabbarLabel ? 'tabbar-label' : ''
	      }, text, badgeEl);
	    }

	    if (icon || iconMaterial || iconIon || iconFa || iconF7 || iconMd || iconIos || iconAurora) {
	      if (iconBadge) {
	        iconBadgeEl = react.createElement(F7Badge, {
	          color: badgeColor
	        }, iconBadge);
	      }

	      iconEl = react.createElement(F7Icon, {
	        material: iconMaterial,
	        f7: iconF7,
	        fa: iconFa,
	        ion: iconIon,
	        icon: icon,
	        md: iconMd,
	        ios: iconIos,
	        aurora: iconAurora,
	        color: iconColor,
	        size: iconSize
	      }, iconBadgeEl);
	    }

	    if (iconOnly || !text && defaultSlots && defaultSlots.length === 0 || !text && !defaultSlots) {
	      self.iconOnlyComputed = true;
	    } else {
	      self.iconOnlyComputed = false;
	    }

	    return react.createElement('a', Object.assign({
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: self.classes
	    }, self.attrs), iconEl, textEl, defaultSlots);
	  };

	  F7Link.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var el = self.refs.el;
	    el.removeEventListener('click', self.onClick);
	    delete el.f7RouteProps;

	    if (self.f7SmartSelect && self.f7SmartSelect.destroy) {
	      self.f7SmartSelect.destroy();
	    }

	    if (self.f7Tooltip && self.f7Tooltip.destroy) {
	      self.f7Tooltip.destroy();
	      self.f7Tooltip = null;
	      delete self.f7Tooltip;
	    }
	  };

	  F7Link.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.tooltip', prevProps, prevState, function (newText) {
	      var self = this$1;
	      if (!newText || !self.f7Tooltip) { return; }
	      self.f7Tooltip.setText(newText);
	    });

	    var self = this;
	    var el = self.refs.el;
	    var ref = self.props;
	    var routeProps = ref.routeProps;

	    if (routeProps) {
	      el.f7RouteProps = routeProps;
	    }
	  };

	  F7Link.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    el.addEventListener('click', self.onClick);
	    var ref = self.props;
	    var tabbarLabel = ref.tabbarLabel;
	    var tabLink = ref.tabLink;
	    var tooltip = ref.tooltip;
	    var smartSelect = ref.smartSelect;
	    var smartSelectParams = ref.smartSelectParams;
	    var routeProps = ref.routeProps;
	    var isTabbarLabel = false;

	    if (tabbarLabel || (tabLink || tabLink === '') && self.$$(el).parents('.tabbar-labels').length) {
	      isTabbarLabel = true;
	    }

	    self.setState({
	      isTabbarLabel: isTabbarLabel
	    });
	    if (routeProps) { el.f7RouteProps = routeProps; }
	    self.$f7ready(function (f7) {
	      if (smartSelect) {
	        var ssParams = Utils$1.extend({
	          el: el
	        }, smartSelectParams || {});
	        self.f7SmartSelect = f7.smartSelect.create(ssParams);
	      }

	      if (tooltip) {
	        self.f7Tooltip = f7.tooltip.create({
	          targetEl: el,
	          text: tooltip
	        });
	      }
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Link.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Link.prototype, prototypeAccessors );

	  return F7Link;
	}(react.Component));

	__reactComponentSetProps(F7Link, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  noLinkClass: Boolean,
	  noFastClick: Boolean,
	  noFastclick: Boolean,
	  text: String,
	  tabLink: [Boolean, String],
	  tabLinkActive: Boolean,
	  tabbarLabel: Boolean,
	  iconOnly: Boolean,
	  badge: [String, Number],
	  badgeColor: [String],
	  iconBadge: [String, Number],
	  href: {
	    type: [String, Boolean],
	    default: '#'
	  },
	  target: String,
	  tooltip: String,
	  smartSelect: Boolean,
	  smartSelectParams: Object
	}, Mixins.colorProps, Mixins.linkIconProps, Mixins.linkRouterProps, Mixins.linkActionsProps));

	F7Link.displayName = 'f7-link';

	var F7ListButton = /*@__PURE__*/(function (superclass) {
	  function F7ListButton(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick']);
	    })();
	  }

	  if ( superclass ) F7ListButton.__proto__ = superclass;
	  F7ListButton.prototype = Object.create( superclass && superclass.prototype );
	  F7ListButton.prototype.constructor = F7ListButton;

	  var prototypeAccessors = { attrs: { configurable: true },classes: { configurable: true },slots: { configurable: true },refs: { configurable: true } };

	  F7ListButton.prototype.onClick = function onClick (event) {
	    this.dispatchEvent('click', event);
	  };

	  prototypeAccessors.attrs.get = function () {
	    var self = this;
	    var props = self.props;
	    var link = props.link;
	    var href = props.href;
	    var target = props.target;
	    var tabLink = props.tabLink;
	    return Utils$1.extend({
	      href: typeof link === 'boolean' && typeof href === 'boolean' ? '#' : link || href,
	      target: target,
	      'data-tab': Utils$1.isStringProp(tabLink) && tabLink
	    }, Mixins.linkRouterAttrs(props), Mixins.linkActionsAttrs(props));
	  };

	  prototypeAccessors.classes.get = function () {
	    var self = this;
	    var props = self.props;
	    var noFastclick = props.noFastclick;
	    var noFastClick = props.noFastClick;
	    var tabLink = props.tabLink;
	    var tabLinkActive = props.tabLinkActive;
	    return Utils$1.classNames({
	      'list-button': true,
	      'tab-link': tabLink || tabLink === '',
	      'tab-link-active': tabLinkActive,
	      'no-fastclick': noFastclick || noFastClick
	    }, Mixins.colorClasses(props), Mixins.linkRouterClasses(props), Mixins.linkActionsClasses(props));
	  };

	  F7ListButton.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var title = props.title;
	    var text = props.text;
	    return react.createElement('li', {
	      id: id,
	      style: style,
	      className: className
	    }, react.createElement('a', Object.assign({
	      className: self.classes
	    }, self.attrs, {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['linkEl'] = __reactNode;
	      }
	    }), this.slots['default'], !this.slots.default && (title || text)));
	  };

	  F7ListButton.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var linkEl = self.refs.linkEl;
	    linkEl.removeEventListener('click', this.onClick);
	    delete linkEl.f7RouteProps;
	  };

	  F7ListButton.prototype.componentDidUpdate = function componentDidUpdate () {
	    var self = this;
	    var linkEl = self.refs.linkEl;
	    var ref = self.props;
	    var routeProps = ref.routeProps;

	    if (routeProps) {
	      linkEl.f7RouteProps = routeProps;
	    }
	  };

	  F7ListButton.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var linkEl = self.refs.linkEl;
	    var ref = self.props;
	    var routeProps = ref.routeProps;

	    if (routeProps) {
	      linkEl.f7RouteProps = routeProps;
	    }

	    linkEl.addEventListener('click', self.onClick);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7ListButton.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7ListButton.prototype, prototypeAccessors );

	  return F7ListButton;
	}(react.Component));

	__reactComponentSetProps(F7ListButton, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  noFastclick: Boolean,
	  noFastClick: Boolean,
	  title: [String, Number],
	  text: [String, Number],
	  tabLink: [Boolean, String],
	  tabLinkActive: Boolean,
	  link: [Boolean, String],
	  href: [Boolean, String],
	  target: String
	}, Mixins.colorProps, Mixins.linkRouterProps, Mixins.linkActionsProps));

	F7ListButton.displayName = 'f7-list-button';

	var F7ListGroup = /*@__PURE__*/(function (superclass) {
	  function F7ListGroup(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7ListGroup.__proto__ = superclass;
	  F7ListGroup.prototype = Object.create( superclass && superclass.prototype );
	  F7ListGroup.prototype.constructor = F7ListGroup;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7ListGroup.prototype.render = function render () {
	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var mediaList = props.mediaList;
	    var sortable = props.sortable;
	    var classes = Utils$1.classNames(className, 'list-group', {
	      'media-list': mediaList,
	      sortable: sortable
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, react.createElement('ul', null, this.slots['default']));
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7ListGroup.prototype, prototypeAccessors );

	  return F7ListGroup;
	}(react.Component));

	__reactComponentSetProps(F7ListGroup, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  mediaList: Boolean,
	  sortable: Boolean
	}, Mixins.colorProps));

	F7ListGroup.displayName = 'f7-list-group';

	var F7ListIndex = /*@__PURE__*/(function (superclass) {
	  function F7ListIndex(props, context) {
	    superclass.call(this, props, context);
	    this.__reactRefs = {};
	  }

	  if ( superclass ) F7ListIndex.__proto__ = superclass;
	  F7ListIndex.prototype = Object.create( superclass && superclass.prototype );
	  F7ListIndex.prototype.constructor = F7ListIndex;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7ListIndex.prototype.update = function update () {
	    if (!this.f7ListIndex) { return; }
	    this.f7ListIndex.update();
	  };

	  F7ListIndex.prototype.scrollListToIndex = function scrollListToIndex (indexContent) {
	    if (!this.f7ListIndex) { return; }
	    this.f7ListIndex.scrollListToIndex(indexContent);
	  };

	  F7ListIndex.prototype.render = function render () {
	    var this$1 = this;

	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'list-index', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  F7ListIndex.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    if (!self.props.init) { return; }
	    self.$f7ready(function (f7) {
	      var el = self.refs.el;
	      var ref = self.props;
	      var listEl = ref.listEl;
	      var indexes = ref.indexes;
	      var iosItemHeight = ref.iosItemHeight;
	      var mdItemHeight = ref.mdItemHeight;
	      var auroraItemHeight = ref.auroraItemHeight;
	      var scrollList = ref.scrollList;
	      var label = ref.label;
	      self.f7ListIndex = f7.listIndex.create({
	        el: el,
	        listEl: listEl,
	        indexes: indexes,
	        iosItemHeight: iosItemHeight,
	        mdItemHeight: mdItemHeight,
	        auroraItemHeight: auroraItemHeight,
	        scrollList: scrollList,
	        label: label,
	        on: {
	          select: function select(index, itemContent, itemIndex) {
	            self.dispatchEvent('listindex:select listIndexSelect', itemContent, itemIndex);
	          }

	        }
	      });
	    });
	  };

	  F7ListIndex.prototype.componentWillUnmount = function componentWillUnmount () {
	    if (!this.props.init) { return; }

	    if (this.f7ListIndex && this.f7ListIndex.destroy) {
	      this.f7ListIndex.destroy();
	    }
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7ListIndex.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  F7ListIndex.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.indexes', prevProps, prevState, function () {
	      if (!this$1.f7ListIndex) { return; }
	      this$1.f7ListIndex.params.indexes = this$1.props.indexes;
	      this$1.update();
	    });
	  };

	  Object.defineProperties( F7ListIndex.prototype, prototypeAccessors );

	  return F7ListIndex;
	}(react.Component));

	__reactComponentSetProps(F7ListIndex, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  init: {
	    type: Boolean,
	    default: true
	  },
	  listEl: [String, Object],
	  indexes: {
	    type: [String, Array],
	    default: 'auto'
	  },
	  scrollList: {
	    type: Boolean,
	    default: true
	  },
	  label: {
	    type: Boolean,
	    default: false
	  },
	  iosItemHeight: {
	    type: Number,
	    default: 14
	  },
	  mdItemHeight: {
	    type: Number,
	    default: 14
	  },
	  auroraItemHeight: {
	    type: Number,
	    default: 14
	  }
	}, Mixins.colorProps));

	F7ListIndex.displayName = 'f7-list-index';

	var F7ListInput = /*@__PURE__*/(function (superclass) {
	  function F7ListInput(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    this.state = (function () {
	      return {
	        isSortable: props.sortable,
	        inputFocused: false,
	        inputInvalid: false
	      };
	    })();

	    (function () {
	      Utils$1.bindMethods(this$1, 'onChange onInput onFocus onBlur onTextareaResize onInputNotEmpty onInputEmpty onInputClear'.split(' '));
	    })();
	  }

	  if ( superclass ) F7ListInput.__proto__ = superclass;
	  F7ListInput.prototype = Object.create( superclass && superclass.prototype );
	  F7ListInput.prototype.constructor = F7ListInput;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7ListInput.prototype.domValue = function domValue () {
	    var self = this;
	    var ref = self.refs;
	    var inputEl = ref.inputEl;
	    if (!inputEl) { return undefined; }
	    return inputEl.value;
	  };

	  F7ListInput.prototype.inputHasValue = function inputHasValue () {
	    var self = this;
	    var ref = self.props;
	    var value = ref.value;
	    var domValue = self.domValue();
	    return typeof value === 'undefined' ? domValue || domValue === 0 : value || value === 0;
	  };

	  F7ListInput.prototype.validateInput = function validateInput (inputEl) {
	    var self = this;
	    var f7 = self.$f7;
	    if (!f7 || !inputEl) { return; }
	    var validity = inputEl.validity;
	    if (!validity) { return; }

	    if (!validity.valid) {
	      if (self.state.inputInvalid !== true) {
	        self.setState({
	          inputInvalid: true
	        });
	      }
	    } else if (self.state.inputInvalid !== false) {
	      self.setState({
	        inputInvalid: false
	      });
	    }
	  };

	  F7ListInput.prototype.onTextareaResize = function onTextareaResize (event) {
	    this.dispatchEvent('textarea:resize textareaResize', event);
	  };

	  F7ListInput.prototype.onInputNotEmpty = function onInputNotEmpty (event) {
	    this.dispatchEvent('input:notempty inputNotEmpty', event);
	  };

	  F7ListInput.prototype.onInputEmpty = function onInputEmpty (event) {
	    this.dispatchEvent('input:empty inputEmpty', event);
	  };

	  F7ListInput.prototype.onInputClear = function onInputClear (event) {
	    this.dispatchEvent('input:clear inputClear', event);
	  };

	  F7ListInput.prototype.onInput = function onInput (event) {
	    var self = this;
	    var ref = self.props;
	    var validate = ref.validate;
	    var validateOnBlur = ref.validateOnBlur;
	    self.dispatchEvent('input', event);

	    if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && self.refs && self.refs.inputEl) {
	      self.validateInput(self.refs.inputEl);
	    }
	  };

	  F7ListInput.prototype.onFocus = function onFocus (event) {
	    this.dispatchEvent('focus', event);
	    this.setState({
	      inputFocused: true
	    });
	  };

	  F7ListInput.prototype.onBlur = function onBlur (event) {
	    var self = this;
	    var ref = self.props;
	    var validate = ref.validate;
	    var validateOnBlur = ref.validateOnBlur;
	    self.dispatchEvent('blur', event);

	    if ((validate || validate === '' || validateOnBlur || validateOnBlur === '') && self.refs && self.refs.inputEl) {
	      self.validateInput(self.refs.inputEl);
	    }

	    self.setState({
	      inputFocused: false
	    });
	  };

	  F7ListInput.prototype.onChange = function onChange (event) {
	    this.dispatchEvent('change', event);
	  };

	  F7ListInput.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var ref = self.state;
	    var inputFocused = ref.inputFocused;
	    var inputInvalid = ref.inputInvalid;
	    var props = self.props;
	    var id = props.id;
	    var style = props.style;
	    var className = props.className;
	    var sortable = props.sortable;
	    var media = props.media;
	    var dropdown = props.dropdown;
	    var renderInput = props.input;
	    var wrap = props.wrap;
	    var type = props.type;
	    var name = props.name;
	    var value = props.value;
	    var defaultValue = props.defaultValue;
	    var readonly = props.readonly;
	    var required = props.required;
	    var disabled = props.disabled;
	    var placeholder = props.placeholder;
	    var inputId = props.inputId;
	    var size = props.size;
	    var accept = props.accept;
	    var autocomplete = props.autocomplete;
	    var autocorrect = props.autocorrect;
	    var autocapitalize = props.autocapitalize;
	    var spellcheck = props.spellcheck;
	    var autofocus = props.autofocus;
	    var autosave = props.autosave;
	    var max = props.max;
	    var min = props.min;
	    var step = props.step;
	    var maxlength = props.maxlength;
	    var minlength = props.minlength;
	    var multiple = props.multiple;
	    var inputStyle = props.inputStyle;
	    var pattern = props.pattern;
	    var validate = props.validate;
	    var validateOnBlur = props.validateOnBlur;
	    var tabindex = props.tabindex;
	    var resizable = props.resizable;
	    var clearButton = props.clearButton;
	    var noFormStoreData = props.noFormStoreData;
	    var noStoreData = props.noStoreData;
	    var ignoreStoreData = props.ignoreStoreData;
	    var errorMessage = props.errorMessage;
	    var errorMessageForce = props.errorMessageForce;
	    var info = props.info;
	    var outline = props.outline;
	    var label = props.label;
	    var inlineLabel = props.inlineLabel;
	    var floatingLabel = props.floatingLabel;
	    var domValue = self.domValue();
	    var inputHasValue = self.inputHasValue();
	    var isSortable = sortable || self.state.isSortable;

	    var createInput = function (InputTag, children) {
	      var needsValue = type !== 'file' && type !== 'datepicker' && type !== 'colorpicker';
	      var needsType = InputTag === 'input';
	      var inputType = type;

	      if (inputType === 'datepicker' || inputType === 'colorpicker') {
	        inputType = 'text';
	      }

	      var inputClassName = Utils$1.classNames({
	        resizable: inputType === 'textarea' && resizable,
	        'no-store-data': noFormStoreData || noStoreData || ignoreStoreData,
	        'input-invalid': errorMessage && errorMessageForce || inputInvalid,
	        'input-with-value': inputHasValue,
	        'input-focused': inputFocused
	      });
	      var input;
	      var inputValue;

	      if (needsValue) {
	        if (typeof value !== 'undefined') { inputValue = value; }else { inputValue = domValue; }
	      }

	      var valueProps = {};

	      if (type !== 'datepicker' && type !== 'colorpicker') {
	        if ('value' in props) { valueProps.value = inputValue; }
	        if ('defaultValue' in props) { valueProps.defaultValue = defaultValue; }
	      }

	      {
	        input = react.createElement(InputTag, Object.assign({
	          ref: function (__reactNode) {
	            this$1.__reactRefs['inputEl'] = __reactNode;
	          },
	          style: inputStyle,
	          name: name,
	          type: needsType ? inputType : undefined,
	          placeholder: placeholder,
	          id: inputId,
	          size: size,
	          accept: accept,
	          autoComplete: autocomplete,
	          autoCorrect: autocorrect,
	          autoCapitalize: autocapitalize,
	          spellCheck: spellcheck,
	          autoFocus: autofocus,
	          autoSave: autosave,
	          disabled: disabled,
	          max: max,
	          maxLength: maxlength,
	          min: min,
	          minLength: minlength,
	          step: step,
	          multiple: multiple,
	          readOnly: readonly,
	          required: required,
	          pattern: pattern,
	          validate: typeof validate === 'string' && validate.length ? validate : undefined,
	          'data-validate': validate === true || validate === '' || validateOnBlur === true || validateOnBlur === '' ? true : undefined,
	          'data-validate-on-blur': validateOnBlur === true || validateOnBlur === '' ? true : undefined,
	          tabIndex: tabindex,
	          'data-error-message': errorMessageForce ? undefined : errorMessage,
	          className: inputClassName,
	          onFocus: self.onFocus,
	          onBlur: self.onBlur,
	          onInput: self.onInput,
	          onChange: self.onChange
	        }, valueProps), children);
	      }
	      return input;
	    };

	    var inputEl;

	    if (renderInput) {
	      if (type === 'select' || type === 'textarea' || type === 'file') {
	        if (type === 'select') {
	          inputEl = createInput('select', self.slots.default);
	        } else if (type === 'file') {
	          inputEl = createInput('input');
	        } else {
	          inputEl = createInput('textarea');
	        }
	      } else {
	        inputEl = createInput('input');
	      }
	    }

	    var hasErrorMessage = !!errorMessage || self.slots['error-message'] && self.slots['error-message'].length;
	    var ItemContent = react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['itemContentEl'] = __reactNode;
	      },
	      className: Utils$1.classNames('item-content item-input', !wrap && className, !wrap && {
	        disabled: disabled
	      }, !wrap && Mixins.colorClasses(props), {
	        'inline-label': inlineLabel,
	        'item-input-outline': outline,
	        'item-input-focused': inputFocused,
	        'item-input-with-info': !!info || self.slots.info && self.slots.info.length,
	        'item-input-with-value': inputHasValue,
	        'item-input-with-error-message': hasErrorMessage && errorMessageForce || inputInvalid,
	        'item-input-invalid': hasErrorMessage && errorMessageForce || inputInvalid
	      })
	    }, this.slots['content-start'], (media || self.slots.media) && react.createElement('div', {
	      className: 'item-media'
	    }, media && react.createElement('img', {
	      src: media
	    }), this.slots['media']), react.createElement('div', {
	      className: 'item-inner'
	    }, this.slots['inner-start'], (label || self.slots.label) && react.createElement('div', {
	      className: Utils$1.classNames('item-title item-label', {
	        'item-floating-label': floatingLabel
	      })
	    }, label, this.slots['label']), react.createElement('div', {
	      className: Utils$1.classNames('item-input-wrap', {
	        'input-dropdown': dropdown === 'auto' ? type === 'select' : dropdown
	      })
	    }, inputEl, this.slots['input'], hasErrorMessage && errorMessageForce && react.createElement('div', {
	      className: 'item-input-error-message'
	    }, errorMessage, this.slots['error-message']), clearButton && react.createElement('span', {
	      className: 'input-clear-button'
	    }), (info || self.slots.info) && react.createElement('div', {
	      className: 'item-input-info'
	    }, info, this.slots['info'])), this.slots['inner'], this.slots['inner-end']), this.slots['content'], this.slots['content-end']);

	    if (!wrap) {
	      return ItemContent;
	    }

	    return react.createElement('li', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: Utils$1.classNames(className, {
	        disabled: disabled
	      }, Mixins.colorClasses(props))
	    }, this.slots['root-start'], ItemContent, isSortable && react.createElement('div', {
	      className: 'sortable-handler'
	    }), this.slots['root'], this.slots['root-end']);
	  };

	  F7ListInput.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var inputEl = self.refs.inputEl;
	    if (!inputEl) { return; }
	    inputEl.removeEventListener('input:notempty', self.onInputNotEmpty, false);
	    inputEl.removeEventListener('textarea:resize', self.onTextareaResize, false);
	    inputEl.removeEventListener('input:empty', self.onInputEmpty, false);
	    inputEl.removeEventListener('input:clear', self.onInputClear, false);

	    if (self.f7Calendar && self.f7Calendar.destroy) {
	      self.f7Calendar.destroy();
	    }

	    if (self.f7ColorPicker && self.f7ColorPicker.destroy) {
	      self.f7ColorPicker.destroy();
	    }

	    delete self.f7Calendar;
	    delete self.f7ColorPicker;
	  };

	  F7ListInput.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.value', prevProps, prevState, function () {
	      var self = this$1;
	      if (!self.$f7) { return; }
	      self.updateInputOnDidUpdate = true;

	      if (self.f7Calendar) {
	        self.f7Calendar.setValue(self.props.value);
	      }

	      if (self.f7ColorPicker) {
	        self.f7ColorPicker.setValue(self.props.value);
	      }
	    });

	    var self = this;
	    var $listEl = self.$listEl;
	    if (!$listEl || $listEl && $listEl.length === 0) { return; }
	    var isSortable = $listEl.hasClass('sortable');

	    if (isSortable !== self.state.isSortable) {
	      self.setState({
	        isSortable: isSortable
	      });
	    }

	    var ref = self.props;
	    var validate = ref.validate;
	    var validateOnBlur = ref.validateOnBlur;
	    var resizable = ref.resizable;
	    var type = ref.type;
	    var f7 = self.$f7;
	    if (!f7) { return; }

	    if (self.updateInputOnDidUpdate) {
	      var inputEl = self.refs.inputEl;
	      if (!inputEl) { return; }
	      self.updateInputOnDidUpdate = false;

	      if (validate && !validateOnBlur) {
	        self.validateInput(inputEl);
	      }

	      if (type === 'textarea' && resizable) {
	        f7.input.resizeTextarea(inputEl);
	      }
	    }
	  };

	  F7ListInput.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    var itemContentEl = self.refs.itemContentEl;
	    if (!el && !itemContentEl) { return; }
	    self.$f7ready(function (f7) {
	      var ref = self.props;
	      var validate = ref.validate;
	      var validateOnBlur = ref.validateOnBlur;
	      var resizable = ref.resizable;
	      var value = ref.value;
	      var defaultValue = ref.defaultValue;
	      var type = ref.type;
	      var calendarParams = ref.calendarParams;
	      var colorPickerParams = ref.colorPickerParams;
	      var inputEl = self.refs.inputEl;
	      if (!inputEl) { return; }
	      inputEl.addEventListener('input:notempty', self.onInputNotEmpty, false);
	      inputEl.addEventListener('textarea:resize', self.onTextareaResize, false);
	      inputEl.addEventListener('input:empty', self.onInputEmpty, false);
	      inputEl.addEventListener('input:clear', self.onInputClear, false);

	      if (type === 'datepicker') {
	        self.f7Calendar = f7.calendar.create(Object.assign({
	          inputEl: inputEl,
	          value: value,
	          on: {
	            change: function change(calendar, calendarValue) {
	              self.dispatchEvent('calendar:change calendarChange', calendarValue);
	            }

	          }
	        }, calendarParams || {}));
	      }

	      if (type === 'colorpicker') {
	        self.f7ColorPicker = f7.colorPicker.create(Object.assign({
	          inputEl: inputEl,
	          value: value,
	          on: {
	            change: function change(colorPicker, colorPickerValue) {
	              self.dispatchEvent('colorpicker:change colorPickerChange', colorPickerValue);
	            }

	          }
	        }, colorPickerParams || {}));
	      }

	      if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && (typeof value !== 'undefined' && value !== null && value !== '' || typeof defaultValue !== 'undefined' && defaultValue !== null && defaultValue !== '')) {
	        setTimeout(function () {
	          self.validateInput(inputEl);
	        }, 0);
	      }

	      if (type === 'textarea' && resizable) {
	        f7.input.resizeTextarea(inputEl);
	      }
	    });
	    self.$listEl = self.$$(el || itemContentEl).parents('.list, .list-group').eq(0);

	    if (self.$listEl.length) {
	      self.setState({
	        isSortable: self.$listEl.hasClass('sortable')
	      });
	    }
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7ListInput.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7ListInput.prototype, prototypeAccessors );

	  return F7ListInput;
	}(react.Component));

	__reactComponentSetProps(F7ListInput, Object.assign({
	  id: [String, Number],
	  style: Object,
	  className: String,
	  sortable: Boolean,
	  media: String,
	  dropdown: {
	    type: [String, Boolean],
	    default: 'auto'
	  },
	  wrap: {
	    type: Boolean,
	    default: true
	  },
	  input: {
	    type: Boolean,
	    default: true
	  },
	  type: {
	    type: String,
	    default: 'text'
	  },
	  name: String,
	  value: [String, Number, Array, Date, Object],
	  defaultValue: [String, Number, Array],
	  readonly: Boolean,
	  required: Boolean,
	  disabled: Boolean,
	  placeholder: String,
	  inputId: [String, Number],
	  size: [String, Number],
	  accept: [String, Number],
	  autocomplete: [String],
	  autocorrect: [String],
	  autocapitalize: [String],
	  spellcheck: [String],
	  autofocus: Boolean,
	  autosave: String,
	  max: [String, Number],
	  min: [String, Number],
	  step: [String, Number],
	  maxlength: [String, Number],
	  minlength: [String, Number],
	  multiple: Boolean,
	  inputStyle: Object,
	  pattern: String,
	  validate: [Boolean, String],
	  validateOnBlur: Boolean,
	  tabindex: [String, Number],
	  resizable: Boolean,
	  clearButton: Boolean,
	  noFormStoreData: Boolean,
	  noStoreData: Boolean,
	  ignoreStoreData: Boolean,
	  errorMessage: String,
	  errorMessageForce: Boolean,
	  info: String,
	  outline: Boolean,
	  label: [String, Number],
	  inlineLabel: Boolean,
	  floatingLabel: Boolean,
	  calendarParams: Object,
	  colorPickerParams: Object
	}, Mixins.colorProps));

	F7ListInput.displayName = 'f7-list-input';

	var F7ListItemCell = /*@__PURE__*/(function (superclass) {
	  function F7ListItemCell(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7ListItemCell.__proto__ = superclass;
	  F7ListItemCell.prototype = Object.create( superclass && superclass.prototype );
	  F7ListItemCell.prototype.constructor = F7ListItemCell;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7ListItemCell.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'item-cell', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7ListItemCell.prototype, prototypeAccessors );

	  return F7ListItemCell;
	}(react.Component));

	__reactComponentSetProps(F7ListItemCell, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7ListItemCell.displayName = 'f7-list-item-cell';

	var F7ListItemContent = /*@__PURE__*/(function (superclass) {
	  function F7ListItemContent(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, 'onClick onChange'.split(' '));
	    })();
	  }

	  if ( superclass ) F7ListItemContent.__proto__ = superclass;
	  F7ListItemContent.prototype = Object.create( superclass && superclass.prototype );
	  F7ListItemContent.prototype.constructor = F7ListItemContent;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7ListItemContent.prototype.onClick = function onClick (event) {
	    this.dispatchEvent('click', event);
	  };

	  F7ListItemContent.prototype.onChange = function onChange (event) {
	    this.dispatchEvent('change', event);
	  };

	  F7ListItemContent.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var className = props.className;
	    var style = props.style;
	    var radio = props.radio;
	    var checkbox = props.checkbox;
	    var value = props.value;
	    var name = props.name;
	    var checked = props.checked;
	    var defaultChecked = props.defaultChecked;
	    var readonly = props.readonly;
	    var disabled = props.disabled;
	    var required = props.required;
	    var media = props.media;
	    var header = props.header;
	    var footer = props.footer;
	    var title = props.title;
	    var subtitle = props.subtitle;
	    var text = props.text;
	    var after = props.after;
	    var badge = props.badge;
	    var mediaList = props.mediaList;
	    var mediaItem = props.mediaItem;
	    var badgeColor = props.badgeColor;
	    var slotsContentStart = [];
	    var slotsContent = [];
	    var slotsContentEnd = [];
	    var slotsInnerStart = [];
	    var slotsInner = [];
	    var slotsInnerEnd = [];
	    var slotsAfterStart = [];
	    var slotsAfter = [];
	    var slotsAfterEnd = [];
	    var slotsMedia = [];
	    var slotsBeforeTitle = [];
	    var slotsTitle = [];
	    var slotsAfterTitle = [];
	    var slotsSubtitle = [];
	    var slotsText = [];
	    var slotsHeader = [];
	    var slotsFooter = [];
	    var titleEl;
	    var afterWrapEl;
	    var afterEl;
	    var badgeEl;
	    var innerEl;
	    var titleRowEl;
	    var subtitleEl;
	    var textEl;
	    var mediaEl;
	    var inputEl;
	    var inputIconEl;
	    var headerEl;
	    var footerEl;
	    var slots = self.slots.default;
	    var flattenSlots = [];

	    if (slots && slots.length) {
	      slots.forEach(function (slot) {
	        if (Array.isArray(slot)) { flattenSlots.push.apply(flattenSlots, slot); }else { flattenSlots.push(slot); }
	      });
	    }

	    flattenSlots.forEach(function (child) {
	      if (typeof child === 'undefined') { return; }
	      var slotName;
	      slotName = child.props ? child.props.slot : undefined;
	      if (!slotName || slotName === 'inner') { slotsInner.push(child); }
	      if (slotName === 'content-start') { slotsContentStart.push(child); }
	      if (slotName === 'content') { slotsContent.push(child); }
	      if (slotName === 'content-end') { slotsContentEnd.push(child); }
	      if (slotName === 'after-start') { slotsAfterStart.push(child); }
	      if (slotName === 'after') { slotsAfter.push(child); }
	      if (slotName === 'after-end') { slotsAfterEnd.push(child); }
	      if (slotName === 'media') { slotsMedia.push(child); }
	      if (slotName === 'inner-start') { slotsInnerStart.push(child); }
	      if (slotName === 'inner-end') { slotsInnerEnd.push(child); }
	      if (slotName === 'before-title') { slotsBeforeTitle.push(child); }
	      if (slotName === 'title') { slotsTitle.push(child); }
	      if (slotName === 'after-title') { slotsAfterTitle.push(child); }
	      if (slotName === 'subtitle') { slotsSubtitle.push(child); }
	      if (slotName === 'text') { slotsText.push(child); }
	      if (slotName === 'header') { slotsHeader.push(child); }
	      if (slotName === 'footer') { slotsFooter.push(child); }
	    });

	    if (radio || checkbox) {
	      {
	        inputEl = react.createElement('input', {
	          ref: function (__reactNode) {
	            this$1.__reactRefs['inputEl'] = __reactNode;
	          },
	          value: value,
	          name: name,
	          checked: checked,
	          defaultChecked: defaultChecked,
	          readOnly: readonly,
	          disabled: disabled,
	          required: required,
	          type: radio ? 'radio' : 'checkbox',
	          onChange: this.onChange
	        });
	      }
	      inputIconEl = react.createElement('i', {
	        className: ("icon icon-" + (radio ? 'radio' : 'checkbox'))
	      });
	    }

	    if (media || slotsMedia.length) {
	      var mediaImgEl;

	      if (media) {
	        mediaImgEl = react.createElement('img', {
	          src: media
	        });
	      }

	      mediaEl = react.createElement('div', {
	        className: 'item-media'
	      }, mediaImgEl, slotsMedia);
	    }

	    var isMedia = mediaItem || mediaList;

	    if (header || slotsHeader.length) {
	      headerEl = react.createElement('div', {
	        className: 'item-header'
	      }, header, slotsHeader);
	    }

	    if (footer || slotsFooter.length) {
	      footerEl = react.createElement('div', {
	        className: 'item-footer'
	      }, footer, slotsFooter);
	    }

	    if (title || slotsTitle.length || !isMedia && headerEl || !isMedia && footerEl) {
	      titleEl = react.createElement('div', {
	        className: 'item-title'
	      }, !isMedia && headerEl, title, slotsTitle, !isMedia && footerEl);
	    }

	    if (subtitle || slotsSubtitle.length) {
	      subtitleEl = react.createElement('div', {
	        className: 'item-subtitle'
	      }, subtitle, slotsSubtitle);
	    }

	    if (text || slotsText.length) {
	      textEl = react.createElement('div', {
	        className: 'item-text'
	      }, text, slotsText);
	    }

	    if (after || badge || slotsAfter.length) {
	      if (after) {
	        afterEl = react.createElement('span', null, after);
	      }

	      if (badge) {
	        badgeEl = react.createElement(F7Badge, {
	          color: badgeColor
	        }, badge);
	      }

	      afterWrapEl = react.createElement('div', {
	        className: 'item-after'
	      }, slotsAfterStart, afterEl, badgeEl, slotsAfter, slotsAfterEnd);
	    }

	    if (isMedia) {
	      titleRowEl = react.createElement('div', {
	        className: 'item-title-row'
	      }, slotsBeforeTitle, titleEl, slotsAfterTitle, afterWrapEl);
	      innerEl = react.createElement('div', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['innerEl'] = __reactNode;
	        },
	        className: 'item-inner'
	      }, slotsInnerStart, headerEl, titleRowEl, subtitleEl, textEl, slotsInner, footerEl, slotsInnerEnd);
	    } else {
	      innerEl = react.createElement('div', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['innerEl'] = __reactNode;
	        },
	        className: 'item-inner'
	      }, slotsInnerStart, slotsBeforeTitle, titleEl, slotsAfterTitle, afterWrapEl, slotsInner, slotsInnerEnd);
	    }

	    var ItemContentTag = checkbox || radio ? 'label' : 'div';
	    var classes = Utils$1.classNames(className, 'item-content', {
	      'item-checkbox': checkbox,
	      'item-radio': radio
	    }, Mixins.colorClasses(props));
	    return react.createElement(ItemContentTag, {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes
	    }, slotsContentStart, inputEl, inputIconEl, mediaEl, innerEl, slotsContent, slotsContentEnd);
	  };

	  F7ListItemContent.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var ref = self.refs;
	    var el = ref.el;
	    el.removeEventListener('click', self.onClick);
	  };

	  F7ListItemContent.prototype.componentDidUpdate = function componentDidUpdate () {
	    var self = this;
	    var ref = self.refs;
	    var inputEl = ref.inputEl;
	    var ref$1 = self.props;
	    var indeterminate = ref$1.indeterminate;

	    if (inputEl) {
	      inputEl.indeterminate = indeterminate;
	    }
	  };

	  F7ListItemContent.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var ref = self.refs;
	    var el = ref.el;
	    var inputEl = ref.inputEl;
	    var ref$1 = self.props;
	    var indeterminate = ref$1.indeterminate;

	    if (indeterminate && inputEl) {
	      inputEl.indeterminate = true;
	    }

	    el.addEventListener('click', self.onClick);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7ListItemContent.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7ListItemContent.prototype, prototypeAccessors );

	  return F7ListItemContent;
	}(react.Component));

	__reactComponentSetProps(F7ListItemContent, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  title: [String, Number],
	  text: [String, Number],
	  media: String,
	  subtitle: [String, Number],
	  header: [String, Number],
	  footer: [String, Number],
	  after: [String, Number],
	  badge: [String, Number],
	  badgeColor: String,
	  mediaList: Boolean,
	  mediaItem: Boolean,
	  checkbox: Boolean,
	  checked: Boolean,
	  defaultChecked: Boolean,
	  indeterminate: Boolean,
	  radio: Boolean,
	  name: String,
	  value: [String, Number, Array],
	  readonly: Boolean,
	  required: Boolean,
	  disabled: Boolean
	}, Mixins.colorProps));

	F7ListItemContent.displayName = 'f7-list-item-content';

	var F7ListItemRow = /*@__PURE__*/(function (superclass) {
	  function F7ListItemRow(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7ListItemRow.__proto__ = superclass;
	  F7ListItemRow.prototype = Object.create( superclass && superclass.prototype );
	  F7ListItemRow.prototype.constructor = F7ListItemRow;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7ListItemRow.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'item-row', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7ListItemRow.prototype, prototypeAccessors );

	  return F7ListItemRow;
	}(react.Component));

	__reactComponentSetProps(F7ListItemRow, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7ListItemRow.displayName = 'f7-list-item-row';

	var F7ListItem = /*@__PURE__*/(function (superclass) {
	  function F7ListItem(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    this.state = (function () {
	      return {
	        isMedia: props.mediaItem || props.mediaList,
	        isSortable: props.sortable,
	        isSimple: false
	      };
	    })();

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick', 'onChange', 'onSwipeoutOpen', 'onSwipeoutOpened', 'onSwipeoutClose', 'onSwipeoutClosed', 'onSwipeoutDelete', 'onSwipeoutDeleted', 'onSwipeoutOverswipeEnter', 'onSwipeoutOverswipeExit', 'onSwipeout', 'onAccBeforeOpen', 'onAccOpen', 'onAccOpened', 'onAccBeforeClose', 'onAccClose', 'onAccClosed']);
	    })();
	  }

	  if ( superclass ) F7ListItem.__proto__ = superclass;
	  F7ListItem.prototype = Object.create( superclass && superclass.prototype );
	  F7ListItem.prototype.constructor = F7ListItem;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7ListItem.prototype.onClick = function onClick (event) {
	    var self = this;

	    if (event.target.tagName.toLowerCase() !== 'input') {
	      self.dispatchEvent('click', event);
	    }
	  };

	  F7ListItem.prototype.onSwipeoutOverswipeEnter = function onSwipeoutOverswipeEnter (event) {
	    this.dispatchEvent('swipeout:overswipeenter swipeoutOverswipeEnter', event);
	  };

	  F7ListItem.prototype.onSwipeoutOverswipeExit = function onSwipeoutOverswipeExit (event) {
	    this.dispatchEvent('swipeout:overswipeexit swipeoutOverswipeExit', event);
	  };

	  F7ListItem.prototype.onSwipeoutDeleted = function onSwipeoutDeleted (event) {
	    this.dispatchEvent('swipeout:deleted swipeoutDeleted', event);
	  };

	  F7ListItem.prototype.onSwipeoutDelete = function onSwipeoutDelete (event) {
	    this.dispatchEvent('swipeout:delete swipeoutDelete', event);
	  };

	  F7ListItem.prototype.onSwipeoutClose = function onSwipeoutClose (event) {
	    this.dispatchEvent('swipeout:close swipeoutClose', event);
	  };

	  F7ListItem.prototype.onSwipeoutClosed = function onSwipeoutClosed (event) {
	    this.dispatchEvent('swipeout:closed swipeoutClosed', event);
	  };

	  F7ListItem.prototype.onSwipeoutOpen = function onSwipeoutOpen (event) {
	    this.dispatchEvent('swipeout:open swipeoutOpen', event);
	  };

	  F7ListItem.prototype.onSwipeoutOpened = function onSwipeoutOpened (event) {
	    this.dispatchEvent('swipeout:opened swipeoutOpened', event);
	  };

	  F7ListItem.prototype.onSwipeout = function onSwipeout (event) {
	    this.dispatchEvent('swipeout', event);
	  };

	  F7ListItem.prototype.onAccBeforeClose = function onAccBeforeClose (event) {
	    this.dispatchEvent('accordion:beforeclose accordionBeforeClose', event, event.detail.prevent);
	  };

	  F7ListItem.prototype.onAccClose = function onAccClose (event) {
	    this.dispatchEvent('accordion:close accordionClose', event);
	  };

	  F7ListItem.prototype.onAccClosed = function onAccClosed (event) {
	    this.dispatchEvent('accordion:closed accordionClosed', event);
	  };

	  F7ListItem.prototype.onAccBeforeOpen = function onAccBeforeOpen (event) {
	    this.dispatchEvent('accordion:beforeopen accordionBeforeOpen', event, event.detail.prevent);
	  };

	  F7ListItem.prototype.onAccOpen = function onAccOpen (event) {
	    this.dispatchEvent('accordion:open accordionOpen', event);
	  };

	  F7ListItem.prototype.onAccOpened = function onAccOpened (event) {
	    this.dispatchEvent('accordion:opened accordionOpened', event);
	  };

	  F7ListItem.prototype.onChange = function onChange (event) {
	    this.dispatchEvent('change', event);
	  };

	  F7ListItem.prototype.onInput = function onInput (event) {
	    this.dispatchEvent('input', event);
	  };

	  F7ListItem.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var linkEl;
	    var itemContentEl;
	    var props = self.props;
	    var id = props.id;
	    var style = props.style;
	    var className = props.className;
	    var title = props.title;
	    var text = props.text;
	    var media = props.media;
	    var subtitle = props.subtitle;
	    var header = props.header;
	    var footer = props.footer;
	    var link = props.link;
	    var href = props.href;
	    var target = props.target;
	    var noFastclick = props.noFastclick;
	    var noFastClick = props.noFastClick;
	    var after = props.after;
	    var badge = props.badge;
	    var badgeColor = props.badgeColor;
	    var mediaItem = props.mediaItem;
	    var mediaList = props.mediaList;
	    var divider = props.divider;
	    var groupTitle = props.groupTitle;
	    var swipeout = props.swipeout;
	    var accordionItem = props.accordionItem;
	    var accordionItemOpened = props.accordionItemOpened;
	    var smartSelect = props.smartSelect;
	    var checkbox = props.checkbox;
	    var radio = props.radio;
	    var checked = props.checked;
	    var defaultChecked = props.defaultChecked;
	    var indeterminate = props.indeterminate;
	    var name = props.name;
	    var value = props.value;
	    var readonly = props.readonly;
	    var required = props.required;
	    var disabled = props.disabled;
	    var sortable = props.sortable;
	    var noChevron = props.noChevron;
	    var chevronCenter = props.chevronCenter;
	    var virtualListIndex = props.virtualListIndex;
	    var isMedia = mediaItem || mediaList || self.state.isMedia;
	    var isSortable = sortable || self.state.isSortable;
	    var isSimple = self.state.isSimple;

	    if (!isSimple) {
	      var needsEvents = !(link || href || accordionItem || smartSelect);
	      itemContentEl = react.createElement(F7ListItemContent, {
	        title: title,
	        text: text,
	        media: media,
	        subtitle: subtitle,
	        after: after,
	        header: header,
	        footer: footer,
	        badge: badge,
	        badgeColor: badgeColor,
	        mediaList: isMedia,
	        accordionItem: accordionItem,
	        checkbox: checkbox,
	        checked: checked,
	        defaultChecked: defaultChecked,
	        indeterminate: indeterminate,
	        radio: radio,
	        name: name,
	        value: value,
	        readonly: readonly,
	        required: required,
	        disabled: disabled,
	        onClick: needsEvents ? self.onClick : null,
	        onChange: needsEvents ? self.onChange : null
	      }, this.slots['content-start'], this.slots['content'], this.slots['content-end'], this.slots['media'], this.slots['inner-start'], this.slots['inner'], this.slots['inner-end'], this.slots['after-start'], this.slots['after'], this.slots['after-end'], this.slots['header'], this.slots['footer'], this.slots['before-title'], this.slots['title'], this.slots['after-title'], this.slots['subtitle'], this.slots['text'], swipeout || accordionItem ? null : self.slots.default);

	      if (link || href || accordionItem || smartSelect) {
	        var linkAttrs = Object.assign({
	          href: link === true ? '' : link || href,
	          target: target
	        }, Mixins.linkRouterAttrs(props), Mixins.linkActionsAttrs(props));
	        var linkClasses = Utils$1.classNames({
	          'item-link': true,
	          'no-fastclick': noFastclick || noFastClick,
	          'smart-select': smartSelect
	        }, Mixins.linkRouterClasses(props), Mixins.linkActionsClasses(props));
	        linkEl = react.createElement('a', Object.assign({
	          ref: function (__reactNode) {
	            this$1.__reactRefs['linkEl'] = __reactNode;
	          },
	          className: linkClasses
	        }, linkAttrs), itemContentEl);
	      }
	    }

	    var liClasses = Utils$1.classNames(className, {
	      'item-divider': divider,
	      'list-group-title': groupTitle,
	      'media-item': isMedia,
	      swipeout: swipeout,
	      'accordion-item': accordionItem,
	      'accordion-item-opened': accordionItemOpened,
	      disabled: disabled && !(radio || checkbox),
	      'no-chevron': noChevron,
	      'chevron-center': chevronCenter
	    }, Mixins.colorClasses(props));

	    if (divider || groupTitle) {
	      return react.createElement('li', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['el'] = __reactNode;
	        },
	        id: id,
	        style: style,
	        className: liClasses,
	        'data-virtual-list-index': virtualListIndex
	      }, react.createElement('span', null, this.slots['default'], !this.slots.default && title));
	    }

	    if (isSimple) {
	      return react.createElement('li', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['el'] = __reactNode;
	        },
	        id: id,
	        style: style,
	        className: liClasses,
	        'data-virtual-list-index': virtualListIndex
	      }, title, this.slots['default']);
	    }

	    var linkItemEl = link || href || smartSelect || accordionItem ? linkEl : itemContentEl;
	    return react.createElement('li', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: liClasses,
	      'data-virtual-list-index': virtualListIndex
	    }, this.slots['root-start'], swipeout ? react.createElement('div', {
	      className: 'swipeout-content'
	    }, linkItemEl) : linkItemEl, isSortable && react.createElement('div', {
	      className: 'sortable-handler'
	    }), (swipeout || accordionItem) && self.slots.default, this.slots['root'], this.slots['root-end']);
	  };

	  F7ListItem.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var ref = self.refs;
	    var el = ref.el;
	    var linkEl = ref.linkEl;
	    var ref$1 = self.props;
	    var link = ref$1.link;
	    var href = ref$1.href;
	    var smartSelect = ref$1.smartSelect;
	    var swipeout = ref$1.swipeout;
	    var accordionItem = ref$1.accordionItem;
	    var needsEvents = !(link || href || accordionItem || smartSelect);

	    if (linkEl) {
	      if (!needsEvents) {
	        linkEl.removeEventListener('click', self.onClick);
	      }

	      delete linkEl.f7RouteProps;
	    }

	    if (el) {
	      if (swipeout) {
	        el.removeEventListener('swipeout:open', self.onSwipeoutOpen);
	        el.removeEventListener('swipeout:opened', self.onSwipeoutOpened);
	        el.removeEventListener('swipeout:close', self.onSwipeoutClose);
	        el.removeEventListener('swipeout:closed', self.onSwipeoutClosed);
	        el.removeEventListener('swipeout:delete', self.onSwipeoutDelete);
	        el.removeEventListener('swipeout:deleted', self.onSwipeoutDeleted);
	        el.removeEventListener('swipeout:overswipeenter', self.onSwipeoutOverswipeEnter);
	        el.removeEventListener('swipeout:overswipeexit', self.onSwipeoutOverswipeExit);
	        el.removeEventListener('swipeout', self.onSwipeout);
	      }

	      if (accordionItem) {
	        el.removeEventListener('accordion:beforeopen', self.onAccBeforeOpen);
	        el.removeEventListener('accordion:open', self.onAccOpen);
	        el.removeEventListener('accordion:opened', self.onAccOpened);
	        el.removeEventListener('accordion:beforeclose', self.onAccBeforeClose);
	        el.removeEventListener('accordion:close', self.onAccClose);
	        el.removeEventListener('accordion:closed', self.onAccClosed);
	      }
	    }

	    if (smartSelect && self.f7SmartSelect) {
	      self.f7SmartSelect.destroy();
	    }
	  };

	  F7ListItem.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.swipeoutOpened', prevProps, prevState, function (opened) {
	      var self = this$1;
	      if (!self.props.swipeout) { return; }
	      var el = self.refs.el;

	      if (opened) {
	        self.$f7.swipeout.open(el);
	      } else {
	        self.$f7.swipeout.close(el);
	      }
	    });

	    var self = this;
	    var $listEl = self.$listEl;
	    var ref = self.refs;
	    var linkEl = ref.linkEl;
	    var ref$1 = self.props;
	    var routeProps = ref$1.routeProps;

	    if (linkEl && routeProps) {
	      linkEl.f7RouteProps = routeProps;
	    }

	    if (!$listEl || $listEl && $listEl.length === 0) { return; }
	    var isMedia = $listEl.hasClass('media-list');
	    var isSimple = $listEl.hasClass('simple-list');
	    var isSortable = $listEl.hasClass('sortable');

	    if (isMedia !== self.state.isMedia) {
	      self.setState({
	        isMedia: isMedia
	      });
	    }

	    if (isSimple !== self.state.isSimple) {
	      self.setState({
	        isSimple: isSimple
	      });
	    }

	    if (isSortable !== self.state.isSortable) {
	      self.setState({
	        isSortable: isSortable
	      });
	    }
	  };

	  F7ListItem.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var ref = self.refs;
	    var el = ref.el;
	    var linkEl = ref.linkEl;
	    if (!el) { return; }
	    var ref$1 = self.props;
	    var link = ref$1.link;
	    var href = ref$1.href;
	    var smartSelect = ref$1.smartSelect;
	    var swipeout = ref$1.swipeout;
	    var swipeoutOpened = ref$1.swipeoutOpened;
	    var accordionItem = ref$1.accordionItem;
	    var smartSelectParams = ref$1.smartSelectParams;
	    var routeProps = ref$1.routeProps;
	    var needsEvents = !(link || href || accordionItem || smartSelect);

	    if (!needsEvents && linkEl) {
	      linkEl.addEventListener('click', self.onClick);
	    }

	    if (linkEl && routeProps) {
	      linkEl.f7RouteProps = routeProps;
	    }

	    self.$listEl = self.$$(el).parents('.list, .list-group').eq(0);

	    if (self.$listEl.length) {
	      self.setState({
	        isMedia: self.$listEl.hasClass('media-list'),
	        isSimple: self.$listEl.hasClass('simple-list'),
	        isSortable: self.$listEl.hasClass('sortable')
	      });
	    }

	    if (swipeout) {
	      el.addEventListener('swipeout:open', self.onSwipeoutOpen);
	      el.addEventListener('swipeout:opened', self.onSwipeoutOpened);
	      el.addEventListener('swipeout:close', self.onSwipeoutClose);
	      el.addEventListener('swipeout:closed', self.onSwipeoutClosed);
	      el.addEventListener('swipeout:delete', self.onSwipeoutDelete);
	      el.addEventListener('swipeout:deleted', self.onSwipeoutDeleted);
	      el.addEventListener('swipeout:overswipeenter', self.onSwipeoutOverswipeEnter);
	      el.addEventListener('swipeout:overswipeexit', self.onSwipeoutOverswipeExit);
	      el.addEventListener('swipeout', self.onSwipeout);
	    }

	    if (accordionItem) {
	      el.addEventListener('accordion:beforeopen', self.onAccBeforeOpen);
	      el.addEventListener('accordion:open', self.onAccOpen);
	      el.addEventListener('accordion:opened', self.onAccOpened);
	      el.addEventListener('accordion:beforeclose', self.onAccBeforeClose);
	      el.addEventListener('accordion:close', self.onAccClose);
	      el.addEventListener('accordion:closed', self.onAccClosed);
	    }

	    self.$f7ready(function (f7) {
	      if (smartSelect) {
	        var ssParams = Utils$1.extend({
	          el: el.querySelector('a.smart-select')
	        }, smartSelectParams || {});
	        self.f7SmartSelect = f7.smartSelect.create(ssParams);
	      }

	      if (swipeoutOpened) {
	        f7.swipeout.open(el);
	      }
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7ListItem.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7ListItem.prototype, prototypeAccessors );

	  return F7ListItem;
	}(react.Component));

	__reactComponentSetProps(F7ListItem, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  title: [String, Number],
	  text: [String, Number],
	  media: String,
	  subtitle: [String, Number],
	  header: [String, Number],
	  footer: [String, Number],
	  link: [Boolean, String],
	  target: String,
	  noFastclick: Boolean,
	  noFastClick: Boolean,
	  after: [String, Number],
	  badge: [String, Number],
	  badgeColor: String,
	  mediaItem: Boolean,
	  mediaList: Boolean,
	  divider: Boolean,
	  groupTitle: Boolean,
	  swipeout: Boolean,
	  swipeoutOpened: Boolean,
	  sortable: Boolean,
	  accordionItem: Boolean,
	  accordionItemOpened: Boolean,
	  smartSelect: Boolean,
	  smartSelectParams: Object,
	  noChevron: Boolean,
	  chevronCenter: Boolean,
	  checkbox: Boolean,
	  radio: Boolean,
	  checked: Boolean,
	  defaultChecked: Boolean,
	  indeterminate: Boolean,
	  name: String,
	  value: [String, Number, Array],
	  readonly: Boolean,
	  required: Boolean,
	  disabled: Boolean,
	  virtualListIndex: Number
	}, Mixins.colorProps, Mixins.linkRouterProps, Mixins.linkActionsProps));

	F7ListItem.displayName = 'f7-list-item';

	var F7List = /*@__PURE__*/(function (superclass) {
	  function F7List(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onSortableEnable', 'onSortableDisable', 'onSortableSort', 'onTabShow', 'onTabHide', 'onSubmit']);
	    })();
	  }

	  if ( superclass ) F7List.__proto__ = superclass;
	  F7List.prototype = Object.create( superclass && superclass.prototype );
	  F7List.prototype.constructor = F7List;

	  var prototypeAccessors = { classes: { configurable: true },slots: { configurable: true },refs: { configurable: true } };

	  F7List.prototype.onSubmit = function onSubmit (event) {
	    this.dispatchEvent('submit', event);
	  };

	  F7List.prototype.onSortableEnable = function onSortableEnable (event) {
	    this.dispatchEvent('sortable:enable sortableEnable', event);
	  };

	  F7List.prototype.onSortableDisable = function onSortableDisable (event) {
	    this.dispatchEvent('sortable:disable sortableDisable', event);
	  };

	  F7List.prototype.onSortableSort = function onSortableSort (event) {
	    var sortData = event.detail;
	    this.dispatchEvent('sortable:sort sortableSort', event, sortData);
	  };

	  F7List.prototype.onTabShow = function onTabShow (event) {
	    this.dispatchEvent('tab:show tabShow', event);
	  };

	  F7List.prototype.onTabHide = function onTabHide (event) {
	    this.dispatchEvent('tab:hide tabHide', event);
	  };

	  prototypeAccessors.classes.get = function () {
	    var self = this;
	    var props = self.props;
	    var inset = props.inset;
	    var tabletInset = props.tabletInset;
	    var mediaList = props.mediaList;
	    var simpleList = props.simpleList;
	    var linksList = props.linksList;
	    var sortable = props.sortable;
	    var accordionList = props.accordionList;
	    var contactsList = props.contactsList;
	    var virtualList = props.virtualList;
	    var sortableEnabled = props.sortableEnabled;
	    var tab = props.tab;
	    var tabActive = props.tabActive;
	    var noHairlines = props.noHairlines;
	    var noHairlinesIos = props.noHairlinesIos;
	    var noHairlinesMd = props.noHairlinesMd;
	    var noHairlinesAurora = props.noHairlinesAurora;
	    var noHairlinesBetween = props.noHairlinesBetween;
	    var noHairlinesBetweenIos = props.noHairlinesBetweenIos;
	    var noHairlinesBetweenMd = props.noHairlinesBetweenMd;
	    var noHairlinesBetweenAurora = props.noHairlinesBetweenAurora;
	    var formStoreData = props.formStoreData;
	    var inlineLabels = props.inlineLabels;
	    var className = props.className;
	    var noChevron = props.noChevron;
	    var chevronCenter = props.chevronCenter;
	    return Utils$1.classNames(className, 'list', {
	      inset: inset,
	      'tablet-inset': tabletInset,
	      'media-list': mediaList,
	      'simple-list': simpleList,
	      'links-list': linksList,
	      sortable: sortable,
	      'accordion-list': accordionList,
	      'contacts-list': contactsList,
	      'virtual-list': virtualList,
	      'sortable-enabled': sortableEnabled,
	      tab: tab,
	      'tab-active': tabActive,
	      'no-hairlines': noHairlines,
	      'no-hairlines-between': noHairlinesBetween,
	      'no-hairlines-md': noHairlinesMd,
	      'no-hairlines-between-md': noHairlinesBetweenMd,
	      'no-hairlines-ios': noHairlinesIos,
	      'no-hairlines-between-ios': noHairlinesBetweenIos,
	      'no-hairlines-aurora': noHairlinesAurora,
	      'no-hairlines-between-aurora': noHairlinesBetweenAurora,
	      'form-store-data': formStoreData,
	      'inline-labels': inlineLabels,
	      'no-chevron': noChevron,
	      'chevron-center': chevronCenter
	    }, Mixins.colorClasses(props));
	  };

	  F7List.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var style = props.style;
	    var form = props.form;
	    var ref = self.slots;
	    var slotsList = ref.list;
	    var slotsDefault = ref.default;
	    var rootChildrenBeforeList = [];
	    var rootChildrenAfterList = [];
	    var ulChildren = slotsList || [];
	    var flattenSlots = Utils$1.flattenArray(slotsDefault);
	    var wasUlChild = false;
	    flattenSlots.forEach(function (child) {
	      if (typeof child === 'undefined') { return; }
	      var tag;
	      {
	        tag = child.type && (child.type.displayName || child.type.name);

	        if (!tag && typeof child.type === 'string') {
	          tag = child.type;
	        }
	      }

	      if (!tag && 'react' === 'react' || tag && !(tag === 'li' || tag === 'F7ListItem' || tag === 'F7ListButton' || tag === 'F7ListInput' || tag.indexOf('list-item') >= 0 || tag.indexOf('list-button') >= 0 || tag.indexOf('list-input') >= 0 || tag.indexOf('f7-list-item') >= 0 || tag.indexOf('f7-list-button') >= 0 || tag.indexOf('f7-list-input') >= 0)) {
	        if (wasUlChild) { rootChildrenAfterList.push(child); }else { rootChildrenBeforeList.push(child); }
	      } else if (tag) {
	        wasUlChild = true;
	        ulChildren.push(child);
	      }
	    });
	    var ListTag = form ? 'form' : 'div';

	    if (ulChildren.length > 0) {
	      return react.createElement(ListTag, {
	        id: id,
	        ref: function (__reactNode) {
	          this$1.__reactRefs['el'] = __reactNode;
	        },
	        style: style,
	        className: self.classes
	      }, self.slots['before-list'], rootChildrenBeforeList, react.createElement('ul', null, ulChildren), self.slots['after-list'], rootChildrenAfterList);
	    } else {
	      return react.createElement(ListTag, {
	        id: id,
	        ref: function (__reactNode) {
	          this$1.__reactRefs['el'] = __reactNode;
	        },
	        style: style,
	        className: self.classes
	      }, self.slots['before-list'], rootChildrenBeforeList, self.slots['after-list'], rootChildrenAfterList);
	    }
	  };

	  F7List.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var el = self.refs.el;

	    if (el) {
	      el.removeEventListener('sortable:enable', self.onSortableEnable);
	      el.removeEventListener('sortable:disable', self.onSortableDisable);
	      el.removeEventListener('sortable:sort', self.onSortableSort);
	      el.removeEventListener('tab:show', self.onTabShow);
	      el.removeEventListener('tab:hide', self.onTabHide);

	      if (self.props.form) {
	        el.removeEventListener('submit', self.onSubmit);
	      }
	    }

	    if (!(self.virtualList && self.f7VirtualList)) { return; }
	    if (self.f7VirtualList.destroy) { self.f7VirtualList.destroy(); }
	  };

	  F7List.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    var ref = self.props;
	    var virtualList = ref.virtualList;
	    var virtualListParams = ref.virtualListParams;
	    var form = ref.form;

	    if (el) {
	      el.addEventListener('sortable:enable', self.onSortableEnable);
	      el.addEventListener('sortable:disable', self.onSortableDisable);
	      el.addEventListener('sortable:sort', self.onSortableSort);
	      el.addEventListener('tab:show', self.onTabShow);
	      el.addEventListener('tab:hide', self.onTabHide);

	      if (form) {
	        el.addEventListener('submit', self.onSubmit);
	      }
	    }

	    if (!virtualList) { return; }
	    self.$f7ready(function (f7) {
	      var $$ = self.$$;
	      var $el = $$(el);
	      var templateScript = $el.find('script');
	      var template = templateScript.html();

	      if (!template && templateScript.length > 0) {
	        template = templateScript[0].outerHTML;
	        template = /\<script type="text\/template7"\>(.*)<\/script>/.exec(template)[1];
	      }

	      var vlParams = virtualListParams || {};
	      if (!template && !vlParams.renderItem && !vlParams.itemTemplate && !vlParams.renderExternal) { return; }
	      if (template) { template = self.$t7.compile(template); }
	      self.f7VirtualList = f7.virtualList.create(Utils$1.extend({
	        el: el,
	        itemTemplate: template,
	        on: {
	          itemBeforeInsert: function itemBeforeInsert(itemEl, item) {
	            var vl = this;
	            self.dispatchEvent('virtual:itembeforeinsert virtualItemBeforeInsert', vl, itemEl, item);
	          },

	          beforeClear: function beforeClear(fragment) {
	            var vl = this;
	            self.dispatchEvent('virtual:beforeclear virtualBeforeClear', vl, fragment);
	          },

	          itemsBeforeInsert: function itemsBeforeInsert(fragment) {
	            var vl = this;
	            self.dispatchEvent('virtual:itemsbeforeinsert virtualItemsBeforeInsert', vl, fragment);
	          },

	          itemsAfterInsert: function itemsAfterInsert(fragment) {
	            var vl = this;
	            self.dispatchEvent('virtual:itemsafterinsert virtualItemsAfterInsert', vl, fragment);
	          }

	        }
	      }, vlParams));
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7List.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7List.prototype, prototypeAccessors );

	  return F7List;
	}(react.Component));

	__reactComponentSetProps(F7List, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  inset: Boolean,
	  tabletInset: Boolean,
	  mediaList: Boolean,
	  sortable: Boolean,
	  sortableEnabled: Boolean,
	  accordionList: Boolean,
	  contactsList: Boolean,
	  simpleList: Boolean,
	  linksList: Boolean,
	  noHairlines: Boolean,
	  noHairlinesBetween: Boolean,
	  noHairlinesMd: Boolean,
	  noHairlinesBetweenMd: Boolean,
	  noHairlinesIos: Boolean,
	  noHairlinesBetweenIos: Boolean,
	  noHairlinesAurora: Boolean,
	  noHairlinesBetweenAurora: Boolean,
	  noChevron: Boolean,
	  chevronCenter: Boolean,
	  tab: Boolean,
	  tabActive: Boolean,
	  form: Boolean,
	  formStoreData: Boolean,
	  inlineLabels: Boolean,
	  virtualList: Boolean,
	  virtualListParams: Object
	}, Mixins.colorProps));

	F7List.displayName = 'f7-list';

	var F7LoginScreenTitle = /*@__PURE__*/(function (superclass) {
	  function F7LoginScreenTitle(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7LoginScreenTitle.__proto__ = superclass;
	  F7LoginScreenTitle.prototype = Object.create( superclass && superclass.prototype );
	  F7LoginScreenTitle.prototype.constructor = F7LoginScreenTitle;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7LoginScreenTitle.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'login-screen-title', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7LoginScreenTitle.prototype, prototypeAccessors );

	  return F7LoginScreenTitle;
	}(react.Component));

	__reactComponentSetProps(F7LoginScreenTitle, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7LoginScreenTitle.displayName = 'f7-login-screen-title';

	var F7LoginScreen = /*@__PURE__*/(function (superclass) {
	  function F7LoginScreen(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onOpen', 'onOpened', 'onClose', 'onClosed']);
	    })();
	  }

	  if ( superclass ) F7LoginScreen.__proto__ = superclass;
	  F7LoginScreen.prototype = Object.create( superclass && superclass.prototype );
	  F7LoginScreen.prototype.constructor = F7LoginScreen;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7LoginScreen.prototype.onOpen = function onOpen (event) {
	    this.dispatchEvent('loginscreen:open loginScreenOpen', event);
	  };

	  F7LoginScreen.prototype.onOpened = function onOpened (event) {
	    this.dispatchEvent('loginscreen:opened loginScreenOpened', event);
	  };

	  F7LoginScreen.prototype.onClose = function onClose (event) {
	    this.dispatchEvent('loginscreen:close loginScreenClose', event);
	  };

	  F7LoginScreen.prototype.onClosed = function onClosed (event) {
	    this.dispatchEvent('loginscreen:closed loginScreenClosed', event);
	  };

	  F7LoginScreen.prototype.open = function open (animate) {
	    var self = this;
	    var el = self.refs.el;
	    if (!self.$f7 || !el) { return undefined; }
	    return self.$f7.loginScreen.open(el, animate);
	  };

	  F7LoginScreen.prototype.close = function close (animate) {
	    var self = this;
	    var el = self.refs.el;
	    if (!self.$f7 || !el) { return undefined; }
	    return self.$f7.loginScreen.close(el, animate);
	  };

	  F7LoginScreen.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'login-screen', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  F7LoginScreen.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var el = self.refs.el;
	    if (self.f7LoginScreen) { self.f7LoginScreen.destroy(); }
	    if (!el) { return; }
	    el.removeEventListener('loginscreen:open', self.onOpen);
	    el.removeEventListener('loginscreen:opened', self.onOpened);
	    el.removeEventListener('loginscreen:close', self.onClose);
	    el.removeEventListener('loginscreen:closed', self.onClosed);
	  };

	  F7LoginScreen.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.addEventListener('loginscreen:open', self.onOpen);
	    el.addEventListener('loginscreen:opened', self.onOpened);
	    el.addEventListener('loginscreen:close', self.onClose);
	    el.addEventListener('loginscreen:closed', self.onClosed);
	    self.$f7ready(function () {
	      self.f7LoginScreen = self.$f7.loginScreen.create({
	        el: el
	      });

	      if (self.props.opened) {
	        self.f7LoginScreen.open(false);
	      }
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7LoginScreen.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  F7LoginScreen.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.opened', prevProps, prevState, function (opened) {
	      var self = this$1;
	      if (!self.f7LoginScreen) { return; }

	      if (opened) {
	        self.f7LoginScreen.open();
	      } else {
	        self.f7LoginScreen.close();
	      }
	    });
	  };

	  Object.defineProperties( F7LoginScreen.prototype, prototypeAccessors );

	  return F7LoginScreen;
	}(react.Component));

	__reactComponentSetProps(F7LoginScreen, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  opened: Boolean
	}, Mixins.colorProps));

	F7LoginScreen.displayName = 'f7-login-screen';

	var F7MenuDropdownItem = /*@__PURE__*/(function (superclass) {
	  function F7MenuDropdownItem(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick']);
	    })();
	  }

	  if ( superclass ) F7MenuDropdownItem.__proto__ = superclass;
	  F7MenuDropdownItem.prototype = Object.create( superclass && superclass.prototype );
	  F7MenuDropdownItem.prototype.constructor = F7MenuDropdownItem;

	  var prototypeAccessors = { attrs: { configurable: true },slots: { configurable: true },refs: { configurable: true } };

	  F7MenuDropdownItem.prototype.onClick = function onClick (event) {
	    this.dispatchEvent('click', event);
	  };

	  prototypeAccessors.attrs.get = function () {
	    var self = this;
	    var props = self.props;
	    var link = props.link;
	    var href = props.href;
	    var target = props.target;
	    var hrefComputed = href;
	    if (typeof hrefComputed === 'undefined' && link) { hrefComputed = '#'; }
	    return Utils$1.extend({
	      href: hrefComputed,
	      target: target
	    }, Mixins.linkRouterAttrs(props), Mixins.linkActionsAttrs(props));
	  };

	  F7MenuDropdownItem.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var className = props.className;
	    var style = props.style;
	    var link = props.link;
	    var href = props.href;
	    var text = props.text;
	    var divider = props.divider;
	    var menuClose = props.menuClose;
	    var isLink = link || href || href === '';
	    var Tag = isLink ? 'a' : 'div';
	    var classes = Utils$1.classNames({
	      'menu-dropdown-link': isLink && !divider,
	      'menu-dropdown-item': !isLink && !divider,
	      'menu-dropdown-divider': divider
	    }, className, Mixins.colorClasses(props), Mixins.linkRouterClasses(props), Mixins.linkActionsClasses(props), {
	      'menu-close': typeof menuClose === 'undefined'
	    });
	    return react.createElement(Tag, Object.assign({
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      className: classes,
	      id: id,
	      style: style
	    }, self.attrs), text, this.slots['default']);
	  };

	  F7MenuDropdownItem.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.removeEventListener('click', self.onClick);
	    delete el.f7RouteProps;
	  };

	  F7MenuDropdownItem.prototype.componentDidUpdate = function componentDidUpdate () {
	    var self = this;
	    var el = self.refs.el;
	    if (!el) { return; }
	    var ref = self.props;
	    var routeProps = ref.routeProps;
	    if (routeProps) { el.f7RouteProps = routeProps; }
	  };

	  F7MenuDropdownItem.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.addEventListener('click', self.onClick);
	    var ref = self.props;
	    var routeProps = ref.routeProps;
	    if (routeProps) { el.f7RouteProps = routeProps; }
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7MenuDropdownItem.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7MenuDropdownItem.prototype, prototypeAccessors );

	  return F7MenuDropdownItem;
	}(react.Component));

	__reactComponentSetProps(F7MenuDropdownItem, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  text: String,
	  link: Boolean,
	  href: String,
	  target: String,
	  divider: Boolean
	}, Mixins.colorProps, Mixins.linkRouterProps, Mixins.linkActionsProps));

	F7MenuDropdownItem.displayName = 'f7-menu-dropdown-item';

	var F7MenuDropdown = /*@__PURE__*/(function (superclass) {
	  function F7MenuDropdown(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7MenuDropdown.__proto__ = superclass;
	  F7MenuDropdown.prototype = Object.create( superclass && superclass.prototype );
	  F7MenuDropdown.prototype.constructor = F7MenuDropdown;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7MenuDropdown.prototype.render = function render () {
	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var className = props.className;
	    var style = props.style;
	    var contentHeight = props.contentHeight;
	    var position = props.position;
	    var left = props.left;
	    var center = props.center;
	    var right = props.right;
	    var positionComputed = position || 'left';
	    if (left) { positionComputed = 'left'; }
	    if (center) { positionComputed = 'center'; }
	    if (right) { positionComputed = 'right'; }
	    var classes = Utils$1.classNames('menu-dropdown', ("menu-dropdown-" + positionComputed), Mixins.colorClasses(props), className);
	    return react.createElement('div', {
	      className: classes,
	      id: id,
	      style: style
	    }, react.createElement('div', {
	      className: 'menu-dropdown-content',
	      style: {
	        height: contentHeight
	      }
	    }, this.slots['default']));
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7MenuDropdown.prototype, prototypeAccessors );

	  return F7MenuDropdown;
	}(react.Component));

	__reactComponentSetProps(F7MenuDropdown, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  contentHeight: String,
	  position: String,
	  left: Boolean,
	  center: Boolean,
	  right: Boolean
	}, Mixins.colorProps));

	F7MenuDropdown.displayName = 'f7-menu-dropdown';

	var F7MenuItem = /*@__PURE__*/(function (superclass) {
	  function F7MenuItem(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick', 'onOpened', 'onClosed']);
	    })();
	  }

	  if ( superclass ) F7MenuItem.__proto__ = superclass;
	  F7MenuItem.prototype = Object.create( superclass && superclass.prototype );
	  F7MenuItem.prototype.constructor = F7MenuItem;

	  var prototypeAccessors = { attrs: { configurable: true },slots: { configurable: true },refs: { configurable: true } };

	  F7MenuItem.prototype.onClick = function onClick (e) {
	    this.dispatchEvent('click', e);
	  };

	  F7MenuItem.prototype.onOpened = function onOpened (e) {
	    this.dispatchEvent('menuOpened menu:opened', e);
	  };

	  F7MenuItem.prototype.onClosed = function onClosed (e) {
	    this.dispatchEvent('menuClosed menu:closed', e);
	  };

	  prototypeAccessors.attrs.get = function () {
	    var self = this;
	    var props = self.props;
	    var href = props.href;
	    var link = props.link;
	    var target = props.target;
	    var hrefComputed = href;
	    if (typeof hrefComputed === 'undefined' && link) { hrefComputed = '#'; }
	    return Utils$1.extend({
	      href: hrefComputed,
	      target: target
	    }, Mixins.linkRouterAttrs(props), Mixins.linkActionsAttrs(props));
	  };

	  F7MenuItem.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var className = props.className;
	    var style = props.style;
	    var link = props.link;
	    var href = props.href;
	    var text = props.text;
	    var dropdown = props.dropdown;
	    var iconOnly = props.iconOnly;
	    var icon = props.icon;
	    var iconColor = props.iconColor;
	    var iconSize = props.iconSize;
	    var iconMaterial = props.iconMaterial;
	    var iconIon = props.iconIon;
	    var iconFa = props.iconFa;
	    var iconF7 = props.iconF7;
	    var iconMd = props.iconMd;
	    var iconIos = props.iconIos;
	    var iconAurora = props.iconAurora;
	    var slots = self.slots;
	    var iconEl;
	    var iconOnlyComputed;

	    if (icon || iconMaterial || iconIon || iconFa || iconF7 || iconMd || iconIos || iconAurora) {
	      iconEl = react.createElement(F7Icon, {
	        material: iconMaterial,
	        f7: iconF7,
	        fa: iconFa,
	        ion: iconIon,
	        icon: icon,
	        md: iconMd,
	        ios: iconIos,
	        aurora: iconAurora,
	        color: iconColor,
	        size: iconSize
	      });
	    }

	    if (iconOnly || !text && slots.text && slots.text.length === 0 || !text && !slots.text) {
	      iconOnlyComputed = true;
	    } else {
	      iconOnlyComputed = false;
	    }

	    var isLink = link || href || href === '';
	    var Tag = isLink ? 'a' : 'div';
	    var isDropdown = dropdown || dropdown === '';
	    var classes = Utils$1.classNames({
	      'menu-item': true,
	      'menu-item-dropdown': isDropdown,
	      'icon-only': iconOnlyComputed
	    }, className, Mixins.colorClasses(props), Mixins.linkRouterClasses(props), Mixins.linkActionsClasses(props));
	    return react.createElement(Tag, Object.assign({
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      className: classes,
	      id: id,
	      style: style
	    }, self.attrs), (text || slots.text && slots.text.length || iconEl) && react.createElement('div', {
	      className: 'menu-item-content'
	    }, text, iconEl, this.slots['text']), this.slots['default']);
	  };

	  F7MenuItem.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.removeEventListener('click', self.onClick);
	    el.removeEventListener('menu:opened', self.onOpened);
	    el.removeEventListener('menu:closed', self.onClosed);
	    delete el.f7RouteProps;
	  };

	  F7MenuItem.prototype.componentDidUpdate = function componentDidUpdate () {
	    var self = this;
	    var el = self.refs.el;
	    if (!el) { return; }
	    var ref = self.props;
	    var routeProps = ref.routeProps;
	    if (routeProps) { el.f7RouteProps = routeProps; }
	  };

	  F7MenuItem.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.addEventListener('click', self.onClick);
	    el.addEventListener('menu:opened', self.onOpened);
	    el.addEventListener('menu:closed', self.onClosed);
	    var ref = self.props;
	    var routeProps = ref.routeProps;
	    if (routeProps) { el.f7RouteProps = routeProps; }
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7MenuItem.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7MenuItem.prototype, prototypeAccessors );

	  return F7MenuItem;
	}(react.Component));

	__reactComponentSetProps(F7MenuItem, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  text: String,
	  iconOnly: Boolean,
	  href: String,
	  link: Boolean,
	  target: String,
	  dropdown: Boolean
	}, Mixins.colorProps, Mixins.linkIconProps, Mixins.linkRouterProps, Mixins.linkActionsProps));

	F7MenuItem.displayName = 'f7-menu-item';

	var F7Menu = /*@__PURE__*/(function (superclass) {
	  function F7Menu(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7Menu.__proto__ = superclass;
	  F7Menu.prototype = Object.create( superclass && superclass.prototype );
	  F7Menu.prototype.constructor = F7Menu;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7Menu.prototype.render = function render () {
	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var className = props.className;
	    var style = props.style;
	    return react.createElement('div', {
	      className: Utils$1.classNames('menu', Mixins.colorClasses(props), className),
	      id: id,
	      style: style
	    }, react.createElement('div', {
	      className: 'menu-inner'
	    }, this.slots['default']));
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7Menu.prototype, prototypeAccessors );

	  return F7Menu;
	}(react.Component));

	__reactComponentSetProps(F7Menu, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7Menu.displayName = 'f7-menu';

	var F7Message = /*@__PURE__*/(function (superclass) {
	  function F7Message(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick', 'onNameClick', 'onTextClick', 'onAvatarClick', 'onHeaderClick', 'onFooterClick', 'onBubbleClick']);
	    })();
	  }

	  if ( superclass ) F7Message.__proto__ = superclass;
	  F7Message.prototype = Object.create( superclass && superclass.prototype );
	  F7Message.prototype.constructor = F7Message;

	  var prototypeAccessors = { classes: { configurable: true },slots: { configurable: true },refs: { configurable: true } };

	  F7Message.prototype.onClick = function onClick (event) {
	    this.dispatchEvent('click', event);
	  };

	  F7Message.prototype.onNameClick = function onNameClick (event) {
	    this.dispatchEvent('click:name clickName', event);
	  };

	  F7Message.prototype.onTextClick = function onTextClick (event) {
	    this.dispatchEvent('click:text clickText', event);
	  };

	  F7Message.prototype.onAvatarClick = function onAvatarClick (event) {
	    this.dispatchEvent('click:avatar clickAvatar', event);
	  };

	  F7Message.prototype.onHeaderClick = function onHeaderClick (event) {
	    this.dispatchEvent('click:header clickHeader', event);
	  };

	  F7Message.prototype.onFooterClick = function onFooterClick (event) {
	    this.dispatchEvent('click:footer clickFooter', event);
	  };

	  F7Message.prototype.onBubbleClick = function onBubbleClick (event) {
	    this.dispatchEvent('click:bubble clickBubble', event);
	  };

	  prototypeAccessors.classes.get = function () {
	    var self = this;
	    var props = self.props;
	    var type = props.type;
	    var typing = props.typing;
	    var first = props.first;
	    var last = props.last;
	    var tail = props.tail;
	    var sameName = props.sameName;
	    var sameHeader = props.sameHeader;
	    var sameFooter = props.sameFooter;
	    var sameAvatar = props.sameAvatar;
	    var className = props.className;
	    return Utils$1.classNames(className, 'message', {
	      'message-sent': type === 'sent',
	      'message-received': type === 'received',
	      'message-typing': typing,
	      'message-first': first,
	      'message-last': last,
	      'message-tail': tail,
	      'message-same-name': sameName,
	      'message-same-header': sameHeader,
	      'message-same-footer': sameFooter,
	      'message-same-avatar': sameAvatar
	    }, Mixins.colorClasses(props));
	  };

	  F7Message.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var text = props.text;
	    var name = props.name;
	    var avatar = props.avatar;
	    var image = props.image;
	    var header = props.header;
	    var footer = props.footer;
	    var textHeader = props.textHeader;
	    var textFooter = props.textFooter;
	    var typing = props.typing;
	    var id = props.id;
	    var style = props.style;
	    var ref = self.slots;
	    var slotsStart = ref.start;
	    var slotsEnd = ref.end;
	    var slotsDefault = ref.default;
	    var slotsContentStart = ref['content-start'];
	    var slotsContentEnd = ref['content-end'];
	    var slotsAvatar = ref.avatar;
	    var slotsName = ref.name;
	    var slotsHeader = ref.header;
	    var slotsFooter = ref.footer;
	    var slotsImage = ref.image;
	    var slotsText = ref.text;
	    var slotsTextHeader = ref['text-header'];
	    var slotsTextFooter = ref['text-footer'];
	    var slotsBubbleStart = ref['bubble-start'];
	    var slotsBubbleEnd = ref['bubble-end'];
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: self.classes
	    }, slotsStart, (avatar || slotsAvatar) && react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['avatarEl'] = __reactNode;
	      },
	      className: 'message-avatar',
	      style: {
	        backgroundImage: avatar && ("url(" + avatar + ")")
	      }
	    }, slotsAvatar), react.createElement('div', {
	      className: 'message-content'
	    }, slotsContentStart, (slotsName || name) && react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['nameEl'] = __reactNode;
	      },
	      className: 'message-name'
	    }, slotsName || name), (slotsHeader || header) && react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['headerEl'] = __reactNode;
	      },
	      className: 'message-header'
	    }, slotsHeader || header), react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['bubbleEl'] = __reactNode;
	      },
	      className: 'message-bubble'
	    }, slotsBubbleStart, (slotsImage || image) && react.createElement('div', {
	      className: 'message-image'
	    }, slotsImage || react.createElement('img', {
	      src: image
	    })), (slotsTextHeader || textHeader) && react.createElement('div', {
	      className: 'message-text-header'
	    }, slotsTextHeader || textHeader), (slotsText || text || typing) && react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['textEl'] = __reactNode;
	      },
	      className: 'message-text'
	    }, slotsText || text, typing && react.createElement('div', {
	      className: 'message-typing-indicator'
	    }, react.createElement('div', null), react.createElement('div', null), react.createElement('div', null))), (slotsTextFooter || textFooter) && react.createElement('div', {
	      className: 'message-text-footer'
	    }, slotsTextFooter || textFooter), slotsBubbleEnd, slotsDefault), (slotsFooter || footer) && react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['footerEl'] = __reactNode;
	      },
	      className: 'message-footer'
	    }, slotsFooter || footer), slotsContentEnd), slotsEnd);
	  };

	  F7Message.prototype.componentWillUnmount = function componentWillUnmount () {
	    var ref = this.refs;
	    var el = ref.el;
	    var nameEl = ref.nameEl;
	    var textEl = ref.textEl;
	    var avatarEl = ref.avatarEl;
	    var headerEl = ref.headerEl;
	    var footerEl = ref.footerEl;
	    var bubbleEl = ref.bubbleEl;
	    el.removeEventListener('click', this.onClick);
	    if (nameEl) { nameEl.removeEventListener('click', this.onNameClick); }
	    if (textEl) { textEl.removeEventListener('click', this.onTextClick); }
	    if (avatarEl) { avatarEl.removeEventListener('click', this.onAvatarClick); }
	    if (headerEl) { headerEl.removeEventListener('click', this.onHeaderClick); }
	    if (footerEl) { footerEl.removeEventListener('click', this.onFooterClick); }
	    if (bubbleEl) { bubbleEl.removeEventListener('click', this.onBubbleClick); }
	  };

	  F7Message.prototype.componentDidMount = function componentDidMount () {
	    var ref = this.refs;
	    var el = ref.el;
	    var nameEl = ref.nameEl;
	    var textEl = ref.textEl;
	    var avatarEl = ref.avatarEl;
	    var headerEl = ref.headerEl;
	    var footerEl = ref.footerEl;
	    var bubbleEl = ref.bubbleEl;
	    el.addEventListener('click', this.onClick);
	    if (nameEl) { nameEl.addEventListener('click', this.onNameClick); }
	    if (textEl) { textEl.addEventListener('click', this.onTextClick); }
	    if (avatarEl) { avatarEl.addEventListener('click', this.onAvatarClick); }
	    if (headerEl) { headerEl.addEventListener('click', this.onHeaderClick); }
	    if (footerEl) { footerEl.addEventListener('click', this.onFooterClick); }
	    if (bubbleEl) { bubbleEl.addEventListener('click', this.onBubbleClick); }
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Message.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Message.prototype, prototypeAccessors );

	  return F7Message;
	}(react.Component));

	__reactComponentSetProps(F7Message, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  text: String,
	  name: String,
	  avatar: String,
	  type: {
	    type: String,
	    default: 'sent'
	  },
	  image: String,
	  header: String,
	  footer: String,
	  textHeader: String,
	  textFooter: String,
	  first: Boolean,
	  last: Boolean,
	  tail: Boolean,
	  sameName: Boolean,
	  sameHeader: Boolean,
	  sameFooter: Boolean,
	  sameAvatar: Boolean,
	  typing: Boolean
	}, Mixins.colorProps));

	F7Message.displayName = 'f7-message';

	var F7MessagebarAttachment = /*@__PURE__*/(function (superclass) {
	  function F7MessagebarAttachment(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick', 'onDeleteClick']);
	    })();
	  }

	  if ( superclass ) F7MessagebarAttachment.__proto__ = superclass;
	  F7MessagebarAttachment.prototype = Object.create( superclass && superclass.prototype );
	  F7MessagebarAttachment.prototype.constructor = F7MessagebarAttachment;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7MessagebarAttachment.prototype.onClick = function onClick (event) {
	    this.dispatchEvent('attachment:click attachmentClick', event);
	  };

	  F7MessagebarAttachment.prototype.onDeleteClick = function onDeleteClick (event) {
	    this.dispatchEvent('attachment:delete attachmentDelete', event);
	  };

	  F7MessagebarAttachment.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var deletable = props.deletable;
	    var image = props.image;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'messagebar-attachment', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes
	    }, image && react.createElement('img', {
	      src: image
	    }), deletable && react.createElement('span', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['deleteEl'] = __reactNode;
	      },
	      className: 'messagebar-attachment-delete'
	    }), this.slots['default']);
	  };

	  F7MessagebarAttachment.prototype.componentWillUnmount = function componentWillUnmount () {
	    this.refs.el.removeEventListener('click', this.onClick);

	    if (this.refs.deleteEl) {
	      this.refs.deleteEl.removeEventListener('click', this.onDeleteClick);
	    }
	  };

	  F7MessagebarAttachment.prototype.componentDidMount = function componentDidMount () {
	    this.refs.el.addEventListener('click', this.onClick);

	    if (this.refs.deleteEl) {
	      this.refs.deleteEl.addEventListener('click', this.onDeleteClick);
	    }
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7MessagebarAttachment.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7MessagebarAttachment.prototype, prototypeAccessors );

	  return F7MessagebarAttachment;
	}(react.Component));

	__reactComponentSetProps(F7MessagebarAttachment, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  image: String,
	  deletable: {
	    type: Boolean,
	    default: true
	  }
	}, Mixins.colorProps));

	F7MessagebarAttachment.displayName = 'f7-messagebar-attachment';

	var F7MessagebarAttachments = /*@__PURE__*/(function (superclass) {
	  function F7MessagebarAttachments(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7MessagebarAttachments.__proto__ = superclass;
	  F7MessagebarAttachments.prototype = Object.create( superclass && superclass.prototype );
	  F7MessagebarAttachments.prototype.constructor = F7MessagebarAttachments;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7MessagebarAttachments.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'messagebar-attachments', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7MessagebarAttachments.prototype, prototypeAccessors );

	  return F7MessagebarAttachments;
	}(react.Component));

	__reactComponentSetProps(F7MessagebarAttachments, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7MessagebarAttachments.displayName = 'f7-messagebar-attachments';

	var F7MessagebarSheetImage = /*@__PURE__*/(function (superclass) {
	  function F7MessagebarSheetImage(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onChange']);
	    })();
	  }

	  if ( superclass ) F7MessagebarSheetImage.__proto__ = superclass;
	  F7MessagebarSheetImage.prototype = Object.create( superclass && superclass.prototype );
	  F7MessagebarSheetImage.prototype.constructor = F7MessagebarSheetImage;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7MessagebarSheetImage.prototype.onChange = function onChange (event) {
	    if (this.props.checked) { this.dispatchEvent('checked', event); }else { this.dispatchEvent('unchecked', event); }
	    this.dispatchEvent('change', event);
	  };

	  F7MessagebarSheetImage.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var image = props.image;
	    var checked = props.checked;
	    var id = props.id;
	    var className = props.className;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'messagebar-sheet-image', 'checkbox', Mixins.colorClasses(props));
	    var styles = Utils$1.extend({
	      backgroundImage: image && ("url(" + image + ")")
	    }, style || {});
	    var inputEl;
	    {
	      inputEl = react.createElement('input', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['inputEl'] = __reactNode;
	        },
	        type: 'checkbox',
	        checked: checked,
	        onChange: self.onChange
	      });
	    }
	    return react.createElement('label', {
	      id: id,
	      className: classes,
	      style: styles
	    }, inputEl, react.createElement('i', {
	      className: 'icon icon-checkbox'
	    }), this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7MessagebarSheetImage.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7MessagebarSheetImage.prototype, prototypeAccessors );

	  return F7MessagebarSheetImage;
	}(react.Component));

	__reactComponentSetProps(F7MessagebarSheetImage, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  image: String,
	  checked: Boolean
	}, Mixins.colorProps));

	F7MessagebarSheetImage.displayName = 'f7-messagebar-sheet-image';

	var F7MessagebarSheetItem = /*@__PURE__*/(function (superclass) {
	  function F7MessagebarSheetItem(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7MessagebarSheetItem.__proto__ = superclass;
	  F7MessagebarSheetItem.prototype = Object.create( superclass && superclass.prototype );
	  F7MessagebarSheetItem.prototype.constructor = F7MessagebarSheetItem;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7MessagebarSheetItem.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'messagebar-sheet-item', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7MessagebarSheetItem.prototype, prototypeAccessors );

	  return F7MessagebarSheetItem;
	}(react.Component));

	__reactComponentSetProps(F7MessagebarSheetItem, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7MessagebarSheetItem.displayName = 'f7-messagebar-sheet-item';

	var F7MessagebarSheet = /*@__PURE__*/(function (superclass) {
	  function F7MessagebarSheet(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7MessagebarSheet.__proto__ = superclass;
	  F7MessagebarSheet.prototype = Object.create( superclass && superclass.prototype );
	  F7MessagebarSheet.prototype.constructor = F7MessagebarSheet;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7MessagebarSheet.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'messagebar-sheet', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7MessagebarSheet.prototype, prototypeAccessors );

	  return F7MessagebarSheet;
	}(react.Component));

	__reactComponentSetProps(F7MessagebarSheet, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7MessagebarSheet.displayName = 'f7-messagebar-sheet';

	var F7Messagebar = /*@__PURE__*/(function (superclass) {
	  function F7Messagebar(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onChange', 'onInput', 'onFocus', 'onBlur', 'onClick', 'onDeleteAttachment', 'onClickAttachment', 'onResizePage']);
	    })();
	  }

	  if ( superclass ) F7Messagebar.__proto__ = superclass;
	  F7Messagebar.prototype = Object.create( superclass && superclass.prototype );
	  F7Messagebar.prototype.constructor = F7Messagebar;

	  var prototypeAccessors = { classes: { configurable: true },slots: { configurable: true },refs: { configurable: true } };

	  F7Messagebar.prototype.clear = function clear () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messagebar) { return undefined; }
	    return (ref = this.f7Messagebar).clear.apply(ref, args);
	  };

	  F7Messagebar.prototype.getValue = function getValue () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messagebar) { return undefined; }
	    return (ref = this.f7Messagebar).getValue.apply(ref, args);
	  };

	  F7Messagebar.prototype.setValue = function setValue () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messagebar) { return undefined; }
	    return (ref = this.f7Messagebar).setValue.apply(ref, args);
	  };

	  F7Messagebar.prototype.setPlaceholder = function setPlaceholder () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messagebar) { return undefined; }
	    return (ref = this.f7Messagebar).setPlaceholder.apply(ref, args);
	  };

	  F7Messagebar.prototype.resize = function resize () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messagebar) { return undefined; }
	    return (ref = this.f7Messagebar).resizePage.apply(ref, args);
	  };

	  F7Messagebar.prototype.focus = function focus () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messagebar) { return undefined; }
	    return (ref = this.f7Messagebar).focus.apply(ref, args);
	  };

	  F7Messagebar.prototype.blur = function blur () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messagebar) { return undefined; }
	    return (ref = this.f7Messagebar).blur.apply(ref, args);
	  };

	  F7Messagebar.prototype.attachmentsShow = function attachmentsShow () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messagebar) { return undefined; }
	    return (ref = this.f7Messagebar).attachmentsShow.apply(ref, args);
	  };

	  F7Messagebar.prototype.attachmentsHide = function attachmentsHide () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messagebar) { return undefined; }
	    return (ref = this.f7Messagebar).attachmentsHide.apply(ref, args);
	  };

	  F7Messagebar.prototype.attachmentsToggle = function attachmentsToggle () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messagebar) { return undefined; }
	    return (ref = this.f7Messagebar).attachmentsToggle.apply(ref, args);
	  };

	  F7Messagebar.prototype.sheetShow = function sheetShow () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messagebar) { return undefined; }
	    return (ref = this.f7Messagebar).sheetShow.apply(ref, args);
	  };

	  F7Messagebar.prototype.sheetHide = function sheetHide () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messagebar) { return undefined; }
	    return (ref = this.f7Messagebar).sheetHide.apply(ref, args);
	  };

	  F7Messagebar.prototype.sheetToggle = function sheetToggle () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messagebar) { return undefined; }
	    return (ref = this.f7Messagebar).sheetToggle.apply(ref, args);
	  };

	  F7Messagebar.prototype.onChange = function onChange (event) {
	    this.dispatchEvent('change', event);
	  };

	  F7Messagebar.prototype.onInput = function onInput (event) {
	    this.dispatchEvent('input', event);
	  };

	  F7Messagebar.prototype.onFocus = function onFocus (event) {
	    this.dispatchEvent('focus', event);
	  };

	  F7Messagebar.prototype.onBlur = function onBlur (event) {
	    this.dispatchEvent('blur', event);
	  };

	  F7Messagebar.prototype.onClick = function onClick (event) {
	    var self = this;
	    var value;
	    {
	      value = self.refs.area.refs.inputEl.value;
	    }
	    var clear = self.f7Messagebar ? function () {
	      self.f7Messagebar.clear();
	    } : function () {};
	    this.dispatchEvent('submit', value, clear);
	    this.dispatchEvent('send', value, clear);
	    this.dispatchEvent('click', event);
	  };

	  F7Messagebar.prototype.onDeleteAttachment = function onDeleteAttachment (event) {
	    this.dispatchEvent('messagebar:attachmentdelete messagebarAttachmentDelete', event);
	  };

	  F7Messagebar.prototype.onClickAttachment = function onClickAttachment (event) {
	    this.dispatchEvent('messagebar:attachmentclick messagebarAttachmentClick', event);
	  };

	  F7Messagebar.prototype.onResizePage = function onResizePage (event) {
	    this.dispatchEvent('messagebar:resizepage messagebarResizePage', event);
	  };

	  prototypeAccessors.classes.get = function () {
	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var attachmentsVisible = props.attachmentsVisible;
	    var sheetVisible = props.sheetVisible;
	    return Utils$1.classNames(className, 'toolbar', 'messagebar', {
	      'messagebar-attachments-visible': attachmentsVisible,
	      'messagebar-sheet-visible': sheetVisible
	    }, Mixins.colorClasses(props));
	  };

	  F7Messagebar.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var ref = self.props;
	    var placeholder = ref.placeholder;
	    var disabled = ref.disabled;
	    var name = ref.name;
	    var readonly = ref.readonly;
	    var resizable = ref.resizable;
	    var value = ref.value;
	    var sendLink = ref.sendLink;
	    var id = ref.id;
	    var style = ref.style;
	    var ref$1 = self.slots;
	    var slotsDefault = ref$1.default;
	    var slotsBeforeInner = ref$1['before-inner'];
	    var slotsAfterInner = ref$1['after-inner'];
	    var slotsSendLink = ref$1['send-link'];
	    var slotsInnerStart = ref$1['inner-start'];
	    var slotsInnerEnd = ref$1['inner-end'];
	    var slotsBeforeArea = ref$1['before-area'];
	    var slotsAfterArea = ref$1['after-area'];
	    var innerEndEls = [];
	    var messagebarAttachmentsEl;
	    var messagebarSheetEl;

	    if (slotsDefault) {
	      slotsDefault.forEach(function (child) {
	        if (typeof child === 'undefined') { return; }
	        var tag;
	        tag = child.type && (child.type.displayName || child.type.name);

	        if (tag && (tag.indexOf('messagebar-attachments') >= 0 || tag === 'F7MessagebarAttachments' || tag === 'f7-messagebar-attachments')) {
	          messagebarAttachmentsEl = child;
	        } else if (tag && (tag.indexOf('messagebar-sheet') >= 0 || tag === 'F7MessagebarSheet' || tag === 'f7-messagebar-sheet')) {
	          messagebarSheetEl = child;
	        } else {
	          innerEndEls.push(child);
	        }
	      });
	    }

	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: self.classes
	    }, slotsBeforeInner, react.createElement('div', {
	      className: 'toolbar-inner'
	    }, slotsInnerStart, react.createElement('div', {
	      className: 'messagebar-area'
	    }, slotsBeforeArea, messagebarAttachmentsEl, react.createElement(F7Input, {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['area'] = __reactNode;
	      },
	      type: 'textarea',
	      wrap: false,
	      placeholder: placeholder,
	      disabled: disabled,
	      name: name,
	      readonly: readonly,
	      resizable: resizable,
	      value: value,
	      onInput: self.onInput,
	      onChange: self.onChange,
	      onFocus: self.onFocus,
	      onBlur: self.onBlur
	    }), slotsAfterArea), (sendLink && sendLink.length > 0 || slotsSendLink) && react.createElement(F7Link, {
	      onClick: self.onClick
	    }, slotsSendLink || sendLink), slotsInnerEnd, innerEndEls), slotsAfterInner, messagebarSheetEl);
	  };

	  F7Messagebar.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    if (self.f7Messagebar && self.f7Messagebar.destroy) { self.f7Messagebar.destroy(); }
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.removeEventListener('messagebar:attachmentdelete', self.onDeleteAttachment);
	    el.removeEventListener('messagebar:attachmentclick', self.onClickAttachment);
	    el.removeEventListener('messagebar:resizepage', self.onResizePage);
	  };

	  F7Messagebar.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.sheetVisible', prevProps, prevState, function () {
	      var self = this$1;
	      if (!self.props.resizable || !self.f7Messagebar) { return; }
	      self.updateSheetVisible = true;
	    });

	    __reactComponentWatch(this, 'props.attachmentsVisible', prevProps, prevState, function () {
	      var self = this$1;
	      if (!self.props.resizable || !self.f7Messagebar) { return; }
	      self.updateAttachmentsVisible = true;
	    });

	    var self = this;
	    if (!self.f7Messagebar) { return; }
	    var ref = self.props;
	    var sheetVisible = ref.sheetVisible;
	    var attachmentsVisible = ref.attachmentsVisible;

	    if (self.updateSheetVisible) {
	      self.updateSheetVisible = false;
	      self.f7Messagebar.sheetVisible = sheetVisible;
	      self.f7Messagebar.resizePage();
	    }

	    if (self.updateAttachmentsVisible) {
	      self.updateAttachmentsVisible = false;
	      self.f7Messagebar.attachmentsVisible = attachmentsVisible;
	      self.f7Messagebar.resizePage();
	    }
	  };

	  F7Messagebar.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var ref = self.props;
	    var init = ref.init;
	    var top = ref.top;
	    var resizePage = ref.resizePage;
	    var bottomOffset = ref.bottomOffset;
	    var topOffset = ref.topOffset;
	    var maxHeight = ref.maxHeight;
	    if (!init) { return; }
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.addEventListener('messagebar:attachmentdelete', self.onDeleteAttachment);
	    el.addEventListener('messagebar:attachmentclick', self.onClickAttachment);
	    el.addEventListener('messagebar:resizepage', self.onResizePage);
	    var params = Utils$1.noUndefinedProps({
	      el: el,
	      top: top,
	      resizePage: resizePage,
	      bottomOffset: bottomOffset,
	      topOffset: topOffset,
	      maxHeight: maxHeight
	    });
	    self.$f7ready(function () {
	      self.f7Messagebar = self.$f7.messagebar.create(params);
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Messagebar.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Messagebar.prototype, prototypeAccessors );

	  return F7Messagebar;
	}(react.Component));

	__reactComponentSetProps(F7Messagebar, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  sheetVisible: Boolean,
	  attachmentsVisible: Boolean,
	  top: Boolean,
	  resizable: {
	    type: Boolean,
	    default: true
	  },
	  bottomOffset: {
	    type: Number,
	    default: 0
	  },
	  topOffset: {
	    type: Number,
	    default: 0
	  },
	  maxHeight: Number,
	  resizePage: {
	    type: Boolean,
	    default: true
	  },
	  sendLink: String,
	  value: [String, Number, Array],
	  disabled: Boolean,
	  readonly: Boolean,
	  textareaId: [Number, String],
	  name: String,
	  placeholder: {
	    type: String,
	    default: 'Message'
	  },
	  init: {
	    type: Boolean,
	    default: true
	  }
	}, Mixins.colorProps));

	F7Messagebar.displayName = 'f7-messagebar';

	var F7MessagesTitle = /*@__PURE__*/(function (superclass) {
	  function F7MessagesTitle(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7MessagesTitle.__proto__ = superclass;
	  F7MessagesTitle.prototype = Object.create( superclass && superclass.prototype );
	  F7MessagesTitle.prototype.constructor = F7MessagesTitle;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7MessagesTitle.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'messages-title', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7MessagesTitle.prototype, prototypeAccessors );

	  return F7MessagesTitle;
	}(react.Component));

	__reactComponentSetProps(F7MessagesTitle, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7MessagesTitle.displayName = 'f7-messages-title';

	var F7Messages = /*@__PURE__*/(function (superclass) {
	  function F7Messages(props, context) {
	    superclass.call(this, props, context);
	    this.__reactRefs = {};
	  }

	  if ( superclass ) F7Messages.__proto__ = superclass;
	  F7Messages.prototype = Object.create( superclass && superclass.prototype );
	  F7Messages.prototype.constructor = F7Messages;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Messages.prototype.renderMessages = function renderMessages (messagesToRender, method) {
	    if (!this.f7Messages) { return undefined; }
	    return this.f7Messages.renderMessages(messagesToRender, method);
	  };

	  F7Messages.prototype.layout = function layout () {
	    if (!this.f7Messages) { return undefined; }
	    return this.f7Messages.layout();
	  };

	  F7Messages.prototype.scroll = function scroll (duration, scrollTop) {
	    if (!this.f7Messages) { return undefined; }
	    return this.f7Messages.scroll(duration, scrollTop);
	  };

	  F7Messages.prototype.clear = function clear () {
	    if (!this.f7Messages) { return undefined; }
	    return this.f7Messages.clear();
	  };

	  F7Messages.prototype.removeMessage = function removeMessage (messageToRemove, layout) {
	    if (!this.f7Messages) { return undefined; }
	    return this.f7Messages.removeMessage(messageToRemove, layout);
	  };

	  F7Messages.prototype.removeMessages = function removeMessages (messagesToRemove, layout) {
	    if (!this.f7Messages) { return undefined; }
	    return this.f7Messages.removeMessages(messagesToRemove, layout);
	  };

	  F7Messages.prototype.addMessage = function addMessage () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messages) { return undefined; }
	    return (ref = this.f7Messages).addMessage.apply(ref, args);
	  };

	  F7Messages.prototype.addMessages = function addMessages () {
	    var ref;

	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    if (!this.f7Messages) { return undefined; }
	    return (ref = this.f7Messages).addMessages.apply(ref, args);
	  };

	  F7Messages.prototype.showTyping = function showTyping (message) {
	    if (!this.f7Messages) { return undefined; }
	    return this.f7Messages.showTyping(message);
	  };

	  F7Messages.prototype.hideTyping = function hideTyping () {
	    if (!this.f7Messages) { return undefined; }
	    return this.f7Messages.hideTyping();
	  };

	  F7Messages.prototype.destroy = function destroy () {
	    if (!this.f7Messages) { return undefined; }
	    return this.f7Messages.destroy();
	  };

	  F7Messages.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var style = props.style;
	    var className = props.className;
	    var classes = Utils$1.classNames(className, 'messages', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  F7Messages.prototype.componentWillUnmount = function componentWillUnmount () {
	    if (this.f7Messages && this.f7Messages.destroy) { this.f7Messages.destroy(); }
	  };

	  F7Messages.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var ref = self.props;
	    var init = ref.init;
	    var autoLayout = ref.autoLayout;
	    var messages = ref.messages;
	    var newMessagesFirst = ref.newMessagesFirst;
	    var scrollMessages = ref.scrollMessages;
	    var scrollMessagesOnEdge = ref.scrollMessagesOnEdge;
	    var firstMessageRule = ref.firstMessageRule;
	    var lastMessageRule = ref.lastMessageRule;
	    var tailMessageRule = ref.tailMessageRule;
	    var sameNameMessageRule = ref.sameNameMessageRule;
	    var sameHeaderMessageRule = ref.sameHeaderMessageRule;
	    var sameFooterMessageRule = ref.sameFooterMessageRule;
	    var sameAvatarMessageRule = ref.sameAvatarMessageRule;
	    var customClassMessageRule = ref.customClassMessageRule;
	    var renderMessage = ref.renderMessage;
	    if (!init) { return; }
	    self.$f7ready(function (f7) {
	      self.f7Messages = f7.messages.create(Utils$1.noUndefinedProps({
	        el: self.refs.el,
	        autoLayout: autoLayout,
	        messages: messages,
	        newMessagesFirst: newMessagesFirst,
	        scrollMessages: scrollMessages,
	        scrollMessagesOnEdge: scrollMessagesOnEdge,
	        firstMessageRule: firstMessageRule,
	        lastMessageRule: lastMessageRule,
	        tailMessageRule: tailMessageRule,
	        sameNameMessageRule: sameNameMessageRule,
	        sameHeaderMessageRule: sameHeaderMessageRule,
	        sameFooterMessageRule: sameFooterMessageRule,
	        sameAvatarMessageRule: sameAvatarMessageRule,
	        customClassMessageRule: customClassMessageRule,
	        renderMessage: renderMessage
	      }));
	    });
	  };

	  F7Messages.prototype.componentDidUpdate = function componentDidUpdate () {
	    var self = this;
	    var ref = self.props;
	    var init = ref.init;
	    var autoLayout = ref.autoLayout;
	    var scrollMessages = ref.scrollMessages;
	    if (!init) { return; }
	    var el = self.refs.el;
	    if (!el) { return; }
	    var children = el.children;
	    if (!children) { return; }

	    for (var i = 0; i < children.length; i += 1) {
	      if (!children[i].classList.contains('message-appeared')) {
	        children[i].classList.add('message-appear-from-bottom');
	      }
	    }

	    if (self.f7Messages && self.f7Messages.layout && autoLayout) {
	      self.f7Messages.layout();
	    }

	    if (self.f7Messages && self.f7Messages.scroll && scrollMessages) {
	      self.f7Messages.scroll();
	    }
	  };

	  F7Messages.prototype.componentWillUpdate = function componentWillUpdate () {
	    var self = this;
	    if (!self.props.init) { return; }
	    var el = self.refs.el;
	    if (!el) { return; }
	    var children = el.children;
	    if (!children) { return; }

	    for (var i = 0; i < children.length; i += 1) {
	      children[i].classList.add('message-appeared');
	    }
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Messages.prototype, prototypeAccessors );

	  return F7Messages;
	}(react.Component));

	__reactComponentSetProps(F7Messages, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  autoLayout: {
	    type: Boolean,
	    default: false
	  },
	  messages: {
	    type: Array,

	    default: function default$1() {
	      return [];
	    }

	  },
	  newMessagesFirst: {
	    type: Boolean,
	    default: false
	  },
	  scrollMessages: {
	    type: Boolean,
	    default: true
	  },
	  scrollMessagesOnEdge: {
	    type: Boolean,
	    default: true
	  },
	  firstMessageRule: Function,
	  lastMessageRule: Function,
	  tailMessageRule: Function,
	  sameNameMessageRule: Function,
	  sameHeaderMessageRule: Function,
	  sameFooterMessageRule: Function,
	  sameAvatarMessageRule: Function,
	  customClassMessageRule: Function,
	  renderMessage: Function,
	  init: {
	    type: Boolean,
	    default: true
	  }
	}, Mixins.colorProps));

	F7Messages.displayName = 'f7-messages';

	var F7NavLeft = /*@__PURE__*/(function (superclass) {
	  function F7NavLeft(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);

	    (function () {
	      Utils$1.bindMethods(this$1, ['onBackClick']);
	    })();
	  }

	  if ( superclass ) F7NavLeft.__proto__ = superclass;
	  F7NavLeft.prototype = Object.create( superclass && superclass.prototype );
	  F7NavLeft.prototype.constructor = F7NavLeft;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7NavLeft.prototype.onBackClick = function onBackClick (event) {
	    this.dispatchEvent('back-click backClick click:back clickBack', event);
	  };

	  F7NavLeft.prototype.render = function render () {
	    var props = this.props;
	    var backLink = props.backLink;
	    var backLinkUrl = props.backLinkUrl;
	    var backLinkForce = props.backLinkForce;
	    var backLinkShowText = props.backLinkShowText;
	    var sliding = props.sliding;
	    var className = props.className;
	    var style = props.style;
	    var id = props.id;
	    var linkEl;
	    var needBackLinkText = backLinkShowText;
	    if (typeof needBackLinkText === 'undefined') { needBackLinkText = !this.$theme.md; }

	    if (backLink) {
	      linkEl = react.createElement(F7Link, {
	        href: backLinkUrl || '#',
	        back: true,
	        icon: 'icon-back',
	        force: backLinkForce || undefined,
	        className: backLink === true || backLink && this.$theme.md ? 'icon-only' : undefined,
	        text: backLink !== true && needBackLinkText ? backLink : undefined,
	        onClick: this.onBackClick
	      });
	    }

	    var classes = Utils$1.classNames(className, 'left', {
	      sliding: sliding
	    }, Mixins.colorClasses(props));
	    var children = [];
	    var slots = this.slots;

	    if (slots && Object.keys(slots).length) {
	      Object.keys(slots).forEach(function (key) {
	        children.push.apply(children, slots[key]);
	      });
	    }

	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, linkEl, children);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7NavLeft.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  Object.defineProperties( F7NavLeft.prototype, prototypeAccessors );

	  return F7NavLeft;
	}(react.Component));

	__reactComponentSetProps(F7NavLeft, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  backLink: [Boolean, String],
	  backLinkUrl: String,
	  backLinkForce: Boolean,
	  backLinkShowText: {
	    type: Boolean,
	    default: undefined
	  },
	  sliding: Boolean
	}, Mixins.colorProps));

	F7NavLeft.displayName = 'f7-nav-left';

	var F7NavRight = /*@__PURE__*/(function (superclass) {
	  function F7NavRight(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7NavRight.__proto__ = superclass;
	  F7NavRight.prototype = Object.create( superclass && superclass.prototype );
	  F7NavRight.prototype.constructor = F7NavRight;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7NavRight.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var sliding = props.sliding;
	    var classes = Utils$1.classNames(className, 'right', {
	      sliding: sliding
	    }, Mixins.colorClasses(props));
	    var children = [];
	    var slots = this.slots;

	    if (slots && Object.keys(slots).length) {
	      Object.keys(slots).forEach(function (key) {
	        children.push.apply(children, slots[key]);
	      });
	    }

	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, children);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7NavRight.prototype, prototypeAccessors );

	  return F7NavRight;
	}(react.Component));

	__reactComponentSetProps(F7NavRight, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  sliding: Boolean
	}, Mixins.colorProps));

	F7NavRight.displayName = 'f7-nav-right';

	var F7NavTitle = /*@__PURE__*/(function (superclass) {
	  function F7NavTitle(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7NavTitle.__proto__ = superclass;
	  F7NavTitle.prototype = Object.create( superclass && superclass.prototype );
	  F7NavTitle.prototype.constructor = F7NavTitle;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7NavTitle.prototype.render = function render () {
	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var style = props.style;
	    var className = props.className;
	    var classes = Utils$1.classNames(className, 'title-large', Mixins.colorClasses(props));
	    var children = [];
	    var slots = self.slots;

	    if (slots && Object.keys(slots).length) {
	      Object.keys(slots).forEach(function (key) {
	        children.push.apply(children, slots[key]);
	      });
	    }

	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, react.createElement('div', {
	      className: 'title-large-text'
	    }, children));
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7NavTitle.prototype, prototypeAccessors );

	  return F7NavTitle;
	}(react.Component));

	__reactComponentSetProps(F7NavTitle, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7NavTitle.displayName = 'f7-nav-title';

	var F7NavTitle$1 = /*@__PURE__*/(function (superclass) {
	  function F7NavTitle(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7NavTitle.__proto__ = superclass;
	  F7NavTitle.prototype = Object.create( superclass && superclass.prototype );
	  F7NavTitle.prototype.constructor = F7NavTitle;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7NavTitle.prototype.render = function render () {
	    var self = this;
	    var props = self.props;
	    var title = props.title;
	    var subtitle = props.subtitle;
	    var id = props.id;
	    var style = props.style;
	    var sliding = props.sliding;
	    var className = props.className;
	    var subtitleEl;

	    if (subtitle) {
	      subtitleEl = react.createElement('span', {
	        className: 'subtitle'
	      }, subtitle);
	    }

	    var classes = Utils$1.classNames(className, 'title', {
	      sliding: sliding
	    }, Mixins.colorClasses(props));
	    var children;
	    var slots = self.slots;

	    if (slots && Object.keys(slots).length) {
	      children = [];
	      Object.keys(slots).forEach(function (key) {
	        children.push.apply(children, slots[key]);
	      });
	    }

	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, children, !children && title, !children && subtitleEl);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7NavTitle.prototype, prototypeAccessors );

	  return F7NavTitle;
	}(react.Component));

	__reactComponentSetProps(F7NavTitle$1, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  title: String,
	  subtitle: String,
	  sliding: Boolean
	}, Mixins.colorProps));

	F7NavTitle$1.displayName = 'f7-nav-title';

	var F7Navbar = /*@__PURE__*/(function (superclass) {
	  function F7Navbar(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onBackClick', 'onHide', 'onShow', 'onExpand', 'onCollapse']);
	    })();
	  }

	  if ( superclass ) F7Navbar.__proto__ = superclass;
	  F7Navbar.prototype = Object.create( superclass && superclass.prototype );
	  F7Navbar.prototype.constructor = F7Navbar;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Navbar.prototype.onHide = function onHide (navbarEl) {
	    var self = this;
	    var ref = self.refs;
	    var el = ref.el;
	    var innerEl = ref.innerEl;

	    if (navbarEl === el || innerEl && innerEl.parentNode === navbarEl) {
	      self.dispatchEvent('navbar:hide navbarHide');
	    }
	  };

	  F7Navbar.prototype.onShow = function onShow (navbarEl) {
	    var self = this;
	    var ref = self.refs;
	    var el = ref.el;
	    var innerEl = ref.innerEl;

	    if (navbarEl === el || innerEl && innerEl.parentNode === navbarEl) {
	      self.dispatchEvent('navbar:show navbarShow');
	    }
	  };

	  F7Navbar.prototype.onExpand = function onExpand (navbarEl) {
	    var self = this;
	    var ref = self.refs;
	    var el = ref.el;
	    var innerEl = ref.innerEl;

	    if (navbarEl === el || innerEl && innerEl.parentNode === navbarEl) {
	      self.dispatchEvent('navbar:expand navbarExpand');
	    }
	  };

	  F7Navbar.prototype.onCollapse = function onCollapse (navbarEl) {
	    var self = this;
	    var ref = self.refs;
	    var el = ref.el;
	    var innerEl = ref.innerEl;

	    if (navbarEl === el || innerEl && innerEl.parentNode === navbarEl) {
	      self.dispatchEvent('navbar:collapse navbarCollapse');
	    }
	  };

	  F7Navbar.prototype.hide = function hide (animate) {
	    var self = this;
	    if (!self.$f7) { return; }
	    self.$f7.navbar.hide(self.refs.el, animate);
	  };

	  F7Navbar.prototype.show = function show (animate) {
	    var self = this;
	    if (!self.$f7) { return; }
	    self.$f7.navbar.show(self.refs.el, animate);
	  };

	  F7Navbar.prototype.size = function size () {
	    var self = this;
	    if (!self.$f7) { return; }
	    self.$f7.navbar.size(self.refs.el);
	  };

	  F7Navbar.prototype.onBackClick = function onBackClick (event) {
	    this.dispatchEvent('back-click backClick click:back clickBack', event);
	  };

	  F7Navbar.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var backLink = props.backLink;
	    var backLinkUrl = props.backLinkUrl;
	    var backLinkForce = props.backLinkForce;
	    var backLinkShowText = props.backLinkShowText;
	    var sliding = props.sliding;
	    var title = props.title;
	    var subtitle = props.subtitle;
	    var inner = props.inner;
	    var innerClass = props.innerClass;
	    var innerClassName = props.innerClassName;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var hidden = props.hidden;
	    var noShadow = props.noShadow;
	    var noHairline = props.noHairline;
	    var large = props.large;
	    var titleLarge = props.titleLarge;
	    var innerEl;
	    var leftEl;
	    var titleEl;
	    var rightEl;
	    var titleLargeEl;
	    var addLeftTitleClass = self.$theme && self.$theme.ios && self.$f7 && !self.$f7.params.navbar.iosCenterTitle;
	    var addCenterTitleClass = self.$theme && self.$theme.md && self.$f7 && self.$f7.params.navbar.mdCenterTitle || self.$theme && self.$theme.aurora && self.$f7 && self.$f7.params.navbar.auroraCenterTitle;
	    var slots = self.slots;
	    var classes = Utils$1.classNames(className, 'navbar', {
	      'navbar-hidden': hidden,
	      'no-shadow': noShadow,
	      'no-hairline': noHairline,
	      'navbar-large': large
	    }, Mixins.colorClasses(props));

	    if (!inner) {
	      return react.createElement('div', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['el'] = __reactNode;
	        },
	        id: id,
	        style: style,
	        className: classes
	      }, this.slots['default']);
	    }

	    if (backLink || slots['nav-left']) {
	      leftEl = react.createElement(F7NavLeft, {
	        backLink: backLink,
	        backLinkUrl: backLinkUrl,
	        backLinkForce: backLinkForce,
	        backLinkShowText: backLinkShowText,
	        onBackClick: self.onBackClick
	      }, slots['nav-left']);
	    }

	    if (title || subtitle || slots.title) {
	      titleEl = react.createElement(F7NavTitle$1, {
	        title: title,
	        subtitle: subtitle
	      }, slots.title);
	    }

	    if (slots['nav-right']) {
	      rightEl = react.createElement(F7NavRight, null, slots['nav-right']);
	    }

	    var largeTitle = titleLarge;
	    if (!largeTitle && large && title) { largeTitle = title; }

	    if (largeTitle) {
	      titleLargeEl = react.createElement('div', {
	        className: 'title-large'
	      }, react.createElement('div', {
	        className: 'title-large-text'
	      }, largeTitle));
	    }

	    innerEl = react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['innerEl'] = __reactNode;
	      },
	      className: Utils$1.classNames('navbar-inner', innerClass, innerClassName, {
	        sliding: sliding,
	        'navbar-inner-left-title': addLeftTitleClass,
	        'navbar-inner-centered-title': addCenterTitleClass,
	        'navbar-inner-large': large
	      })
	    }, leftEl, titleEl, rightEl, titleLargeEl, this.slots['default']);
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['before-inner'], innerEl, this.slots['after-inner']);
	  };

	  F7Navbar.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    if (!self.props.inner) { return; }
	    var ref = self.refs;
	    var innerEl = ref.innerEl;
	    if (!innerEl) { return; }
	    var f7 = self.$f7;
	    if (!f7) { return; }
	    f7.off('navbarShow', self.onShow);
	    f7.off('navbarHide', self.onHide);
	    f7.off('navbarCollapse', self.onCollapse);
	    f7.off('navbarExpand', self.onExpand);
	  };

	  F7Navbar.prototype.componentDidUpdate = function componentDidUpdate () {
	    var self = this;
	    if (!self.$f7) { return; }
	    var el = self.refs.el;

	    if (el && el.children && el.children.length) {
	      self.$f7.navbar.size(el);
	    } else if (self.refs.innerEl) {
	      self.$f7.navbar.size(self.refs.innerEl);
	    }
	  };

	  F7Navbar.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var ref = self.refs;
	    var innerEl = ref.innerEl;
	    if (!innerEl) { return; }
	    self.$f7ready(function (f7) {
	      f7.on('navbarShow', self.onShow);
	      f7.on('navbarHide', self.onHide);
	      f7.on('navbarCollapse', self.onCollapse);
	      f7.on('navbarExpand', self.onExpand);
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Navbar.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Navbar.prototype, prototypeAccessors );

	  return F7Navbar;
	}(react.Component));

	__reactComponentSetProps(F7Navbar, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  backLink: [Boolean, String],
	  backLinkUrl: String,
	  backLinkForce: Boolean,
	  backLinkShowText: {
	    type: Boolean,
	    default: undefined
	  },
	  sliding: {
	    type: Boolean,
	    default: true
	  },
	  title: String,
	  subtitle: String,
	  hidden: Boolean,
	  noShadow: Boolean,
	  noHairline: Boolean,
	  inner: {
	    type: Boolean,
	    default: true
	  },
	  innerClass: String,
	  innerClassName: String,
	  large: Boolean,
	  titleLarge: String
	}, Mixins.colorProps));

	F7Navbar.displayName = 'f7-navbar';

	var F7PageContent = /*@__PURE__*/(function (superclass) {
	  function F7PageContent(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onPtrPullStart', 'onPtrPullMove', 'onPtrPullEnd', 'onPtrRefresh', 'onPtrDone', 'onInfinite', 'onTabShow', 'onTabHide']);
	    })();
	  }

	  if ( superclass ) F7PageContent.__proto__ = superclass;
	  F7PageContent.prototype = Object.create( superclass && superclass.prototype );
	  F7PageContent.prototype.constructor = F7PageContent;

	  var prototypeAccessors = { classes: { configurable: true },slots: { configurable: true },refs: { configurable: true } };

	  F7PageContent.prototype.onPtrPullStart = function onPtrPullStart (event) {
	    this.dispatchEvent('ptr:pullstart ptrPullStart', event);
	  };

	  F7PageContent.prototype.onPtrPullMove = function onPtrPullMove (event) {
	    this.dispatchEvent('ptr:pullmove ptrPullMove', event);
	  };

	  F7PageContent.prototype.onPtrPullEnd = function onPtrPullEnd (event) {
	    this.dispatchEvent('ptr:pullend ptrPullEnd', event);
	  };

	  F7PageContent.prototype.onPtrRefresh = function onPtrRefresh (event) {
	    var done = event.detail;
	    this.dispatchEvent('ptr:refresh ptrRefresh', event, done);
	  };

	  F7PageContent.prototype.onPtrDone = function onPtrDone (event) {
	    this.dispatchEvent('ptr:done ptrDone', event);
	  };

	  F7PageContent.prototype.onInfinite = function onInfinite (event) {
	    this.dispatchEvent('infinite', event);
	  };

	  F7PageContent.prototype.onTabShow = function onTabShow (event) {
	    this.dispatchEvent('tab:show tabShow', event);
	  };

	  F7PageContent.prototype.onTabHide = function onTabHide (event) {
	    this.dispatchEvent('tab:hide tabHide', event);
	  };

	  prototypeAccessors.classes.get = function () {
	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var tab = props.tab;
	    var tabActive = props.tabActive;
	    var ptr = props.ptr;
	    var ptrBottom = props.ptrBottom;
	    var infinite = props.infinite;
	    var infiniteTop = props.infiniteTop;
	    var hideBarsOnScroll = props.hideBarsOnScroll;
	    var hideNavbarOnScroll = props.hideNavbarOnScroll;
	    var hideToolbarOnScroll = props.hideToolbarOnScroll;
	    var messagesContent = props.messagesContent;
	    var loginScreen = props.loginScreen;
	    return Utils$1.classNames(className, 'page-content', {
	      tab: tab,
	      'tab-active': tabActive,
	      'ptr-content': ptr,
	      'ptr-bottom': ptrBottom,
	      'infinite-scroll-content': infinite,
	      'infinite-scroll-top': infiniteTop,
	      'hide-bars-on-scroll': hideBarsOnScroll,
	      'hide-navbar-on-scroll': hideNavbarOnScroll,
	      'hide-toolbar-on-scroll': hideToolbarOnScroll,
	      'messages-content': messagesContent,
	      'login-screen-content': loginScreen
	    }, Mixins.colorClasses(props));
	  };

	  F7PageContent.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var ptr = props.ptr;
	    var ptrPreloader = props.ptrPreloader;
	    var ptrDistance = props.ptrDistance;
	    var ptrBottom = props.ptrBottom;
	    var ptrMousewheel = props.ptrMousewheel;
	    var infinite = props.infinite;
	    var infinitePreloader = props.infinitePreloader;
	    var id = props.id;
	    var style = props.style;
	    var infiniteDistance = props.infiniteDistance;
	    var infiniteTop = props.infiniteTop;
	    var ptrEl;
	    var infiniteEl;

	    if (ptr && ptrPreloader) {
	      ptrEl = react.createElement('div', {
	        className: 'ptr-preloader'
	      }, react.createElement('div', {
	        className: 'preloader'
	      }), react.createElement('div', {
	        className: 'ptr-arrow'
	      }));
	    }

	    if (infinite && infinitePreloader) {
	      infiniteEl = react.createElement('div', {
	        className: 'preloader infinite-scroll-preloader'
	      });
	    }

	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: self.classes,
	      'data-ptr-distance': ptrDistance || undefined,
	      'data-ptr-mousewheel': ptrMousewheel || undefined,
	      'data-infinite-distance': infiniteDistance || undefined,
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      }
	    }, ptrBottom ? null : ptrEl, infiniteTop ? infiniteEl : null, self.slots.default, infiniteTop ? null : infiniteEl, ptrBottom ? ptrEl : null);
	  };

	  F7PageContent.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var el = self.refs.el;
	    el.removeEventListener('ptr:pullstart', self.onPtrPullStart);
	    el.removeEventListener('ptr:pullmove', self.onPtrPullMove);
	    el.removeEventListener('ptr:pullend', self.onPtrPullEnd);
	    el.removeEventListener('ptr:refresh', self.onPtrRefresh);
	    el.removeEventListener('ptr:done', self.onPtrDone);
	    el.removeEventListener('infinite', self.onInfinite);
	    el.removeEventListener('tab:show', self.onTabShow);
	    el.removeEventListener('tab:hide', self.onTabHide);
	  };

	  F7PageContent.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    var ref = self.props;
	    var ptr = ref.ptr;
	    var infinite = ref.infinite;
	    var tab = ref.tab;

	    if (ptr) {
	      el.addEventListener('ptr:pullstart', self.onPtrPullStart);
	      el.addEventListener('ptr:pullmove', self.onPtrPullMove);
	      el.addEventListener('ptr:pullend', self.onPtrPullEnd);
	      el.addEventListener('ptr:refresh', self.onPtrRefresh);
	      el.addEventListener('ptr:done', self.onPtrDone);
	    }

	    if (infinite) {
	      el.addEventListener('infinite', self.onInfinite);
	    }

	    if (tab) {
	      el.addEventListener('tab:show', self.onTabShow);
	      el.addEventListener('tab:hide', self.onTabHide);
	    }
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7PageContent.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7PageContent.prototype, prototypeAccessors );

	  return F7PageContent;
	}(react.Component));

	__reactComponentSetProps(F7PageContent, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  tab: Boolean,
	  tabActive: Boolean,
	  ptr: Boolean,
	  ptrDistance: Number,
	  ptrPreloader: {
	    type: Boolean,
	    default: true
	  },
	  ptrBottom: Boolean,
	  ptrMousewheel: Boolean,
	  infinite: Boolean,
	  infiniteTop: Boolean,
	  infiniteDistance: Number,
	  infinitePreloader: {
	    type: Boolean,
	    default: true
	  },
	  hideBarsOnScroll: Boolean,
	  hideNavbarOnScroll: Boolean,
	  hideToolbarOnScroll: Boolean,
	  messagesContent: Boolean,
	  loginScreen: Boolean
	}, Mixins.colorProps));

	F7PageContent.displayName = 'f7-page-content';

	var F7Page = /*@__PURE__*/(function (superclass) {
	  function F7Page(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    this.state = (function () {
	      return {
	        hasSubnavbar: false,
	        hasNavbarLarge: false,
	        hasNavbarLargeCollapsed: false,
	        hasCardExpandableOpened: false,
	        routerPositionClass: '',
	        routerForceUnstack: false,
	        routerPageRole: null,
	        routerPageMasterStack: false
	      };
	    })();

	    (function () {
	      Utils$1.bindMethods(this$1, ['onPtrPullStart', 'onPtrPullMove', 'onPtrPullEnd', 'onPtrRefresh', 'onPtrDone', 'onInfinite', 'onPageMounted', 'onPageInit', 'onPageReinit', 'onPageBeforeIn', 'onPageBeforeOut', 'onPageAfterOut', 'onPageAfterIn', 'onPageBeforeRemove', 'onPageStack', 'onPageUnstack', 'onPagePosition', 'onPageRole', 'onPageMasterStack', 'onPageMasterUnstack', 'onPageNavbarLargeCollapsed', 'onPageNavbarLargeExpanded', 'onCardOpened', 'onCardClose']);
	    })();
	  }

	  if ( superclass ) F7Page.__proto__ = superclass;
	  F7Page.prototype = Object.create( superclass && superclass.prototype );
	  F7Page.prototype.constructor = F7Page;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Page.prototype.onPtrPullStart = function onPtrPullStart (event) {
	    this.dispatchEvent('ptr:pullstart ptrPullStart', event);
	  };

	  F7Page.prototype.onPtrPullMove = function onPtrPullMove (event) {
	    this.dispatchEvent('ptr:pullmove ptrPullMove', event);
	  };

	  F7Page.prototype.onPtrPullEnd = function onPtrPullEnd (event) {
	    this.dispatchEvent('ptr:pullend ptrPullEnd', event);
	  };

	  F7Page.prototype.onPtrRefresh = function onPtrRefresh (event) {
	    var done = event.detail;
	    this.dispatchEvent('ptr:refresh ptrRefresh', event, done);
	  };

	  F7Page.prototype.onPtrDone = function onPtrDone (event) {
	    this.dispatchEvent('ptr:done ptrDone', event);
	  };

	  F7Page.prototype.onInfinite = function onInfinite (event) {
	    this.dispatchEvent('infinite', event);
	  };

	  F7Page.prototype.onPageMounted = function onPageMounted (event) {
	    var page = event.detail;
	    this.dispatchEvent('page:mounted pageMounted', event, page);
	  };

	  F7Page.prototype.onPageStack = function onPageStack () {
	    this.setState({
	      routerForceUnstack: false
	    });
	  };

	  F7Page.prototype.onPageUnstack = function onPageUnstack () {
	    this.setState({
	      routerForceUnstack: true
	    });
	  };

	  F7Page.prototype.onPagePosition = function onPagePosition (event) {
	    var position = event.detail.position;
	    this.setState({
	      routerPositionClass: ("page-" + position)
	    });
	  };

	  F7Page.prototype.onPageRole = function onPageRole (event) {
	    this.setState({
	      routerPageRole: event.detail.role
	    });
	  };

	  F7Page.prototype.onPageMasterStack = function onPageMasterStack () {
	    this.setState({
	      routerPageMasterStack: true
	    });
	  };

	  F7Page.prototype.onPageMasterUnstack = function onPageMasterUnstack () {
	    this.setState({
	      routerPageMasterStack: false
	    });
	  };

	  F7Page.prototype.onPageNavbarLargeCollapsed = function onPageNavbarLargeCollapsed () {
	    this.setState({
	      hasNavbarLargeCollapsed: true
	    });
	  };

	  F7Page.prototype.onPageNavbarLargeExpanded = function onPageNavbarLargeExpanded () {
	    this.setState({
	      hasNavbarLargeCollapsed: false
	    });
	  };

	  F7Page.prototype.onPageInit = function onPageInit (event) {
	    var page = event.detail;
	    var ref = this.props;
	    var withSubnavbar = ref.withSubnavbar;
	    var subnavbar = ref.subnavbar;
	    var withNavbarLarge = ref.withNavbarLarge;
	    var navbarLarge = ref.navbarLarge;

	    if (typeof withSubnavbar === 'undefined' && typeof subnavbar === 'undefined') {
	      if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find('.subnavbar').length || page.$el.children('.navbar').find('.subnavbar').length) {
	        this.setState({
	          hasSubnavbar: true
	        });
	      }
	    }

	    if (typeof withNavbarLarge === 'undefined' && typeof navbarLarge === 'undefined') {
	      if (page.$navbarEl && page.$navbarEl.hasClass('navbar-inner-large')) {
	        this.setState({
	          hasNavbarLarge: true
	        });
	      }
	    }

	    this.dispatchEvent('page:init pageInit', event, page);
	  };

	  F7Page.prototype.onPageReinit = function onPageReinit (event) {
	    var page = event.detail;
	    this.dispatchEvent('page:reinit pageReinit', event, page);
	  };

	  F7Page.prototype.onPageBeforeIn = function onPageBeforeIn (event) {
	    var page = event.detail;

	    if (page.from === 'next') {
	      this.setState({
	        routerPositionClass: 'page-next'
	      });
	    }

	    if (page.from === 'previous') {
	      this.setState({
	        routerPositionClass: 'page-previous'
	      });
	    }

	    this.dispatchEvent('page:beforein pageBeforeIn', event, page);
	  };

	  F7Page.prototype.onPageBeforeOut = function onPageBeforeOut (event) {
	    var page = event.detail;
	    this.dispatchEvent('page:beforeout pageBeforeOut', event, page);
	  };

	  F7Page.prototype.onPageAfterOut = function onPageAfterOut (event) {
	    var page = event.detail;

	    if (page.to === 'next') {
	      this.setState({
	        routerPositionClass: 'page-next'
	      });
	    }

	    if (page.to === 'previous') {
	      this.setState({
	        routerPositionClass: 'page-previous'
	      });
	    }

	    this.dispatchEvent('page:afterout pageAfterOut', event, page);
	  };

	  F7Page.prototype.onPageAfterIn = function onPageAfterIn (event) {
	    var page = event.detail;
	    this.setState({
	      routerPositionClass: 'page-current'
	    });
	    this.dispatchEvent('page:afterin pageAfterIn', event, page);
	  };

	  F7Page.prototype.onPageBeforeRemove = function onPageBeforeRemove (event) {
	    var page = event.detail;
	    this.dispatchEvent('page:beforeremove pageBeforeRemove', event, page);
	  };

	  F7Page.prototype.onCardOpened = function onCardOpened () {
	    this.setState({
	      hasCardExpandableOpened: true
	    });
	  };

	  F7Page.prototype.onCardClose = function onCardClose () {
	    this.setState({
	      hasCardExpandableOpened: false
	    });
	  };

	  F7Page.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var style = props.style;
	    var name = props.name;
	    var pageContent = props.pageContent;
	    var messagesContent = props.messagesContent;
	    var ptr = props.ptr;
	    var ptrDistance = props.ptrDistance;
	    var ptrPreloader = props.ptrPreloader;
	    var ptrBottom = props.ptrBottom;
	    var ptrMousewheel = props.ptrMousewheel;
	    var infinite = props.infinite;
	    var infiniteDistance = props.infiniteDistance;
	    var infinitePreloader = props.infinitePreloader;
	    var infiniteTop = props.infiniteTop;
	    var hideBarsOnScroll = props.hideBarsOnScroll;
	    var hideNavbarOnScroll = props.hideNavbarOnScroll;
	    var hideToolbarOnScroll = props.hideToolbarOnScroll;
	    var loginScreen = props.loginScreen;
	    var className = props.className;
	    var stacked = props.stacked;
	    var tabs = props.tabs;
	    var subnavbar = props.subnavbar;
	    var withSubnavbar = props.withSubnavbar;
	    var navbarLarge = props.navbarLarge;
	    var withNavbarLarge = props.withNavbarLarge;
	    var noNavbar = props.noNavbar;
	    var noToolbar = props.noToolbar;
	    var noSwipeback = props.noSwipeback;
	    var fixedList = [];
	    var staticList = [];
	    var needsPageContent = pageContent;
	    var ref = self.slots;
	    var slotsStatic = ref.static;
	    var slotsFixed = ref.fixed;
	    var slotsDefault = ref.default;
	    var fixedTags;
	    fixedTags = 'navbar toolbar tabbar subnavbar searchbar messagebar fab list-index'.split(' ').map(function (tagName) { return ("f7-" + tagName); });
	    var hasSubnavbar;
	    var hasMessages;
	    var hasNavbarLarge;
	    hasMessages = messagesContent;

	    if (slotsDefault) {
	      slotsDefault.forEach(function (child) {
	        if (typeof child === 'undefined') { return; }
	        var isFixedTag = false;
	        {
	          var tag = child.type && (child.type.displayName || child.type.name);

	          if (!tag) {
	            if (needsPageContent) { staticList.push(child); }
	            return;
	          }

	          if (tag === 'F7Subnavbar' || tag === 'f7-subnavbar') { hasSubnavbar = true; }

	          if (tag === 'F7Navbar' || tag === 'f7-navbar') {
	            if (child.props && child.props.large) { hasNavbarLarge = true; }
	          }

	          if (typeof hasMessages === 'undefined' && (tag === 'F7Messages' || tag === 'f7-messages')) { hasMessages = true; }

	          if (fixedTags.indexOf(tag) >= 0) {
	            isFixedTag = true;
	          }
	        }

	        if (needsPageContent) {
	          if (isFixedTag) { fixedList.push(child); }else { staticList.push(child); }
	        }
	      });
	    }

	    var forceSubnavbar = typeof subnavbar === 'undefined' && typeof withSubnavbar === 'undefined' ? hasSubnavbar || this.state.hasSubnavbar : false;
	    var forceNavbarLarge = typeof navbarLarge === 'undefined' && typeof withNavbarLarge === 'undefined' ? hasNavbarLarge || this.state.hasNavbarLarge : false;
	    var classes = Utils$1.classNames(className, 'page', this.state.routerPositionClass, {
	      stacked: stacked && !this.state.routerForceUnstack,
	      tabs: tabs,
	      'page-with-subnavbar': subnavbar || withSubnavbar || forceSubnavbar,
	      'page-with-navbar-large': navbarLarge || withNavbarLarge || forceNavbarLarge,
	      'no-navbar': noNavbar,
	      'no-toolbar': noToolbar,
	      'no-swipeback': noSwipeback,
	      'page-master': this.state.routerPageRole === 'master',
	      'page-master-detail': this.state.routerPageRole === 'detail',
	      'page-master-stacked': this.state.routerPageMasterStack === true,
	      'page-with-navbar-large-collapsed': this.state.hasNavbarLargeCollapsed === true,
	      'page-with-card-opened': this.state.hasCardExpandableOpened === true
	    }, Mixins.colorClasses(props));

	    if (!needsPageContent) {
	      return react.createElement('div', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['el'] = __reactNode;
	        },
	        id: id,
	        style: style,
	        className: classes,
	        'data-name': name
	      }, slotsFixed, slotsStatic, slotsDefault);
	    }

	    var pageContentEl = react.createElement(F7PageContent, {
	      ptr: ptr,
	      ptrDistance: ptrDistance,
	      ptrPreloader: ptrPreloader,
	      ptrBottom: ptrBottom,
	      ptrMousewheel: ptrMousewheel,
	      infinite: infinite,
	      infiniteTop: infiniteTop,
	      infiniteDistance: infiniteDistance,
	      infinitePreloader: infinitePreloader,
	      hideBarsOnScroll: hideBarsOnScroll,
	      hideNavbarOnScroll: hideNavbarOnScroll,
	      hideToolbarOnScroll: hideToolbarOnScroll,
	      messagesContent: messagesContent || hasMessages,
	      loginScreen: loginScreen
	    }, slotsStatic, staticList);
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes,
	      'data-name': name
	    }, fixedList, slotsFixed, pageContentEl);
	  };

	  F7Page.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var el = self.refs.el;
	    el.removeEventListener('ptr:pullstart', self.onPtrPullStart);
	    el.removeEventListener('ptr:pullmove', self.onPtrPullMove);
	    el.removeEventListener('ptr:pullend', self.onPtrPullEnd);
	    el.removeEventListener('ptr:refresh', self.onPtrRefresh);
	    el.removeEventListener('ptr:done', self.onPtrDone);
	    el.removeEventListener('infinite', self.onInfinite);
	    el.removeEventListener('page:mounted', self.onPageMounted);
	    el.removeEventListener('page:init', self.onPageInit);
	    el.removeEventListener('page:reinit', self.onPageReinit);
	    el.removeEventListener('page:beforein', self.onPageBeforeIn);
	    el.removeEventListener('page:beforeout', self.onPageBeforeOut);
	    el.removeEventListener('page:afterout', self.onPageAfterOut);
	    el.removeEventListener('page:afterin', self.onPageAfterIn);
	    el.removeEventListener('page:beforeremove', self.onPageBeforeRemove);
	    el.removeEventListener('page:stack', self.onPageStack);
	    el.removeEventListener('page:unstack', self.onPageUnstack);
	    el.removeEventListener('page:position', self.onPagePosition);
	    el.removeEventListener('page:role', self.onPageRole);
	    el.removeEventListener('page:masterstack', self.onPageMasterStack);
	    el.removeEventListener('page:masterunstack', self.onPageMasterUnstack);
	    el.removeEventListener('page:navbarlargecollapsed', self.onPageNavbarLargeCollapsed);
	    el.removeEventListener('page:navbarlargeexpanded', self.onPageNavbarLargeExpanded);
	    el.removeEventListener('card:opened', self.onCardOpened);
	    el.removeEventListener('card:close', self.onCardClose);
	  };

	  F7Page.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    var ref = self.props;
	    var ptr = ref.ptr;
	    var infinite = ref.infinite;

	    if (ptr) {
	      el.addEventListener('ptr:pullstart', self.onPtrPullStart);
	      el.addEventListener('ptr:pullmove', self.onPtrPullMove);
	      el.addEventListener('ptr:pullend', self.onPtrPullEnd);
	      el.addEventListener('ptr:refresh', self.onPtrRefresh);
	      el.addEventListener('ptr:done', self.onPtrDone);
	    }

	    if (infinite) {
	      el.addEventListener('infinite', self.onInfinite);
	    }

	    el.addEventListener('page:mounted', self.onPageMounted);
	    el.addEventListener('page:init', self.onPageInit);
	    el.addEventListener('page:reinit', self.onPageReinit);
	    el.addEventListener('page:beforein', self.onPageBeforeIn);
	    el.addEventListener('page:beforeout', self.onPageBeforeOut);
	    el.addEventListener('page:afterout', self.onPageAfterOut);
	    el.addEventListener('page:afterin', self.onPageAfterIn);
	    el.addEventListener('page:beforeremove', self.onPageBeforeRemove);
	    el.addEventListener('page:stack', self.onPageStack);
	    el.addEventListener('page:unstack', self.onPageUnstack);
	    el.addEventListener('page:position', self.onPagePosition);
	    el.addEventListener('page:role', self.onPageRole);
	    el.addEventListener('page:masterstack', self.onPageMasterStack);
	    el.addEventListener('page:masterunstack', self.onPageMasterUnstack);
	    el.addEventListener('page:navbarlargecollapsed', self.onPageNavbarLargeCollapsed);
	    el.addEventListener('page:navbarlargeexpanded', self.onPageNavbarLargeExpanded);
	    el.addEventListener('card:opened', self.onCardOpened);
	    el.addEventListener('card:close', self.onCardClose);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Page.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Page.prototype, prototypeAccessors );

	  return F7Page;
	}(react.Component));

	__reactComponentSetProps(F7Page, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  name: String,
	  stacked: Boolean,
	  withSubnavbar: {
	    type: Boolean,
	    default: undefined
	  },
	  subnavbar: {
	    type: Boolean,
	    default: undefined
	  },
	  withNavbarLarge: {
	    type: Boolean,
	    default: undefined
	  },
	  navbarLarge: {
	    type: Boolean,
	    default: undefined
	  },
	  noNavbar: Boolean,
	  noToolbar: Boolean,
	  tabs: Boolean,
	  pageContent: {
	    type: Boolean,
	    default: true
	  },
	  noSwipeback: Boolean,
	  ptr: Boolean,
	  ptrDistance: Number,
	  ptrPreloader: {
	    type: Boolean,
	    default: true
	  },
	  ptrBottom: Boolean,
	  ptrMousewheel: Boolean,
	  infinite: Boolean,
	  infiniteTop: Boolean,
	  infiniteDistance: Number,
	  infinitePreloader: {
	    type: Boolean,
	    default: true
	  },
	  hideBarsOnScroll: Boolean,
	  hideNavbarOnScroll: Boolean,
	  hideToolbarOnScroll: Boolean,
	  messagesContent: Boolean,
	  loginScreen: Boolean
	}, Mixins.colorProps));

	F7Page.displayName = 'f7-page';

	var F7Panel = /*@__PURE__*/(function (superclass) {
	  function F7Panel(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onOpen', 'onOpened', 'onClose', 'onClosed', 'onBackdropClick', 'onPanelSwipe', 'onPanelSwipeOpen', 'onBreakpoint', 'onResize']);
	    })();
	  }

	  if ( superclass ) F7Panel.__proto__ = superclass;
	  F7Panel.prototype = Object.create( superclass && superclass.prototype );
	  F7Panel.prototype.constructor = F7Panel;

	  var prototypeAccessors = { classes: { configurable: true },slots: { configurable: true },refs: { configurable: true } };

	  F7Panel.prototype.onOpen = function onOpen (event) {
	    this.dispatchEvent('panel:open panelOpen', event);
	  };

	  F7Panel.prototype.onOpened = function onOpened (event) {
	    this.dispatchEvent('panel:opened panelOpened', event);
	  };

	  F7Panel.prototype.onClose = function onClose (event) {
	    this.dispatchEvent('panel:close panelClose', event);
	  };

	  F7Panel.prototype.onClosed = function onClosed (event) {
	    this.dispatchEvent('panel:closed panelClosed', event);
	  };

	  F7Panel.prototype.onBackdropClick = function onBackdropClick (event) {
	    this.dispatchEvent('panel:backdrop-click panelBackdropClick', event);
	  };

	  F7Panel.prototype.onPanelSwipe = function onPanelSwipe (event) {
	    this.dispatchEvent('panel:swipe panelSwipe', event);
	  };

	  F7Panel.prototype.onPanelSwipeOpen = function onPanelSwipeOpen (event) {
	    this.dispatchEvent('panel:swipeopen panelSwipeOpen', event);
	  };

	  F7Panel.prototype.onBreakpoint = function onBreakpoint (event) {
	    this.dispatchEvent('panel:breakpoint panelBreakpoint', event);
	  };

	  F7Panel.prototype.onResize = function onResize (event) {
	    this.dispatchEvent('panel:resize panelResize', event);
	  };

	  F7Panel.prototype.open = function open (animate) {
	    var self = this;
	    if (!self.$f7) { return; }
	    var side = self.props.side || (self.props.left ? 'left' : 'right');
	    self.$f7.panel.open(side, animate);
	  };

	  F7Panel.prototype.close = function close (animate) {
	    var self = this;
	    if (!self.$f7) { return; }
	    var side = self.props.side || (self.props.left ? 'left' : 'right');
	    self.$f7.panel.close(side, animate);
	  };

	  F7Panel.prototype.toggle = function toggle (animate) {
	    var self = this;
	    if (!self.$f7) { return; }
	    var side = self.props.side || (self.props.left ? 'left' : 'right');
	    self.$f7.panel.toggle(side, animate);
	  };

	  prototypeAccessors.classes.get = function () {
	    var obj;

	    var self = this;
	    var props = self.props;
	    var left = props.left;
	    var reveal = props.reveal;
	    var className = props.className;
	    var opened = props.opened;
	    var resizable = props.resizable;
	    var side = props.side;
	    var effect = props.effect;
	    side = side || (left ? 'left' : 'right');
	    effect = effect || (reveal ? 'reveal' : 'cover');
	    return Utils$1.classNames(className, 'panel', ( obj = {
	      'panel-active': opened,
	      'panel-resizable': resizable
	    }, obj[("panel-" + side)] = side, obj[("panel-" + effect)] = effect, obj ), Mixins.colorClasses(props));
	  };

	  F7Panel.prototype.render = function render () {
	    var this$1 = this;

	    var props = this.props;
	    var id = props.id;
	    var style = props.style;
	    var resizable = props.resizable;
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: this.classes
	    }, this.slots['default'], resizable && react.createElement('div', {
	      className: 'panel-resize-handler'
	    }));
	  };

	  F7Panel.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    if (self.f7Panel) { self.f7Panel.destroy(); }
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.removeEventListener('panel:open', self.onOpen);
	    el.removeEventListener('panel:opened', self.onOpened);
	    el.removeEventListener('panel:close', self.onClose);
	    el.removeEventListener('panel:closed', self.onClosed);
	    el.removeEventListener('panel:backdrop-click', self.onBackdropClick);
	    el.removeEventListener('panel:swipe', self.onPanelSwipe);
	    el.removeEventListener('panel:swipeopen', self.onPanelSwipeOpen);
	    el.removeEventListener('panel:breakpoint', self.onBreakpoint);
	    el.removeEventListener('panel:resize', self.onResize);
	  };

	  F7Panel.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    var ref = self.props;
	    var side = ref.side;
	    var effect = ref.effect;
	    var opened = ref.opened;
	    var left = ref.left;
	    var reveal = ref.reveal;
	    var resizable = ref.resizable;

	    if (el) {
	      el.addEventListener('panel:open', self.onOpen);
	      el.addEventListener('panel:opened', self.onOpened);
	      el.addEventListener('panel:close', self.onClose);
	      el.addEventListener('panel:closed', self.onClosed);
	      el.addEventListener('panel:backdrop-click', self.onBackdropClick);
	      el.addEventListener('panel:swipe', self.onPanelSwipe);
	      el.addEventListener('panel:swipeopen', self.onPanelSwipeOpen);
	      el.addEventListener('panel:breakpoint', self.onBreakpoint);
	      el.addEventListener('panel:resize', self.onResize);
	    }

	    self.$f7ready(function () {
	      var $ = self.$$;
	      if (!$) { return; }

	      if ($('.panel-backdrop').length === 0) {
	        $('<div class="panel-backdrop"></div>').insertBefore(el);
	      }

	      self.f7Panel = self.$f7.panel.create({
	        el: el,
	        resizable: resizable
	      });
	    });

	    if (opened) {
	      el.style.display = 'block';
	    }

	    var $ = self.$$;
	    if (!$) { return; }
	    var panelSide = side || (left ? 'left' : 'right');
	    var panelEffect = effect || (reveal ? 'reveal' : 'cover');

	    if (opened) {
	      $('html').addClass(("with-panel-" + panelSide + "-" + panelEffect));
	    }
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Panel.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  F7Panel.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.resizable', prevProps, prevState, function (resizable) {
	      var self = this$1;
	      if (!resizable) { return; }

	      if (self.f7Panel && !self.f7Panel.resizableInitialized) {
	        self.f7Panel.initResizablePanel();
	      }
	    });

	    __reactComponentWatch(this, 'props.opened', prevProps, prevState, function (opened) {
	      var self = this$1;
	      if (!self.$f7) { return; }
	      var side = self.props.side || (self.props.left ? 'left' : 'right');

	      if (opened) {
	        self.$f7.panel.open(side);
	      } else {
	        self.$f7.panel.open(side);
	      }
	    });
	  };

	  Object.defineProperties( F7Panel.prototype, prototypeAccessors );

	  return F7Panel;
	}(react.Component));

	__reactComponentSetProps(F7Panel, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  side: String,
	  effect: String,
	  cover: Boolean,
	  reveal: Boolean,
	  left: Boolean,
	  right: Boolean,
	  opened: Boolean,
	  resizable: Boolean
	}, Mixins.colorProps));

	F7Panel.displayName = 'f7-panel';

	var F7PhotoBrowser = /*@__PURE__*/(function (superclass) {
	  function F7PhotoBrowser(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7PhotoBrowser.__proto__ = superclass;
	  F7PhotoBrowser.prototype = Object.create( superclass && superclass.prototype );
	  F7PhotoBrowser.prototype.constructor = F7PhotoBrowser;

	  F7PhotoBrowser.prototype.open = function open (index) {
	    return this.f7PhotoBrowser.open(index);
	  };

	  F7PhotoBrowser.prototype.close = function close () {
	    return this.f7PhotoBrowser.close();
	  };

	  F7PhotoBrowser.prototype.expositionToggle = function expositionToggle () {
	    return this.f7PhotoBrowser.expositionToggle();
	  };

	  F7PhotoBrowser.prototype.expositionEnable = function expositionEnable () {
	    return this.f7PhotoBrowser.expositionEnable();
	  };

	  F7PhotoBrowser.prototype.expositionDisable = function expositionDisable () {
	    return this.f7PhotoBrowser.expositionDisable();
	  };

	  F7PhotoBrowser.prototype.render = function render () {
	    return null;
	  };

	  F7PhotoBrowser.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    if (!self.props.init) { return; }
	    self.$f7ready(function (f7) {
	      var params;
	      if (typeof self.props.params !== 'undefined') { params = self.props.params; }else { params = Object.assign({}, self.props); }
	      Object.keys(params).forEach(function (param) {
	        if (typeof params[param] === 'undefined' || params[param] === '') { delete params[param]; }
	      });
	      params = Utils$1.extend({}, params, {
	        on: {
	          open: function open() {
	            self.dispatchEvent('photobrowser:open photoBrowserOpen');
	          },

	          close: function close() {
	            self.dispatchEvent('photobrowser:close photoBrowserClose');
	          },

	          opened: function opened() {
	            self.dispatchEvent('photobrowser:opened photoBrowserOpened');
	          },

	          closed: function closed() {
	            self.dispatchEvent('photobrowser:closed photoBrowserClosed');
	          },

	          swipeToClose: function swipeToClose() {
	            self.dispatchEvent('photobrowser:swipetoclose photoBrowserSwipeToClose');
	          }

	        }
	      });
	      self.f7PhotoBrowser = f7.photoBrowser.create(params);
	    });
	  };

	  F7PhotoBrowser.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    if (self.f7PhotoBrowser && self.f7PhotoBrowser.destroy) { self.f7PhotoBrowser.destroy(); }
	  };

	  F7PhotoBrowser.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  F7PhotoBrowser.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.photos', prevProps, prevState, function (newValue) {
	      var self = this$1;
	      var pb = self.f7PhotoBrowser;
	      if (!pb) { return; }
	      self.f7PhotoBrowser.photos = newValue;

	      if (pb.opened && pb.swiper) {
	        pb.swiper.update();
	      }
	    });
	  };

	  return F7PhotoBrowser;
	}(react.Component));

	__reactComponentSetProps(F7PhotoBrowser, {
	  id: [String, Number],
	  className: String,
	  style: Object,
	  init: {
	    type: Boolean,
	    default: true
	  },
	  params: Object,
	  photos: Array,
	  exposition: {
	    type: Boolean,
	    default: true
	  },
	  expositionHideCaptions: {
	    type: Boolean,
	    default: false
	  },
	  type: {
	    type: String
	  },
	  navbar: {
	    type: Boolean,
	    default: true
	  },
	  toolbar: {
	    type: Boolean,
	    default: true
	  },
	  theme: {
	    type: String
	  },
	  captionsTheme: {
	    type: String
	  },
	  iconsColor: {
	    type: String
	  },
	  swipeToClose: {
	    type: Boolean,
	    default: true
	  },
	  backLinkText: {
	    type: String
	  },
	  navbarOfText: {
	    type: String
	  },
	  swiper: {
	    type: Object
	  },
	  url: {
	    type: String
	  },
	  routableModals: {
	    type: Boolean,
	    default: true
	  },
	  virtualSlides: {
	    type: Boolean,
	    default: true
	  },
	  view: [String, Object],
	  renderNavbar: Function,
	  renderToolbar: Function,
	  renderCaption: Function,
	  renderObject: Function,
	  renderLazyPhoto: Function,
	  renderPhoto: Function,
	  renderPage: Function,
	  renderPopup: Function,
	  renderStandalone: Function
	});

	F7PhotoBrowser.displayName = 'f7-photo-browser';

	var F7Popover = /*@__PURE__*/(function (superclass) {
	  function F7Popover(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onOpen', 'onOpened', 'onClose', 'onClosed']);
	    })();
	  }

	  if ( superclass ) F7Popover.__proto__ = superclass;
	  F7Popover.prototype = Object.create( superclass && superclass.prototype );
	  F7Popover.prototype.constructor = F7Popover;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Popover.prototype.onOpen = function onOpen (event) {
	    this.dispatchEvent('popover:open popoverOpen', event);
	  };

	  F7Popover.prototype.onOpened = function onOpened (event) {
	    this.dispatchEvent('popover:opened popoverOpened', event);
	  };

	  F7Popover.prototype.onClose = function onClose (event) {
	    this.dispatchEvent('popover:close popoverClose', event);
	  };

	  F7Popover.prototype.onClosed = function onClosed (event) {
	    this.dispatchEvent('popover:closed popoverClosed', event);
	  };

	  F7Popover.prototype.open = function open (target, animate) {
	    var self = this;
	    if (!self.$f7) { return undefined; }
	    return self.$f7.popover.open(self.refs.el, target, animate);
	  };

	  F7Popover.prototype.close = function close (animate) {
	    var self = this;
	    if (!self.$f7) { return undefined; }
	    return self.$f7.sheet.close(self.refs.el, animate);
	  };

	  F7Popover.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'popover', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes
	    }, react.createElement('div', {
	      className: 'popover-angle'
	    }), react.createElement('div', {
	      className: 'popover-inner'
	    }, this.slots['default']));
	  };

	  F7Popover.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    if (self.f7Popover) { self.f7Popover.destroy(); }
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.removeEventListener('popover:open', self.onOpen);
	    el.removeEventListener('popover:opened', self.onOpened);
	    el.removeEventListener('popover:close', self.onClose);
	    el.removeEventListener('popover:closed', self.onClosed);
	  };

	  F7Popover.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.addEventListener('popover:open', self.onOpen);
	    el.addEventListener('popover:opened', self.onOpened);
	    el.addEventListener('popover:close', self.onClose);
	    el.addEventListener('popover:closed', self.onClosed);
	    var props = self.props;
	    var target = props.target;
	    var opened = props.opened;
	    var backdrop = props.backdrop;
	    var backdropEl = props.backdropEl;
	    var closeByBackdropClick = props.closeByBackdropClick;
	    var closeByOutsideClick = props.closeByOutsideClick;
	    var closeOnEscape = props.closeOnEscape;
	    var popoverParams = {
	      el: el
	    };
	    if (target) { popoverParams.targetEl = target; }
	    {
	      if ('closeByBackdropClick' in props) { popoverParams.closeByBackdropClick = closeByBackdropClick; }
	      if ('closeByOutsideClick' in props) { popoverParams.closeByOutsideClick = closeByOutsideClick; }
	      if ('closeOnEscape' in props) { popoverParams.closeOnEscape = closeOnEscape; }
	      if ('backdrop' in props) { popoverParams.backdrop = backdrop; }
	      if ('backdropEl' in props) { popoverParams.backdropEl = backdropEl; }
	    }
	    self.$f7ready(function () {
	      self.f7Popover = self.$f7.popover.create(popoverParams);

	      if (opened && target) {
	        self.f7Popover.open(target, false);
	      }
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Popover.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  F7Popover.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.opened', prevProps, prevState, function (opened) {
	      var self = this$1;
	      if (!self.f7Popover) { return; }

	      if (opened) {
	        self.f7Popover.open();
	      } else {
	        self.f7Popover.close();
	      }
	    });
	  };

	  Object.defineProperties( F7Popover.prototype, prototypeAccessors );

	  return F7Popover;
	}(react.Component));

	__reactComponentSetProps(F7Popover, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  opened: Boolean,
	  target: [String, Object],
	  backdrop: Boolean,
	  backdropEl: [String, Object, window.HTMLElement],
	  closeByBackdropClick: Boolean,
	  closeByOutsideClick: Boolean,
	  closeOnEscape: Boolean
	}, Mixins.colorProps));

	F7Popover.displayName = 'f7-popover';

	var F7Popup = /*@__PURE__*/(function (superclass) {
	  function F7Popup(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onOpen', 'onOpened', 'onClose', 'onClosed']);
	    })();
	  }

	  if ( superclass ) F7Popup.__proto__ = superclass;
	  F7Popup.prototype = Object.create( superclass && superclass.prototype );
	  F7Popup.prototype.constructor = F7Popup;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Popup.prototype.onOpen = function onOpen (event) {
	    this.dispatchEvent('popup:open popupOpen', event);
	  };

	  F7Popup.prototype.onOpened = function onOpened (event) {
	    this.dispatchEvent('popup:opened popupOpened', event);
	  };

	  F7Popup.prototype.onClose = function onClose (event) {
	    this.dispatchEvent('popup:close popupClose', event);
	  };

	  F7Popup.prototype.onClosed = function onClosed (event) {
	    this.dispatchEvent('popup:closed popupClosed', event);
	  };

	  F7Popup.prototype.open = function open (animate) {
	    var self = this;
	    if (!self.$f7) { return undefined; }
	    return self.$f7.popup.open(self.refs.el, animate);
	  };

	  F7Popup.prototype.close = function close (animate) {
	    var self = this;
	    if (!self.$f7) { return undefined; }
	    return self.$f7.popup.close(self.refs.el, animate);
	  };

	  F7Popup.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var tabletFullscreen = props.tabletFullscreen;
	    var classes = Utils$1.classNames(className, 'popup', {
	      'popup-tablet-fullscreen': tabletFullscreen
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  F7Popup.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    if (self.f7Popup) { self.f7Popup.destroy(); }
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.removeEventListener('popup:open', self.onOpen);
	    el.removeEventListener('popup:opened', self.onOpened);
	    el.removeEventListener('popup:close', self.onClose);
	    el.removeEventListener('popup:closed', self.onClosed);
	  };

	  F7Popup.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.addEventListener('popup:open', self.onOpen);
	    el.addEventListener('popup:opened', self.onOpened);
	    el.addEventListener('popup:close', self.onClose);
	    el.addEventListener('popup:closed', self.onClosed);
	    var props = self.props;
	    var closeByBackdropClick = props.closeByBackdropClick;
	    var backdrop = props.backdrop;
	    var backdropEl = props.backdropEl;
	    var animate = props.animate;
	    var closeOnEscape = props.closeOnEscape;
	    var swipeToClose = props.swipeToClose;
	    var swipeHandler = props.swipeHandler;
	    var popupParams = {
	      el: el
	    };
	    {
	      if ('closeByBackdropClick' in props) { popupParams.closeByBackdropClick = closeByBackdropClick; }
	      if ('closeOnEscape' in props) { popupParams.closeOnEscape = closeOnEscape; }
	      if ('animate' in props) { popupParams.animate = animate; }
	      if ('backdrop' in props) { popupParams.backdrop = backdrop; }
	      if ('backdropEl' in props) { popupParams.backdropEl = backdropEl; }
	      if ('swipeToClose' in props) { popupParams.swipeToClose = swipeToClose; }
	      if ('swipeHandler' in props) { popupParams.swipeHandler = swipeHandler; }
	    }
	    self.$f7ready(function () {
	      self.f7Popup = self.$f7.popup.create(popupParams);

	      if (self.props.opened) {
	        self.f7Popup.open(false);
	      }
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Popup.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  F7Popup.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.opened', prevProps, prevState, function (opened) {
	      var self = this$1;
	      if (!self.f7Popup) { return; }

	      if (opened) {
	        self.f7Popup.open();
	      } else {
	        self.f7Popup.close();
	      }
	    });
	  };

	  Object.defineProperties( F7Popup.prototype, prototypeAccessors );

	  return F7Popup;
	}(react.Component));

	__reactComponentSetProps(F7Popup, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  tabletFullscreen: Boolean,
	  opened: Boolean,
	  animate: Boolean,
	  backdrop: Boolean,
	  backdropEl: [String, Object, window.HTMLElement],
	  closeByBackdropClick: Boolean,
	  closeOnEscape: Boolean,
	  swipeToClose: {
	    type: [Boolean, String],
	    default: false
	  },
	  swipeHandler: [String, Object, window.HTMLElement]
	}, Mixins.colorProps));

	F7Popup.displayName = 'f7-popup';

	var F7Preloader = /*@__PURE__*/(function (superclass) {
	  function F7Preloader(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7Preloader.__proto__ = superclass;
	  F7Preloader.prototype = Object.create( superclass && superclass.prototype );
	  F7Preloader.prototype.constructor = F7Preloader;

	  var prototypeAccessors = { sizeComputed: { configurable: true } };

	  prototypeAccessors.sizeComputed.get = function () {
	    var s = this.props.size;

	    if (s && typeof s === 'string' && s.indexOf('px') >= 0) {
	      s = s.replace('px', '');
	    }

	    return s;
	  };

	  F7Preloader.prototype.render = function render () {
	    var self = this;
	    var sizeComputed = self.sizeComputed;
	    var props = self.props;
	    var id = props.id;
	    var style = props.style;
	    var className = props.className;
	    var preloaderStyle = {};

	    if (sizeComputed) {
	      preloaderStyle.width = sizeComputed + "px";
	      preloaderStyle.height = sizeComputed + "px";
	      preloaderStyle['--f7-preloader-size'] = sizeComputed + "px";
	    }

	    if (style) { Utils$1.extend(preloaderStyle, style || {}); }
	    var innerEl;

	    if (self.$theme.md) {
	      innerEl = react.createElement('span', {
	        className: 'preloader-inner'
	      }, react.createElement('span', {
	        className: 'preloader-inner-gap'
	      }), react.createElement('span', {
	        className: 'preloader-inner-left'
	      }, react.createElement('span', {
	        className: 'preloader-inner-half-circle'
	      })), react.createElement('span', {
	        className: 'preloader-inner-right'
	      }, react.createElement('span', {
	        className: 'preloader-inner-half-circle'
	      })));
	    } else if (self.$theme.ios) {
	      innerEl = react.createElement('span', {
	        className: 'preloader-inner'
	      }, react.createElement('span', {
	        className: 'preloader-inner-line'
	      }), react.createElement('span', {
	        className: 'preloader-inner-line'
	      }), react.createElement('span', {
	        className: 'preloader-inner-line'
	      }), react.createElement('span', {
	        className: 'preloader-inner-line'
	      }), react.createElement('span', {
	        className: 'preloader-inner-line'
	      }), react.createElement('span', {
	        className: 'preloader-inner-line'
	      }), react.createElement('span', {
	        className: 'preloader-inner-line'
	      }), react.createElement('span', {
	        className: 'preloader-inner-line'
	      }), react.createElement('span', {
	        className: 'preloader-inner-line'
	      }), react.createElement('span', {
	        className: 'preloader-inner-line'
	      }), react.createElement('span', {
	        className: 'preloader-inner-line'
	      }), react.createElement('span', {
	        className: 'preloader-inner-line'
	      }));
	    } else if (self.$theme.aurora) {
	      innerEl = react.createElement('span', {
	        className: 'preloader-inner'
	      }, react.createElement('span', {
	        className: 'preloader-inner-circle'
	      }));
	    }

	    var classes = Utils$1.classNames(className, 'preloader', Mixins.colorClasses(props));
	    return react.createElement('span', {
	      id: id,
	      style: preloaderStyle,
	      className: classes
	    }, innerEl);
	  };

	  Object.defineProperties( F7Preloader.prototype, prototypeAccessors );

	  return F7Preloader;
	}(react.Component));

	__reactComponentSetProps(F7Preloader, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  size: [Number, String]
	}, Mixins.colorProps));

	F7Preloader.displayName = 'f7-preloader';

	var F7Progressbar = /*@__PURE__*/(function (superclass) {
	  function F7Progressbar(props, context) {
	    superclass.call(this, props, context);
	    this.__reactRefs = {};
	  }

	  if ( superclass ) F7Progressbar.__proto__ = superclass;
	  F7Progressbar.prototype = Object.create( superclass && superclass.prototype );
	  F7Progressbar.prototype.constructor = F7Progressbar;

	  var prototypeAccessors = { refs: { configurable: true } };

	  F7Progressbar.prototype.set = function set (progress, speed) {
	    var self = this;
	    if (!self.$f7) { return; }
	    self.$f7.progressbar.set(self.refs.el, progress, speed);
	  };

	  F7Progressbar.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var progress = props.progress;
	    var id = props.id;
	    var style = props.style;
	    var infinite = props.infinite;
	    var className = props.className;
	    var transformStyle = {
	      transform: progress ? ("translate3d(" + (-100 + progress) + "%, 0, 0)") : '',
	      WebkitTransform: progress ? ("translate3d(" + (-100 + progress) + "%, 0, 0)") : ''
	    };
	    var classes = Utils$1.classNames(className, 'progressbar', {
	      'progressbar-infinite': infinite
	    }, Mixins.colorClasses(props));
	    return react.createElement('span', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes,
	      'data-progress': progress
	    }, react.createElement('span', {
	      style: transformStyle
	    }));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Progressbar.prototype, prototypeAccessors );

	  return F7Progressbar;
	}(react.Component));

	__reactComponentSetProps(F7Progressbar, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  progress: Number,
	  infinite: Boolean
	}, Mixins.colorProps));

	F7Progressbar.displayName = 'f7-progressbar';

	var F7Radio = /*@__PURE__*/(function (superclass) {
	  function F7Radio(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onChange']);
	    })();
	  }

	  if ( superclass ) F7Radio.__proto__ = superclass;
	  F7Radio.prototype = Object.create( superclass && superclass.prototype );
	  F7Radio.prototype.constructor = F7Radio;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Radio.prototype.onChange = function onChange (event) {
	    this.dispatchEvent('change', event);
	  };

	  F7Radio.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var name = props.name;
	    var value = props.value;
	    var disabled = props.disabled;
	    var readonly = props.readonly;
	    var checked = props.checked;
	    var defaultChecked = props.defaultChecked;
	    var id = props.id;
	    var style = props.style;
	    var className = props.className;
	    var inputEl;
	    {
	      inputEl = react.createElement('input', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['inputEl'] = __reactNode;
	        },
	        type: 'radio',
	        name: name,
	        value: value,
	        disabled: disabled,
	        readOnly: readonly,
	        checked: checked,
	        defaultChecked: defaultChecked,
	        onChange: self.onChange
	      });
	    }
	    var iconEl = react.createElement('i', {
	      className: 'icon-radio'
	    });
	    var classes = Utils$1.classNames(className, 'radio', {
	      disabled: disabled
	    }, Mixins.colorClasses(props));
	    return react.createElement('label', {
	      id: id,
	      style: style,
	      className: classes
	    }, inputEl, iconEl, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Radio.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Radio.prototype, prototypeAccessors );

	  return F7Radio;
	}(react.Component));

	__reactComponentSetProps(F7Radio, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  checked: Boolean,
	  name: [Number, String],
	  value: [Number, String, Boolean],
	  disabled: Boolean,
	  readonly: Boolean,
	  defaultChecked: Boolean
	}, Mixins.colorProps));

	F7Radio.displayName = 'f7-radio';

	var F7Row = /*@__PURE__*/(function (superclass) {
	  function F7Row(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick']);
	    })();
	  }

	  if ( superclass ) F7Row.__proto__ = superclass;
	  F7Row.prototype = Object.create( superclass && superclass.prototype );
	  F7Row.prototype.constructor = F7Row;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Row.prototype.onClick = function onClick (event) {
	    this.dispatchEvent('click', event);
	  };

	  F7Row.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var tag = props.tag;
	    var noGap = props.noGap;
	    var RowTag = tag;
	    var classes = Utils$1.classNames(className, 'row', {
	      'no-gap': noGap
	    }, Mixins.colorClasses(props));
	    return react.createElement(RowTag, {
	      id: id,
	      style: style,
	      className: classes,
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      }
	    }, this.slots['default']);
	  };

	  F7Row.prototype.componentWillUnmount = function componentWillUnmount () {
	    this.refs.el.removeEventListener('click', this.onClick);
	  };

	  F7Row.prototype.componentDidMount = function componentDidMount () {
	    this.refs.el.addEventListener('click', this.onClick);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Row.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Row.prototype, prototypeAccessors );

	  return F7Row;
	}(react.Component));

	__reactComponentSetProps(F7Row, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  noGap: Boolean,
	  tag: {
	    type: String,
	    default: 'div'
	  }
	}, Mixins.colorProps));

	F7Row.displayName = 'f7-row';

	var F7Searchbar = /*@__PURE__*/(function (superclass) {
	  function F7Searchbar(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onSubmit', 'onClearButtonClick', 'onDisableButtonClick', 'onInput', 'onChange', 'onFocus', 'onBlur']);
	    })();
	  }

	  if ( superclass ) F7Searchbar.__proto__ = superclass;
	  F7Searchbar.prototype = Object.create( superclass && superclass.prototype );
	  F7Searchbar.prototype.constructor = F7Searchbar;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Searchbar.prototype.search = function search (query) {
	    if (!this.f7Searchbar) { return undefined; }
	    return this.f7Searchbar.search(query);
	  };

	  F7Searchbar.prototype.enable = function enable () {
	    if (!this.f7Searchbar) { return undefined; }
	    return this.f7Searchbar.enable();
	  };

	  F7Searchbar.prototype.disable = function disable () {
	    if (!this.f7Searchbar) { return undefined; }
	    return this.f7Searchbar.disable();
	  };

	  F7Searchbar.prototype.toggle = function toggle () {
	    if (!this.f7Searchbar) { return undefined; }
	    return this.toggle.disable();
	  };

	  F7Searchbar.prototype.clear = function clear () {
	    if (!this.f7Searchbar) { return undefined; }
	    return this.f7Searchbar.clear();
	  };

	  F7Searchbar.prototype.onChange = function onChange (event) {
	    this.dispatchEvent('change', event);
	  };

	  F7Searchbar.prototype.onInput = function onInput (event) {
	    this.dispatchEvent('input', event);
	  };

	  F7Searchbar.prototype.onFocus = function onFocus (event) {
	    this.dispatchEvent('focus', event);
	  };

	  F7Searchbar.prototype.onBlur = function onBlur (event) {
	    this.dispatchEvent('blur', event);
	  };

	  F7Searchbar.prototype.onSubmit = function onSubmit (event) {
	    this.dispatchEvent('submit', event);
	  };

	  F7Searchbar.prototype.onClearButtonClick = function onClearButtonClick (event) {
	    this.dispatchEvent('click:clear clickClear', event);
	  };

	  F7Searchbar.prototype.onDisableButtonClick = function onDisableButtonClick (event) {
	    this.dispatchEvent('click:disable clickDisable', event);
	  };

	  F7Searchbar.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var clearEl;
	    var disableEl;
	    var props = self.props;
	    var placeholder = props.placeholder;
	    var clearButton = props.clearButton;
	    var disableButton = props.disableButton;
	    var disableButtonText = props.disableButtonText;
	    var form = props.form;
	    var noShadow = props.noShadow;
	    var noHairline = props.noHairline;
	    var expandable = props.expandable;
	    var className = props.className;
	    var style = props.style;
	    var id = props.id;
	    var value = props.value;
	    var inline = props.inline;

	    if (clearButton) {
	      clearEl = react.createElement('span', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['clearEl'] = __reactNode;
	        },
	        className: 'input-clear-button'
	      });
	    }

	    if (disableButton) {
	      disableEl = react.createElement('span', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['disableEl'] = __reactNode;
	        },
	        className: 'searchbar-disable-button'
	      }, disableButtonText);
	    }

	    var SearchbarTag = form ? 'form' : 'div';
	    var classes = Utils$1.classNames(className, 'searchbar', {
	      'searchbar-inline': inline,
	      'no-shadow': noShadow,
	      'no-hairline': noHairline,
	      'searchbar-expandable': expandable
	    }, Mixins.colorClasses(props));
	    var inputEl;
	    {
	      inputEl = react.createElement('input', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['inputEl'] = __reactNode;
	        },
	        value: value,
	        placeholder: placeholder,
	        type: 'search',
	        onInput: self.onInput,
	        onChange: self.onChange.bind(self),
	        onFocus: self.onFocus,
	        onBlur: self.onBlur
	      });
	    }
	    return react.createElement(SearchbarTag, {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['before-inner'], react.createElement('div', {
	      className: 'searchbar-inner'
	    }, this.slots['inner-start'], react.createElement('div', {
	      className: 'searchbar-input-wrap'
	    }, this.slots['input-wrap-start'], inputEl, react.createElement('i', {
	      className: 'searchbar-icon'
	    }), clearEl, this.slots['input-wrap-end']), disableEl, this.slots['inner-end'], this.slots['default']), this.slots['after-inner']);
	  };

	  F7Searchbar.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var ref = self.refs;
	    var el = ref.el;
	    var clearEl = ref.clearEl;
	    var disableEl = ref.disableEl;

	    if (self.props.form && el) {
	      el.removeEventListener('submit', self.onSubmit, false);
	    }

	    if (clearEl) {
	      clearEl.removeEventListener('click', self.onClearButtonClick);
	    }

	    if (disableEl) {
	      disableEl.removeEventListener('click', self.onDisableButtonClick);
	    }

	    if (self.f7Searchbar && self.f7Searchbar.destroy) { self.f7Searchbar.destroy(); }
	  };

	  F7Searchbar.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var ref = self.props;
	    var init = ref.init;
	    var inputEvents = ref.inputEvents;
	    var searchContainer = ref.searchContainer;
	    var searchIn = ref.searchIn;
	    var searchItem = ref.searchItem;
	    var searchGroup = ref.searchGroup;
	    var searchGroupTitle = ref.searchGroupTitle;
	    var hideOnEnableEl = ref.hideOnEnableEl;
	    var hideOnSearchEl = ref.hideOnSearchEl;
	    var foundEl = ref.foundEl;
	    var notFoundEl = ref.notFoundEl;
	    var backdrop = ref.backdrop;
	    var backdropEl = ref.backdropEl;
	    var disableButton = ref.disableButton;
	    var ignore = ref.ignore;
	    var customSearch = ref.customSearch;
	    var removeDiacritics = ref.removeDiacritics;
	    var hideDividers = ref.hideDividers;
	    var hideGroups = ref.hideGroups;
	    var form = ref.form;
	    var expandable = ref.expandable;
	    var inline = ref.inline;
	    var ref$1 = self.refs;
	    var el = ref$1.el;
	    var clearEl = ref$1.clearEl;
	    var disableEl = ref$1.disableEl;

	    if (form && el) {
	      el.addEventListener('submit', self.onSubmit, false);
	    }

	    if (clearEl) {
	      clearEl.addEventListener('click', self.onClearButtonClick);
	    }

	    if (disableEl) {
	      disableEl.addEventListener('click', self.onDisableButtonClick);
	    }

	    if (!init) { return; }
	    self.$f7ready(function () {
	      var params = Utils$1.noUndefinedProps({
	        el: self.refs.el,
	        inputEvents: inputEvents,
	        searchContainer: searchContainer,
	        searchIn: searchIn,
	        searchItem: searchItem,
	        searchGroup: searchGroup,
	        searchGroupTitle: searchGroupTitle,
	        hideOnEnableEl: hideOnEnableEl,
	        hideOnSearchEl: hideOnSearchEl,
	        foundEl: foundEl,
	        notFoundEl: notFoundEl,
	        backdrop: backdrop,
	        backdropEl: backdropEl,
	        disableButton: disableButton,
	        ignore: ignore,
	        customSearch: customSearch,
	        removeDiacritics: removeDiacritics,
	        hideDividers: hideDividers,
	        hideGroups: hideGroups,
	        expandable: expandable,
	        inline: inline,
	        on: {
	          search: function search(searchbar, query, previousQuery) {
	            self.dispatchEvent('searchbar:search searchbarSearch', searchbar, query, previousQuery);
	          },

	          clear: function clear(searchbar, previousQuery) {
	            self.dispatchEvent('searchbar:clear searchbarClear', searchbar, previousQuery);
	          },

	          enable: function enable(searchbar) {
	            self.dispatchEvent('searchbar:enable searchbarEnable', searchbar);
	          },

	          disable: function disable(searchbar) {
	            self.dispatchEvent('searchbar:disable searchbarDisable', searchbar);
	          }

	        }
	      });
	      Object.keys(params).forEach(function (key) {
	        if (params[key] === '') {
	          delete params[key];
	        }
	      });
	      self.f7Searchbar = self.$f7.searchbar.create(params);
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Searchbar.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Searchbar.prototype, prototypeAccessors );

	  return F7Searchbar;
	}(react.Component));

	__reactComponentSetProps(F7Searchbar, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  noShadow: Boolean,
	  noHairline: Boolean,
	  form: {
	    type: Boolean,
	    default: true
	  },
	  placeholder: {
	    type: String,
	    default: 'Search'
	  },
	  disableButton: {
	    type: Boolean,
	    default: true
	  },
	  disableButtonText: {
	    type: String,
	    default: 'Cancel'
	  },
	  clearButton: {
	    type: Boolean,
	    default: true
	  },
	  value: [String, Number, Array],
	  inputEvents: {
	    type: String,
	    default: 'change input compositionend'
	  },
	  expandable: Boolean,
	  inline: Boolean,
	  searchContainer: [String, Object],
	  searchIn: {
	    type: String,
	    default: '.item-title'
	  },
	  searchItem: {
	    type: String,
	    default: 'li'
	  },
	  searchGroup: {
	    type: String,
	    default: '.list-group'
	  },
	  searchGroupTitle: {
	    type: String,
	    default: '.item-divider, .list-group-title'
	  },
	  foundEl: {
	    type: [String, Object],
	    default: '.searchbar-found'
	  },
	  notFoundEl: {
	    type: [String, Object],
	    default: '.searchbar-not-found'
	  },
	  backdrop: {
	    type: Boolean,
	    default: undefined
	  },
	  backdropEl: [String, Object],
	  hideOnEnableEl: {
	    type: [String, Object],
	    default: '.searchbar-hide-on-enable'
	  },
	  hideOnSearchEl: {
	    type: [String, Object],
	    default: '.searchbar-hide-on-search'
	  },
	  ignore: {
	    type: String,
	    default: '.searchbar-ignore'
	  },
	  customSearch: {
	    type: Boolean,
	    default: false
	  },
	  removeDiacritics: {
	    type: Boolean,
	    default: false
	  },
	  hideDividers: {
	    type: Boolean,
	    default: true
	  },
	  hideGroups: {
	    type: Boolean,
	    default: true
	  },
	  init: {
	    type: Boolean,
	    default: true
	  }
	}, Mixins.colorProps));

	F7Searchbar.displayName = 'f7-searchbar';

	var F7Segmented = /*@__PURE__*/(function (superclass) {
	  function F7Segmented(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7Segmented.__proto__ = superclass;
	  F7Segmented.prototype = Object.create( superclass && superclass.prototype );
	  F7Segmented.prototype.constructor = F7Segmented;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7Segmented.prototype.render = function render () {
	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var raised = props.raised;
	    var raisedIos = props.raisedIos;
	    var raisedAurora = props.raisedAurora;
	    var raisedMd = props.raisedMd;
	    var round = props.round;
	    var roundIos = props.roundIos;
	    var roundAurora = props.roundAurora;
	    var roundMd = props.roundMd;
	    var id = props.id;
	    var style = props.style;
	    var tag = props.tag;
	    var classNames = Utils$1.classNames(className, {
	      segmented: true,
	      'segmented-raised': raised,
	      'segmented-raised-ios': raisedIos,
	      'segmented-raised-aurora': raisedAurora,
	      'segmented-raised-md': raisedMd,
	      'segmented-round': round,
	      'segmented-round-ios': roundIos,
	      'segmented-round-aurora': roundAurora,
	      'segmented-round-md': roundMd
	    }, Mixins.colorClasses(props));
	    var SegmentedTag = tag;
	    return react.createElement(SegmentedTag, {
	      id: id,
	      style: style,
	      className: classNames
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7Segmented.prototype, prototypeAccessors );

	  return F7Segmented;
	}(react.Component));

	__reactComponentSetProps(F7Segmented, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  raised: Boolean,
	  raisedIos: Boolean,
	  raisedMd: Boolean,
	  raisedAurora: Boolean,
	  round: Boolean,
	  roundIos: Boolean,
	  roundMd: Boolean,
	  roundAurora: Boolean,
	  tag: {
	    type: String,
	    default: 'div'
	  }
	}, Mixins.colorProps));

	F7Segmented.displayName = 'f7-segmented';

	var F7Sheet = /*@__PURE__*/(function (superclass) {
	  function F7Sheet(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onOpen', 'onOpened', 'onClose', 'onClosed', 'onStepOpen', 'onStepClose']);
	    })();
	  }

	  if ( superclass ) F7Sheet.__proto__ = superclass;
	  F7Sheet.prototype = Object.create( superclass && superclass.prototype );
	  F7Sheet.prototype.constructor = F7Sheet;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Sheet.prototype.onStepOpen = function onStepOpen (event) {
	    this.dispatchEvent('sheet:stepopen sheetStepOpen', event);
	  };

	  F7Sheet.prototype.onStepClose = function onStepClose (event) {
	    this.dispatchEvent('sheet:stepclose sheetStepClose', event);
	  };

	  F7Sheet.prototype.onOpen = function onOpen (event) {
	    this.dispatchEvent('sheet:open sheetOpen', event);
	  };

	  F7Sheet.prototype.onOpened = function onOpened (event) {
	    this.dispatchEvent('sheet:opened sheetOpened', event);
	  };

	  F7Sheet.prototype.onClose = function onClose (event) {
	    this.dispatchEvent('sheet:close sheetClose', event);
	  };

	  F7Sheet.prototype.onClosed = function onClosed (event) {
	    this.dispatchEvent('sheet:closed sheetClosed', event);
	  };

	  F7Sheet.prototype.open = function open (animate) {
	    var self = this;
	    if (!self.$f7) { return undefined; }
	    return self.$f7.sheet.open(self.refs.el, animate);
	  };

	  F7Sheet.prototype.close = function close (animate) {
	    var self = this;
	    if (!self.$f7) { return undefined; }
	    return self.$f7.sheet.close(self.refs.el, animate);
	  };

	  F7Sheet.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var fixedList = [];
	    var staticList = [];
	    var props = self.props;
	    var id = props.id;
	    var style = props.style;
	    var className = props.className;
	    var top = props.top;
	    var bottom = props.bottom;
	    var position = props.position;
	    var fixedTags;
	    fixedTags = 'navbar toolbar tabbar subnavbar searchbar messagebar fab list-index'.split(' ').map(function (tagName) { return ("f7-" + tagName); });
	    var slotsDefault = self.slots.default;

	    if (slotsDefault && slotsDefault.length) {
	      slotsDefault.forEach(function (child) {
	        if (typeof child === 'undefined') { return; }
	        var isFixedTag = false;
	        {
	          var tag = child.type && (child.type.displayName || child.type.name);

	          if (!tag) {
	            staticList.push(child);
	            return;
	          }

	          if (fixedTags.indexOf(tag) >= 0) {
	            isFixedTag = true;
	          }
	        }
	        if (isFixedTag) { fixedList.push(child); }else { staticList.push(child); }
	      });
	    }

	    var innerEl = react.createElement('div', {
	      className: 'sheet-modal-inner'
	    }, staticList);
	    var positionComputed = 'bottom';
	    if (position) { positionComputed = position; }else if (top) { positionComputed = 'top'; }else if (bottom) { positionComputed = 'bottom'; }
	    var classes = Utils$1.classNames(className, 'sheet-modal', ("sheet-modal-" + positionComputed), Mixins.colorClasses(props));
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes
	    }, fixedList, innerEl);
	  };

	  F7Sheet.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    if (self.f7Sheet) { self.f7Sheet.destroy(); }
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.removeEventListener('sheet:open', self.onOpen);
	    el.removeEventListener('sheet:opened', self.onOpened);
	    el.removeEventListener('sheet:close', self.onClose);
	    el.removeEventListener('sheet:closed', self.onClosed);
	    el.removeEventListener('sheet:stepopen', self.onStepOpen);
	    el.removeEventListener('sheet:stepclose', self.onStepClose);
	  };

	  F7Sheet.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    if (!el) { return; }
	    el.addEventListener('sheet:open', self.onOpen);
	    el.addEventListener('sheet:opened', self.onOpened);
	    el.addEventListener('sheet:close', self.onClose);
	    el.addEventListener('sheet:closed', self.onClosed);
	    el.addEventListener('sheet:stepopen', self.onStepOpen);
	    el.addEventListener('sheet:stepclose', self.onStepClose);
	    var props = self.props;
	    var opened = props.opened;
	    var backdrop = props.backdrop;
	    var backdropEl = props.backdropEl;
	    var closeByBackdropClick = props.closeByBackdropClick;
	    var closeByOutsideClick = props.closeByOutsideClick;
	    var closeOnEscape = props.closeOnEscape;
	    var swipeToClose = props.swipeToClose;
	    var swipeToStep = props.swipeToStep;
	    var swipeHandler = props.swipeHandler;
	    var sheetParams = {
	      el: self.refs.el
	    };
	    {
	      if ('backdrop' in props && typeof backdrop !== 'undefined') { sheetParams.backdrop = backdrop; }
	      if ('backdropEl' in props) { sheetParams.backdropEl = backdropEl; }
	      if ('closeByBackdropClick' in props) { sheetParams.closeByBackdropClick = closeByBackdropClick; }
	      if ('closeByOutsideClick' in props) { sheetParams.closeByOutsideClick = closeByOutsideClick; }
	      if ('closeOnEscape' in props) { sheetParams.closeOnEscape = closeOnEscape; }
	      if ('swipeToClose' in props) { sheetParams.swipeToClose = swipeToClose; }
	      if ('swipeToStep' in props) { sheetParams.swipeToStep = swipeToStep; }
	      if ('swipeHandler' in props) { sheetParams.swipeHandler = swipeHandler; }
	    }
	    self.$f7ready(function () {
	      self.f7Sheet = self.$f7.sheet.create(sheetParams);

	      if (opened) {
	        self.f7Sheet.open(false);
	      }
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Sheet.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  F7Sheet.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
	    var this$1 = this;

	    __reactComponentWatch(this, 'props.opened', prevProps, prevState, function (opened) {
	      var self = this$1;
	      if (!self.f7Sheet) { return; }

	      if (opened) {
	        self.f7Sheet.open();
	      } else {
	        self.f7Sheet.close();
	      }
	    });
	  };

	  Object.defineProperties( F7Sheet.prototype, prototypeAccessors );

	  return F7Sheet;
	}(react.Component));

	__reactComponentSetProps(F7Sheet, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  opened: Boolean,
	  top: Boolean,
	  bottom: Boolean,
	  position: String,
	  backdrop: Boolean,
	  backdropEl: [String, Object, window.HTMLElement],
	  closeByBackdropClick: Boolean,
	  closeByOutsideClick: Boolean,
	  closeOnEscape: Boolean,
	  swipeToClose: Boolean,
	  swipeToStep: Boolean,
	  swipeHandler: [String, Object, window.HTMLElement]
	}, Mixins.colorProps));

	F7Sheet.displayName = 'f7-sheet';

	var F7SkeletonBlock = /*@__PURE__*/(function (superclass) {
	  function F7SkeletonBlock(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7SkeletonBlock.__proto__ = superclass;
	  F7SkeletonBlock.prototype = Object.create( superclass && superclass.prototype );
	  F7SkeletonBlock.prototype.constructor = F7SkeletonBlock;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7SkeletonBlock.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var width = props.width;
	    var height = props.height;
	    var tag = props.tag;
	    var classes = Utils$1.classNames('skeleton-block', className, Mixins.colorClasses(props));
	    var styleAttribute = style;

	    if (width) {
	      var widthValue = typeof width === 'number' ? (width + "px") : width;

	      if (!styleAttribute) {
	        styleAttribute = {
	          width: widthValue
	        };
	      } else if (typeof styleAttribute === 'object') {
	        styleAttribute = Object.assign({
	          width: widthValue
	        }, styleAttribute);
	      } else if (typeof styleAttribute === 'string') {
	        styleAttribute = "width: " + widthValue + "; " + styleAttribute;
	      }
	    }

	    if (height) {
	      var heightValue = typeof height === 'number' ? (height + "px") : height;

	      if (!styleAttribute) {
	        styleAttribute = {
	          height: heightValue
	        };
	      } else if (typeof styleAttribute === 'object') {
	        styleAttribute = Object.assign({
	          height: heightValue
	        }, styleAttribute);
	      } else if (typeof styleAttribute === 'string') {
	        styleAttribute = "height: " + heightValue + "; " + styleAttribute;
	      }
	    }

	    var Tag = tag;
	    return react.createElement(Tag, {
	      id: id,
	      style: styleAttribute,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7SkeletonBlock.prototype, prototypeAccessors );

	  return F7SkeletonBlock;
	}(react.Component));

	__reactComponentSetProps(F7SkeletonBlock, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  width: [Number, String],
	  height: [Number, String],
	  tag: {
	    type: String,
	    default: 'div'
	  }
	}, Mixins.colorProps));

	F7SkeletonBlock.displayName = 'f7-skeleton-block';

	var F7SkeletonText = /*@__PURE__*/(function (superclass) {
	  function F7SkeletonText(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7SkeletonText.__proto__ = superclass;
	  F7SkeletonText.prototype = Object.create( superclass && superclass.prototype );
	  F7SkeletonText.prototype.constructor = F7SkeletonText;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7SkeletonText.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var width = props.width;
	    var height = props.height;
	    var tag = props.tag;
	    var classes = Utils$1.classNames('skeleton-text', className, Mixins.colorClasses(props));
	    var styleAttribute = style;

	    if (width) {
	      var widthValue = typeof width === 'number' ? (width + "px") : width;

	      if (!styleAttribute) {
	        styleAttribute = {
	          width: widthValue
	        };
	      } else if (typeof styleAttribute === 'object') {
	        styleAttribute = Object.assign({
	          width: widthValue
	        }, styleAttribute);
	      } else if (typeof styleAttribute === 'string') {
	        styleAttribute = "width: " + widthValue + "; " + styleAttribute;
	      }
	    }

	    if (height) {
	      var heightValue = typeof height === 'number' ? (height + "px") : height;

	      if (!styleAttribute) {
	        styleAttribute = {
	          height: heightValue
	        };
	      } else if (typeof styleAttribute === 'object') {
	        styleAttribute = Object.assign({
	          height: heightValue
	        }, styleAttribute);
	      } else if (typeof styleAttribute === 'string') {
	        styleAttribute = "height: " + heightValue + "; " + styleAttribute;
	      }
	    }

	    var Tag = tag;
	    return react.createElement(Tag, {
	      id: id,
	      style: styleAttribute,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7SkeletonText.prototype, prototypeAccessors );

	  return F7SkeletonText;
	}(react.Component));

	__reactComponentSetProps(F7SkeletonText, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  width: [Number, String],
	  height: [Number, String],
	  tag: {
	    type: String,
	    default: 'span'
	  }
	}, Mixins.colorProps));

	F7SkeletonText.displayName = 'f7-skeleton-text';

	var F7Statusbar = /*@__PURE__*/(function (superclass) {
	  function F7Statusbar(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7Statusbar.__proto__ = superclass;
	  F7Statusbar.prototype = Object.create( superclass && superclass.prototype );
	  F7Statusbar.prototype.constructor = F7Statusbar;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7Statusbar.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'statusbar', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7Statusbar.prototype, prototypeAccessors );

	  return F7Statusbar;
	}(react.Component));

	__reactComponentSetProps(F7Statusbar, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7Statusbar.displayName = 'f7-statusbar';

	var F7Stepper = /*@__PURE__*/(function (superclass) {
	  function F7Stepper(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onInput', 'onMinusClick', 'onPlusClick']);
	    })();
	  }

	  if ( superclass ) F7Stepper.__proto__ = superclass;
	  F7Stepper.prototype = Object.create( superclass && superclass.prototype );
	  F7Stepper.prototype.constructor = F7Stepper;

	  var prototypeAccessors = { classes: { configurable: true },refs: { configurable: true } };

	  F7Stepper.prototype.increment = function increment () {
	    if (!this.f7Stepper) { return; }
	    this.f7Stepper.increment();
	  };

	  F7Stepper.prototype.decrement = function decrement () {
	    if (!this.f7Stepper) { return; }
	    this.f7Stepper.decrement();
	  };

	  F7Stepper.prototype.setValue = function setValue (newValue) {
	    var self = this;
	    if (self.f7Stepper && self.f7Stepper.setValue) { self.f7Stepper.setValue(newValue); }
	  };

	  F7Stepper.prototype.getValue = function getValue () {
	    var self = this;

	    if (self.f7Stepper && self.f7Stepper.getValue) {
	      return self.f7Stepper.getValue();
	    }

	    return undefined;
	  };

	  F7Stepper.prototype.onInput = function onInput (event) {
	    var stepper = this.f7Stepper;
	    this.dispatchEvent('input', event, stepper);
	  };

	  F7Stepper.prototype.onChange = function onChange (event) {
	    var stepper = this.f7Stepper;
	    this.dispatchEvent('change', event, stepper);
	  };

	  F7Stepper.prototype.onMinusClick = function onMinusClick (event) {
	    var stepper = this.f7Stepper;
	    this.dispatchEvent('stepper:minusclick stepperMinusClick', event, stepper);
	  };

	  F7Stepper.prototype.onPlusClick = function onPlusClick (event) {
	    var stepper = this.f7Stepper;
	    this.dispatchEvent('stepper:plusclick stepperPlusClick', event, stepper);
	  };

	  prototypeAccessors.classes.get = function () {
	    var self = this;
	    var props = self.props;
	    var round = props.round;
	    var roundIos = props.roundIos;
	    var roundMd = props.roundMd;
	    var roundAurora = props.roundAurora;
	    var fill = props.fill;
	    var fillIos = props.fillIos;
	    var fillMd = props.fillMd;
	    var fillAurora = props.fillAurora;
	    var large = props.large;
	    var largeIos = props.largeIos;
	    var largeMd = props.largeMd;
	    var largeAurora = props.largeAurora;
	    var small = props.small;
	    var smallIos = props.smallIos;
	    var smallMd = props.smallMd;
	    var smallAurora = props.smallAurora;
	    var raised = props.raised;
	    var raisedMd = props.raisedMd;
	    var raisedIos = props.raisedIos;
	    var raisedAurora = props.raisedAurora;
	    var disabled = props.disabled;
	    return Utils$1.classNames(self.props.className, 'stepper', {
	      disabled: disabled,
	      'stepper-round': round,
	      'stepper-round-ios': roundIos,
	      'stepper-round-md': roundMd,
	      'stepper-round-aurora': roundAurora,
	      'stepper-fill': fill,
	      'stepper-fill-ios': fillIos,
	      'stepper-fill-md': fillMd,
	      'stepper-fill-aurora': fillAurora,
	      'stepper-large': large,
	      'stepper-large-ios': largeIos,
	      'stepper-large-md': largeMd,
	      'stepper-large-aurora': largeAurora,
	      'stepper-small': small,
	      'stepper-small-ios': smallIos,
	      'stepper-small-md': smallMd,
	      'stepper-small-aurora': smallAurora,
	      'stepper-raised': raised,
	      'stepper-raised-ios': raisedIos,
	      'stepper-raised-md': raisedMd,
	      'stepper-raised-aurora': raisedAurora
	    }, Mixins.colorClasses(props));
	  };

	  F7Stepper.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var input = props.input;
	    var buttonsOnly = props.buttonsOnly;
	    var inputType = props.inputType;
	    var value = props.value;
	    var inputReadonly = props.inputReadonly;
	    var min = props.min;
	    var max = props.max;
	    var step = props.step;
	    var id = props.id;
	    var style = props.style;
	    var inputWrapEl;
	    var valueEl;

	    if (input && !buttonsOnly) {
	      var inputEl;
	      {
	        inputEl = react.createElement('input', {
	          ref: function (__reactNode) {
	            this$1.__reactRefs['inputEl'] = __reactNode;
	          },
	          type: inputType,
	          min: inputType === 'number' ? min : undefined,
	          max: inputType === 'number' ? max : undefined,
	          step: inputType === 'number' ? step : undefined,
	          onInput: self.onInput,
	          onChange: self.onChange,
	          value: value,
	          readOnly: inputReadonly
	        });
	      }
	      inputWrapEl = react.createElement('div', {
	        className: 'stepper-input-wrap'
	      }, inputEl);
	    }

	    if (!input && !buttonsOnly) {
	      valueEl = react.createElement('div', {
	        className: 'stepper-value'
	      }, value);
	    }

	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: self.classes
	    }, react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['minusEl'] = __reactNode;
	      },
	      className: 'stepper-button-minus'
	    }), inputWrapEl, valueEl, react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['plusEl'] = __reactNode;
	      },
	      className: 'stepper-button-plus'
	    }));
	  };

	  F7Stepper.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var ref = self.refs;
	    var minusEl = ref.minusEl;
	    var plusEl = ref.plusEl;

	    if (minusEl) {
	      minusEl.removeEventListener('click', self.onMinusClick);
	    }

	    if (plusEl) {
	      plusEl.removeEventListener('click', self.onPlusClick);
	    }

	    if (!self.props.init) { return; }

	    if (self.f7Stepper && self.f7Stepper.destroy) {
	      self.f7Stepper.destroy();
	    }
	  };

	  F7Stepper.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var ref = self.refs;
	    var minusEl = ref.minusEl;
	    var plusEl = ref.plusEl;

	    if (minusEl) {
	      minusEl.addEventListener('click', self.onMinusClick);
	    }

	    if (plusEl) {
	      plusEl.addEventListener('click', self.onPlusClick);
	    }

	    if (!self.props.init) { return; }
	    self.$f7ready(function (f7) {
	      var ref = self.props;
	      var min = ref.min;
	      var max = ref.max;
	      var value = ref.value;
	      var step = ref.step;
	      var formatValue = ref.formatValue;
	      var autorepeat = ref.autorepeat;
	      var autorepeatDynamic = ref.autorepeatDynamic;
	      var wraps = ref.wraps;
	      var manualInputMode = ref.manualInputMode;
	      var decimalPoint = ref.decimalPoint;
	      var buttonsEndInputMode = ref.buttonsEndInputMode;
	      var el = self.refs.el;
	      if (!el) { return; }
	      self.f7Stepper = f7.stepper.create(Utils$1.noUndefinedProps({
	        el: el,
	        min: min,
	        max: max,
	        value: value,
	        step: step,
	        formatValue: formatValue,
	        autorepeat: autorepeat,
	        autorepeatDynamic: autorepeatDynamic,
	        wraps: wraps,
	        manualInputMode: manualInputMode,
	        decimalPoint: decimalPoint,
	        buttonsEndInputMode: buttonsEndInputMode,
	        on: {
	          change: function change(stepper, newValue) {
	            self.dispatchEvent('stepper:change stepperChange', newValue);
	          }

	        }
	      }));
	    });
	  };

	  F7Stepper.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Stepper.prototype, prototypeAccessors );

	  return F7Stepper;
	}(react.Component));

	__reactComponentSetProps(F7Stepper, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  init: {
	    type: Boolean,
	    default: true
	  },
	  value: {
	    type: Number,
	    default: 0
	  },
	  min: {
	    type: Number,
	    default: 0
	  },
	  max: {
	    type: Number,
	    default: 100
	  },
	  step: {
	    type: Number,
	    default: 1
	  },
	  formatValue: Function,
	  input: {
	    type: Boolean,
	    default: true
	  },
	  inputType: {
	    type: String,
	    default: 'text'
	  },
	  inputReadonly: {
	    type: Boolean,
	    default: false
	  },
	  autorepeat: {
	    type: Boolean,
	    default: false
	  },
	  autorepeatDynamic: {
	    type: Boolean,
	    default: false
	  },
	  wraps: {
	    type: Boolean,
	    default: false
	  },
	  manualInputMode: {
	    type: Boolean,
	    default: false
	  },
	  decimalPoint: {
	    type: Number,
	    default: 4
	  },
	  buttonsEndInputMode: {
	    type: Boolean,
	    default: true
	  },
	  disabled: Boolean,
	  buttonsOnly: Boolean,
	  round: Boolean,
	  roundMd: Boolean,
	  roundIos: Boolean,
	  roundAurora: Boolean,
	  fill: Boolean,
	  fillMd: Boolean,
	  fillIos: Boolean,
	  fillAurora: Boolean,
	  large: Boolean,
	  largeMd: Boolean,
	  largeIos: Boolean,
	  largeAurora: Boolean,
	  small: Boolean,
	  smallMd: Boolean,
	  smallIos: Boolean,
	  smallAurora: Boolean,
	  raised: Boolean,
	  raisedMd: Boolean,
	  raisedIos: Boolean,
	  raisedAurora: Boolean
	}, Mixins.colorProps));

	F7Stepper.displayName = 'f7-stepper';

	var F7Subnavbar = /*@__PURE__*/(function (superclass) {
	  function F7Subnavbar(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7Subnavbar.__proto__ = superclass;
	  F7Subnavbar.prototype = Object.create( superclass && superclass.prototype );
	  F7Subnavbar.prototype.constructor = F7Subnavbar;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7Subnavbar.prototype.render = function render () {
	    var self = this;
	    var props = self.props;
	    var inner = props.inner;
	    var title = props.title;
	    var style = props.style;
	    var id = props.id;
	    var className = props.className;
	    var sliding = props.sliding;
	    var classes = Utils$1.classNames(className, 'subnavbar', {
	      sliding: sliding
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      className: classes,
	      id: id,
	      style: style
	    }, inner ? react.createElement('div', {
	      className: 'subnavbar-inner'
	    }, title && react.createElement('div', {
	      className: 'title'
	    }, title), this.slots['default']) : this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7Subnavbar.prototype, prototypeAccessors );

	  return F7Subnavbar;
	}(react.Component));

	__reactComponentSetProps(F7Subnavbar, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  sliding: Boolean,
	  title: String,
	  inner: {
	    type: Boolean,
	    default: true
	  }
	}, Mixins.colorProps));

	F7Subnavbar.displayName = 'f7-subnavbar';

	var F7SwipeoutActions = /*@__PURE__*/(function (superclass) {
	  function F7SwipeoutActions(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7SwipeoutActions.__proto__ = superclass;
	  F7SwipeoutActions.prototype = Object.create( superclass && superclass.prototype );
	  F7SwipeoutActions.prototype.constructor = F7SwipeoutActions;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7SwipeoutActions.prototype.render = function render () {
	    var props = this.props;
	    var left = props.left;
	    var right = props.right;
	    var side = props.side;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var sideComputed = side;

	    if (!sideComputed) {
	      if (left) { sideComputed = 'left'; }
	      if (right) { sideComputed = 'right'; }
	    }

	    var classes = Utils$1.classNames(className, ("swipeout-actions-" + sideComputed), Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7SwipeoutActions.prototype, prototypeAccessors );

	  return F7SwipeoutActions;
	}(react.Component));

	__reactComponentSetProps(F7SwipeoutActions, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  left: Boolean,
	  right: Boolean,
	  side: String
	}, Mixins.colorProps));

	F7SwipeoutActions.displayName = 'f7-swipeout-actions';

	var F7SwipeoutButton = /*@__PURE__*/(function (superclass) {
	  function F7SwipeoutButton(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick']);
	    })();
	  }

	  if ( superclass ) F7SwipeoutButton.__proto__ = superclass;
	  F7SwipeoutButton.prototype = Object.create( superclass && superclass.prototype );
	  F7SwipeoutButton.prototype.constructor = F7SwipeoutButton;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7SwipeoutButton.prototype.onClick = function onClick (event) {
	    this.dispatchEvent('click', event);
	  };

	  F7SwipeoutButton.prototype.render = function render () {
	    var this$1 = this;

	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var overswipe = props.overswipe;
	    var deleteProp = props.delete;
	    var close = props.close;
	    var href = props.href;
	    var confirmTitle = props.confirmTitle;
	    var confirmText = props.confirmText;
	    var text = props.text;
	    var classes = Utils$1.classNames(className, {
	      'swipeout-overswipe': overswipe,
	      'swipeout-delete': deleteProp,
	      'swipeout-close': close
	    }, Mixins.colorClasses(props));
	    return react.createElement('a', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      href: href || '#',
	      id: id,
	      style: style,
	      'data-confirm': confirmText || undefined,
	      'data-confirm-title': confirmTitle || undefined,
	      className: classes
	    }, this.slots['default'], !this.slots.default && text);
	  };

	  F7SwipeoutButton.prototype.componentWillUnmount = function componentWillUnmount () {
	    this.refs.el.removeEventListener('click', this.onClick);
	  };

	  F7SwipeoutButton.prototype.componentDidMount = function componentDidMount () {
	    this.refs.el.addEventListener('click', this.onClick);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7SwipeoutButton.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7SwipeoutButton.prototype, prototypeAccessors );

	  return F7SwipeoutButton;
	}(react.Component));

	__reactComponentSetProps(F7SwipeoutButton, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  text: String,
	  confirmTitle: String,
	  confirmText: String,
	  overswipe: Boolean,
	  close: Boolean,
	  delete: Boolean,
	  href: String
	}, Mixins.colorProps));

	F7SwipeoutButton.displayName = 'f7-swipeout-button';

	var F7SwiperSlide = /*@__PURE__*/(function (superclass) {
	  function F7SwiperSlide(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7SwiperSlide.__proto__ = superclass;
	  F7SwiperSlide.prototype = Object.create( superclass && superclass.prototype );
	  F7SwiperSlide.prototype.constructor = F7SwiperSlide;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7SwiperSlide.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var zoom = props.zoom;
	    var classes = Utils$1.classNames(className, 'swiper-slide');
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, zoom ? react.createElement('div', {
	      className: 'swiper-zoom-container'
	    }, this.slots['default']) : this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7SwiperSlide.prototype, prototypeAccessors );

	  return F7SwiperSlide;
	}(react.Component));

	__reactComponentSetProps(F7SwiperSlide, {
	  id: [String, Number],
	  className: String,
	  style: Object,
	  zoom: Boolean
	});

	F7SwiperSlide.displayName = 'f7-swiper-slide';

	var F7Swiper = /*@__PURE__*/(function (superclass) {
	  function F7Swiper(props, context) {
	    superclass.call(this, props, context);
	    this.__reactRefs = {};
	  }

	  if ( superclass ) F7Swiper.__proto__ = superclass;
	  F7Swiper.prototype = Object.create( superclass && superclass.prototype );
	  F7Swiper.prototype.constructor = F7Swiper;

	  var prototypeAccessors = { paginationComputed: { configurable: true },scrollbarComputed: { configurable: true },navigationComputed: { configurable: true },slots: { configurable: true },refs: { configurable: true } };

	  prototypeAccessors.paginationComputed.get = function () {
	    var self = this;
	    var ref = self.props;
	    var pagination = ref.pagination;
	    var params = ref.params;

	    if (pagination === true || params && params.pagination && !params.pagination.el) {
	      return true;
	    }

	    return false;
	  };

	  prototypeAccessors.scrollbarComputed.get = function () {
	    var self = this;
	    var ref = self.props;
	    var scrollbar = ref.scrollbar;
	    var params = ref.params;

	    if (scrollbar === true || params && params.scrollbar && !params.scrollbar.el) {
	      return true;
	    }

	    return false;
	  };

	  prototypeAccessors.navigationComputed.get = function () {
	    var self = this;
	    var ref = self.props;
	    var navigation = ref.navigation;
	    var params = ref.params;

	    if (navigation === true || params && params.navigation && !params.navigation.nextEl && !params.navigation.prevEl) {
	      return true;
	    }

	    return false;
	  };

	  F7Swiper.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var style = props.style;
	    var className = props.className;
	    var paginationEl;
	    var scrollbarEl;
	    var buttonNextEl;
	    var buttonPrevEl;

	    if (self.paginationComputed) {
	      paginationEl = react.createElement('div', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['paginationEl'] = __reactNode;
	        },
	        className: 'swiper-pagination'
	      });
	    }

	    if (self.scrollbarComputed) {
	      scrollbarEl = react.createElement('div', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['scrollbarEl'] = __reactNode;
	        },
	        className: 'swiper-scrollbar'
	      });
	    }

	    if (self.navigationComputed) {
	      buttonNextEl = react.createElement('div', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['nextEl'] = __reactNode;
	        },
	        className: 'swiper-button-next'
	      });
	      buttonPrevEl = react.createElement('div', {
	        ref: function (__reactNode) {
	          this$1.__reactRefs['prevEl'] = __reactNode;
	        },
	        className: 'swiper-button-prev'
	      });
	    }

	    var classes = Utils$1.classNames(className, 'swiper-container', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      className: classes
	    }, this.slots['before-wrapper'], react.createElement('div', {
	      className: 'swiper-wrapper'
	    }, this.slots['default']), paginationEl, scrollbarEl, buttonPrevEl, buttonNextEl, this.slots['after-wrapper']);
	  };

	  F7Swiper.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    if (!self.props.init) { return; }
	    if (self.swiper && self.swiper.destroy) { self.swiper.destroy(); }
	  };

	  F7Swiper.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    if (!self.props.init) { return; }
	    self.$f7ready(function (f7) {
	      var newParams = {
	        pagination: {},
	        navigation: {},
	        scrollbar: {}
	      };
	      var ref = self.props;
	      var params = ref.params;
	      var pagination = ref.pagination;
	      var navigation = ref.navigation;
	      var scrollbar = ref.scrollbar;
	      if (params) { Utils$1.extend(newParams, params); }
	      if (pagination && !newParams.pagination.el) { newParams.pagination.el = self.refs.paginationEl; }

	      if (navigation && !newParams.navigation.nextEl && !newParams.navigation.prevEl) {
	        newParams.navigation.nextEl = self.refs.nextEl;
	        newParams.navigation.prevEl = self.refs.prevEl;
	      }

	      if (scrollbar && !newParams.scrollbar.el) { newParams.scrollbar.el = self.refs.scrollbarEl; }
	      self.swiper = f7.swiper.create(self.refs.el, newParams);
	    });
	  };

	  F7Swiper.prototype.componentDidUpdate = function componentDidUpdate () {
	    var self = this;

	    if (!self.initialUpdate) {
	      self.initialUpdate = true;
	      return;
	    }

	    if (self.swiper && self.swiper.update) { self.swiper.update(); }
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Swiper.prototype, prototypeAccessors );

	  return F7Swiper;
	}(react.Component));

	__reactComponentSetProps(F7Swiper, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  params: Object,
	  pagination: Boolean,
	  scrollbar: Boolean,
	  navigation: Boolean,
	  init: {
	    type: Boolean,
	    default: true
	  }
	}, Mixins.colorProps));

	F7Swiper.displayName = 'f7-swiper';

	var F7Tab = /*@__PURE__*/(function (superclass) {
	  function F7Tab(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    this.state = (function () {
	      return {
	        tabContent: null
	      };
	    })();

	    (function () {
	      Utils$1.bindMethods(this$1, ['onTabShow', 'onTabHide']);
	    })();
	  }

	  if ( superclass ) F7Tab.__proto__ = superclass;
	  F7Tab.prototype = Object.create( superclass && superclass.prototype );
	  F7Tab.prototype.constructor = F7Tab;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Tab.prototype.show = function show (animate) {
	    if (!this.$f7) { return; }
	    this.$f7.tab.show(this.refs.el, animate);
	  };

	  F7Tab.prototype.onTabShow = function onTabShow (event) {
	    this.dispatchEvent('tab:show tabShow', event);
	  };

	  F7Tab.prototype.onTabHide = function onTabHide (event) {
	    this.dispatchEvent('tab:hide tabHide', event);
	  };

	  F7Tab.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var tabActive = props.tabActive;
	    var id = props.id;
	    var className = props.className;
	    var style = props.style;
	    var tabContent = self.state.tabContent;
	    var classes = Utils$1.classNames(className, 'tab', {
	      'tab-active': tabActive
	    }, Mixins.colorClasses(props));
	    var TabContent;
	    if (tabContent) { TabContent = tabContent.component; }
	    {
	      return react.createElement('div', {
	        id: id,
	        style: style,
	        ref: function (__reactNode) {
	          this$1.__reactRefs['el'] = __reactNode;
	        },
	        className: classes
	      }, tabContent ? react.createElement(TabContent, Object.assign({
	        key: tabContent.id
	      }, tabContent.props)) : this.slots['default']);
	    }
	  };

	  F7Tab.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;

	    if (el) {
	      el.addEventListener('tab:show', self.onTabShow);
	      el.addEventListener('tab:hide', self.onTabHide);
	    }

	    self.setState({
	      tabContent: null
	    });
	    self.$f7ready(function () {
	      self.routerData = {
	        el: el,
	        component: self
	      };
	      f7.routers.tabs.push(self.routerData);
	    });
	  };

	  F7Tab.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var el = self.refs.el;

	    if (el) {
	      el.removeEventListener('tab:show', self.onTabShow);
	      el.removeEventListener('tab:hide', self.onTabHide);
	    }

	    if (!self.routerData) { return; }
	    f7.routers.tabs.splice(f7.routers.tabs.indexOf(self.routerData), 1);
	    self.routerData = null;
	    delete self.routerData;
	  };

	  F7Tab.prototype.componentDidUpdate = function componentDidUpdate () {
	    var self = this;
	    if (!self.routerData) { return; }
	    eventsEmitter.emit('tabRouterDidUpdate', self.routerData);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7Tab.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Tab.prototype, prototypeAccessors );

	  return F7Tab;
	}(react.Component));

	__reactComponentSetProps(F7Tab, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  tabActive: Boolean
	}, Mixins.colorProps));

	F7Tab.displayName = 'f7-tab';

	var F7Tabs = /*@__PURE__*/(function (superclass) {
	  function F7Tabs(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7Tabs.__proto__ = superclass;
	  F7Tabs.prototype = Object.create( superclass && superclass.prototype );
	  F7Tabs.prototype.constructor = F7Tabs;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7Tabs.prototype.render = function render () {
	    var self = this;
	    var props = self.props;
	    var animated = props.animated;
	    var swipeable = props.swipeable;
	    var id = props.id;
	    var style = props.style;
	    var className = props.className;
	    var routable = props.routable;
	    var classes = Utils$1.classNames(className, Mixins.colorClasses(props));
	    var wrapClasses = Utils$1.classNames({
	      'tabs-animated-wrap': animated,
	      'tabs-swipeable-wrap': swipeable
	    });
	    var tabsClasses = Utils$1.classNames({
	      tabs: true,
	      'tabs-routable': routable
	    });

	    if (animated || swipeable) {
	      return react.createElement('div', {
	        id: id,
	        style: style,
	        className: Utils$1.classNames(wrapClasses, classes)
	      }, react.createElement('div', {
	        className: tabsClasses
	      }, this.slots['default']));
	    }

	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: Utils$1.classNames(tabsClasses, classes)
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7Tabs.prototype, prototypeAccessors );

	  return F7Tabs;
	}(react.Component));

	__reactComponentSetProps(F7Tabs, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  animated: Boolean,
	  swipeable: Boolean,
	  routable: Boolean
	}, Mixins.colorProps));

	F7Tabs.displayName = 'f7-tabs';

	var F7Toolbar = /*@__PURE__*/(function (superclass) {
	  function F7Toolbar(props, context) {
	    superclass.call(this, props, context);
	    this.__reactRefs = {};
	  }

	  if ( superclass ) F7Toolbar.__proto__ = superclass;
	  F7Toolbar.prototype = Object.create( superclass && superclass.prototype );
	  F7Toolbar.prototype.constructor = F7Toolbar;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7Toolbar.prototype.hide = function hide (animate) {
	    var self = this;
	    if (!self.$f7) { return; }
	    self.$f7.toolbar.hide(this.refs.el, animate);
	  };

	  F7Toolbar.prototype.show = function show (animate) {
	    var self = this;
	    if (!self.$f7) { return; }
	    self.$f7.toolbar.show(this.refs.el, animate);
	  };

	  F7Toolbar.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var style = props.style;
	    var className = props.className;
	    var inner = props.inner;
	    var tabbar = props.tabbar;
	    var labels = props.labels;
	    var scrollable = props.scrollable;
	    var hidden = props.hidden;
	    var noShadow = props.noShadow;
	    var noHairline = props.noHairline;
	    var noBorder = props.noBorder;
	    var topMd = props.topMd;
	    var topIos = props.topIos;
	    var topAurora = props.topAurora;
	    var top = props.top;
	    var bottomMd = props.bottomMd;
	    var bottomIos = props.bottomIos;
	    var bottomAurora = props.bottomAurora;
	    var bottom = props.bottom;
	    var position = props.position;
	    var classes = Utils$1.classNames(className, 'toolbar', {
	      tabbar: tabbar,
	      'toolbar-bottom': self.$theme.md && bottomMd || self.$theme.ios && bottomIos || self.$theme.aurora && bottomAurora || bottom || position === 'bottom',
	      'toolbar-top': self.$theme.md && topMd || self.$theme.ios && topIos || self.$theme.aurora && topAurora || top || position === 'top',
	      'tabbar-labels': labels,
	      'tabbar-scrollable': scrollable,
	      'toolbar-hidden': hidden,
	      'no-shadow': noShadow,
	      'no-hairline': noHairline || noBorder
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      className: classes
	    }, this.slots['before-inner'], inner ? react.createElement('div', {
	      className: 'toolbar-inner'
	    }, this.slots['default']) : this.slots['default'], this.slots['after-inner']);
	  };

	  F7Toolbar.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    self.$f7ready(function (f7) {
	      if (self.props.tabbar) { f7.toolbar.setHighlight(self.refs.el); }
	    });
	  };

	  F7Toolbar.prototype.componentDidUpdate = function componentDidUpdate () {
	    var self = this;

	    if (self.props.tabbar && self.$f7) {
	      self.$f7.toolbar.setHighlight(self.refs.el);
	    }
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7Toolbar.prototype, prototypeAccessors );

	  return F7Toolbar;
	}(react.Component));

	__reactComponentSetProps(F7Toolbar, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  tabbar: Boolean,
	  labels: Boolean,
	  scrollable: Boolean,
	  hidden: Boolean,
	  noShadow: Boolean,
	  noHairline: Boolean,
	  noBorder: Boolean,
	  position: {
	    type: String,
	    default: undefined
	  },
	  topMd: {
	    type: Boolean,
	    default: undefined
	  },
	  topIos: {
	    type: Boolean,
	    default: undefined
	  },
	  topAurora: {
	    type: Boolean,
	    default: undefined
	  },
	  top: {
	    type: Boolean,
	    default: undefined
	  },
	  bottomMd: {
	    type: Boolean,
	    default: undefined
	  },
	  bottomIos: {
	    type: Boolean,
	    default: undefined
	  },
	  bottomAurora: {
	    type: Boolean,
	    default: undefined
	  },
	  bottom: {
	    type: Boolean,
	    default: undefined
	  },
	  inner: {
	    type: Boolean,
	    default: true
	  }
	}, Mixins.colorProps));

	F7Toolbar.displayName = 'f7-toolbar';

	var F7TreeviewItem = /*@__PURE__*/(function (superclass) {
	  function F7TreeviewItem(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    (function () {
	      Utils$1.bindMethods(this$1, ['onClick', 'onOpen', 'onClose', 'onLoadChildren']);
	    })();
	  }

	  if ( superclass ) F7TreeviewItem.__proto__ = superclass;
	  F7TreeviewItem.prototype = Object.create( superclass && superclass.prototype );
	  F7TreeviewItem.prototype.constructor = F7TreeviewItem;

	  var prototypeAccessors = { itemRootAttrs: { configurable: true },itemRootClasses: { configurable: true },classes: { configurable: true },slots: { configurable: true },refs: { configurable: true } };

	  F7TreeviewItem.prototype.onClick = function onClick (event) {
	    this.dispatchEvent('click', event);
	  };

	  F7TreeviewItem.prototype.onOpen = function onOpen (event) {
	    this.dispatchEvent('treeview:open treeviewOpen', event);
	  };

	  F7TreeviewItem.prototype.onClose = function onClose (event) {
	    this.dispatchEvent('treeview:close treeviewClose', event);
	  };

	  F7TreeviewItem.prototype.onLoadChildren = function onLoadChildren (event) {
	    this.dispatchEvent('treeview:loadchildren treeviewLoadChildren', event, event.detail);
	  };

	  prototypeAccessors.itemRootAttrs.get = function () {
	    var self = this;
	    var props = self.props;
	    var link = props.link;
	    var href = link;
	    if (link === true) { href = '#'; }
	    if (link === false) { href = undefined; }
	    return Utils$1.extend({
	      href: href
	    }, Mixins.linkRouterAttrs(props), Mixins.linkActionsAttrs(props));
	  };

	  prototypeAccessors.itemRootClasses.get = function () {
	    var self = this;
	    var props = self.props;
	    var selectable = props.selectable;
	    var selected = props.selected;
	    var itemToggle = props.itemToggle;
	    return Utils$1.classNames('treeview-item-root', {
	      'treeview-item-selectable': selectable,
	      'treeview-item-selected': selected,
	      'treeview-item-toggle': itemToggle
	    }, Mixins.linkRouterClasses(props), Mixins.linkActionsClasses(props));
	  };

	  prototypeAccessors.classes.get = function () {
	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var opened = props.opened;
	    var loadChildren = props.loadChildren;
	    return Utils$1.classNames(className, 'treeview-item', {
	      'treeview-item-opened': opened,
	      'treeview-load-children': loadChildren
	    }, Mixins.colorClasses(props));
	  };

	  F7TreeviewItem.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var style = props.style;
	    var toggle = props.toggle;
	    var label = props.label;
	    var icon = props.icon;
	    var iconMaterial = props.iconMaterial;
	    var iconIon = props.iconIon;
	    var iconFa = props.iconFa;
	    var iconF7 = props.iconF7;
	    var iconMd = props.iconMd;
	    var iconIos = props.iconIos;
	    var iconAurora = props.iconAurora;
	    var iconSize = props.iconSize;
	    var iconColor = props.iconColor;
	    var link = props.link;
	    var slots = self.slots;
	    var hasChildren = slots.default && slots.default.length || slots.children && slots.children.length || slots['children-start'] && slots['children-start'].length;
	    var needToggle = typeof toggle === 'undefined' ? hasChildren : toggle;
	    var iconEl;

	    if (icon || iconMaterial || iconIon || iconFa || iconF7 || iconMd || iconIos || iconAurora) {
	      iconEl = react.createElement(F7Icon, {
	        material: iconMaterial,
	        f7: iconF7,
	        fa: iconFa,
	        ion: iconIon,
	        icon: icon,
	        md: iconMd,
	        ios: iconIos,
	        aurora: iconAurora,
	        color: iconColor,
	        size: iconSize
	      });
	    }

	    var TreeviewRootTag = link || link === '' ? 'a' : 'div';
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: self.classes
	    }, react.createElement(TreeviewRootTag, Object.assign({
	      ref: function (__reactNode) {
	        this$1.__reactRefs['rootEl'] = __reactNode;
	      },
	      className: self.itemRootClasses
	    }, self.itemRootAttrs), this.slots['root-start'], needToggle && react.createElement('div', {
	      className: 'treeview-toggle'
	    }), react.createElement('div', {
	      className: 'treeview-item-content'
	    }, this.slots['content-start'], iconEl, this.slots['media'], react.createElement('div', {
	      className: 'treeview-item-label'
	    }, this.slots['label-start'], label, this.slots['label']), this.slots['content'], this.slots['content-end']), this.slots['root'], this.slots['root-end']), hasChildren && react.createElement('div', {
	      className: 'treeview-item-children'
	    }, this.slots['children-start'], this.slots['default'], this.slots['children']));
	  };

	  F7TreeviewItem.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var ref = self.refs;
	    var el = ref.el;
	    var rootEl = ref.rootEl;
	    rootEl.removeEventListener('click', self.onClick);
	    el.removeEventListener('treeview:open', self.onOpen);
	    el.removeEventListener('treeview:close', self.onClose);
	    el.removeEventListener('treeview:loadchildren', self.onLoadChildren);
	  };

	  F7TreeviewItem.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var ref = self.refs;
	    var el = ref.el;
	    var rootEl = ref.rootEl;
	    rootEl.addEventListener('click', self.onClick);
	    el.addEventListener('treeview:open', self.onOpen);
	    el.addEventListener('treeview:close', self.onClose);
	    el.addEventListener('treeview:loadchildren', self.onLoadChildren);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7TreeviewItem.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7TreeviewItem.prototype, prototypeAccessors );

	  return F7TreeviewItem;
	}(react.Component));

	__reactComponentSetProps(F7TreeviewItem, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  toggle: {
	    type: Boolean,
	    default: undefined
	  },
	  itemToggle: Boolean,
	  selectable: Boolean,
	  selected: Boolean,
	  opened: Boolean,
	  label: String,
	  loadChildren: Boolean,
	  link: {
	    type: [Boolean, String],
	    default: undefined
	  }
	}, Mixins.colorProps, Mixins.linkActionsProps, Mixins.linkRouterProps, Mixins.linkIconProps));

	F7TreeviewItem.displayName = 'f7-treeview-item';

	var F7Treeview = /*@__PURE__*/(function (superclass) {
	  function F7Treeview(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7Treeview.__proto__ = superclass;
	  F7Treeview.prototype = Object.create( superclass && superclass.prototype );
	  F7Treeview.prototype.constructor = F7Treeview;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7Treeview.prototype.render = function render () {
	    var props = this.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var classes = Utils$1.classNames(className, 'treeview', Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7Treeview.prototype, prototypeAccessors );

	  return F7Treeview;
	}(react.Component));

	__reactComponentSetProps(F7Treeview, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object
	}, Mixins.colorProps));

	F7Treeview.displayName = 'f7-treeview';

	var F7View = /*@__PURE__*/(function (superclass) {
	  function F7View(props, context) {
	    var this$1 = this;

	    superclass.call(this, props, context);
	    this.__reactRefs = {};

	    this.state = (function () {
	      return {
	        pages: []
	      };
	    })();

	    (function () {
	      Utils$1.bindMethods(this$1, ['onSwipeBackMove', 'onSwipeBackBeforeChange', 'onSwipeBackAfterChange', 'onSwipeBackBeforeReset', 'onSwipeBackAfterReset', 'onTabShow', 'onTabHide', 'onViewInit']);
	    })();
	  }

	  if ( superclass ) F7View.__proto__ = superclass;
	  F7View.prototype = Object.create( superclass && superclass.prototype );
	  F7View.prototype.constructor = F7View;

	  var prototypeAccessors = { slots: { configurable: true },refs: { configurable: true } };

	  F7View.prototype.onViewInit = function onViewInit (event) {
	    var self = this;
	    var view = event.detail;
	    self.dispatchEvent('view:init viewInit', event, view);

	    if (!self.props.init) {
	      self.routerData.instance = view;
	      self.f7View = self.routerData.instance;
	    }
	  };

	  F7View.prototype.onSwipeBackMove = function onSwipeBackMove (event) {
	    var swipeBackData = event.detail;
	    this.dispatchEvent('swipeback:move swipeBackMove', event, swipeBackData);
	  };

	  F7View.prototype.onSwipeBackBeforeChange = function onSwipeBackBeforeChange (event) {
	    var swipeBackData = event.detail;
	    this.dispatchEvent('swipeback:beforechange swipeBackBeforeChange', event, swipeBackData);
	  };

	  F7View.prototype.onSwipeBackAfterChange = function onSwipeBackAfterChange (event) {
	    var swipeBackData = event.detail;
	    this.dispatchEvent('swipeback:afterchange swipeBackAfterChange', event, swipeBackData);
	  };

	  F7View.prototype.onSwipeBackBeforeReset = function onSwipeBackBeforeReset (event) {
	    var swipeBackData = event.detail;
	    this.dispatchEvent('swipeback:beforereset swipeBackBeforeReset', event, swipeBackData);
	  };

	  F7View.prototype.onSwipeBackAfterReset = function onSwipeBackAfterReset (event) {
	    var swipeBackData = event.detail;
	    this.dispatchEvent('swipeback:afterreset swipeBackAfterReset', event, swipeBackData);
	  };

	  F7View.prototype.onTabShow = function onTabShow (event) {
	    this.dispatchEvent('tab:show tabShow', event);
	  };

	  F7View.prototype.onTabHide = function onTabHide (event) {
	    this.dispatchEvent('tab:hide tabHide', event);
	  };

	  F7View.prototype.render = function render () {
	    var this$1 = this;

	    var self = this;
	    var props = self.props;
	    var id = props.id;
	    var style = props.style;
	    var tab = props.tab;
	    var main = props.main;
	    var tabActive = props.tabActive;
	    var className = props.className;
	    var classes = Utils$1.classNames(className, 'view', {
	      'view-main': main,
	      'tab-active': tabActive,
	      tab: tab
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      ref: function (__reactNode) {
	        this$1.__reactRefs['el'] = __reactNode;
	      },
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default'], self.state.pages.map(function (page) {
	      var PageComponent = page.component;
	      {
	        return react.createElement(PageComponent, Object.assign({
	          key: page.id
	        }, page.props));
	      }
	    }));
	  };

	  F7View.prototype.componentDidUpdate = function componentDidUpdate () {
	    var self = this;
	    if (!self.routerData) { return; }
	    eventsEmitter.emit('viewRouterDidUpdate', self.routerData);
	  };

	  F7View.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    var el = self.refs.el;
	    el.removeEventListener('swipeback:move', self.onSwipeBackMove);
	    el.removeEventListener('swipeback:beforechange', self.onSwipeBackBeforeChange);
	    el.removeEventListener('swipeback:afterchange', self.onSwipeBackAfterChange);
	    el.removeEventListener('swipeback:beforereset', self.onSwipeBackBeforeReset);
	    el.removeEventListener('swipeback:afterreset', self.onSwipeBackAfterReset);
	    el.removeEventListener('tab:show', self.onTabShow);
	    el.removeEventListener('tab:hide', self.onTabHide);
	    el.removeEventListener('view:init', self.onViewInit);
	    if (!self.props.init) { return; }
	    if (self.f7View && self.f7View.destroy) { self.f7View.destroy(); }
	    f7.routers.views.splice(f7.routers.views.indexOf(self.routerData), 1);
	    self.routerData = null;
	    delete self.routerData;
	  };

	  F7View.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var el = self.refs.el;
	    el.addEventListener('swipeback:move', self.onSwipeBackMove);
	    el.addEventListener('swipeback:beforechange', self.onSwipeBackBeforeChange);
	    el.addEventListener('swipeback:afterchange', self.onSwipeBackAfterChange);
	    el.addEventListener('swipeback:beforereset', self.onSwipeBackBeforeReset);
	    el.addEventListener('swipeback:afterreset', self.onSwipeBackAfterReset);
	    el.addEventListener('tab:show', self.onTabShow);
	    el.addEventListener('tab:hide', self.onTabHide);
	    el.addEventListener('view:init', self.onViewInit);
	    self.setState({
	      pages: []
	    });
	    self.$f7ready(function (f7Instance) {
	      self.routerData = {
	        el: el,
	        component: self,
	        instance: null
	      };
	      f7.routers.views.push(self.routerData);
	      if (!self.props.init) { return; }
	      self.routerData.instance = f7Instance.views.create(el, Utils$1.noUndefinedProps(self.props));
	      self.f7View = self.routerData.instance;
	    });
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  F7View.prototype.dispatchEvent = function dispatchEvent (events) {
	    var args = [], len = arguments.length - 1;
	    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	    return __reactComponentDispatchEvent.apply(void 0, [ this, events ].concat( args ));
	  };

	  prototypeAccessors.refs.get = function () {
	    return this.__reactRefs;
	  };

	  prototypeAccessors.refs.set = function (refs) {};

	  Object.defineProperties( F7View.prototype, prototypeAccessors );

	  return F7View;
	}(react.Component));

	__reactComponentSetProps(F7View, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  tab: Boolean,
	  tabActive: Boolean,
	  name: String,
	  router: Boolean,
	  linksView: [Object, String],
	  url: String,
	  main: Boolean,
	  stackPages: Boolean,
	  xhrCache: Boolean,
	  xhrCacheIgnore: Array,
	  xhrCacheIgnoreGetParameters: Boolean,
	  xhrCacheDuration: Number,
	  preloadPreviousPage: Boolean,
	  allowDuplicateUrls: Boolean,
	  reloadPages: Boolean,
	  reloadDetail: Boolean,
	  masterDetailBreakpoint: Number,
	  removeElements: Boolean,
	  removeElementsWithTimeout: Boolean,
	  removeElementsTimeout: Number,
	  restoreScrollTopOnBack: Boolean,
	  iosSwipeBack: Boolean,
	  iosSwipeBackAnimateShadow: Boolean,
	  iosSwipeBackAnimateOpacity: Boolean,
	  iosSwipeBackActiveArea: Number,
	  iosSwipeBackThreshold: Number,
	  mdSwipeBack: Boolean,
	  mdSwipeBackAnimateShadow: Boolean,
	  mdSwipeBackAnimateOpacity: Boolean,
	  mdSwipeBackActiveArea: Number,
	  mdSwipeBackThreshold: Number,
	  auroraSwipeBack: Boolean,
	  auroraSwipeBackAnimateShadow: Boolean,
	  auroraSwipeBackAnimateOpacity: Boolean,
	  auroraSwipeBackActiveArea: Number,
	  auroraSwipeBackThreshold: Number,
	  pushState: Boolean,
	  pushStateRoot: String,
	  pushStateAnimate: Boolean,
	  pushStateAnimateOnLoad: Boolean,
	  pushStateSeparator: String,
	  pushStateOnLoad: Boolean,
	  animate: Boolean,
	  iosDynamicNavbar: Boolean,
	  iosSeparateDynamicNavbar: Boolean,
	  iosAnimateNavbarBackIcon: Boolean,
	  materialPageLoadDelay: Number,
	  passRouteQueryToRequest: Boolean,
	  passRouteParamsToRequest: Boolean,
	  routes: Array,
	  routesAdd: Array,
	  routesBeforeEnter: [Function, Array],
	  routesBeforeLeave: [Function, Array],
	  init: {
	    type: Boolean,
	    default: true
	  }
	}, Mixins.colorProps));

	F7View.displayName = 'f7-view';

	var F7Views = /*@__PURE__*/(function (superclass) {
	  function F7Views(props, context) {
	    superclass.call(this, props, context);
	  }

	  if ( superclass ) F7Views.__proto__ = superclass;
	  F7Views.prototype = Object.create( superclass && superclass.prototype );
	  F7Views.prototype.constructor = F7Views;

	  var prototypeAccessors = { slots: { configurable: true } };

	  F7Views.prototype.render = function render () {
	    var self = this;
	    var props = self.props;
	    var className = props.className;
	    var id = props.id;
	    var style = props.style;
	    var tabs = props.tabs;
	    var classes = Utils$1.classNames(className, 'views', {
	      tabs: tabs
	    }, Mixins.colorClasses(props));
	    return react.createElement('div', {
	      id: id,
	      style: style,
	      className: classes
	    }, this.slots['default']);
	  };

	  prototypeAccessors.slots.get = function () {
	    return __reactComponentSlots(this.props);
	  };

	  Object.defineProperties( F7Views.prototype, prototypeAccessors );

	  return F7Views;
	}(react.Component));

	__reactComponentSetProps(F7Views, Object.assign({
	  id: [String, Number],
	  className: String,
	  style: Object,
	  tabs: Boolean
	}, Mixins.colorProps));

	F7Views.displayName = 'f7-views';

	/* eslint no-underscore-dangle: "off" */

	var routerComponentIdCounter = 0;

	var componentsRouter = {
	  proto: {
	    pageComponentLoader: function pageComponentLoader(routerEl, component, componentUrl, options, resolve, reject) {
	      var router = this;
	      var el = routerEl;
	      var routerComponent;
	      f7.routers.views.forEach(function (data) {
	        if (data.el && data.el === routerEl) {
	          routerComponent = data.component;
	        }
	      });

	      if (!routerComponent || !routerComponent.state.pages) {
	        reject();
	        return;
	      }

	      var id = (Utils$1.now()) + "_" + ((routerComponentIdCounter += 1));
	      var pageData = {
	        component: component,
	        id: id,
	        props: Utils$1.extend(
	          {
	            f7route: options.route,
	            f7router: router,
	          },
	          options.route.params,
	          options.props || {}
	        ),
	      };
	      routerComponent.$f7router = router;
	      routerComponent.$f7route = options.route;

	      var resolved;
	      function onDidUpdate(componentRouterData) {
	        if (componentRouterData.component !== routerComponent || resolved) { return; }
	        eventsEmitter.off('viewRouterDidUpdate', onDidUpdate);

	        var pageEl = el.children[el.children.length - 1];
	        pageData.el = pageEl;

	        resolve(pageEl);
	        resolved = true;
	      }

	      eventsEmitter.on('viewRouterDidUpdate', onDidUpdate);

	      routerComponent.state.pages.push(pageData);
	      routerComponent.setState({ pages: routerComponent.state.pages });
	    },
	    removePage: function removePage($pageEl) {
	      if (!$pageEl) { return; }
	      var router = this;
	      var f7Page;
	      if ('length' in $pageEl) { f7Page = $pageEl[0].f7Page; }
	      else { f7Page = $pageEl.f7Page; }
	      if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
	        router.app.$($pageEl).remove();
	        return;
	      }
	      var routerComponent;
	      f7.routers.views.forEach(function (data) {
	        if (data.el && data.el === router.el) {
	          routerComponent = data.component;
	        }
	      });

	      var pageEl;
	      if ('length' in $pageEl) {
	        // Dom7
	        if ($pageEl.length === 0) { return; }
	        pageEl = $pageEl[0];
	      } else {
	        pageEl = $pageEl;
	      }
	      if (!pageEl) { return; }

	      var pageComponentFound;
	      routerComponent.state.pages.forEach(function (page, index) {
	        if (page.el === pageEl) {
	          pageComponentFound = true;
	          routerComponent.state.pages.splice(index, 1);
	          routerComponent.setState({ pages: routerComponent.state.pages });
	        }
	      });
	      if (!pageComponentFound) {
	        pageEl.parentNode.removeChild(pageEl);
	      }
	    },
	    tabComponentLoader: function tabComponentLoader(tabEl, component, componentUrl, options, resolve, reject) {
	      var router = this;
	      if (!tabEl) { reject(); }

	      var tabsComponent;
	      f7.routers.tabs.forEach(function (tabData) {
	        if (tabData.el && tabData.el === tabEl) {
	          tabsComponent = tabData.component;
	        }
	      });
	      if (!tabsComponent) {
	        reject();
	        return;
	      }

	      var id = (Utils$1.now()) + "_" + ((routerComponentIdCounter += 1));
	      var tabContent = {
	        id: id,
	        component: component,
	        props: Utils$1.extend(
	          {
	            f7route: options.route,
	            f7router: router,
	          },
	          options.route.params,
	          options.props || {}
	        ),
	      };

	      tabsComponent.$f7router = router;
	      tabsComponent.$f7route = options.route;

	      var resolved;
	      function onDidUpdate(componentRouterData) {
	        if (componentRouterData.component !== tabsComponent || resolved) { return; }
	        eventsEmitter.off('tabRouterDidUpdate', onDidUpdate);

	        var tabContentEl = tabEl.children[0];
	        resolve(tabContentEl);

	        resolved = true;
	      }

	      eventsEmitter.on('tabRouterDidUpdate', onDidUpdate);

	      tabsComponent.setState({ tabContent: tabContent });
	    },
	    removeTabContent: function removeTabContent(tabEl) {
	      if (!tabEl) { return; }

	      var tabComponent;
	      f7.routers.tabs.forEach(function (tabData) {
	        if (tabData.el && tabData.el === tabEl) {
	          tabComponent = tabData.component;
	        }
	      });
	      var hasComponent = !!tabComponent.state.tabContent;
	      if (!tabComponent || !hasComponent) {
	        tabEl.innerHTML = ''; // eslint-disable-line
	        return;
	      }
	      tabComponent.setState({ tabContent: null });
	    },
	    modalComponentLoader: function modalComponentLoader(rootEl, component, componentUrl, options, resolve, reject) {
	      var router = this;
	      var modalsComponent = f7.routers.modals && f7.routers.modals.component;
	      var modalsComponentEl = f7.routers.modals && f7.routers.modals.el;

	      if (!modalsComponent || !modalsComponent.state.modals) {
	        reject();
	        return;
	      }

	      var id = (Utils$1.now()) + "_" + ((routerComponentIdCounter += 1));
	      var modalData = {
	        component: component,
	        id: id,
	        props: Utils$1.extend(
	          {
	            f7route: options.route,
	            f7router: router,
	          },
	          options.route.params,
	          options.props || {}
	        ),
	      };
	      modalsComponent.$f7router = router;
	      modalsComponent.$f7route = options.route;

	      var resolved;
	      function onDidUpdate(componentRouterData) {
	        if (componentRouterData.component !== modalsComponent || resolved) { return; }
	        eventsEmitter.off('modalsRouterDidUpdate', onDidUpdate);

	        var modalEl = modalsComponentEl.children[modalsComponentEl.children.length - 1];
	        modalData.el = modalEl;

	        resolve(modalEl);
	        resolved = true;
	      }

	      eventsEmitter.on('modalsRouterDidUpdate', onDidUpdate);

	      modalsComponent.state.modals.push(modalData);
	      modalsComponent.setState({ modals: modalsComponent.state.modals });
	    },
	    removeModal: function removeModal(modalEl) {
	      var modalsComponent = f7.routers.modals && f7.routers.modals.component;
	      if (!modalsComponent) { return; }

	      var modalDataToRemove;
	      modalsComponent.state.modals.forEach(function (modalData) {
	        if (modalData.el === modalEl) { modalDataToRemove = modalData; }
	      });

	      modalsComponent.state.modals.splice(modalsComponent.state.modals.indexOf(modalDataToRemove), 1);
	      modalsComponent.setState({ modals: modalsComponent.state.modals });
	    },
	  },
	};

	var Plugin = {
	  name: 'phenomePlugin',
	  installed: false,
	  install: function install(params) {
	    if ( params === void 0 ) params = {};

	    if (Plugin.installed) { return; }
	    Plugin.installed = true;

	    var Framework7 = this;
	    f7.Framework7 = Framework7;

	    var Extend = params.React ? params.React.Component : react.Component; // eslint-disable-line

	    
	    // Define protos
	    Object.defineProperty(Extend.prototype, '$f7', {
	      get: function get() {
	        return f7.instance;
	      },
	    });

	    var $theme = {};
	    var theme = params.theme;
	    if (theme === 'md') { $theme.md = true; }
	    if (theme === 'ios') { $theme.ios = true; }
	    if (theme === 'aurora') { $theme.aurora = true; }
	    if (!theme || theme === 'auto') {
	      $theme.ios = !!Framework7.device.ios;
	      $theme.aurora = Framework7.device.desktop && Framework7.device.electron;
	      $theme.md = !$theme.ios && !$theme.aurora;
	    }
	    Object.defineProperty(Extend.prototype, '$theme', {
	      get: function get() {
	        return {
	          ios: f7.instance ? f7.instance.theme === 'ios' : $theme.ios,
	          md: f7.instance ? f7.instance.theme === 'md' : $theme.md,
	          aurora: f7.instance ? f7.instance.theme === 'aurora' : $theme.aurora,
	        };
	      },
	    });

	    function f7ready(callback) {
	      f7.ready(callback);
	    }
	    Extend.prototype.Dom7 = Framework7.$;
	    Extend.prototype.$$ = Framework7.$;
	    Extend.prototype.$device = Framework7.device;
	    Extend.prototype.$request = Framework7.request;
	    Extend.prototype.$utils = Framework7.utils;
	    Extend.prototype.$f7ready = f7ready;
	    Extend.prototype.$f7Ready = f7ready;

	    Object.defineProperty(Extend.prototype, '$f7route', {
	      get: function get() {
	        var self = this;
	        if (self.props && self.props.f7route) { return self.props.f7route; }
	        if (self.f7route) { return self.f7route; }
	        if (self._f7route) { return self._f7route; }

	        var route;
	        return route;
	      },
	      set: function set(value) {
	        var self = this;
	        self._f7route = value;
	      },
	    });
	    Object.defineProperty(Extend.prototype, '$f7router', {
	      get: function get() {
	        var self = this;
	        if (self.props && self.props.f7router) { return self.props.f7router; }
	        if (self.f7router) { return self.f7router; }
	        if (self._f7router) { return self._f7router; }

	        var router;
	        return router;
	      },
	      set: function set(value) {
	        var self = this;
	        self._f7router = value;
	      },
	    });

	    // Extend F7 Router
	    Framework7.Router.use(componentsRouter);
	  },
	};

	/**
	 * Framework7 React 4.4.0
	 * Build full featured iOS & Android apps using Framework7 & React
	 * http://framework7.io/react/
	 *
	 * Copyright 2014-2019 Vladimir Kharlampidi
	 *
	 * Released under the MIT License
	 *
	 * Released on: June 6, 2019
	 */

	var AccordionContent = F7AccordionContent;
	var AccordionItem = F7AccordionItem;
	var AccordionToggle = F7AccordionToggle;
	var ActionsButton = F7ActionsButton;
	var ActionsGroup = F7ActionsGroup;
	var ActionsLabel = F7ActionsLabel;
	var Actions$2 = F7Actions;
	var App = F7App;
	var Badge = F7Badge;
	var BlockFooter = F7BlockFooter;
	var BlockHeader = F7BlockHeader;
	var BlockTitle = F7BlockTitle;
	var Block = F7Block;
	var Button = F7Button;
	var CardContent = F7CardContent;
	var CardFooter = F7CardFooter;
	var CardHeader = F7CardHeader;
	var Card$1 = F7Card;
	var Checkbox$1 = F7Checkbox;
	var Chip$1 = F7Chip;
	var Col = F7Col;
	var FabButton = F7FabButton;
	var FabButtons = F7FabButtons;
	var Fab$2 = F7Fab;
	var Gauge$2 = F7Gauge;
	var Icon = F7Icon;
	var Link = F7Link;
	var ListButton = F7ListButton;
	var ListGroup = F7ListGroup;
	var ListIndex$2 = F7ListIndex;
	var ListInput = F7ListInput;
	var ListItemCell = F7ListItemCell;
	var ListItemRow = F7ListItemRow;
	var ListItem = F7ListItem;
	var List = F7List;
	var LoginScreenTitle = F7LoginScreenTitle;
	var LoginScreen$2 = F7LoginScreen;
	var MenuDropdownItem = F7MenuDropdownItem;
	var MenuDropdown = F7MenuDropdown;
	var MenuItem = F7MenuItem;
	var Menu$2 = F7Menu;
	var Message = F7Message;
	var MessagebarAttachment = F7MessagebarAttachment;
	var MessagebarAttachments = F7MessagebarAttachments;
	var MessagebarSheetImage = F7MessagebarSheetImage;
	var MessagebarSheet = F7MessagebarSheet;
	var Messagebar$2 = F7Messagebar;
	var MessagesTitle = F7MessagesTitle;
	var Messages$2 = F7Messages;
	var NavLeft = F7NavLeft;
	var NavRight = F7NavRight;
	var NavTitleLarge = F7NavTitle;
	var NavTitle = F7NavTitle$1;
	var Navbar$2 = F7Navbar;
	var PageContent = F7PageContent;
	var Page = F7Page;
	var Panel$2 = F7Panel;
	var PhotoBrowser$2 = F7PhotoBrowser;
	var Popover$2 = F7Popover;
	var Popup$2 = F7Popup;
	var Preloader$2 = F7Preloader;
	var Progressbar$2 = F7Progressbar;
	var Radio$1 = F7Radio;
	var Range$2 = F7Range;
	var Row = F7Row;
	var Searchbar$2 = F7Searchbar;
	var Segmented = F7Segmented;
	var Sheet$2 = F7Sheet;
	var SkeletonBlock = F7SkeletonBlock;
	var Statusbar$2 = F7Statusbar;
	var Stepper$2 = F7Stepper;
	var Subnavbar$1 = F7Subnavbar;
	var SwipeoutActions = F7SwipeoutActions;
	var SwipeoutButton = F7SwipeoutButton;
	var SwiperSlide = F7SwiperSlide;
	var Swiper$2 = F7Swiper;
	var Tab$1 = F7Tab;
	var Tabs$1 = F7Tabs;
	var Toggle$2 = F7Toggle;
	var Toolbar$2 = F7Toolbar;
	var TreeviewItem = F7TreeviewItem;
	var Treeview$2 = F7Treeview;
	var View$2 = F7View;

	var defaultExport = /*@__PURE__*/(function (superclass) {
	  function defaultExport() {
	    superclass.call(this);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { large: true, sliding: false },
	          react.createElement( NavLeft, null,
	            react.createElement( Link, { panelOpen: "left", iconIos: "f7:menu", iconAurora: "f7:menu", iconMd: "material:menu" })
	          ),
	          react.createElement( NavTitle, { sliding: true }, "Framework7 React"),
	          react.createElement( NavRight, null,
	            react.createElement( Link, { searchbarEnable: ".searchbar-components", iconIos: "f7:search", iconAurora: "f7:search", iconMd: "material:search" })
	          ),
	          react.createElement( NavTitleLarge, null, "Framework7 React" ),
	          react.createElement( Searchbar$2, {
	            className: "searchbar-components", searchContainer: ".components-list", searchIn: "a", expandable: true, disableButton: !this.$theme.aurora })
	        ),

	        react.createElement( List, { className: "searchbar-hide-on-search" },
	          react.createElement( ListItem, { title: "About Framework7", link: "/about/" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          )
	        ),

	        react.createElement( BlockTitle, { className: "searchbar-found" }, "Components"),
	        react.createElement( List, { className: "components-list searchbar-found" },
	          react.createElement( ListItem, { link: "/accordion/", title: "Accordion" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/action-sheet/", title: "Action Sheet" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/appbar/", title: "Appbar" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/autocomplete/", title: "Autocomplete" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/badge/", title: "Badge" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/buttons/", title: "Buttons" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/calendar/", title: "Calendar / Date Picker" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/cards/", title: "Cards" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/cards-expandable/", title: "Cards Expandable" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/checkbox/", title: "Checkbox" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/chips/", title: "Chips/Tags" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/color-picker/", title: "Color Picker" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/contacts-list/", title: "Contacts List" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/content-block/", title: "Content Block" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/data-table/", title: "Data Table" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/dialog/", title: "Dialog" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/elevation/", title: "Elevation" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/fab/", title: "FAB" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/fab-morph/", title: "FAB Morph" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/form-storage/", title: "Form Storage" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/gauge/", title: "Gauge" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/grid/", title: "Grid / Layout Grid" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/icons/", title: "Icons" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/infinite-scroll/", title: "Infinite Scroll" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/inputs/", title: "Inputs" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/lazy-load/", title: "Lazy Load" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/list/", title: "List View" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/list-index/", title: "List Index" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/login-screen/", title: "Login Screen" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/menu/", title: "Menu" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/messages/", title: "Messages" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/navbar/", title: "Navbar" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/notifications/", title: "Notifications" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/panel/", title: "Panel / Side Panels" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/photo-browser/", title: "Photo Browser" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/picker/", title: "Picker" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/popover/", title: "Popover" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/popup/", title: "Popup" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/preloader/", title: "Preloader" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/progressbar/", title: "Progress Bar" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/pull-to-refresh/", title: "Pull To Refresh" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/radio/", title: "Radio" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/range/", title: "Range Slider" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/searchbar/", title: "Searchbar" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/searchbar-expandable/", title: "Searchbar Expandable" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/sheet-modal/", title: "Sheet Modal" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/skeleton/", title: "Skeleton (Ghost) Elements" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/smart-select/", title: "Smart Select" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/sortable/", title: "Sortable List" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/statusbar/", title: "Statusbar" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/stepper/", title: "Stepper" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/subnavbar/", title: "Subnavbar" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/swipeout/", title: "Swipeout (Swipe To Delete)" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/swiper/", title: "Swiper Slider" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/tabs/", title: "Tabs" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/timeline/", title: "Timeline" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/toast/", title: "Toast" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/toggle/", title: "Toggle" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/toolbar-tabbar/", title: "Toolbar & Tabbar" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/tooltip/", title: "Tooltip" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/treeview/", title: "Treeview" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "/virtual-list/", title: "Virtual List" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          )
	        ),
	        react.createElement( List, { className: "searchbar-not-found" },
	          react.createElement( ListItem, { title: "Nothing found" })
	        ),
	        react.createElement( BlockTitle, { className: "searchbar-hide-on-search" }, "Themes"),
	        react.createElement( List, { className: "searchbar-hide-on-search" },
	          react.createElement( ListItem, { title: "iOS Theme", external: true, link: "./index.html?theme=ios" }),
	          react.createElement( ListItem, { title: "Material (MD) Theme", external: true, link: "./index.html?theme=md" }),
	          react.createElement( ListItem, { title: "Aurora Desktop Theme", external: true, link: "./index.html?theme=aurora" }),
	          react.createElement( ListItem, { title: "Color Themes", link: "/color-themes/" })
	        ),
	        react.createElement( BlockTitle, { className: "searchbar-hide-on-search" }, "Page Loaders & Router"),
	        react.createElement( List, { className: "searchbar-hide-on-search" },
	          react.createElement( ListItem, { title: "Routable Modals", link: "/routable-modals/" }),
	          react.createElement( ListItem, { title: "Default Route (404)", link: "/load-something-that-doesnt-exist/" }),
	          react.createElement( ListItem, { title: "Master-Detail (Split View)", link: "/master-detail/" })
	        )
	      )
	    );
	  };

	  return defaultExport;
	}(react.Component));

	function PanelLeft () { return (
	  react.createElement( Page, null,
	    react.createElement( BlockTitle, null, "Left Panel" ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "This is a left side panel. You can close it by clicking outsite or on this link: ", react.createElement( Link, { panelClose: true }, "close me"), ". You can put here anything, even another isolated view like in  ", react.createElement( Link, { panelOpen: "right" }, "Right Panel") )
	    ),
	    react.createElement( BlockTitle, null, "Main View Navigation" ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { link: "/accordion/", title: "Accordion", panelClose: true }),
	      react.createElement( ListItem, { link: "/action-sheet/", title: "Action Sheet", panelClose: true }),
	      react.createElement( ListItem, { link: "/badge/", title: "Badge", panelClose: true }),
	      react.createElement( ListItem, { link: "/buttons/", title: "Buttons", panelClose: true }),
	      react.createElement( ListItem, { link: "/cards/", title: "Cards", panelClose: true }),
	      react.createElement( ListItem, { link: "/checkbox/", title: "Checkbox", panelClose: true }),
	      react.createElement( ListItem, { link: "/chips/", title: "Chips/Tags", panelClose: true }),
	      react.createElement( ListItem, { link: "/contacts-list/", title: "Contacts List", panelClose: true }),
	      react.createElement( ListItem, { link: "/data-table/", title: "Data Table", panelClose: true })
	    ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse faucibus mauris leo, eu bibendum neque congue non. Ut leo mauris, eleifend eu commodo a, egestas ac urna. Maecenas in lacus faucibus, viverra ipsum pulvinar, molestie arcu. Etiam lacinia venenatis dignissim. Suspendisse non nisl semper tellus malesuada suscipit eu et eros. Nulla eu enim quis quam elementum vulputate. Mauris ornare consequat nunc viverra pellentesque. Aenean semper eu massa sit amet aliquam. Integer et neque sed libero mollis elementum at vitae ligula. Vestibulum pharetra sed libero sed porttitor. Suspendisse a faucibus lectus." ),
	      react.createElement( 'p', null, "Duis ut mauris sollicitudin, venenatis nisi sed, luctus ligula. Phasellus blandit nisl ut lorem semper pharetra. Nullam tortor nibh, suscipit in consequat vel, feugiat sed quam. Nam risus libero, auctor vel tristique ac, malesuada ut ante. Sed molestie, est in eleifend sagittis, leo tortor ullamcorper erat, at vulputate eros sapien nec libero. Mauris dapibus laoreet nibh quis bibendum. Fusce dolor sem, suscipit in iaculis id, pharetra at urna. Pellentesque tempor congue massa quis faucibus. Vestibulum nunc eros, convallis blandit dui sit amet, gravida adipiscing libero." )
	    )
	  )
	); }

	function PanelRight () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Right Panel" }),
	    react.createElement( BlockTitle, null, "Left Panel" ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "This is a right side panel. You can close it by clicking outsite or on this link: ", react.createElement( Link, { panelClose: true }, "close me"), ". You can put here anything, even another isolated view." )
	    ),
	    react.createElement( BlockTitle, null, "Panel Navigation" ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { link: "/panel-right-1/", title: "Right panel page 1" }),
	      react.createElement( ListItem, { link: "/panel-right-2/", title: "Right panel page 2" })
	    )
	  )
	); }

	function About () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { large: true, title: "About", 'title-large': "About", backLink: "Framework7" }),
	    react.createElement( BlockTitle, null, "Welcome to Framework7" ),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "Framework7 - is a free and open source HTML mobile framework to develop hybrid mobile apps or web apps with iOS or Android (Material) native look and feel. It is also an indispensable prototyping apps tool to show working app prototype as soon as possible in case you need to. Framework7 is created by Vladimir Kharlampidi (iDangero.us)." ),
	      react.createElement( 'p', null, "The main approach of the Framework7 is to give you an opportunity to create iOS and Android (Material) apps with HTML, CSS and JavaScript easily and clear. Framework7 is full of freedom. It doesn't limit your imagination or offer ways of any solutions somehow. Framework7 gives you freedom!" ),
	      react.createElement( 'p', null, "Framework7 is not compatible with all platforms. It is focused only on iOS and Android (Material) to bring the best experience and simplicity." ),
	      react.createElement( 'p', null, "Framework7 is definitely for you if you decide to build iOS and Android hybrid app (PhoneGap) or web app that looks like and feels as great native iOS or Android (Material) apps." )
	    )
	  )
	); }

	function Accordion$2 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Accordion", backLink: "Back" }),

	    react.createElement( BlockTitle, null, "List View Accordion" ),
	    react.createElement( List, { accordionList: true },
	      react.createElement( ListItem, { accordionItem: true, title: "Lorem Ipsum" },
	        react.createElement( AccordionContent, null,
	          react.createElement( Block, null,
	            react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean elementum id neque nec commodo. Sed vel justo at turpis laoreet pellentesque quis sed lorem. Integer semper arcu nibh, non mollis arcu tempor vel. Sed pharetra tortor vitae est rhoncus, vel congue dui sollicitudin. Donec eu arcu dignissim felis viverra blandit suscipit eget ipsum." )
	          )
	        )
	      ),
	      react.createElement( ListItem, { accordionItem: true, title: "Nested List" },
	        react.createElement( AccordionContent, null,
	          react.createElement( List, null,
	            react.createElement( ListItem, { title: "Item 1" }),
	            react.createElement( ListItem, { title: "Item 2" }),
	            react.createElement( ListItem, { title: "Item 3" }),
	            react.createElement( ListItem, { title: "Item 4" })
	          )
	        )
	      ),
	      react.createElement( ListItem, { accordionItem: true, title: "Integer semper" },
	        react.createElement( AccordionContent, null,
	          react.createElement( Block, null,
	            react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean elementum id neque nec commodo. Sed vel justo at turpis laoreet pellentesque quis sed lorem. Integer semper arcu nibh, non mollis arcu tempor vel. Sed pharetra tortor vitae est rhoncus, vel congue dui sollicitudin. Donec eu arcu dignissim felis viverra blandit suscipit eget ipsum." )
	          )
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Inset Accordion" ),
	    react.createElement( List, { accordionList: true, inset: true },
	      react.createElement( ListItem, { accordionItem: true, title: "Lorem Ipsum" },
	        react.createElement( AccordionContent, null,
	          react.createElement( Block, null,
	            react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean elementum id neque nec commodo. Sed vel justo at turpis laoreet pellentesque quis sed lorem. Integer semper arcu nibh, non mollis arcu tempor vel. Sed pharetra tortor vitae est rhoncus, vel congue dui sollicitudin. Donec eu arcu dignissim felis viverra blandit suscipit eget ipsum." )
	          )
	        )
	      ),
	      react.createElement( ListItem, { accordionItem: true, title: "Nested List" },
	        react.createElement( AccordionContent, null,
	          react.createElement( List, null,
	            react.createElement( ListItem, { title: "Item 1" }),
	            react.createElement( ListItem, { title: "Item 2" }),
	            react.createElement( ListItem, { title: "Item 3" }),
	            react.createElement( ListItem, { title: "Item 4" })
	          )
	        )
	      ),
	      react.createElement( ListItem, { accordionItem: true, title: "Integer semper" },
	        react.createElement( AccordionContent, null,
	          react.createElement( Block, null,
	            react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean elementum id neque nec commodo. Sed vel justo at turpis laoreet pellentesque quis sed lorem. Integer semper arcu nibh, non mollis arcu tempor vel. Sed pharetra tortor vitae est rhoncus, vel congue dui sollicitudin. Donec eu arcu dignissim felis viverra blandit suscipit eget ipsum." )
	          )
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Custom Collapsible" ),
	    react.createElement( Block, { inner: true, accordionList: true },
	      Array.from(Array(3).keys()).map(function (n) { return (
	        react.createElement( AccordionItem, { key: n },
	          react.createElement( AccordionToggle, null, react.createElement( 'b', null, "Item ", n + 1 ) ),
	          react.createElement( AccordionContent, null, "Content ", n + 1 )
	        )
	      ); })
	    )
	  )
	); }

	var defaultExport$1 = /*@__PURE__*/(function (superclass) {
	  function defaultExport() {
	    superclass.call(this);

	    this.state = {
	      actionGridOpened: false,
	      oneGroupOpened: false
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;

	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Action Sheet", backLink: "Back" }),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', { className: "row" }
	            /* One group, open by direct accessing instance .open() method */,
	            react.createElement( Button, { className: "col", fill: true, onClick: function () { return this$1.refs.actionsOneGroup.open(); } }, "One group")
	            /*  Two groups, open by "actionsOpen" attribute */,
	            react.createElement( Button, { className: "col", fill: true, actionsOpen: "#actions-two-groups" }, "Two groups")
	          ),
	          react.createElement( 'p', null
	            /* Actions Grid, open by changing actionGridOpened state property */,
	            react.createElement( Button, { fill: true, onClick: function () { return this$1.setActionsGridOpened(true); } }, "Action Grid")
	          )
	        ),

	        react.createElement( BlockTitle, null, "Action Sheet To Popover" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', { ref: function (e) { return this$1.buttonToPopoverWrapper = e; } }, "Action Sheet can be automatically converted to Popover (for tablets). This button will open Popover on tablets and Action Sheet on phones: ", react.createElement( Button, {
	              style: { display: 'inline-block' }, className: "button-to-popover", onClick: this.openActionsPopover.bind(this) }, "Actions")
	          )
	        )

	        /* One Group */,
	        react.createElement( Actions$2, { ref: "actionsOneGroup" },
	          react.createElement( ActionsGroup, null,
	            react.createElement( ActionsLabel, null, "Do something" ),
	            react.createElement( ActionsButton, { bold: true }, "Button 1"),
	            react.createElement( ActionsButton, null, "Button 2" ),
	            react.createElement( ActionsButton, { color: "red" }, "Cancel")
	          )
	        )

	        /* Two Groups */,
	        react.createElement( Actions$2, { id: "actions-two-groups" },
	          react.createElement( ActionsGroup, null,
	            react.createElement( ActionsLabel, null, "Do something" ),
	            react.createElement( ActionsButton, { bold: true }, "Button 1"),
	            react.createElement( ActionsButton, null, "Button 2" )
	          ),
	          react.createElement( ActionsGroup, null,
	            react.createElement( ActionsButton, { color: "red" }, "Cancel")
	          )
	        )

	        /* Grid */,
	        react.createElement( Actions$2, { grid: true, opened: this.state.actionGridOpened, onActionsClosed: function () { return this$1.setActionsGridOpened(false); } },
	          react.createElement( ActionsGroup, null,
	            react.createElement( ActionsButton, null,
	              react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/people-96x96-1.jpg", width: "48", style: {maxWidth: '100%'} }),
	              react.createElement( 'span', null, "Button 1" )
	            ),
	            react.createElement( ActionsButton, null,
	              react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/people-96x96-2.jpg", width: "48", style: {maxWidth: '100%'} }),
	              react.createElement( 'span', null, "Button 2" )
	            ),
	            react.createElement( ActionsButton, null,
	              react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/people-96x96-3.jpg", width: "48", style: {maxWidth: '100%'} }),
	              react.createElement( 'span', null, "Button 3" )
	            )
	          ),
	          react.createElement( ActionsGroup, null,
	            react.createElement( ActionsButton, null,
	              react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/fashion-96x96-4.jpg", width: "48", style: {maxWidth: '100%'} }),
	              react.createElement( 'span', null, "Button 4" )
	            ),
	            react.createElement( ActionsButton, null,
	              react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/fashion-96x96-5.jpg", width: "48", style: {maxWidth: '100%'} }),
	              react.createElement( 'span', null, "Button 5" )
	            ),
	            react.createElement( ActionsButton, null,
	              react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/fashion-96x96-6.jpg", width: "48", style: {maxWidth: '100%'} }),
	              react.createElement( 'span', null, "Button 6" )
	            )
	          )
	        )

	      )
	    )
	  };

	  defaultExport.prototype.componentWillUnmount = function componentWillUnmount () {
	    if (this.actionsToPopover) {
	      this.actionsToPopover.destroy();
	    }
	  };

	  defaultExport.prototype.openActionsPopover = function openActionsPopover () {
	    var app = this.$f7;

	    if (!this.actionsToPopover) {
	      this.actionsToPopover = app.actions.create({
	        buttons: [
	          {
	            text: 'Do something',
	            label: true,
	          },
	          {
	            text: 'Button 1',
	            bold: true,
	          },
	          {
	            text: 'Button 2',
	          },
	          {
	            text: 'Cancel',
	            color: 'red',
	          } ],
	        // Need to specify popover target
	        targetEl: this.buttonToPopoverWrapper.querySelector('.button-to-popover'),
	      });
	    }

	    // Open
	    this.actionsToPopover.open();
	  };

	  defaultExport.prototype.setOneGroupOpened = function setOneGroupOpened (oneGroupOpened) {
	    this.setState({
	      oneGroupOpened: oneGroupOpened
	    });
	  };

	  defaultExport.prototype.setActionsGridOpened = function setActionsGridOpened (actionGridOpened) {
	    this.setState({
	      actionGridOpened: actionGridOpened
	    });
	  };

	  return defaultExport;
	}(react.Component));

	var appbarEnabled = false;

	var defaultExport$2 = /*@__PURE__*/(function (superclass) {
	  function defaultExport() {
	    superclass.call(this);

	    this.state = {
	      appbarEnabled: appbarEnabled,
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.enableAppbar = function enableAppbar () {
	    var self = this;
	    self.setState({appbarEnabled: true});
	    appbarEnabled = true;
	    self.$f7.root.prepend("\n    <div class=\"appbar\">\n      <div class=\"appbar-inner\">\n        <div class=\"left\">\n          <a href=\"#\" class=\"button button-small panel-toggle display-flex\" data-panel=\"left\">\n            <i class=\"f7-icons\">bars</i>\n          </a>\n          <a href=\"#\" class=\"button button-small display-flex margin-left-half\">\n            <i class=\"f7-icons\">list</i>\n          </a>\n          <a href=\"#\" class=\"button button-small display-flex margin-left-half\">\n            <i class=\"f7-icons\">reply_fill</i>\n          </a>\n          <a href=\"#\" class=\"button button-small display-flex margin-left-half\">\n            <i class=\"f7-icons\">forward_fill</i>\n          </a>\n        </div>\n        <div class=\"right\">\n          <div class=\"searchbar searchbar-inline\">\n            <div class=\"searchbar-input-wrap\">\n              <input type=\"text\" placeholder=\"Search app\">\n              <i class=\"searchbar-icon\"></i>\n              <div class=\"input-clear-button\"></div>\n            </div>\n          </div>\n        </div>\n\n      </div>\n    </div>\n    ");
	  };
	  defaultExport.prototype.disableAppbar = function disableAppbar () {
	    var self = this;
	    self.setState({appbarEnabled: false});
	    appbarEnabled = false;
	    self.$$('.appbar').remove();
	  };
	  defaultExport.prototype.toggleAppbar = function toggleAppbar () {
	    var self = this;
	    if (self.state.appbarEnabled) {
	      self.disableAppbar();
	    } else {
	      self.enableAppbar();
	    }
	  };
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Appbar", backLink: "Back" }),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Appbar is the main app bar with actions on top of the whole app. It is designed to be used in desktop apps with Aurora theme." )
	        ),
	        react.createElement( Block, { strong: true },
	          react.createElement( Button, { fill: true, onClick: function () { return this$1.toggleAppbar(); } }, "Toggle Appbar")
	        )
	      )
	    )
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$3 = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	    this.state = {
	      fruits: 'Apple Apricot Avocado Banana Melon Orange Peach Pear Pineapple'.split(' '),
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, { onPageInit: this.onPageInit.bind(this), onPageBeforeRemove: this.onPageBeforeRemove.bind(this) },
	        react.createElement( Navbar$2, { title: "Autocomplete", backLink: "Back" },
	          react.createElement( Subnavbar$1, { inner: false },
	            react.createElement( Searchbar$2, { init: false, id: "searchbar-autocomplete", disableButton: !this.$theme.aurora })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Dropdown Autocomplete" ),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Dropdown autocomplete is good to use as a quick and simple solution to provide more options in addition to free-type value." )
	        ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( BlockHeader, null, "Simple Dropdown Autocomplete" ),
	          react.createElement( ListInput, {
	            label: "Fruit", inlineLabel: true, type: "text", placeholder: "Fruit", inputId: "autocomplete-dropdown" })
	        ),

	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( BlockHeader, null, "Dropdown With Input Expand" ),
	          react.createElement( ListInput, {
	            label: "Fruit", inlineLabel: true, type: "text", placeholder: "Fruit", inputId: "autocomplete-dropdown-expand" })
	        ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( BlockHeader, null, "Dropdown With All Values" ),
	          react.createElement( ListInput, {
	            label: "Fruit", type: "text", placeholder: "Fruit", inputId: "autocomplete-dropdown-all" })
	        ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( BlockHeader, null, "Dropdown With Placeholder" ),
	          react.createElement( ListInput, {
	            label: "Fruit", type: "text", placeholder: "Fruit", inputId: "autocomplete-dropdown-placeholder" })
	        ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( BlockHeader, null, "Dropdown With Typeahead" ),
	          react.createElement( ListInput, {
	            label: "Fruit", type: "text", placeholder: "Fruit", inputId: "autocomplete-dropdown-typeahead" })
	        ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( BlockHeader, null, "Dropdown With Ajax-Data" ),
	          react.createElement( ListInput, {
	            label: "Language", type: "text", placeholder: "Language", inputId: "autocomplete-dropdown-ajax" })
	        ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( BlockHeader, null, "Dropdown With Ajax-Data + Typeahead" ),
	          react.createElement( ListInput, {
	            label: "Language", type: "text", placeholder: "Language", inputId: "autocomplete-dropdown-ajax-typeahead" })
	        ),
	        react.createElement( BlockTitle, null, "Standalone Autocomplete" ),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Standalone autocomplete provides better mobile UX by opening it in a new page or popup. Good to use when you need to get strict values without allowing free-type values." )
	        ),
	        react.createElement( List, null,
	          react.createElement( BlockHeader, null, "Simple Standalone Autocomplete" ),
	          react.createElement( ListItem, { link: "#", id: "autocomplete-standalone", title: "Favorite Fruite", after: " " },
	            react.createElement( 'input', { type: "hidden" })
	          )
	        ),
	        react.createElement( List, null,
	          react.createElement( BlockHeader, null, "Popup Autocomplete" ),
	          react.createElement( ListItem, { link: "#", id: "autocomplete-standalone-popup", title: "Favorite Fruite", after: " " },
	            react.createElement( 'input', { type: "hidden" })
	          )
	        ),
	        react.createElement( List, null,
	          react.createElement( BlockHeader, null, "Multiple Values" ),
	          react.createElement( ListItem, { link: "#", id: "autocomplete-standalone-multiple", title: "Favorite Fruite", after: " " },
	            react.createElement( 'input', { type: "hidden" })
	          )
	        ),
	        react.createElement( List, null,
	          react.createElement( BlockHeader, null, "With Ajax-Data" ),
	          react.createElement( ListItem, { link: "#", id: "autocomplete-standalone-ajax", title: "Language", after: " " },
	            react.createElement( 'input', { type: "hidden" })
	          )
	        )
	      )
	    );
	  };
	  defaultExport.prototype.onPageBeforeRemove = function onPageBeforeRemove () {
	    var self = this;
	    // Destroy all autocompletes
	    self.autocompleteDropdownSimple.destroy();
	    self.autocompleteDropdownExpand.destroy();
	    self.autocompleteDropdownAll.destroy();
	    self.autocompleteDropdownPlaceholder.destroy();
	    self.autocompleteDropdownTypeahead.destroy();
	    self.autocompleteDropdownAjax.destroy();
	    self.autocompleteDropdownAjaxTypeahead.destroy();
	    self.autocompleteStandaloneSimple.destroy();
	    self.autocompleteStandalonePopup.destroy();
	    self.autocompleteStandaloneMultiple.destroy();
	    self.autocompleteStandaloneAjax.destroy();
	  };
	  defaultExport.prototype.onPageInit = function onPageInit () {
	    var self = this;
	    var app = self.$f7;
	    var fruits = self.state.fruits;
	    var $ = self.$$;

	    // Simple Dropdown
	    self.autocompleteDropdownSimple = app.autocomplete.create({
	      inputEl: '#autocomplete-dropdown input',
	      openIn: 'dropdown',
	      source: function source(query, render) {
	        var results = [];
	        if (query.length === 0) {
	          render(results);
	          return;
	        }
	        // Find matched items
	        for (var i = 0; i < fruits.length; i += 1) {
	          if (fruits[i].toLowerCase().indexOf(query.toLowerCase()) >= 0) { results.push(fruits[i]); }
	        }
	        // Render items by passing array with result items
	        render(results);
	      },
	    });

	    // Dropdown with input expand
	    self.autocompleteDropdownExpand = app.autocomplete.create({
	      inputEl: '#autocomplete-dropdown-expand input',
	      openIn: 'dropdown',
	      expandInput: true, // expand input
	      source: function source(query, render) {
	        var results = [];
	        if (query.length === 0) {
	          render(results);
	          return;
	        }
	        // Find matched items
	        for (var i = 0; i < fruits.length; i += 1) {
	          if (fruits[i].toLowerCase().indexOf(query.toLowerCase()) >= 0) { results.push(fruits[i]); }
	        }
	        // Render items by passing array with result items
	        render(results);
	      },
	    });

	    // Dropdown with all values
	    self.autocompleteDropdownAll = app.autocomplete.create({
	      inputEl: '#autocomplete-dropdown-all input',
	      openIn: 'dropdown',
	      source: function source(query, render) {
	        var results = [];
	        // Find matched items
	        for (var i = 0; i < fruits.length; i += 1) {
	          if (fruits[i].toLowerCase().indexOf(query.toLowerCase()) >= 0) { results.push(fruits[i]); }
	        }
	        // Render items by passing array with result items
	        render(results);
	      },
	    });

	    // Dropdown with placeholder
	    self.autocompleteDropdownPlaceholder = app.autocomplete.create({
	      inputEl: '#autocomplete-dropdown-placeholder input',
	      openIn: 'dropdown',
	      dropdownPlaceholderText: 'Try to type "Apple"',
	      source: function source(query, render) {
	        var results = [];
	        if (query.length === 0) {
	          render(results);
	          return;
	        }
	        // Find matched items
	        for (var i = 0; i < fruits.length; i += 1) {
	          if (fruits[i].toLowerCase().indexOf(query.toLowerCase()) >= 0) { results.push(fruits[i]); }
	        }
	        // Render items by passing array with result items
	        render(results);
	      },
	    });

	    // Dropdown with typeahead
	    self.autocompleteDropdownTypeahead = app.autocomplete.create({
	      inputEl: '#autocomplete-dropdown-typeahead input',
	      openIn: 'dropdown',
	      dropdownPlaceholderText: 'Try to type "Pineapple"',
	      typeahead: true,
	      source: function source(query, render) {
	        var results = [];
	        if (query.length === 0) {
	          render(results);
	          return;
	        }
	        // Find matched items
	        for (var i = 0; i < fruits.length; i += 1) {
	          if (fruits[i].toLowerCase().indexOf(query.toLowerCase()) === 0) { results.push(fruits[i]); }
	        }
	        // Render items by passing array with result items
	        render(results);
	      },
	    });

	    // Dropdown with ajax data
	    self.autocompleteDropdownAjax = app.autocomplete.create({
	      inputEl: '#autocomplete-dropdown-ajax input',
	      openIn: 'dropdown',
	      preloader: true, // enable preloader
	      /* If we set valueProperty to "id" then input value on select will be set according to this property */
	      valueProperty: 'name', // object's "value" property name
	      textProperty: 'name', // object's "text" property name
	      limit: 20, // limit to 20 results
	      dropdownPlaceholderText: 'Try "JavaScript"',
	      source: function source(query, render) {
	        var autocomplete = this;
	        var results = [];
	        if (query.length === 0) {
	          render(results);
	          return;
	        }
	        // Show Preloader
	        autocomplete.preloaderShow();

	        // Do Ajax request to Autocomplete data
	        app.request({
	          url: './js/autocomplete-languages.json',
	          method: 'GET',
	          dataType: 'json',
	          // send "query" to server. Useful in case you generate response dynamically
	          data: {
	            query: query,
	          },
	          success: function success(data) {
	          // Find matched items
	            for (var i = 0; i < data.length; i += 1) {
	              if (data[i].name.toLowerCase().indexOf(query.toLowerCase()) >= 0) { results.push(data[i]); }
	            }
	            // Hide Preoloader
	            autocomplete.preloaderHide();
	            // Render items by passing array with result items
	            render(results);
	          },
	        });
	      },
	    });

	    // Dropdown with ajax data
	    self.autocompleteDropdownAjaxTypeahead = app.autocomplete.create({
	      inputEl: '#autocomplete-dropdown-ajax-typeahead input',
	      openIn: 'dropdown',
	      preloader: true, // enable preloader
	      /* If we set valueProperty to "id" then input value on select will be set according to this property */
	      valueProperty: 'name', // object's "value" property name
	      textProperty: 'name', // object's "text" property name
	      limit: 20, // limit to 20 results
	      typeahead: true,
	      dropdownPlaceholderText: 'Try "JavaScript"',
	      source: function source(query, render) {
	        var autocomplete = this;
	        var results = [];
	        if (query.length === 0) {
	          render(results);
	          return;
	        }
	        // Show Preloader
	        autocomplete.preloaderShow();

	        // Do Ajax request to Autocomplete data
	        app.request({
	          url: './js/autocomplete-languages.json',
	          method: 'GET',
	          dataType: 'json',
	          // send "query" to server. Useful in case you generate response dynamically
	          data: {
	            query: query,
	          },
	          success: function success(data) {
	          // Find matched items
	            for (var i = 0; i < data.length; i += 1) {
	              if (data[i].name.toLowerCase().indexOf(query.toLowerCase()) === 0) { results.push(data[i]); }
	            }
	            // Hide Preoloader
	            autocomplete.preloaderHide();
	            // Render items by passing array with result items
	            render(results);
	          },
	        });
	      },
	    });

	    // Simple Standalone
	    self.autocompleteStandaloneSimple = app.autocomplete.create({
	      openIn: 'page', // open in page
	      openerEl: '#autocomplete-standalone a', // link that opens autocomplete
	      closeOnSelect: true, // go back after we select something
	      source: function source(query, render) {
	        var results = [];
	        if (query.length === 0) {
	          render(results);
	          return;
	        }
	        // Find matched items
	        for (var i = 0; i < fruits.length; i += 1) {
	          if (fruits[i].toLowerCase().indexOf(query.toLowerCase()) >= 0) { results.push(fruits[i]); }
	        }
	        // Render items by passing array with result items
	        render(results);
	      },
	      on: {
	        change: function change(value) {
	          // Add item text value to item-after
	          $('#autocomplete-standalone').find('.item-after').text(value[0]);
	          // Add item value to input value
	          $('#autocomplete-standalone').find('input').val(value[0]);
	        },
	      },
	    });

	    // Standalone Popup
	    self.autocompleteStandalonePopup = app.autocomplete.create({
	      openIn: 'popup', // open in page
	      openerEl: '#autocomplete-standalone-popup a', // link that opens autocomplete
	      closeOnSelect: true, // go back after we select something
	      source: function source(query, render) {
	        var results = [];
	        if (query.length === 0) {
	          render(results);
	          return;
	        }
	        // Find matched items
	        for (var i = 0; i < fruits.length; i += 1) {
	          if (fruits[i].toLowerCase().indexOf(query.toLowerCase()) >= 0) { results.push(fruits[i]); }
	        }
	        // Render items by passing array with result items
	        render(results);
	      },
	      on: {
	        change: function change(value) {
	          // Add item text value to item-after
	          $('#autocomplete-standalone-popup').find('.item-after').text(value[0]);
	          // Add item value to input value
	          $('#autocomplete-standalone-popup').find('input').val(value[0]);
	        },
	      },
	    });

	    // Multiple Standalone
	    self.autocompleteStandaloneMultiple = app.autocomplete.create({
	      openIn: 'page', // open in page
	      openerEl: '#autocomplete-standalone-multiple a', // link that opens autocomplete
	      multiple: true, // allow multiple values
	      source: function source(query, render) {
	        var results = [];
	        if (query.length === 0) {
	          render(results);
	          return;
	        }
	        // Find matched items
	        for (var i = 0; i < fruits.length; i += 1) {
	          if (fruits[i].toLowerCase().indexOf(query.toLowerCase()) >= 0) { results.push(fruits[i]); }
	        }
	        // Render items by passing array with result items
	        render(results);
	      },
	      on: {
	        change: function change(value) {
	          // Add item text value to item-after
	          $('#autocomplete-standalone-multiple').find('.item-after').text(value.join(', '));
	          // Add item value to input value
	          $('#autocomplete-standalone-multiple').find('input').val(value.join(', '));
	        },
	      },
	    });

	    // Standalone With Ajax
	    self.autocompleteStandaloneAjax = app.autocomplete.create({
	      openIn: 'page', // open in page
	      openerEl: '#autocomplete-standalone-ajax a', // link that opens autocomplete
	      multiple: true, // allow multiple values
	      valueProperty: 'id', // object's "value" property name
	      textProperty: 'name', // object's "text" property name
	      limit: 50,
	      preloader: true, // enable preloader
	      source: function source(query, render) {
	        var autocomplete = this;
	        var results = [];
	        if (query.length === 0) {
	          render(results);
	          return;
	        }
	        // Show Preloader
	        autocomplete.preloaderShow();
	        // Do Ajax request to Autocomplete data
	        app.request({
	          url: './js/autocomplete-languages.json',
	          method: 'GET',
	          dataType: 'json',
	          // send "query" to server. Useful in case you generate response dynamically
	          data: {
	            query: query,
	          },
	          success: function success(data) {
	          // Find matched items
	            for (var i = 0; i < data.length; i += 1) {
	              if (data[i].name.toLowerCase().indexOf(query.toLowerCase()) >= 0) { results.push(data[i]); }
	            }
	            // Hide Preoloader
	            autocomplete.preloaderHide();
	            // Render items by passing array with result items
	            render(results);
	          },
	        });
	      },
	      on: {
	        change: function change(value) {
	          var itemText = [];
	          var inputValue = [];
	          for (var i = 0; i < value.length; i += 1) {
	            itemText.push(value[i].name);
	            inputValue.push(value[i].id);
	          }
	          // Add item text value to item-after
	          $('#autocomplete-standalone-ajax').find('.item-after').text(itemText.join(', '));
	          // Add item value to input value
	          $('#autocomplete-standalone-ajax').find('input').val(inputValue.join(', '));
	        },
	      },
	    });

	    // Searchbar Autocomplete
	    self.autocompleteSearchbar = app.autocomplete.create({
	      openIn: 'dropdown',
	      inputEl: '#searchbar-autocomplete input[type="search"]',
	      dropdownPlaceholderText: 'Type "Apple"',
	      source: function source(query, render) {
	        var results = [];
	        if (query.length === 0) {
	          render(results);
	          return;
	        }
	        // Find matched items
	        for (var i = 0; i < fruits.length; i += 1) {
	          if (fruits[i].toLowerCase().indexOf(query.toLowerCase()) >= 0) { results.push(fruits[i]); }
	        }
	        // Render items by passing array with result items
	        render(results);
	      },
	    });
	    self.searchbar = app.searchbar.create({
	      el: '#searchbar-autocomplete',
	      customSearch: true,
	      on: {
	        search: function search(sb, query) {
	          console.log(query);
	        },
	      },
	    });
	  };

	  return defaultExport;
	}(react.Component));

	function Badge$1 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { sliding: true, backLink: "Back", title: "Badge" },
	      react.createElement( NavRight, null,
	        react.createElement( Link, { iconOnly: true },
	          react.createElement( Icon, { ios: "f7:person_round_fill", aurora: "f7:person_round_fill", md: "material:person" },
	            react.createElement( Badge, { color: "red" }, "5")
	          )
	        )
	      )
	    ),
	    react.createElement( Toolbar$2, { bottom: true, tabbar: true, labels: true },
	      react.createElement( Link, { tabLink: "#tab-1", tabLinkActive: true },
	        react.createElement( Icon, { ios: "f7:email_fill", aurora: "f7:email_fill", md: "material:email" },
	          react.createElement( Badge, { color: "green" }, "5")
	        ),
	        react.createElement( 'span', { className: "tabbar-label" }, "Inbox")
	      ),
	      react.createElement( Link, { tabLink: "#tab-2" },
	        react.createElement( Icon, { ios: "f7:calendar_fill", aurora: "f7:calendar_fill", md: "material:today" },
	          react.createElement( Badge, { color: "red" }, "7")
	        ),
	        react.createElement( 'span', { className: "tabbar-label" }, "Calendar")
	      ),
	      react.createElement( Link, { tabLink: "#tab-3" },
	        react.createElement( Icon, { ios: "f7:cloud_upload_fill", aurora: "f7:cloud_upload_fill", md: "material:file_upload" },
	          react.createElement( Badge, { color: "red" }, "1")
	        ),
	        react.createElement( 'span', { className: "tabbar-label" }, "Upload")
	      )
	    ),

	    react.createElement( List, null,
	      react.createElement( ListItem, { title: "Foo Bar", badge: "0" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { title: "Ivan Petrov", badge: "CEO", badgeColor: "blue" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { title: "John Doe", badge: "5", badgeColor: "green" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { title: "Jane Doe", badge: "NEW", badgeColor: "orange" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      )
	    )
	  )
	); }

	function Buttons () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Buttons", backLink: "Back" }),

	    react.createElement( BlockTitle, null, "Usual Buttons" ),
	    react.createElement( Block, null,
	      react.createElement( Row, null,
	        react.createElement( Col, null,
	          react.createElement( Button, null, "Button" )
	        ),
	        react.createElement( Col, null,
	          react.createElement( Button, null, "Button" )
	        ),
	        react.createElement( Col, null,
	          react.createElement( Button, { round: true }, "Round")
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Fill Buttons" ),
	    react.createElement( Block, null,
	      react.createElement( Row, null,
	        react.createElement( Col, null,
	          react.createElement( Button, { fill: true }, "Button")
	        ),
	        react.createElement( Col, null,
	          react.createElement( Button, { fill: true }, "Button")
	        ),
	        react.createElement( Col, null,
	          react.createElement( Button, { fill: true, round: true }, "Round")
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Outline Buttons" ),
	    react.createElement( Block, null,
	      react.createElement( Row, null,
	        react.createElement( Col, null,
	          react.createElement( Button, { outline: true }, "Button")
	        ),
	        react.createElement( Col, null,
	          react.createElement( Button, { outline: true }, "Button")
	        ),
	        react.createElement( Col, null,
	          react.createElement( Button, { outline: true, round: true }, "Round")
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Raised Buttons" ),
	    react.createElement( Block, null,
	      react.createElement( Row, { tag: "p" },
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { raised: true }, "Button")
	        ),
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { raised: true, fill: true }, "Fill")
	        ),
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { raised: true, outline: true }, "Outline")
	        )
	      ),
	      react.createElement( Row, { tag: "p" },
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { raised: true, round: true }, "Round")
	        ),
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { raised: true, fill: true, round: true }, "Fill")
	        ),
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { raised: true, outline: true, round: true }, "Outline")
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Segmented" ),
	    react.createElement( Block, null,
	      react.createElement( Segmented, { raised: true, tag: "p" },
	        react.createElement( Button, null, "Button" ),
	        react.createElement( Button, null, "Button" ),
	        react.createElement( Button, { active: true }, "Active")
	      ),
	      react.createElement( Segmented, { raised: true, tag: "p" },
	        react.createElement( Button, { outline: true }, "Outline"),
	        react.createElement( Button, { outline: true }, "Outline"),
	        react.createElement( Button, { outline: true, active: true }, "Active")
	      ),
	      react.createElement( Segmented, { raised: true, round: true, tag: "p" },
	        react.createElement( Button, { round: true }, "Button"),
	        react.createElement( Button, { round: true }, "Button"),
	        react.createElement( Button, { round: true, active: true }, "Active")
	      ),
	      react.createElement( Segmented, { raised: true, round: true, tag: "p" },
	        react.createElement( Button, { round: true, outline: true }, "Outline"),
	        react.createElement( Button, { round: true, outline: true }, "Outline"),
	        react.createElement( Button, { round: true, outline: true, active: true }, "Active")
	      )
	    ),

	    react.createElement( BlockTitle, null, "Large Buttons" ),
	    react.createElement( Block, null,
	      react.createElement( Row, { tag: "p" },
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { large: true }, "Button")
	        ),
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { large: true, fill: true }, "Fill")
	        )
	      ),
	      react.createElement( Row, { tag: "p" },
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { large: true, raised: true }, "Raised")
	        ),
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { large: true, raised: true, fill: true }, "Raised Fill")
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Small Buttons" ),
	    react.createElement( Block, null,
	      react.createElement( Row, { tag: "p" },
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { large: true, small: true }, "Button")
	        ),
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { large: true, small: true, outline: true }, "Outline")
	        ),
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { large: true, small: true, fill: true }, "Fill")
	        )
	      ),
	      react.createElement( Row, { tag: "p" },
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { large: true, small: true, round: true }, "Button")
	        ),
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { large: true, small: true, outline: true, round: true }, "Outline")
	        ),
	        react.createElement( Col, { tag: "span" },
	          react.createElement( Button, { large: true, small: true, fill: true, round: true }, "Fill")
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Color Buttons" ),
	    react.createElement( Block, null,
	      react.createElement( Row, null,
	        react.createElement( Col, null,
	          react.createElement( Button, { color: "red" }, "Red")
	        ),
	        react.createElement( Col, null,
	          react.createElement( Button, { color: "green" }, "Green")
	        ),
	        react.createElement( Col, null,
	          react.createElement( Button, { color: "blue" }, "Blue")
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Color Fill Buttons" ),
	    react.createElement( Block, null,
	      react.createElement( Row, null,
	        react.createElement( Col, null,
	          react.createElement( Button, { fill: true, color: "red" }, "Red")
	        ),
	        react.createElement( Col, null,
	          react.createElement( Button, { fill: true, color: "green" }, "Green")
	        ),
	        react.createElement( Col, null,
	          react.createElement( Button, { fill: true, color: "blue" }, "Blue")
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "List-Block Buttons" ),
	    react.createElement( List, { inset: true },
	      react.createElement( ListButton, { title: "List Button 1" }),
	      react.createElement( ListButton, { title: "List Button 2" }),
	      react.createElement( ListButton, { title: "List Button 3" })
	    ),
	    react.createElement( List, { inset: true },
	      react.createElement( ListButton, { title: "Large Red Button", color: "red" })
	    )
	  )
	); }

	var defaultExport$4 = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, { onPageInit: this.onPageInit.bind(this), onPageBeforeRemove: this.onPageBeforeRemove.bind(this) },
	        react.createElement( Navbar$2, { title: "Calendar", backLink: "Back" }),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Calendar is a touch optimized component that provides an easy way to handle dates." ),
	          react.createElement( 'p', null, "Calendar could be used as inline component or as overlay. Overlay Calendar will be automatically converted to Popover on tablets (iPad)." )
	        ),

	        react.createElement( BlockTitle, null, "Default setup" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, { type: "datepicker", placeholder: "Your birth date", readonly: true })
	        ),

	        react.createElement( BlockTitle, null, "Custom date format" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, { type: "datepicker", placeholder: "Select date", readonly: true, calendarParams: {dateFormat: 'DD, MM dd, yyyy'} })
	        ),

	        react.createElement( BlockTitle, null, "Multiple Values" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, { type: "datepicker", placeholder: "Select multiple dates", readonly: true, calendarParams: { dateFormat: 'M dd yyyy', multiple: true } })
	        ),

	        react.createElement( BlockTitle, null, "Range Picker" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, { type: "datepicker", placeholder: "Select date range", readonly: true, calendarParams: { dateFormat: 'M dd yyyy', rangePicker: true } })
	        ),

	        react.createElement( BlockTitle, null, "Open in Modal" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, { type: "datepicker", placeholder: "Select date", readonly: true, calendarParams: {openIn: 'customModal', header: true, footer: true, dateFormat: 'MM dd yyyy'} })
	        ),

	        react.createElement( BlockTitle, null, "Calendar Page" ),
	        react.createElement( List, null,
	          react.createElement( ListItem, {
	            title: "Open Calendar Page", link: "/calendar-page/" })
	        ),

	        react.createElement( BlockTitle, null, "Inline with custom toolbar" ),
	        react.createElement( Block, { className: "no-padding" },
	          react.createElement( 'div', { id: "demo-calendar-inline-container" })
	        ),

	        react.createElement( BlockTitle, null, "Jalali Calendar" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, { type: "datepicker", placeholder: "Your birth date in Jalali", readonly: true, calendarParams: {calendarType: 'jalali'} })
	        )
	      )
	    );
	  };
	  defaultExport.prototype.onPageInit = function onPageInit (e) {
	    var self = this;
	    var app = self.$f7;
	    var $ = self.$$;

	    // Inline with custom toolbar
	    var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
	    self.calendarInline = app.calendar.create({
	      containerEl: '#demo-calendar-inline-container',
	      value: [new Date()],
	      renderToolbar: function renderToolbar() {
	        return "\n          <div class=\"toolbar calendar-custom-toolbar no-shadow\">\n            <div class=\"toolbar-inner\">\n              <div class=\"left\">\n                <a href=\"#\" class=\"link icon-only\"><i class=\"icon icon-back\"></i></a>\n              </div>\n              <div class=\"center\"></div>\n              <div class=\"right\">\n                <a href=\"#\" class=\"link icon-only\"><i class=\"icon icon-forward\"></i></a>\n              </div>\n            </div>\n          </div>\n        ".trim();
	      },
	      on: {
	        init: function init(c) {
	          $('.calendar-custom-toolbar .center').text(((monthNames[c.currentMonth]) + ", " + (c.currentYear)));
	          $('.calendar-custom-toolbar .left .link').on('click', function () {
	            self.calendarInline.prevMonth();
	          });
	          $('.calendar-custom-toolbar .right .link').on('click', function () {
	            self.calendarInline.nextMonth();
	          });
	        },
	        monthYearChangeStart: function monthYearChangeStart(c) {
	          $('.calendar-custom-toolbar .center').text(((monthNames[c.currentMonth]) + ", " + (c.currentYear)));
	        },
	      },
	    });
	  };
	  defaultExport.prototype.onPageBeforeRemove = function onPageBeforeRemove () {
	    var self = this;
	    self.calendarInline.destroy();
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$5 = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);

	    var date = new Date();
	    var year = date.getFullYear();
	    var month = date.getMonth();
	    var day = date.getDate();

	    this.state = {
	      today: new Date(year, month, day),
	      events: [
	        {
	          date: new Date(year, month, day),
	          hours: 12,
	          minutes: 30,
	          title: 'Meeting with Vladimir',
	          color: '#2196f3',
	        },
	        {
	          date: new Date(year, month, day),
	          hours: 18,
	          minutes: 0,
	          title: 'Shopping',
	          color: '#4caf50',
	        },
	        {
	          date: new Date(year, month, day),
	          hours: 21,
	          minutes: 0,
	          title: 'Gym',
	          color: '#e91e63',
	        },
	        {
	          date: new Date(year, month, day + 2),
	          hours: 16,
	          minutes: 0,
	          title: 'Pay loan',
	          color: '#2196f3',
	        },
	        {
	          date: new Date(year, month, day + 2),
	          hours: 21,
	          minutes: 0,
	          title: 'Gym',
	          color: '#ff9800',
	        } ],
	      eventItems: [],
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, { onPageInit: this.onPageInit.bind(this), onPageBeforeRemove: this.onPageBeforeRemove.bind(this) },
	        react.createElement( Navbar$2, { backLink: "Back", noShadow: true },
	          react.createElement( NavTitle, { className: "navbar-calendar-title" })
	        ),
	        react.createElement( Block, {
	          id: "calendar", strong: true, className: "no-padding no-margin no-hairline-top" }),
	        react.createElement( List, {
	          id: "calendar-events", noHairlines: true, className: "no-margin no-safe-area-left" },
	          this.state.eventItems.map(function (item, index) { return (
	            react.createElement( ListItem, {
	              key: index, title: item.title, after: item.time },
	              react.createElement( 'div', { class: "event-color", style: {'background-color': item.color}, slot: "root-start" })
	            )
	          ); }),
	          this.state.eventItems.length === 0 && (
	            react.createElement( ListItem, null,
	              react.createElement( 'span', { className: "text-color-gray", slot: "title" }, "No events for this day")
	            )
	          )
	        )
	      )
	    );
	  };
	  defaultExport.prototype.renderEvents = function renderEvents (calendar) {
	    var self = this;
	    var currentDate = calendar.value[0];
	    var currentEvents = self.state.events
	      .filter(function (event) { return (
	        event.date.getTime() >= currentDate.getTime() &&
	        event.date.getTime() < currentDate.getTime() + 24 * 60 * 60 * 1000
	      ); });

	    var eventItems = [];
	    if (currentEvents.length) {
	      currentEvents.forEach(function (event) {
	        var hours = event.date.getHours();
	        var minutes = event.date.getMinutes();
	        if (minutes < 10) { minutes = "0" + minutes; }
	        eventItems.push({
	          title: event.title,
	          time: (hours + ":" + minutes),
	          color: event.color,
	        });
	      });
	    }
	    self.setState({
	      eventItems: eventItems,
	    });
	  };
	  defaultExport.prototype.onPageInit = function onPageInit (e, page) {
	    var self = this;
	    var app = self.$f7;
	    var $ = self.$$;
	    var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
	    self.calendar = app.calendar.create({
	      containerEl: '#calendar',
	      toolbar: false,
	      value: [self.state.today],
	      events: self.state.events,
	      on: {
	        init: function init(calendar) {
	          $('.navbar-calendar-title').text(((monthNames[calendar.currentMonth]) + ", " + (calendar.currentYear)));
	          app.navbar.size(app.navbar.getElByPage(page.el));
	          calendar.$el.addClass('no-safe-area-right');
	          self.renderEvents(calendar);
	        },
	        monthYearChangeStart: function monthYearChangeStart(calendar) {
	          $('.navbar-calendar-title').text(((monthNames[calendar.currentMonth]) + ", " + (calendar.currentYear)));
	          app.navbar.size(app.navbar.getElByPage(page.el));
	        },
	        change: function change(calendar) {
	          self.renderEvents(calendar);
	        },
	      },
	    });
	  };
	  defaultExport.prototype.onPageBeforeRemove = function onPageBeforeRemove () {
	    var self = this;
	    self.calendar.destroy();
	  };

	  return defaultExport;
	}(react.Component));

	function Cards () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Cards", backLink: "Back" }),

	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Cards are a great way to contain and organize your information, especially when combined with List Views. Cards can contain unique related data, like for example photos, text or links about a particular subject. Cards are typically an entry point to more complex and detailed information." )
	    ),
	    react.createElement( BlockTitle, null, "Simple Cards" ),
	    react.createElement( Card$1, {
	      content: "This is a simple card with plain text, but cards can also contain their own header, footer, list view, image, or any other element." }),
	    react.createElement( Card$1, {
	      title: "Card header", content: "Card with header and footer. Card headers are used to display card titles and footers for additional information or just for custom actions.", footer: "Card footer" }),
	    react.createElement( Card$1, {
	      content: "Another card. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse feugiat sem est, non tincidunt ligula volutpat sit amet. Mauris aliquet magna justo. " }),

	    react.createElement( BlockTitle, null, "Outline Cards" ),
	    react.createElement( Card$1, {
	      outline: true, content: "This is a simple card with plain text, but cards can also contain their own header, footer, list view, image, or any other element." }),
	    react.createElement( Card$1, {
	      outline: true, title: "Card header", content: "Card with header and footer. Card headers are used to display card titles and footers for additional information or just for custom actions.", footer: "Card footer" }),
	    react.createElement( Card$1, {
	      outline: true, content: "Another card. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse feugiat sem est, non tincidunt ligula volutpat sit amet. Mauris aliquet magna justo. " }),

	    react.createElement( BlockTitle, null, "Styled Cards" ),
	    react.createElement( Card$1, { className: "demo-card-header-pic" },
	      react.createElement( CardHeader, {
	        className: "no-border", valign: "bottom", style: { backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-1000x600-3.jpg)' } }, "Journey To Mountains"),
	      react.createElement( CardContent, null,
	        react.createElement( 'p', { className: "date" }, "Posted on January 21, 2015"),
	        react.createElement( 'p', null, "Quisque eget vestibulum nulla. Quisque quis dui quis ex ultricies efficitur vitae non felis. Phasellus quis nibh hendrerit..." )
	      ),
	      react.createElement( CardFooter, null,
	        react.createElement( Link, null, "Like" ),
	        react.createElement( Link, null, "Read more" )
	      )
	    ),
	    react.createElement( Card$1, { className: "demo-card-header-pic" },
	      react.createElement( CardHeader, {
	        className: "no-border", valign: "bottom", style: { backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-1000x600-6.jpg)' } }, "Journey To Mountains"),
	      react.createElement( CardContent, null,
	        react.createElement( 'p', { className: "date" }, "Posted on January 21, 2015"),
	        react.createElement( 'p', null, "Quisque eget vestibulum nulla. Quisque quis dui quis ex ultricies efficitur vitae non felis. Phasellus quis nibh hendrerit..." )
	      ),
	      react.createElement( CardFooter, null,
	        react.createElement( Link, null, "Like" ),
	        react.createElement( Link, null, "Read more" )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Facebook Cards" ),
	    react.createElement( Card$1, { className: "demo-facebook-card" },
	      react.createElement( CardHeader, { className: "no-border" },
	        react.createElement( 'div', { className: "demo-facebook-avatar" }, react.createElement( 'img', { src: "https://cdn.framework7.io/placeholder/people-68x68-1.jpg", width: "34", height: "34" })),
	        react.createElement( 'div', { className: "demo-facebook-name" }, "John Doe"),
	        react.createElement( 'div', { className: "demo-facebook-date" }, "Monday at 3:47 PM")
	      ),
	      react.createElement( CardContent, { padding: false },
	        react.createElement( 'img', { src: "https://cdn.framework7.io/placeholder/nature-1000x700-8.jpg", width: "100%" })
	      ),
	      react.createElement( CardFooter, { className: "no-border" },
	        react.createElement( Link, null, "Like" ),
	        react.createElement( Link, null, "Comment" ),
	        react.createElement( Link, null, "Share" )
	      )
	    ),
	    react.createElement( Card$1, { className: "demo-facebook-card" },
	      react.createElement( CardHeader, { className: "no-border" },
	        react.createElement( 'div', { className: "demo-facebook-avatar" }, react.createElement( 'img', { src: "https://cdn.framework7.io/placeholder/people-68x68-1.jpg", width: "34", height: "34" })),
	        react.createElement( 'div', { className: "demo-facebook-name" }, "John Doe"),
	        react.createElement( 'div', { className: "demo-facebook-date" }, "Monday at 2:15 PM")
	      ),
	      react.createElement( CardContent, null,
	        react.createElement( 'p', null, "What a nice photo i took yesterday!" ), react.createElement( 'img', { src: "https://cdn.framework7.io/placeholder/nature-1000x700-8.jpg", width: "100%" }),
	        react.createElement( 'p', { className: "likes" }, "Likes: 112 &nbsp;&nbsp; Comments: 43")
	      ),
	      react.createElement( CardFooter, { className: "no-border" },
	        react.createElement( Link, null, "Like" ),
	        react.createElement( Link, null, "Comment" ),
	        react.createElement( Link, null, "Share" )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Cards With List View" ),
	    react.createElement( Card$1, null,
	      react.createElement( CardContent, { padding: false },
	        react.createElement( List, null,
	          react.createElement( ListItem, { link: "#" }, "Link 1"),
	          react.createElement( ListItem, { link: "#" }, "Link 2"),
	          react.createElement( ListItem, { link: "#" }, "Link 3"),
	          react.createElement( ListItem, { link: "#" }, "Link 4"),
	          react.createElement( ListItem, { link: "#" }, "Link 5")
	        )
	      )
	    ),
	    react.createElement( Card$1, { title: "New Releases:" },
	      react.createElement( CardContent, { padding: false },
	        react.createElement( List, { 'medial-list': true },
	          react.createElement( ListItem, {
	            title: "Yellow Submarine", subtitle: "Beatles" },
	            react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/fashion-88x88-4.jpg", width: "44" })
	          ),
	          react.createElement( ListItem, {
	            title: "Don't Stop Me Now", subtitle: "Queen" },
	            react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/fashion-88x88-5.jpg", width: "44" })
	          ),
	          react.createElement( ListItem, {
	            title: "Billie Jean", subtitle: "Michael Jackson" },
	            react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/fashion-88x88-6.jpg", width: "44" })
	          )
	        )
	      ),
	      react.createElement( CardFooter, null,
	        react.createElement( 'span', null, "January 20, 2015" ),
	        react.createElement( 'span', null, "5 comments" )
	      )
	    )
	  )
	); }

	function CardsExpandable () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Cards Expandable", backLink: "Back" }),

	    react.createElement( Block, null,
	      react.createElement( 'p', null, "In addition to usual ", react.createElement( 'a', { href: "/cards/" }, "Cards"), " there are also Expandable Cards that allow to store more information and illustrations about particular subject." )
	    ),

	    react.createElement( 'div', { className: "demo-expandable-cards" },
	      react.createElement( Card$1, { expandable: true },
	        react.createElement( CardContent, { padding: false },
	          react.createElement( 'div', { className: "bg-color-red", style: {height: '300px'} },
	            react.createElement( CardHeader, { textColor: "white", className: "display-block" }, "Framework7 ", react.createElement( 'br', null ),
	              react.createElement( 'small', { style: {opacity: 0.7} }, "Build Mobile Apps")
	            ),
	            react.createElement( Link, { cardClose: true, color: "white", className: "card-opened-fade-in", style: {position: 'absolute', right: '15px', top: '15px'}, iconF7: "close_round_fill" })
	          ),
	          react.createElement( 'div', { className: "card-content-padding" },
	            react.createElement( 'p', null, "Framework7 - is a free and open source HTML mobile framework to develop hybrid mobile apps or web apps with iOS or Android (Material) native look and feel. It is also an indispensable prototyping apps tool to show working app prototype as soon as possible in case you need to. Framework7 is created by Vladimir Kharlampidi (iDangero.us)." ),
	            react.createElement( 'p', null, "The main approach of the Framework7 is to give you an opportunity to create iOS and Android (Material) apps with HTML, CSS and JavaScript easily and clear. Framework7 is full of freedom. It doesn't limit your imagination or offer ways of any solutions somehow. Framework7 gives you freedom!" ),
	            react.createElement( 'p', null, "Framework7 is not compatible with all platforms. It is focused only on iOS and Android (Material) to bring the best experience and simplicity." ),
	            react.createElement( 'p', null, "Framework7 is definitely for you if you decide to build iOS and Android hybrid app (Cordova or PhoneGap) or web app that looks like and feels as great native iOS or Android (Material) apps." ),
	            react.createElement( 'p', null,
	              react.createElement( Button, { fill: true, round: true, large: true, cardClose: true, color: "red" }, "Close")
	            )
	          )
	        )
	      ),

	      react.createElement( Card$1, { expandable: true },
	        react.createElement( CardContent, { padding: false },
	          react.createElement( 'div', { className: "bg-color-yellow", style: {height: '300px'} },
	            react.createElement( CardHeader, { textColor: "black", className: "display-block" }, "Framework7 ", react.createElement( 'br', null ),
	              react.createElement( 'small', { style: {opacity: 0.7} }, "Build Mobile Apps")
	            ),
	            react.createElement( Link, { cardClose: true, color: "black", className: "card-opened-fade-in", style: {position: 'absolute', right: '15px', top: '15px'}, iconF7: "close_round_fill" })
	          ),
	          react.createElement( 'div', { className: "card-content-padding" },
	            react.createElement( 'p', null, "Framework7 - is a free and open source HTML mobile framework to develop hybrid mobile apps or web apps with iOS or Android (Material) native look and feel. It is also an indispensable prototyping apps tool to show working app prototype as soon as possible in case you need to. Framework7 is created by Vladimir Kharlampidi (iDangero.us)." ),
	            react.createElement( 'p', null, "The main approach of the Framework7 is to give you an opportunity to create iOS and Android (Material) apps with HTML, CSS and JavaScript easily and clear. Framework7 is full of freedom. It doesn't limit your imagination or offer ways of any solutions somehow. Framework7 gives you freedom!" ),
	            react.createElement( 'p', null, "Framework7 is not compatible with all platforms. It is focused only on iOS and Android (Material) to bring the best experience and simplicity." ),
	            react.createElement( 'p', null, "Framework7 is definitely for you if you decide to build iOS and Android hybrid app (Cordova or PhoneGap) or web app that looks like and feels as great native iOS or Android (Material) apps." ),
	            react.createElement( 'p', null,
	              react.createElement( Button, { fill: true, round: true, large: true, cardClose: true, color: "yellow", textColor: "black" }, "Close")
	            )
	          )
	        )
	      ),

	      react.createElement( Card$1, { expandable: true },
	        react.createElement( CardContent, { padding: false },
	          react.createElement( 'div', { style: {background: 'url(./img/beach.jpg) no-repeat center bottom', backgroundSize: 'cover', height: '240px'} }),
	          react.createElement( Link, { cardClose: true, color: "white", className: "card-opened-fade-in", style: {position: 'absolute', right: '15px', top: '15px'}, iconF7: "close_round_fill" }),
	          react.createElement( CardHeader, { style: {height: '60px'} }, "Beach, Goa"),
	          react.createElement( 'div', { className: "card-content-padding" },
	            react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam cursus rhoncus cursus. Etiam lorem est, consectetur vitae tempor a, volutpat eget purus. Duis urna lectus, vehicula at quam id, sodales dapibus turpis. Suspendisse potenti. Proin condimentum luctus nulla, et rhoncus ante rutrum eu. Maecenas ut tincidunt diam. Vestibulum lacinia dui ligula, sit amet pulvinar nisl blandit luctus. Vestibulum aliquam ligula nulla, tincidunt rhoncus tellus interdum at. Phasellus mollis ipsum at mollis tristique. Maecenas sit amet tempus justo. Duis dolor elit, mollis quis viverra quis, vehicula eu ante. Integer a molestie risus. Vestibulum eu sollicitudin massa, sit amet dictum sem. Aliquam nisi tellus, maximus eget placerat in, porta vel lorem. Aenean tempus sodales nisl in cursus. Curabitur tincidunt turpis in nisl ornare euismod eget at libero." ),
	            react.createElement( 'p', null, "Suspendisse ligula eros, congue in nulla pellentesque, imperdiet blandit sapien. Morbi nisi sem, efficitur a rutrum porttitor, feugiat vel enim. Fusce eget vehicula odio, et luctus neque. Donec mattis a nulla laoreet commodo. Integer eget hendrerit augue, vel porta libero. Morbi imperdiet, eros at ultricies rutrum, eros urna auctor enim, eget laoreet massa diam vitae lorem. Proin eget urna ultrices, semper ligula aliquam, dignissim eros. Donec vitae augue eu sapien tristique elementum a nec nulla. Aliquam erat volutpat. Curabitur condimentum, metus blandit lobortis fringilla, enim mauris venenatis neque, et venenatis lorem urna ut justo. Maecenas neque enim, congue ac tempor quis, tincidunt ut mi. Donec venenatis ante non consequat molestie. Quisque ut rhoncus ligula. Vestibulum sodales maximus justo sit amet ornare. Nullam pulvinar eleifend nisi sit amet molestie." ),
	            react.createElement( 'p', null,
	              react.createElement( Button, { fill: true, round: true, large: true, cardClose: true }, "Close")
	            )
	          )
	        )
	      ),

	      react.createElement( Card$1, { expandable: true },
	        react.createElement( CardContent, { padding: false },
	          react.createElement( 'div', { style: {background: 'url(./img/monkey.jpg) no-repeat center top', backgroundSize: 'cover', height: '400px'} },
	            react.createElement( CardHeader, { textColor: "white" }, "Monkeys"),
	            react.createElement( Link, { cardClose: true, color: "white", className: "card-opened-fade-in", style: {position: 'absolute', right: '15px', top: '15px'}, iconF7: "close_round_fill" })
	          ),
	          react.createElement( 'div', { className: "card-content-padding" },
	            react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam cursus rhoncus cursus. Etiam lorem est, consectetur vitae tempor a, volutpat eget purus. Duis urna lectus, vehicula at quam id, sodales dapibus turpis. Suspendisse potenti. Proin condimentum luctus nulla, et rhoncus ante rutrum eu. Maecenas ut tincidunt diam. Vestibulum lacinia dui ligula, sit amet pulvinar nisl blandit luctus. Vestibulum aliquam ligula nulla, tincidunt rhoncus tellus interdum at. Phasellus mollis ipsum at mollis tristique. Maecenas sit amet tempus justo. Duis dolor elit, mollis quis viverra quis, vehicula eu ante. Integer a molestie risus. Vestibulum eu sollicitudin massa, sit amet dictum sem. Aliquam nisi tellus, maximus eget placerat in, porta vel lorem. Aenean tempus sodales nisl in cursus. Curabitur tincidunt turpis in nisl ornare euismod eget at libero." ),
	            react.createElement( 'p', null, "Suspendisse ligula eros, congue in nulla pellentesque, imperdiet blandit sapien. Morbi nisi sem, efficitur a rutrum porttitor, feugiat vel enim. Fusce eget vehicula odio, et luctus neque. Donec mattis a nulla laoreet commodo. Integer eget hendrerit augue, vel porta libero. Morbi imperdiet, eros at ultricies rutrum, eros urna auctor enim, eget laoreet massa diam vitae lorem. Proin eget urna ultrices, semper ligula aliquam, dignissim eros. Donec vitae augue eu sapien tristique elementum a nec nulla. Aliquam erat volutpat. Curabitur condimentum, metus blandit lobortis fringilla, enim mauris venenatis neque, et venenatis lorem urna ut justo. Maecenas neque enim, congue ac tempor quis, tincidunt ut mi. Donec venenatis ante non consequat molestie. Quisque ut rhoncus ligula. Vestibulum sodales maximus justo sit amet ornare. Nullam pulvinar eleifend nisi sit amet molestie." ),
	            react.createElement( 'p', null,
	              react.createElement( Button, { fill: true, round: true, large: true, cardClose: true }, "Close")
	            )
	          )
	        )
	      )
	    )
	  )
	); }

	var defaultExport$6 = /*@__PURE__*/(function (superclass) {
	  function defaultExport() {
	    superclass.call(this);
	    this.state = {
	      movies: ['Movie 1'],
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.onMovieChange = function onMovieChange (e) {
	    var self = this;
	    var value = e.target.value;
	    var movies = self.state.movies;
	    if (e.target.checked) {
	      movies.push(value);
	    } else {
	      movies.splice(movies.indexOf(value), 1);
	    }
	    self.setState({ movies: movies });
	  };
	  defaultExport.prototype.onMoviesChange = function onMoviesChange (e) {
	    var self = this;
	    var movies = self.state.movies;
	    if (movies.length === 1 || movies.length === 0) {
	      movies = ['Movie 1', 'Movie 2'];
	    } else if (movies.length === 2) {
	      movies = [];
	    }
	    self.setState({ movies: movies });
	  };
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Checkbox", backLink: "Back" }),
	        react.createElement( BlockTitle, null, "Inline" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Lorem ", react.createElement( Checkbox$1, { name: "checkbox-1" }), " ipsum dolor sit amet, consectetur adipisicing elit. Alias beatae illo nihil aut eius commodi sint eveniet aliquid eligendi ", react.createElement( Checkbox$1, { name: "checkbox-2", defaultChecked: true }), " ad delectus impedit tempore nemo, enim vel praesentium consequatur nulla mollitia!" )
	        ),

	        react.createElement( BlockTitle, null, "Checkbox Group" ),
	        react.createElement( List, null,
	          react.createElement( ListItem, { checkbox: true, title: "Books", name: "demo-checkbox", defaultChecked: true }),
	          react.createElement( ListItem, { checkbox: true, title: "Movies", name: "demo-checkbox" }),
	          react.createElement( ListItem, { checkbox: true, title: "Food", name: "demo-checkbox" }),
	          react.createElement( ListItem, { checkbox: true, title: "Drinks", name: "demo-checkbox" })
	        ),

	        react.createElement( BlockTitle, null, "Indeterminate State" ),
	        react.createElement( List, null,
	          react.createElement( ListItem, {
	            checkbox: true, title: "Movies", name: "demo-checkbox", checked: this.state.movies.length === 2, indeterminate: this.state.movies.length === 1, onChange: function (e) { return this$1.onMoviesChange(e); } },
	            react.createElement( 'ul', { slot: "root" },
	              react.createElement( ListItem, {
	                checkbox: true, title: "Movie 1", name: "demo-checkbox", value: "Movie 1", checked: this.state.movies.indexOf('Movie 1') >= 0, onChange: function (e) { return this$1.onMovieChange(e); } }),
	              react.createElement( ListItem, {
	                checkbox: true, title: "Movie 2", name: "demo-checkbox", value: "Movie 2", checked: this.state.movies.indexOf('Movie 2') >= 0, onChange: function (e) { return this$1.onMovieChange(e); } })
	            )
	          )
	        ),

	        react.createElement( BlockTitle, null, "With Media Lists" ),
	        react.createElement( List, { mediaList: true },
	          react.createElement( ListItem, {
	            checkbox: true, defaultChecked: true, name: "demo-media-checkbox", title: "Facebook", after: "17:14", subtitle: "New messages from John Doe", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." }),
	          react.createElement( ListItem, {
	            checkbox: true, name: "demo-media-checkbox", title: "John Doe (via Twitter)", after: "17:11", subtitle: "John Doe (@_johndoe) mentioned you on Twitter!", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." }),
	          react.createElement( ListItem, {
	            checkbox: true, name: "demo-media-checkbox", title: "Facebook", after: "16:48", subtitle: "New messages from John Doe", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." }),
	          react.createElement( ListItem, {
	            checkbox: true, name: "demo-media-checkbox", title: "John Doe (via Twitter)", after: "15:32", subtitle: "John Doe (@_johndoe) mentioned you on Twitter!", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." })
	        )
	      )
	    );
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$7 = /*@__PURE__*/(function (superclass) {
	  function defaultExport() {
	    superclass.call(this);
	    this.deleteChipBound = this.deleteChip.bind(this);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Chips", backLink: "Back" }),
	        react.createElement( BlockTitle, null, "Chips With Text" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( Chip$1, { text: "Example Chip" }),
	          react.createElement( Chip$1, { text: "Another Chip" }),
	          react.createElement( Chip$1, { text: "One More Chip" }),
	          react.createElement( Chip$1, { text: "Fourth Chip" }),
	          react.createElement( Chip$1, { text: "Last One" })
	        ),
	        react.createElement( BlockTitle, null, "Outline Chips" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( Chip$1, { outline: true, text: "Example Chip" }),
	          react.createElement( Chip$1, { outline: true, text: "Another Chip" }),
	          react.createElement( Chip$1, { outline: true, text: "One More Chip" }),
	          react.createElement( Chip$1, { outline: true, text: "Fourth Chip" }),
	          react.createElement( Chip$1, { outline: true, text: "Last One" })
	        ),
	        react.createElement( BlockTitle, null, "Icon Chips" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( Chip$1, { text: "Add Contact", mediaBgColor: "blue" },
	            react.createElement( Icon, { slot: "media", ios: "f7:add_round", aurora: "f7:add_round", md: "material:add_circle" })
	          ),
	          react.createElement( Chip$1, { text: "London", mediaBgColor: "green" },
	            react.createElement( Icon, { slot: "media", ios: "f7:compass", aurora: "f7:compass", md: "material:location_on" })
	          ),
	          react.createElement( Chip$1, { text: "John Doe", mediaBgColor: "red" },
	            react.createElement( Icon, { slot: "media", ios: "f7:person", aurora: "f7:person", md: "material:person" })
	          )
	        ),
	        react.createElement( BlockTitle, null, "Contact Chips" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( Chip$1, { text: "Jane Doe" },
	            react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/people-100x100-9.jpg" })
	          ),
	          react.createElement( Chip$1, { text: "John Doe" },
	            react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/people-100x100-3.jpg" })
	          ),
	          react.createElement( Chip$1, { text: "Adam Smith" },
	            react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/people-100x100-7.jpg" })
	          ),
	          react.createElement( Chip$1, { text: "Jennifer", mediaBgColor: "pink", media: "J" }),
	          react.createElement( Chip$1, { text: "Chris", mediaBgColor: "yellow", mediaTextColor: "black", media: "C" }),
	          react.createElement( Chip$1, { text: "Kate", mediaBgColor: "red", media: "K" })
	        ),
	        react.createElement( BlockTitle, null, "Deletable Chips / Tags" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( Chip$1, { text: "Example Chip", deleteable: true, onClick: this.deleteChipBound }),
	          react.createElement( Chip$1, { text: "Chris", media: "C", mediaBgColor: "orange", textColor: "black", deleteable: true, onClick: this.deleteChipBound }),
	          react.createElement( Chip$1, { text: "Jane Doe", deleteable: true, onClick: this.deleteChipBound },
	            react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/people-100x100-9.jpg" })
	          ),
	          react.createElement( Chip$1, { text: "One More Chip", deleteable: true, onClick: this.deleteChipBound }),
	          react.createElement( Chip$1, { text: "Jennifer", mediaBgColor: "pink", media: "J", deleteable: true, onClick: this.deleteChipBound }),
	          react.createElement( Chip$1, { text: "Adam Smith", deleteable: true, onClick: this.deleteChipBound },
	            react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/people-100x100-7.jpg" })
	          )
	        ),
	        react.createElement( BlockTitle, null, "Color Chips" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( Chip$1, { text: "Red Chip", color: "red" }),
	          react.createElement( Chip$1, { text: "Green Chip", color: "green" }),
	          react.createElement( Chip$1, { text: "Blue Chip", color: "blue" }),
	          react.createElement( Chip$1, { text: "Orange Chip", color: "orange" }),
	          react.createElement( Chip$1, { text: "Pink Chip", color: "pink" }),
	          react.createElement( Chip$1, { outline: true, text: "Red Chip", color: "red" }),
	          react.createElement( Chip$1, { outline: true, text: "Green Chip", color: "green" }),
	          react.createElement( Chip$1, { outline: true, text: "Blue Chip", color: "blue" }),
	          react.createElement( Chip$1, { outline: true, text: "Orange Chip", color: "orange" }),
	          react.createElement( Chip$1, { outline: true, text: "Pink Chip", color: "pink" })
	        )
	      )
	    )
	  };
	  defaultExport.prototype.deleteChip = function deleteChip (e) {
	    var $$ = this.$$;
	    var app = this.$f7;
	    var target = e.target;
	    app.dialog.confirm('Do you want to delete this tiny demo Chip?', function () {
	      $$(target).parents('.chip').remove();
	    });
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$8 = /*@__PURE__*/(function (superclass) {
	  function defaultExport() {
	    superclass.call(this);
	    this.state = {
	      wheePickerValue: { hex: '#00ff00' },
	      spectrumPickerValue: { hex: '#ff0000' },
	      hsSpectrumPickerValue: { hex: '#ff0000' },
	      rgbPickerValue: { hex: '#0000ff' },
	      rgbaPickerValue: { hex: '#ff00ff' },
	      hsbPickerValue: { hex: '#00ff00' },
	      rgbBarsPickerValue: { hex: '#0000ff' },
	      rgbSlidersColorsPickerValue: { hex: '#ffff00' },
	      palettePickerValue: { hex: '#FFEBEE' },
	      proPickerValue: { hex: '#00ffff' },
	      inlinePickerValue: { hex: '#77ff66' },
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    var app = self.$f7;

	    self.colorPickerInline = app.colorPicker.create({
	      value: self.state.inlinePickerValue,
	      containerEl: '#demo-color-picker-inline',
	      modules: ['sb-spectrum', 'hsb-sliders', 'alpha-slider'],
	      on: {
	        change: function change(cp, value) {
	          self.setState({ inlinePickerValue: value });
	        },
	      },
	    });
	  };
	  defaultExport.prototype.componentWillUnmount = function componentWillUnmount () {
	    var self = this;
	    self.colorPickerInline.destroy();
	  };
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Color Picker", backLink: "Back" }),

	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Framework7 comes with ultimate modular Color Picker component that allows to create color picker with limitless combinations of color modules." )
	        ),

	        react.createElement( BlockTitle, null, "Color Wheel" ),
	        react.createElement( BlockHeader, null, "Minimal example with color wheel in Popover" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, {
	            type: "colorpicker", placeholder: "Color", readonly: true, value: this.state.wheePickerValue, onColorPickerChange: function (value) { return this$1.setState({wheePickerValue: value}); }, colorPickerParams: {
	              targetEl: '.wheel-picker-target'
	            } },
	            react.createElement( 'i', {
	              slot: "media", style: {backgroundColor: ("" + (this.state.wheePickerValue.hex))}, className: "icon demo-list-icon wheel-picker-target" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Saturation-Brightness Spectrum" ),
	        react.createElement( BlockHeader, null, "SB Spectrum + Hue Slider in Popover" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, {
	            type: "colorpicker", placeholder: "Color", readonly: true, value: this.state.spectrumPickerValue, onColorPickerChange: function (value) { return this$1.setState({spectrumPickerValue: value}); }, colorPickerParams: {
	              modules: ['sb-spectrum', 'hue-slider'],
	              targetEl: '.spectrum-picker-target'
	            } },
	            react.createElement( 'i', {
	              slot: "media", style: {backgroundColor: ("" + (this.state.spectrumPickerValue.hex))}, className: "icon demo-list-icon spectrum-picker-target" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Hue-Saturation Spectrum" ),
	        react.createElement( BlockHeader, null, "HS Spectrum + Brightness Slider in Popover" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, {
	            type: "colorpicker", placeholder: "Color", readonly: true, value: this.state.hsSpectrumPickerValue, onColorPickerChange: function (value) { return this$1.setState({hsSpectrumPickerValue: value}); }, colorPickerParams: {
	              modules: ['hs-spectrum', 'brightness-slider'],
	              targetEl: '.hs-spectrum-picker-target'
	            } },
	            react.createElement( 'i', {
	              slot: "media", style: {backgroundColor: ("" + (this.state.hsSpectrumPickerValue.hex))}, className: "icon demo-list-icon hs-spectrum-picker-target" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "RGB Sliders" ),
	        react.createElement( BlockHeader, null, "RGB sliders with labels and values in Popover" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, {
	            type: "colorpicker", placeholder: "Color", readonly: true, value: this.state.rgbPickerValue, onColorPickerChange: function (value) { return this$1.setState({rgbPickerValue: value}); }, colorPickerParams: {
	              modules: ['rgb-sliders'],
	              sliderValue: true,
	              sliderLabel: true,
	              targetEl: '.rgb-picker-target'
	            } },
	            react.createElement( 'i', {
	              slot: "media", style: {backgroundColor: ("" + (this.state.rgbPickerValue.hex))}, className: "icon demo-list-icon rgb-picker-target" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "RGBA Sliders" ),
	        react.createElement( BlockHeader, null, "RGB sliders + Alpha Slider with labels and values in Popover" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, {
	            type: "colorpicker", placeholder: "Color", readonly: true, value: this.state.rgbaPickerValue, onColorPickerChange: function (value) { return this$1.setState({rgbaPickerValue: value}); }, colorPickerParams: {
	              modules: ['rgb-sliders', 'alpha-slider'],
	              sliderValue: true,
	              sliderLabel: true,
	              targetEl: '.rgba-picker-target',
	              formatValue: function formatValue(value) {
	                return ("rgba(" + (value.rgba.join(', ')) + ")");
	              },
	            } },
	            react.createElement( 'i', {
	              slot: "media", style: {backgroundColor: this.state.rgbaPickerValue.rgba ? ("rgba(" + (this.state.rgbaPickerValue.rgba.join(', ')) + ")") : this.state.rgbaPickerValue.hex}, className: "icon demo-list-icon rgba-picker-target" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "HSB Sliders" ),
	        react.createElement( BlockHeader, null, "HSB sliders with labels and values in Popover" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, {
	            type: "colorpicker", placeholder: "Color", readonly: true, value: this.state.hsbPickerValue, onColorPickerChange: function (value) { return this$1.setState({hsbPickerValue: value}); }, colorPickerParams: {
	              modules: ['hsb-sliders'],
	              sliderValue: true,
	              sliderLabel: true,
	              targetEl: 'hsb-picker-target',
	              formatValue: function formatValue(value) {
	                return ("hsb(" + (value.hsb[0]) + ", " + (value.hsb[1] * 1000 / 10) + "%, " + (value.hsb[2] * 1000 / 10) + "%)")
	              },
	            } },
	            react.createElement( 'i', {
	              slot: "media", style: {backgroundColor: ("" + (this.state.hsbPickerValue.hex))}, className: "icon demo-list-icon hsb-picker-target" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "RGB Bars" ),
	        react.createElement( BlockHeader, null, "RGB bars with labels and values in Popover on tablet and in Popup on phone" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, {
	            type: "colorpicker", placeholder: "Color", readonly: true, value: this.state.rgbBarsPickerValue, onColorPickerChange: function (value) { return this$1.setState({rgbBarsPickerValue: value}); }, colorPickerParams: {
	              modules: ['rgb-bars'],
	              openIn: 'auto',
	              barValue: true,
	              barLabel: true,
	              targetEl: '.rgb-bars-picker-target',
	              formatValue: function formatValue(value) {
	                return ("rgb(" + (value.rgb.join(', ')) + ")");
	              },
	            } },
	            react.createElement( 'i', {
	              slot: "media", style: {backgroundColor: ("" + (this.state.rgbBarsPickerValue.hex))}, className: "icon demo-list-icon rgb-bars-picker-target" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "RGB Sliders + Colors" ),
	        react.createElement( BlockHeader, null, "RGB sliders with labels and values in Popover, and previous and current color values blocks" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, {
	            type: "colorpicker", placeholder: "Color", readonly: true, value: this.state.rgbSlidersColorsPickerValue, onColorPickerChange: function (value) { return this$1.setState({rgbSlidersColorsPickerValue: value}); }, colorPickerParams: {
	              modules: ['initial-current-colors', 'rgb-sliders'],
	              sliderValue: true,
	              sliderLabel: true,
	              targetEl: '.rgb-sliders-colors-picker-target',
	              formatValue: function formatValue(value) {
	                return ("rgb(" + (value.rgb.join(', ')) + ")");
	              },
	            } },
	            react.createElement( 'i', {
	              slot: "media", style: {backgroundColor: ("" + (this.state.rgbSlidersColorsPickerValue.hex))}, className: "icon demo-list-icon rgb-sliders-colors-picker-target" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Palette" ),
	        react.createElement( BlockHeader, null, "Palette opened in Sheet modal on phone and Popover on larger screens" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, {
	            type: "colorpicker", placeholder: "Color", readonly: true, value: this.state.palettePickerValue, onColorPickerChange: function (value) { return this$1.setState({palettePickerValue: value}); }, colorPickerParams: {
	              modules: ['palette'],
	              openIn: 'auto',
	              openInPhone: 'sheet',
	              palette: [
	                ['#FFEBEE', '#FFCDD2', '#EF9A9A', '#E57373', '#EF5350', '#F44336', '#E53935', '#D32F2F', '#C62828', '#B71C1C'],
	                ['#F3E5F5', '#E1BEE7', '#CE93D8', '#BA68C8', '#AB47BC', '#9C27B0', '#8E24AA', '#7B1FA2', '#6A1B9A', '#4A148C'],
	                ['#E8EAF6', '#C5CAE9', '#9FA8DA', '#7986CB', '#5C6BC0', '#3F51B5', '#3949AB', '#303F9F', '#283593', '#1A237E'],
	                ['#E1F5FE', '#B3E5FC', '#81D4FA', '#4FC3F7', '#29B6F6', '#03A9F4', '#039BE5', '#0288D1', '#0277BD', '#01579B'],
	                ['#E0F2F1', '#B2DFDB', '#80CBC4', '#4DB6AC', '#26A69A', '#009688', '#00897B', '#00796B', '#00695C', '#004D40'],
	                ['#F1F8E9', '#DCEDC8', '#C5E1A5', '#AED581', '#9CCC65', '#8BC34A', '#7CB342', '#689F38', '#558B2F', '#33691E'],
	                ['#FFFDE7', '#FFF9C4', '#FFF59D', '#FFF176', '#FFEE58', '#FFEB3B', '#FDD835', '#FBC02D', '#F9A825', '#F57F17'],
	                ['#FFF3E0', '#FFE0B2', '#FFCC80', '#FFB74D', '#FFA726', '#FF9800', '#FB8C00', '#F57C00', '#EF6C00', '#E65100'] ],
	              targetEl: '.palette-picker-target',
	              formatValue: function formatValue(value) {
	                return value.hex;
	              },
	            } },
	            react.createElement( 'i', {
	              slot: "media", style: {backgroundColor: ("" + (this.state.palettePickerValue.hex))}, className: "icon demo-list-icon palette-picker-target" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Pro Mode" ),
	        react.createElement( BlockHeader, null, "Current Color + HSB Sliders + RGB sliders + Alpha Slider + HEX + Palette with labels and editable values" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, {
	            type: "colorpicker", placeholder: "Color", readonly: true, value: this.state.proPickerValue, onColorPickerChange: function (value) { return this$1.setState({proPickerValue: value}); }, colorPickerParams: {
	              modules: ['initial-current-colors', 'sb-spectrum', 'hsb-sliders', 'rgb-sliders', 'alpha-slider', 'hex', 'palette'],
	              openIn: 'auto',
	              sliderValue: true,
	              sliderValueEditable: true,
	              sliderLabel: true,
	              hexLabel: true,
	              hexValueEditable: true,
	              groupedModules: true,
	              palette: [
	                ['#FFEBEE', '#FFCDD2', '#EF9A9A', '#E57373', '#EF5350', '#F44336', '#E53935', '#D32F2F', '#C62828', '#B71C1C'],
	                ['#F3E5F5', '#E1BEE7', '#CE93D8', '#BA68C8', '#AB47BC', '#9C27B0', '#8E24AA', '#7B1FA2', '#6A1B9A', '#4A148C'],
	                ['#E8EAF6', '#C5CAE9', '#9FA8DA', '#7986CB', '#5C6BC0', '#3F51B5', '#3949AB', '#303F9F', '#283593', '#1A237E'],
	                ['#E1F5FE', '#B3E5FC', '#81D4FA', '#4FC3F7', '#29B6F6', '#03A9F4', '#039BE5', '#0288D1', '#0277BD', '#01579B'],
	                ['#E0F2F1', '#B2DFDB', '#80CBC4', '#4DB6AC', '#26A69A', '#009688', '#00897B', '#00796B', '#00695C', '#004D40'],
	                ['#F1F8E9', '#DCEDC8', '#C5E1A5', '#AED581', '#9CCC65', '#8BC34A', '#7CB342', '#689F38', '#558B2F', '#33691E'],
	                ['#FFFDE7', '#FFF9C4', '#FFF59D', '#FFF176', '#FFEE58', '#FFEB3B', '#FDD835', '#FBC02D', '#F9A825', '#F57F17'],
	                ['#FFF3E0', '#FFE0B2', '#FFCC80', '#FFB74D', '#FFA726', '#FF9800', '#FB8C00', '#F57C00', '#EF6C00', '#E65100'] ],
	              targetEl: '.pro-picker-target',
	              formatValue: function formatValue(value) {
	                return ("rgba(" + (value.rgba.join(', ')) + ")");
	              },
	            } },
	            react.createElement( 'i', {
	              slot: "media", style: {backgroundColor: this.state.proPickerValue.rgba ? ("rgba(" + (this.state.proPickerValue.rgba.join(', ')) + ")") : this.state.proPickerValue.hex}, className: "icon demo-list-icon pro-picker-target" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Inline Color Picker" ),
	        react.createElement( BlockHeader, null, "SB Spectrum + HSB Sliders" ),
	        react.createElement( 'div', { className: "block block-strong no-padding" },
	          this.state.inlinePickerValue.rgb && (
	            react.createElement( 'div', { className: "padding" }, "HEX: ", this.state.inlinePickerValue.hex, react.createElement( 'br', null ), "Alpha: ", this.state.inlinePickerValue.alpha, react.createElement( 'br', null ), "Hue: ", this.state.inlinePickerValue.hue, react.createElement( 'br', null ), "RGB: ", this.state.inlinePickerValue.rgb.join(', '), react.createElement( 'br', null ), "HSL: ", this.state.inlinePickerValue.hsl.join(', '), react.createElement( 'br', null ), "HSB: ", this.state.inlinePickerValue.hsb.join(', '), react.createElement( 'br', null ), "RGBA: ", this.state.inlinePickerValue.rgba.join(', '), react.createElement( 'br', null ), "HSLA: ", this.state.inlinePickerValue.hsla.join(', ')
	            )
	          ),
	          react.createElement( 'div', { id: "demo-color-picker-inline" })
	        )

	      )
	    )
	  };

	  return defaultExport;
	}(react.Component));

	function ContactsList$1 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Contacts List", backLink: "Back" }),
	    react.createElement( List, { contactsList: true },
	      react.createElement( ListGroup, null,
	        react.createElement( ListItem, { title: "A", groupTitle: true }),
	        react.createElement( ListItem, { title: "Aaron " }),
	        react.createElement( ListItem, { title: "Abbie" }),
	        react.createElement( ListItem, { title: "Adam" }),
	        react.createElement( ListItem, { title: "Adele" }),
	        react.createElement( ListItem, { title: "Agatha" }),
	        react.createElement( ListItem, { title: "Agnes" }),
	        react.createElement( ListItem, { title: "Albert" }),
	        react.createElement( ListItem, { title: "Alexander" })
	      ),
	      react.createElement( ListGroup, null,
	        react.createElement( ListItem, { title: "B", groupTitle: true }),
	        react.createElement( ListItem, { title: "Bailey" }),
	        react.createElement( ListItem, { title: "Barclay" }),
	        react.createElement( ListItem, { title: "Bartolo" }),
	        react.createElement( ListItem, { title: "Bellamy" }),
	        react.createElement( ListItem, { title: "Belle" }),
	        react.createElement( ListItem, { title: "Benjamin" })
	      ),
	      react.createElement( ListGroup, null,
	        react.createElement( ListItem, { title: "C", groupTitle: true }),
	        react.createElement( ListItem, { title: "Caiden" }),
	        react.createElement( ListItem, { title: "Calvin" }),
	        react.createElement( ListItem, { title: "Candy" }),
	        react.createElement( ListItem, { title: "Carl" }),
	        react.createElement( ListItem, { title: "Cherilyn" }),
	        react.createElement( ListItem, { title: "Chester" }),
	        react.createElement( ListItem, { title: "Chloe" })
	      ),
	      react.createElement( ListGroup, null,
	        react.createElement( ListItem, { title: "V", groupTitle: true }),
	        react.createElement( ListItem, { title: "Vladimir" })
	      )
	    )
	  )
	); }

	function ContentBlock () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Content Block", backLink: "Back" }),
	    react.createElement( 'p', null, "This paragraph is outside of content block. Not cool, but useful for any custom elements with custom styling." ),

	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Here comes paragraph within content block. Donec et nulla auctor massa pharetra adipiscing ut sit amet sem. Suspendisse molestie velit vitae mattis tincidunt. Ut sit amet quam mollis, vulputate turpis vel, sagittis felis. " )
	    ),

	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "Here comes another text block with additional \"block-strong\" class. Praesent nec imperdiet diam. Maecenas vel lectus porttitor, consectetur magna nec, viverra sem. Aliquam sed risus dolor. Morbi tincidunt ut libero id sodales. Integer blandit varius nisi quis consectetur. " )
	    ),

	    react.createElement( BlockTitle, null, "Block title" ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Donec et nulla auctor massa pharetra adipiscing ut sit amet sem. Suspendisse molestie velit vitae mattis tincidunt. Ut sit amet quam mollis, vulputate turpis vel, sagittis felis. " )
	    ),

	    react.createElement( BlockTitle, null, "Another ultra long content block title" ),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "Donec et nulla auctor massa pharetra adipiscing ut sit amet sem. Suspendisse molestie velit vitae mattis tincidunt. Ut sit amet quam mollis, vulputate turpis vel, sagittis felis. " )
	    ),

	    react.createElement( BlockTitle, null, "Inset" ),
	    react.createElement( Block, { strong: true, inset: true },
	      react.createElement( 'p', null, "Donec et nulla auctor massa pharetra adipiscing ut sit amet sem. Suspendisse molestie velit vitae mattis tincidunt. Ut sit amet quam mollis, vulputate turpis vel, sagittis felis. " )
	    ),

	    react.createElement( BlockTitle, null, "Tablet Inset" ),
	    react.createElement( Block, { strong: true, tabletInset: true },
	      react.createElement( 'p', null, "Donec et nulla auctor massa pharetra adipiscing ut sit amet sem. Suspendisse molestie velit vitae mattis tincidunt. Ut sit amet quam mollis, vulputate turpis vel, sagittis felis. " )
	    ),

	    react.createElement( BlockTitle, null, "With Header & Footer" ),
	    react.createElement( Block, null,
	      react.createElement( BlockHeader, null, "Block Header" ),
	      react.createElement( 'p', null, "Here comes paragraph within content block. Donec et nulla auctor massa pharetra adipiscing ut sit amet sem. Suspendisse molestie velit vitae mattis tincidunt. Ut sit amet quam mollis, vulputate turpis vel, sagittis felis. " ),
	      react.createElement( BlockFooter, null, "Block Footer" )
	    ),

	    react.createElement( BlockHeader, null, "Block Header" ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Here comes paragraph within content block. Donec et nulla auctor massa pharetra adipiscing ut sit amet sem. Suspendisse molestie velit vitae mattis tincidunt. Ut sit amet quam mollis, vulputate turpis vel, sagittis felis. " )
	    ),
	    react.createElement( BlockFooter, null, "Block Footer" ),

	    react.createElement( Block, { strong: true },
	      react.createElement( BlockHeader, null, "Block Header" ),
	      react.createElement( 'p', null, "Here comes paragraph within content block. Donec et nulla auctor massa pharetra adipiscing ut sit amet sem. Suspendisse molestie velit vitae mattis tincidunt. Ut sit amet quam mollis, vulputate turpis vel, sagittis felis. " ),
	      react.createElement( BlockFooter, null, "Block Footer" )
	    ),

	    react.createElement( BlockHeader, null, "Block Header" ),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "Here comes paragraph within content block. Donec et nulla auctor massa pharetra adipiscing ut sit amet sem. Suspendisse molestie velit vitae mattis tincidunt. Ut sit amet quam mollis, vulputate turpis vel, sagittis felis. " )
	    ),
	    react.createElement( BlockFooter, null, "Block Footer" ),

	    react.createElement( BlockTitle, { large: true }, "Block Title Large"),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "Donec et nulla auctor massa pharetra adipiscing ut sit amet sem. Suspendisse molestie velit vitae mattis tincidunt. Ut sit amet quam mollis, vulputate turpis vel, sagittis felis. " )
	    ),

	    react.createElement( BlockTitle, { medium: true }, "Block Title Medium"),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "Donec et nulla auctor massa pharetra adipiscing ut sit amet sem. Suspendisse molestie velit vitae mattis tincidunt. Ut sit amet quam mollis, vulputate turpis vel, sagittis felis. " )
	    )
	  )
	); }

	function DataTable$2 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Data Table", backLink: "Back" }),
	    react.createElement( BlockTitle, null, "Plain table" ),
	    react.createElement( 'div', { className: "data-table" },
	      react.createElement( 'table', null,
	        react.createElement( 'thead', null,
	          react.createElement( 'tr', null,
	            react.createElement( 'th', { className: "label-cell" }, "Desert (100g serving)"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Calories"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Fat (g)"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Carbs"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Protein (g)")
	          )
	        ),
	        react.createElement( 'tbody', null,
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "label-cell" }, "Frozen yogurt"),
	            react.createElement( 'td', { className: "numeric-cell" }, "159"),
	            react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	            react.createElement( 'td', { className: "numeric-cell" }, "24"),
	            react.createElement( 'td', { className: "numeric-cell" }, "4.0")
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "label-cell" }, "Ice cream sandwich"),
	            react.createElement( 'td', { className: "numeric-cell" }, "237"),
	            react.createElement( 'td', { className: "numeric-cell" }, "9.0"),
	            react.createElement( 'td', { className: "numeric-cell" }, "37"),
	            react.createElement( 'td', { className: "numeric-cell" }, "4.4")
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "label-cell" }, "Eclair"),
	            react.createElement( 'td', { className: "numeric-cell" }, "262"),
	            react.createElement( 'td', { className: "numeric-cell" }, "16.0"),
	            react.createElement( 'td', { className: "numeric-cell" }, "24"),
	            react.createElement( 'td', { className: "numeric-cell" }, "6.0")
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "label-cell" }, "Cupcake"),
	            react.createElement( 'td', { className: "numeric-cell" }, "305"),
	            react.createElement( 'td', { className: "numeric-cell" }, "3.7"),
	            react.createElement( 'td', { className: "numeric-cell" }, "67"),
	            react.createElement( 'td', { className: "numeric-cell" }, "4.3")
	          )
	        )
	      )
	    ),
	    react.createElement( BlockTitle, null, "Within card" ),
	    react.createElement( Card$1, { className: "data-table" },
	      react.createElement( 'table', null,
	        react.createElement( 'thead', null,
	          react.createElement( 'tr', null,
	            react.createElement( 'th', { className: "label-cell" }, "Desert (100g serving)"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Calories"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Fat (g)"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Carbs"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Protein (g)")
	          )
	        ),
	        react.createElement( 'tbody', null,
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "label-cell" }, "Frozen yogurt"),
	            react.createElement( 'td', { className: "numeric-cell" }, "159"),
	            react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	            react.createElement( 'td', { className: "numeric-cell" }, "24"),
	            react.createElement( 'td', { className: "numeric-cell" }, "4.0")
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "label-cell" }, "Ice cream sandwich"),
	            react.createElement( 'td', { className: "numeric-cell" }, "237"),
	            react.createElement( 'td', { className: "numeric-cell" }, "9.0"),
	            react.createElement( 'td', { className: "numeric-cell" }, "37"),
	            react.createElement( 'td', { className: "numeric-cell" }, "4.4")
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "label-cell" }, "Eclair"),
	            react.createElement( 'td', { className: "numeric-cell" }, "262"),
	            react.createElement( 'td', { className: "numeric-cell" }, "16.0"),
	            react.createElement( 'td', { className: "numeric-cell" }, "24"),
	            react.createElement( 'td', { className: "numeric-cell" }, "6.0")
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "label-cell" }, "Cupcake"),
	            react.createElement( 'td', { className: "numeric-cell" }, "305"),
	            react.createElement( 'td', { className: "numeric-cell" }, "3.7"),
	            react.createElement( 'td', { className: "numeric-cell" }, "67"),
	            react.createElement( 'td', { className: "numeric-cell" }, "4.3")
	          )
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Selectable rows" ),
	    react.createElement( Card$1, { className: "data-table data-table-init" },
	      react.createElement( 'table', null,
	        react.createElement( 'thead', null,
	          react.createElement( 'tr', null,
	            react.createElement( 'th', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null )
	            ),
	            react.createElement( 'th', { className: "label-cell" }, "Desert (100g serving)"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Calories"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Fat (g)"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Carbs"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Protein (g)"),
	            react.createElement( 'th', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null ),
	              react.createElement( 'span', null, "In Stock" )
	            )
	          )
	        ),
	        react.createElement( 'tbody', null,
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null )
	            ),
	            react.createElement( 'td', { className: "label-cell" }, "Frozen yogurt"),
	            react.createElement( 'td', { className: "numeric-cell" }, "159"),
	            react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	            react.createElement( 'td', { className: "numeric-cell" }, "24"),
	            react.createElement( 'td', { className: "numeric-cell" }, "4.0"),
	            react.createElement( 'td', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null )
	            )
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null )
	            ),
	            react.createElement( 'td', { className: "label-cell" }, "Ice cream sandwich"),
	            react.createElement( 'td', { className: "numeric-cell" }, "237"),
	            react.createElement( 'td', { className: "numeric-cell" }, "9.0"),
	            react.createElement( 'td', { className: "numeric-cell" }, "37"),
	            react.createElement( 'td', { className: "numeric-cell" }, "4.4"),
	            react.createElement( 'td', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null )
	            )
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null )
	            ),
	            react.createElement( 'td', { className: "label-cell" }, "Eclair"),
	            react.createElement( 'td', { className: "numeric-cell" }, "262"),
	            react.createElement( 'td', { className: "numeric-cell" }, "16.0"),
	            react.createElement( 'td', { className: "numeric-cell" }, "24"),
	            react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	            react.createElement( 'td', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null )
	            )
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null )
	            ),
	            react.createElement( 'td', { className: "label-cell" }, "Cupcake"),
	            react.createElement( 'td', { className: "numeric-cell" }, "305"),
	            react.createElement( 'td', { className: "numeric-cell" }, "3.7"),
	            react.createElement( 'td', { className: "numeric-cell" }, "67"),
	            react.createElement( 'td', { className: "numeric-cell" }, "4.3"),
	            react.createElement( 'td', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null )
	            )
	          )
	        )
	      )
	    ),
	    react.createElement( BlockTitle, null, "Tablet-only columns" ),
	    react.createElement( BlockHeader, null,
	      react.createElement( 'p', null, "\"Comments\" column will be visible only on large screen devices (tablets)" )
	    ),
	    react.createElement( Card$1, { className: "data-table data-table-init" },
	      react.createElement( 'table', null,
	        react.createElement( 'thead', null,
	          react.createElement( 'tr', null,
	            react.createElement( 'th', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null )
	            ),
	            react.createElement( 'th', { className: "label-cell" }, "Desert (100g serving)"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Calories"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Fat (g)"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Carbs"),
	            react.createElement( 'th', { className: "numeric-cell" }, "Protein (g)"),
	            react.createElement( 'th', { className: "tablet-only" }, react.createElement( Icon, { ios: "f7:message_fill", aurora: "f7:message_fill", md: "material:message" }), " Comments")
	          )
	        ),
	        react.createElement( 'tbody', null,
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null )
	            ),
	            react.createElement( 'td', { className: "label-cell" }, "Frozen yogurt"),
	            react.createElement( 'td', { className: "numeric-cell" }, "159"),
	            react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	            react.createElement( 'td', { className: "numeric-cell" }, "24"),
	            react.createElement( 'td', { className: "numeric-cell" }, "4.0"),
	            react.createElement( 'td', { className: "tablet-only" }, "I like frozen yogurt")
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null )
	            ),
	            react.createElement( 'td', { className: "label-cell" }, "Ice cream sandwich"),
	            react.createElement( 'td', { className: "numeric-cell" }, "237"),
	            react.createElement( 'td', { className: "numeric-cell" }, "9.0"),
	            react.createElement( 'td', { className: "numeric-cell" }, "37"),
	            react.createElement( 'td', { className: "numeric-cell" }, "4.4"),
	            react.createElement( 'td', { className: "tablet-only" }, "But like ice cream more")
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null )
	            ),
	            react.createElement( 'td', { className: "label-cell" }, "Eclair"),
	            react.createElement( 'td', { className: "numeric-cell" }, "262"),
	            react.createElement( 'td', { className: "numeric-cell" }, "16.0"),
	            react.createElement( 'td', { className: "numeric-cell" }, "24"),
	            react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	            react.createElement( 'td', { className: "tablet-only" }, "Super tasty")
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', { className: "checkbox-cell" },
	              react.createElement( Checkbox$1, null )
	            ),
	            react.createElement( 'td', { className: "label-cell" }, "Cupcake"),
	            react.createElement( 'td', { className: "numeric-cell" }, "305"),
	            react.createElement( 'td', { className: "numeric-cell" }, "3.7"),
	            react.createElement( 'td', { className: "numeric-cell" }, "67"),
	            react.createElement( 'td', { className: "numeric-cell" }, "4.3"),
	            react.createElement( 'td', { className: "tablet-only" }, "Don't like it")
	          )
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "With inputs" ),
	    react.createElement( BlockHeader, null, "Such tables are widely used in admin interfaces for filtering or search data" ),
	    react.createElement( Card$1, { className: "data-table" },
	      react.createElement( 'table', null,
	        react.createElement( 'thead', null,
	          react.createElement( 'tr', null,
	            react.createElement( 'th', { className: "input-cell" },
	              react.createElement( 'span', { className: "table-head-label" }, "ID"),
	              react.createElement( 'div', { className: "input", style: {width: '50px'} },
	                react.createElement( 'input', { type: "number", placeholder: "Filter" })
	              )
	            ),
	            react.createElement( 'th', { className: "input-cell" },
	              react.createElement( 'span', { className: "table-head-label" }, "Name"),
	              react.createElement( 'div', { className: "input" },
	                react.createElement( 'input', { type: "text", placeholder: "Filter" })
	              )
	            ),
	            react.createElement( 'th', { className: "input-cell" },
	              react.createElement( 'span', { className: "table-head-label" }, "Email"),
	              react.createElement( 'div', { className: "input" },
	                react.createElement( 'input', { type: "email", placeholder: "Filter" })
	              )
	            ),
	            react.createElement( 'th', { className: "input-cell" },
	              react.createElement( 'span', { className: "table-head-label" }, "Gender"),
	              react.createElement( 'div', { className: "input input-dropdown" },
	                react.createElement( 'select', null,
	                  react.createElement( 'option', { value: "All" }, "All"),
	                  react.createElement( 'option', { value: "Male" }, "Male"),
	                  react.createElement( 'option', { value: "Female" }, "Female")
	                )
	              )
	            )
	          )
	        ),
	        react.createElement( 'tbody', null,
	          react.createElement( 'tr', null,
	            react.createElement( 'td', null, "1" ),
	            react.createElement( 'td', null, "John Doe" ),
	            react.createElement( 'td', null, "john@doe.com" ),
	            react.createElement( 'td', null, "Male" )
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', null, "2" ),
	            react.createElement( 'td', null, "Jane Doe" ),
	            react.createElement( 'td', null, "jane@doe.com" ),
	            react.createElement( 'td', null, "Female" )
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', null, "3" ),
	            react.createElement( 'td', null, "Vladimir Kharlampidi" ),
	            react.createElement( 'td', null, "vladimir@google.com" ),
	            react.createElement( 'td', null, "Male" )
	          ),
	          react.createElement( 'tr', null,
	            react.createElement( 'td', null, "4" ),
	            react.createElement( 'td', null, "Jennifer Doe" ),
	            react.createElement( 'td', null, "jennifer@doe.com" ),
	            react.createElement( 'td', null, "Female" )
	          )
	        )
	      )
	    ),
	    react.createElement( BlockTitle, null, "Within card with title and actions" ),
	    react.createElement( Card$1, { className: "data-table data-table-init" },
	      react.createElement( CardHeader, null,
	        react.createElement( 'div', { className: "data-table-title" }, "Nutrition"),
	        react.createElement( 'div', { className: "data-table-actions" },
	          react.createElement( Link, { iconIos: "f7:sort", iconAurora: "f7:sort", iconMd: "material:sort" }),
	          react.createElement( Link, { iconIos: "f7:more_vertical_round", iconAurora: "f7:more_vertical_round", iconMd: "material:more_vert" })
	        )
	      ),
	      react.createElement( CardContent, { padding: false },
	        react.createElement( 'table', null,
	          react.createElement( 'thead', null,
	            react.createElement( 'tr', null,
	              react.createElement( 'th', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'th', { className: "label-cell" }, "Desert (100g serving)"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Calories"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Fat (g)"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Carbs"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Protein (g)"),
	              react.createElement( 'th', { className: "tablet-only" }, react.createElement( Icon, { ios: "f7:message_fill", aurora: "f7:message_fill", md: "material:message" }), " Comments")
	            )
	          ),
	          react.createElement( 'tbody', null,
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Frozen yogurt"),
	              react.createElement( 'td', { className: "numeric-cell" }, "159"),
	              react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "24"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.0"),
	              react.createElement( 'td', { className: "tablet-only" }, "I like frozen yogurt")
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Ice cream sandwich"),
	              react.createElement( 'td', { className: "numeric-cell" }, "237"),
	              react.createElement( 'td', { className: "numeric-cell" }, "9.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "37"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.4"),
	              react.createElement( 'td', { className: "tablet-only" }, "But like ice cream more")
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Eclair"),
	              react.createElement( 'td', { className: "numeric-cell" }, "262"),
	              react.createElement( 'td', { className: "numeric-cell" }, "16.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "24"),
	              react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	              react.createElement( 'td', { className: "tablet-only" }, "Super tasty")
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Cupcake"),
	              react.createElement( 'td', { className: "numeric-cell" }, "305"),
	              react.createElement( 'td', { className: "numeric-cell" }, "3.7"),
	              react.createElement( 'td', { className: "numeric-cell" }, "67"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.3"),
	              react.createElement( 'td', { className: "tablet-only" }, "Don't like it")
	            )
	          )
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Sortable columns" ),
	    react.createElement( Card$1, { className: "data-table data-table-init" },
	      react.createElement( CardHeader, null,
	        react.createElement( 'div', { className: "data-table-title" }, "Nutrition"),
	        react.createElement( 'div', { className: "data-table-actions" },
	          react.createElement( Link, { iconIos: "f7:sort", iconAurora: "f7:sort", iconMd: "material:sort" }),
	          react.createElement( Link, { iconIos: "f7:more_vertical_round", iconAurora: "f7:more_vertical_round", iconMd: "material:more_vert" })
	        )
	      ),
	      react.createElement( CardContent, { padding: false },
	        react.createElement( 'table', null,
	          react.createElement( 'thead', null,
	            react.createElement( 'tr', null,
	              react.createElement( 'th', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'th', { className: "label-cell sortable-cell sortable-cell-active" }, "Desert (100g serving)"),
	              react.createElement( 'th', { className: "numeric-cell sortable-cell" }, "Calories"),
	              react.createElement( 'th', { className: "numeric-cell sortable-cell" }, "Fat (g)"),
	              react.createElement( 'th', { className: "numeric-cell sortable-cell" }, "Carbs"),
	              react.createElement( 'th', { className: "numeric-cell sortable-cell" }, "Protein (g)"),
	              react.createElement( 'th', { className: "tablet-only" }, react.createElement( Icon, { ios: "f7:message_fill", aurora: "f7:message_fill", md: "material:message" }), " Comments")
	            )
	          ),
	          react.createElement( 'tbody', null,
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Frozen yogurt"),
	              react.createElement( 'td', { className: "numeric-cell" }, "159"),
	              react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "24"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.0"),
	              react.createElement( 'td', { className: "tablet-only" }, "I like frozen yogurt")
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Ice cream sandwich"),
	              react.createElement( 'td', { className: "numeric-cell" }, "237"),
	              react.createElement( 'td', { className: "numeric-cell" }, "9.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "37"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.4"),
	              react.createElement( 'td', { className: "tablet-only" }, "But like ice cream more")
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Eclair"),
	              react.createElement( 'td', { className: "numeric-cell" }, "262"),
	              react.createElement( 'td', { className: "numeric-cell" }, "16.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "24"),
	              react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	              react.createElement( 'td', { className: "tablet-only" }, "Super tasty")
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Cupcake"),
	              react.createElement( 'td', { className: "numeric-cell" }, "305"),
	              react.createElement( 'td', { className: "numeric-cell" }, "3.7"),
	              react.createElement( 'td', { className: "numeric-cell" }, "67"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.3"),
	              react.createElement( 'td', { className: "tablet-only" }, "Don't like it")
	            )
	          )
	        )
	      )
	    ),
	    react.createElement( BlockTitle, null, "With title and different actions on select" ),
	    react.createElement( Card$1, { className: "data-table data-table-init" },
	      react.createElement( CardHeader, null,
	        react.createElement( 'div', { className: "data-table-header" },
	          react.createElement( 'div', { className: "data-table-title" }, "Nutrition"),
	          react.createElement( 'div', { className: "data-table-actions" },
	            react.createElement( Link, { iconIos: "f7:sort", iconAurora: "f7:sort", iconMd: "material:sort" }),
	            react.createElement( Link, { iconIos: "f7:more_vertical_round", iconAurora: "f7:more_vertical_round", iconMd: "material:more_vert" })
	          )
	        ),
	        react.createElement( 'div', { className: "data-table-header-selected" },
	          react.createElement( 'div', { className: "data-table-title-selected" }, react.createElement( 'span', { className: "data-table-selected-count" }), " items selected"),
	          react.createElement( 'div', { className: "data-table-actions" },
	            react.createElement( Link, { iconIos: "f7:trash", iconAurora: "f7:trash", iconMd: "material:delete" }),
	            react.createElement( Link, { iconIos: "f7:more_vertical_round", iconAurora: "f7:more_vertical_round", iconMd: "material:more_vert" })
	          )
	        )
	      ),
	      react.createElement( CardContent, { padding: false },
	        react.createElement( 'table', null,
	          react.createElement( 'thead', null,
	            react.createElement( 'tr', null,
	              react.createElement( 'th', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'th', { className: "label-cell" }, "Desert (100g serving)"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Calories"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Fat (g)"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Carbs"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Protein (g)"),
	              react.createElement( 'th', { className: "tablet-only" }, react.createElement( Icon, { ios: "f7:message_fill", aurora: "f7:message_fill", md: "material:message" }), " Comments")
	            )
	          ),
	          react.createElement( 'tbody', null,
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Frozen yogurt"),
	              react.createElement( 'td', { className: "numeric-cell" }, "159"),
	              react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "24"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.0"),
	              react.createElement( 'td', { className: "tablet-only" }, "I like frozen yogurt")
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Ice cream sandwich"),
	              react.createElement( 'td', { className: "numeric-cell" }, "237"),
	              react.createElement( 'td', { className: "numeric-cell" }, "9.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "37"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.4"),
	              react.createElement( 'td', { className: "tablet-only" }, "But like ice cream more")
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Eclair"),
	              react.createElement( 'td', { className: "numeric-cell" }, "262"),
	              react.createElement( 'td', { className: "numeric-cell" }, "16.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "24"),
	              react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	              react.createElement( 'td', { className: "tablet-only" }, "Super tasty")
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Cupcake"),
	              react.createElement( 'td', { className: "numeric-cell" }, "305"),
	              react.createElement( 'td', { className: "numeric-cell" }, "3.7"),
	              react.createElement( 'td', { className: "numeric-cell" }, "67"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.3"),
	              react.createElement( 'td', { className: "tablet-only" }, "Don't like it")
	            )
	          )
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Alternate header with actions" ),
	    react.createElement( Card$1, { className: "data-table data-table-init" },
	      react.createElement( CardHeader, null,
	        react.createElement( 'div', { className: "data-table-links" }, react.createElement( 'a', { className: "button" }, "Add"), react.createElement( 'a', { className: "button" }, "Remove")),
	        react.createElement( 'div', { className: "data-table-actions" },
	          react.createElement( Link, { iconIos: "f7:sort", iconAurora: "f7:sort", iconMd: "material:sort" }),
	          react.createElement( Link, { iconIos: "f7:more_vertical_round", iconAurora: "f7:more_vertical_round", iconMd: "material:more_vert" })
	        )
	      ),
	      react.createElement( CardContent, { padding: false },
	        react.createElement( 'table', null,
	          react.createElement( 'thead', null,
	            react.createElement( 'tr', null,
	              react.createElement( 'th', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'th', { className: "label-cell" }, "Desert (100g serving)"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Calories"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Fat (g)"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Carbs"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Protein (g)"),
	              react.createElement( 'th', { className: "tablet-only" }, react.createElement( Icon, { ios: "f7:message_fill", aurora: "f7:message_fill", md: "material:message" }), " Comments"),
	              react.createElement( 'th', null )
	            )
	          ),
	          react.createElement( 'tbody', null,
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Frozen yogurt"),
	              react.createElement( 'td', { className: "numeric-cell" }, "159"),
	              react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "24"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.0"),
	              react.createElement( 'td', { className: "tablet-only" }, "I like frozen yogurt"),
	              react.createElement( 'td', { className: "actions-cell" },
	                react.createElement( Link, { iconIos: "f7:compose", iconAurora: "f7:compose", iconMd: "material:edit" }),
	                react.createElement( Link, { iconIos: "f7:trash", iconAurora: "f7:trash", iconMd: "material:delete" })
	              )
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Ice cream sandwich"),
	              react.createElement( 'td', { className: "numeric-cell" }, "237"),
	              react.createElement( 'td', { className: "numeric-cell" }, "9.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "37"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.4"),
	              react.createElement( 'td', { className: "tablet-only" }, "But like ice cream more"),
	              react.createElement( 'td', { className: "actions-cell" },
	                react.createElement( Link, { iconIos: "f7:compose", iconAurora: "f7:compose", iconMd: "material:edit" }),
	                react.createElement( Link, { iconIos: "f7:trash", iconAurora: "f7:trash", iconMd: "material:delete" })
	              )
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Eclair"),
	              react.createElement( 'td', { className: "numeric-cell" }, "262"),
	              react.createElement( 'td', { className: "numeric-cell" }, "16.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "24"),
	              react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	              react.createElement( 'td', { className: "tablet-only" }, "Super tasty"),
	              react.createElement( 'td', { className: "actions-cell" },
	                react.createElement( Link, { iconIos: "f7:compose", iconAurora: "f7:compose", iconMd: "material:edit" }),
	                react.createElement( Link, { iconIos: "f7:trash", iconAurora: "f7:trash", iconMd: "material:delete" })
	              )
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "checkbox-cell" },
	                react.createElement( Checkbox$1, null )
	              ),
	              react.createElement( 'td', { className: "label-cell" }, "Cupcake"),
	              react.createElement( 'td', { className: "numeric-cell" }, "305"),
	              react.createElement( 'td', { className: "numeric-cell" }, "3.7"),
	              react.createElement( 'td', { className: "numeric-cell" }, "67"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.3"),
	              react.createElement( 'td', { className: "tablet-only" }, "Don't like it"),
	              react.createElement( 'td', { className: "actions-cell" },
	                react.createElement( Link, { iconIos: "f7:compose", iconAurora: "f7:compose", iconMd: "material:edit" }),
	                react.createElement( Link, { iconIos: "f7:trash", iconAurora: "f7:trash", iconMd: "material:delete" })
	              )
	            )
	          )
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Collapsible" ),
	    react.createElement( BlockHeader, null,
	      react.createElement( 'p', null, "The following table will be collapsed to kind of List View on small screens:" )
	    ),
	    react.createElement( Card$1, { className: "data-table data-table-collapsible data-table-init" },
	      react.createElement( CardHeader, null,
	        react.createElement( 'div', { className: "data-table-title" }, "Nutrition"),
	        react.createElement( 'div', { className: "data-table-actions" },
	          react.createElement( Link, { iconIos: "f7:sort", iconAurora: "f7:sort", iconMd: "material:sort" }),
	          react.createElement( Link, { iconIos: "f7:more_vertical_round", iconAurora: "f7:more_vertical_round", iconMd: "material:more_vert" })
	        )
	      ),
	      react.createElement( CardContent, { padding: false },
	        react.createElement( 'table', null,
	          react.createElement( 'thead', null,
	            react.createElement( 'tr', null,
	              react.createElement( 'th', { className: "label-cell" }, "Desert (100g serving)"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Calories"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Fat (g)"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Carbs"),
	              react.createElement( 'th', { className: "numeric-cell" }, "Protein (g)")
	            )
	          ),
	          react.createElement( 'tbody', null,
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "label-cell" }, "Frozen yogurt"),
	              react.createElement( 'td', { className: "numeric-cell" }, "159"),
	              react.createElement( 'td', { className: "numeric-cell" }, "6.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "24"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.0")
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "label-cell" }, "Ice cream sandwich"),
	              react.createElement( 'td', { className: "numeric-cell" }, "237"),
	              react.createElement( 'td', { className: "numeric-cell" }, "9.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "37"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.4")
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "label-cell" }, "Eclair"),
	              react.createElement( 'td', { className: "numeric-cell" }, "262"),
	              react.createElement( 'td', { className: "numeric-cell" }, "16.0"),
	              react.createElement( 'td', { className: "numeric-cell" }, "24"),
	              react.createElement( 'td', { className: "numeric-cell" }, "6.0")
	            ),
	            react.createElement( 'tr', null,
	              react.createElement( 'td', { className: "label-cell" }, "Cupcake"),
	              react.createElement( 'td', { className: "numeric-cell" }, "305"),
	              react.createElement( 'td', { className: "numeric-cell" }, "3.7"),
	              react.createElement( 'td', { className: "numeric-cell" }, "67"),
	              react.createElement( 'td', { className: "numeric-cell" }, "4.3")
	            )
	          )
	        )
	      )
	    )
	  )
	); }

	var defaultExport$9 = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Dialog", backLink: "Back" }),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "There are 1:1 replacements of native Alert, Prompt and Confirm modals. They support callbacks, have very easy api and can be combined with each other. Check these examples:" ),
	          react.createElement( Row, { tag: "p" },
	            react.createElement( Button, { fill: true, className: "col", onClick: this.openAlert.bind(this) }, "Alert"),
	            react.createElement( Button, { fill: true, className: "col", onClick: this.openConfirm.bind(this) }, "Confirm"),
	            react.createElement( Button, { fill: true, className: "col", onClick: this.openPrompt.bind(this) }, "Prompt")
	          ),
	          react.createElement( Row, { tag: "p" },
	            react.createElement( Button, { fill: true, className: "col", onClick: this.openLogin.bind(this) }, "Login"),
	            react.createElement( Button, { fill: true, className: "col", onClick: this.openPassword.bind(this) }, "Password")
	          )
	        ),
	        react.createElement( BlockTitle, null, "Vertical Buttons" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, onClick: this.openVerticalButtons.bind(this) }, "Vertical Buttons")
	          )
	        ),
	        react.createElement( BlockTitle, null, "Preloader Dialog" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( Row, { tag: "p" },
	            react.createElement( Button, { fill: true, className: "col", onClick: this.openPreloader.bind(this) }, "Preloader"),
	            react.createElement( Button, { fill: true, className: "col", onClick: this.openCustomPreloader.bind(this) }, "Custom Text")
	          )
	        ),
	        react.createElement( BlockTitle, null, "Progress Dialog" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( Row, { tag: "p" },
	            react.createElement( Button, { fill: true, className: "col", onClick: this.openInfiniteProgress.bind(this) }, "Infinite"),
	            react.createElement( Button, { fill: true, className: "col", onClick: this.openDeterminedProgress.bind(this) }, "Determined")
	          )
	        ),
	        react.createElement( BlockTitle, null, "Dialogs Stack" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "This feature doesn't allow to open multiple dialogs at the same time, and will automatically open next dialog when you close the current one. Such behavior is similar to browser native dialogs: " ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, onClick: this.openAlerts.bind(this) }, "Open Multiple Alerts")
	          )
	        )
	      )
	    );
	  };
	  defaultExport.prototype.openAlert = function openAlert () {
	    var app = this.$f7;
	    app.dialog.alert('Hello!');
	  };
	  defaultExport.prototype.openConfirm = function openConfirm () {
	    var app = this.$f7;
	    app.dialog.confirm('Are you feel good today?', function () {
	      app.dialog.alert('Great!');
	    });
	  };
	  defaultExport.prototype.openPrompt = function openPrompt () {
	    var app = this.$f7;
	    app.dialog.prompt('What is your name?', function (name) {
	      app.dialog.confirm(("Are you sure that your name is " + name + "?"), function () {
	        app.dialog.alert(("Ok, your name is " + name));
	      });
	    });
	  };
	  defaultExport.prototype.openLogin = function openLogin () {
	    var app = this.$f7;
	    app.dialog.login('Enter your username and password', function (username, password) {
	      app.dialog.alert(("Thank you!<br>Username:" + username + "<br>Password:" + password));
	    });
	  };
	  defaultExport.prototype.openPassword = function openPassword () {
	    var app = this.$f7;
	    app.dialog.password('Enter your username and password', function (password) {
	      app.dialog.alert(("Thank you!<br>Password:" + password));
	    });
	  };
	  defaultExport.prototype.openAlerts = function openAlerts () {
	    var app = this.$f7;
	    app.dialog.alert('Alert 1');
	    app.dialog.alert('Alert 2');
	    app.dialog.alert('Alert 3');
	    app.dialog.alert('Alert 4');
	    app.dialog.alert('Alert 5');
	  };
	  defaultExport.prototype.openVerticalButtons = function openVerticalButtons () {
	    var app = this.$f7;
	    app.dialog.create({
	      title: 'Vertical Buttons',
	      buttons: [
	        {
	          text: 'Button 1',
	        },
	        {
	          text: 'Button 2',
	        },
	        {
	          text: 'Button 3',
	        } ],
	      verticalButtons: true,
	    }).open();
	  };
	  defaultExport.prototype.openPreloader = function openPreloader () {
	    var app = this.$f7;
	    app.dialog.preloader();
	    setTimeout(function () {
	      app.dialog.close();
	    }, 3000);
	  };
	  defaultExport.prototype.openCustomPreloader = function openCustomPreloader () {
	    var app = this.$f7;
	    app.dialog.preloader('My text...');
	    setTimeout(function () {
	      app.dialog.close();
	    }, 3000);
	  };
	  defaultExport.prototype.openInfiniteProgress = function openInfiniteProgress () {
	    var app = this.$f7;
	    app.dialog.progress();
	    setTimeout(function () {
	      app.dialog.close();
	    }, 3000);
	  };
	  defaultExport.prototype.openDeterminedProgress = function openDeterminedProgress () {
	    var app = this.$f7;
	    var progress = 0;
	    var dialog = app.dialog.progress('Loading assets', progress);
	    dialog.setText('Image 1 of 10');
	    var interval = setInterval(function () {
	      progress += 10;
	      dialog.setProgress(progress);
	      dialog.setText(("Image " + ((progress) / 10) + " of 10"));
	      if (progress === 100) {
	        clearInterval(interval);
	        dialog.close();
	      }
	    }, 300);
	  };

	  return defaultExport;
	}(react.Component));

	function Elevation$1 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Elevation", backLink: "Back" }),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "Shadows provide important visual cues about objects' depth and directional movement. They are the only visual cue indicating the amount of separation between surfaces. An object’s elevation determines the appearance of its shadow. The elevation values are mapped out in a \"z-space\" and range from 1 to 24." ),
	      react.createElement( 'p', null, "Elevation can be added to any element by adding ", react.createElement( 'code', null, "elevation-0" ), ", ", react.createElement( 'code', null, "elevation-1" ), ", ..., ", react.createElement( 'code', null, "elevation-24" ), " classes." ),
	      react.createElement( 'p', null, "To add different elevation only on hover (desktop), you can use ", react.createElement( 'code', null, "elevation-hover-0" ), ", ", react.createElement( 'code', null, "elevation-hover-1" ), ", ..., ", react.createElement( 'code', null, "elevation-hover-24" ), " classes." ),
	      react.createElement( 'p', null, "To specify elevation only when item pressed, you can use ", react.createElement( 'code', null, "elevation-pressed-0" ), ", ", react.createElement( 'code', null, "elevation-pressed-1" ), ", ..., ", react.createElement( 'code', null, "elevation-pressed-24" ), " classes." )
	    ),
	    react.createElement( Block, null,
	      react.createElement( Row, null,
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-1" }, "1")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-2" }, "2")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-3" }, "3")
	        )
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-4" }, "4")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-5" }, "5")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-6" }, "6")
	        )
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-7" }, "7")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-8" }, "8")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-9" }, "9")
	        )
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-10" }, "10")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-11" }, "11")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-12" }, "12")
	        )
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-13" }, "13")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-14" }, "14")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-15" }, "15")
	        )
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-16" }, "16")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-17" }, "17")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-18" }, "18")
	        )
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-19" }, "19")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-20" }, "20")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-21" }, "21")
	        )
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-22" }, "22")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-23" }, "23")
	        ),
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-24" }, "24")
	        )
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, null,
	          react.createElement( 'div', { className: "elevation-demo elevation-6 elevation-hover-24 elevation-pressed-12 elevation-transition" }, "6 + hover-24 + pressed-12")
	        )
	      )
	    )
	  )
	); }

	function Fab$3 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Floating Action Button", backLink: "Back" }),

	    react.createElement( Fab$2, { position: "right-top", slot: "fixed" },
	      react.createElement( Icon, { ios: "f7:add", aurora: "f7:add", md: "material:add" }),
	      react.createElement( Icon, { ios: "f7:close", aurora: "f7:close", md: "material:close" }),
	      react.createElement( FabButtons, { position: "left" },
	        react.createElement( FabButton, null, "1" ),
	        react.createElement( FabButton, null, "2" ),
	        react.createElement( FabButton, null, "3" )
	      )
	    ),

	    react.createElement( Fab$2, { position: "right-bottom", slot: "fixed" },
	      react.createElement( Icon, { ios: "f7:add", aurora: "f7:add", md: "material:add" }),
	      react.createElement( Icon, { ios: "f7:close", aurora: "f7:close", md: "material:close" }),
	      react.createElement( FabButtons, { position: "top" },
	        react.createElement( FabButton, { label: "Action 1" }, "1"),
	        react.createElement( FabButton, { label: "Action 2" }, "2"),
	        react.createElement( FabButton, { label: "Third Action" }, "3")
	      )
	    ),

	    react.createElement( Fab$2, { position: "left-bottom", slot: "fixed" },
	      react.createElement( Icon, { ios: "f7:add", aurora: "f7:add", md: "material:add" }),
	      react.createElement( Icon, { ios: "f7:close", aurora: "f7:close", md: "material:close" }),
	      react.createElement( FabButtons, { position: "top" },
	        react.createElement( FabButton, null, "1" ),
	        react.createElement( FabButton, null, "2" ),
	        react.createElement( FabButton, null, "3" )
	      )
	    ),

	    react.createElement( Fab$2, { position: "left-top", slot: "fixed" },
	      react.createElement( Icon, { ios: "f7:add", aurora: "f7:add", md: "material:add" }),
	      react.createElement( Icon, { ios: "f7:close", aurora: "f7:close", md: "material:close" }),
	      react.createElement( FabButtons, { position: "bottom" },
	        react.createElement( FabButton, null, "1" ),
	        react.createElement( FabButton, null, "2" ),
	        react.createElement( FabButton, null, "3" )
	      )
	    ),

	    react.createElement( Fab$2, { position: "center-center", slot: "fixed" },
	      react.createElement( Icon, { ios: "f7:add", aurora: "f7:add", md: "material:add" }),
	      react.createElement( Icon, { ios: "f7:close", aurora: "f7:close", md: "material:close" }),
	      react.createElement( FabButtons, { position: "center" },
	        react.createElement( FabButton, null, "1" ),
	        react.createElement( FabButton, null, "2" ),
	        react.createElement( FabButton, null, "3" ),
	        react.createElement( FabButton, null, "4" )
	      )
	    ),

	    react.createElement( Fab$2, { position: "center-bottom", slot: "fixed", text: "Create" },
	      react.createElement( Icon, { ios: "f7:add", aurora: "f7:add", md: "material:add" })
	    ),

	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quia, quo rem beatae, delectus eligendi est saepe molestias perferendis suscipit, commodi labore ipsa non quasi eum magnam neque ducimus! Quasi, numquam." ),
	      react.createElement( 'p', null, "Maiores culpa, itaque! Eaque natus ab cum ipsam numquam blanditiis a, quia, molestiae aut laudantium recusandae ipsa. Ad iste ex asperiores ipsa, mollitia perferendis consectetur quam eaque, voluptate laboriosam unde." ),
	      react.createElement( 'p', null, "Sed odit quis aperiam temporibus vitae necessitatibus, laboriosam, exercitationem dolores odio sapiente provident. Accusantium id, itaque aliquam libero ipsum eos fugiat distinctio laboriosam exercitationem sequi facere quas quidem magnam reprehenderit." ),
	      react.createElement( 'p', null, "Pariatur corporis illo, amet doloremque. Ab veritatis sunt nisi consectetur error modi, nam illo et nostrum quia aliquam ipsam vitae facere voluptates atque similique odit mollitia, rerum placeat nobis est." ),
	      react.createElement( 'p', null, "Et impedit soluta minus a autem adipisci cupiditate eius dignissimos nihil officia dolore voluptatibus aperiam reprehenderit esse facilis labore qui, officiis consectetur. Ipsa obcaecati aspernatur odio assumenda veniam, ipsum alias." )
	    ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Culpa ipsa debitis sed nihil eaque dolore cum iste quibusdam, accusamus doloribus, tempora quia quos voluptatibus corporis officia at quas dolorem earum!" ),
	      react.createElement( 'p', null, "Quod soluta eos inventore magnam suscipit enim at hic in maiores temporibus pariatur tempora minima blanditiis vero autem est perspiciatis totam dolorum, itaque repellat? Nobis necessitatibus aut odit aliquam adipisci." ),
	      react.createElement( 'p', null, "Tenetur delectus perspiciatis ex numquam, unde corrupti velit! Quam aperiam, animi fuga veritatis consectetur, voluptatibus atque consequuntur dignissimos itaque, sint impedit cum cumque at. Adipisci sint, iusto blanditiis ullam? Vel?" ),
	      react.createElement( 'p', null, "Dignissimos velit officia quibusdam! Eveniet beatae, aut, omnis temporibus consequatur expedita eaque aliquid quos accusamus fugiat id iusto autem obcaecati repellat fugit cupiditate suscipit natus quas doloribus? Temporibus necessitatibus, libero." ),
	      react.createElement( 'p', null, "Architecto quisquam ipsa fugit facere, repudiandae asperiores vitae obcaecati possimus, labore excepturi reprehenderit consectetur perferendis, ullam quidem hic, repellat fugiat eaque fuga. Consectetur in eveniet, deleniti recusandae omnis eum quas?" ),
	      react.createElement( 'p', null, "Quos nulla consequatur quo, officia quaerat. Nulla voluptatum, assumenda quibusdam, placeat cum aut illo deleniti dolores commodi odio ipsam, recusandae est pariatur veniam repudiandae blanditiis. Voluptas unde deleniti quisquam, nobis?" ),
	      react.createElement( 'p', null, "Atque qui quaerat quasi officia molestiae, molestias totam incidunt reprehenderit laboriosam facilis veritatis, non iusto! Dolore ipsam obcaecati voluptates minima maxime minus qui mollitia facere. Nostrum esse recusandae voluptatibus eligendi." )
	    )
	  )
	); }

	function FabMorph () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Floating Action Button Morph", backLink: "Back" }),
	    react.createElement( Toolbar$2, { tabbar: true, labels: true, bottom: true, className: "fab-morph-target" },
	      react.createElement( Link, { tabLink: true, tabLinkActive: true, iconIos: "f7:email_fill", iconAurora: "f7:email_fill", iconMd: "material:email", text: "Inbox" }),
	      react.createElement( Link, { tabLink: true, iconIos: "f7:calendar_fill", iconAurora: "f7:calendar_fill", iconMd: "material:today", text: "Calendar" }),
	      react.createElement( Link, { tabLink: true, iconIos: "f7:cloud_upload_fill", iconAurora: "f7:cloud_upload_fill", iconMd: "material:file_upload", text: "Upload" })
	    ),
	    react.createElement( Fab$2, { position: "right-bottom", morphTo: ".toolbar.fab-morph-target" },
	      react.createElement( Icon, { ios: "f7:add", aurora: "f7:add", md: "material:add" })
	    ),
	    react.createElement( Fab$2, { position: "left-bottom", morphTo: ".demo-fab-sheet.fab-morph-target" },
	      react.createElement( Icon, { ios: "f7:add", aurora: "f7:add", md: "material:add" })
	    ),
	    react.createElement( Fab$2, { position: "center-bottom", morphTo: ".demo-fab-fullscreen-sheet.fab-morph-target" },
	      react.createElement( Icon, { ios: "f7:add", aurora: "f7:add", md: "material:add" })
	    ),
	    react.createElement( 'div', { className: "list links-list demo-fab-sheet fab-morph-target", slot: "fixed" },
	      react.createElement( 'ul', null,
	        react.createElement( 'li', null, react.createElement( 'a', { href: "#", className: "fab-close" }, "Link 1") ),
	        react.createElement( 'li', null, react.createElement( 'a', { href: "#", className: "fab-close" }, "Link 2") ),
	        react.createElement( 'li', null, react.createElement( 'a', { href: "#", className: "fab-close" }, "Link 3") ),
	        react.createElement( 'li', null, react.createElement( 'a', { href: "#", className: "fab-close" }, "Link 4") )
	      )
	    ),
	    react.createElement( 'div', { className: "demo-fab-fullscreen-sheet fab-morph-target", slot: "fixed" },
	      react.createElement( BlockTitle, null, "Choose Something" ),
	      react.createElement( 'div', { className: "list links-list" },
	        react.createElement( 'ul', null,
	          react.createElement( 'li', null, react.createElement( 'a', { href: "#", className: "fab-close" }, "Link 1") ),
	          react.createElement( 'li', null, react.createElement( 'a', { href: "#", className: "fab-close" }, "Link 2") ),
	          react.createElement( 'li', null, react.createElement( 'a', { href: "#", className: "fab-close" }, "Link 3") ),
	          react.createElement( 'li', null, react.createElement( 'a', { href: "#", className: "fab-close" }, "Link 4") )
	        )
	      )
	    ),

	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quia, quo rem beatae, delectus eligendi est saepe molestias perferendis suscipit, commodi labore ipsa non quasi eum magnam neque ducimus! Quasi, numquam." ),
	      react.createElement( 'p', null, "Maiores culpa, itaque! Eaque natus ab cum ipsam numquam blanditiis a, quia, molestiae aut laudantium recusandae ipsa. Ad iste ex asperiores ipsa, mollitia perferendis consectetur quam eaque, voluptate laboriosam unde." ),
	      react.createElement( 'p', null, "Sed odit quis aperiam temporibus vitae necessitatibus, laboriosam, exercitationem dolores odio sapiente provident. Accusantium id, itaque aliquam libero ipsum eos fugiat distinctio laboriosam exercitationem sequi facere quas quidem magnam reprehenderit." ),
	      react.createElement( 'p', null, "Pariatur corporis illo, amet doloremque. Ab veritatis sunt nisi consectetur error modi, nam illo et nostrum quia aliquam ipsam vitae facere voluptates atque similique odit mollitia, rerum placeat nobis est." ),
	      react.createElement( 'p', null, "Et impedit soluta minus a autem adipisci cupiditate eius dignissimos nihil officia dolore voluptatibus aperiam reprehenderit esse facilis labore qui, officiis consectetur. Ipsa obcaecati aspernatur odio assumenda veniam, ipsum alias." )
	    ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Culpa ipsa debitis sed nihil eaque dolore cum iste quibusdam, accusamus doloribus, tempora quia quos voluptatibus corporis officia at quas dolorem earum!" ),
	      react.createElement( 'p', null, "Quod soluta eos inventore magnam suscipit enim at hic in maiores temporibus pariatur tempora minima blanditiis vero autem est perspiciatis totam dolorum, itaque repellat? Nobis necessitatibus aut odit aliquam adipisci." ),
	      react.createElement( 'p', null, "Tenetur delectus perspiciatis ex numquam, unde corrupti velit! Quam aperiam, animi fuga veritatis consectetur, voluptatibus atque consequuntur dignissimos itaque, sint impedit cum cumque at. Adipisci sint, iusto blanditiis ullam? Vel?" ),
	      react.createElement( 'p', null, "Dignissimos velit officia quibusdam! Eveniet beatae, aut, omnis temporibus consequatur expedita eaque aliquid quos accusamus fugiat id iusto autem obcaecati repellat fugit cupiditate suscipit natus quas doloribus? Temporibus necessitatibus, libero." ),
	      react.createElement( 'p', null, "Architecto quisquam ipsa fugit facere, repudiandae asperiores vitae obcaecati possimus, labore excepturi reprehenderit consectetur perferendis, ullam quidem hic, repellat fugiat eaque fuga. Consectetur in eveniet, deleniti recusandae omnis eum quas?" ),
	      react.createElement( 'p', null, "Quos nulla consequatur quo, officia quaerat. Nulla voluptatum, assumenda quibusdam, placeat cum aut illo deleniti dolores commodi odio ipsam, recusandae est pariatur veniam repudiandae blanditiis. Voluptas unde deleniti quisquam, nobis?" ),
	      react.createElement( 'p', null, "Atque qui quaerat quasi officia molestiae, molestias totam incidunt reprehenderit laboriosam facilis veritatis, non iusto! Dolore ipsam obcaecati voluptates minima maxime minus qui mollitia facere. Nostrum esse recusandae voluptatibus eligendi." )
	    )
	  )
	); }

	function FormStorage$1 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Form Storage", backLink: "Back" }),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "With forms storage it is easy to store and parse form data, especially on Ajax loaded pages. All you need to make it work is to add \"form-store-data\" class to your <form> and Framework7 will store form data with every input change. And the most awesome part is that when you load this page again Framework7 will parse this data and fill all form fields automatically!" ),
	      react.createElement( 'p', null, "Just try to fill the form below and then go to any other page, or even you may close this site, and when you return here form fields will have kept your data." )
	    ),
	    react.createElement( List, { form: true, formStoreData: true, id: "demo-form" },
	      react.createElement( ListInput, {
	        label: "Name", name: "name", type: "text", clearButton: true, placeholder: "Your name" }),
	      react.createElement( ListInput, {
	        label: "Password", name: "password", type: "password", clearButton: true, placeholder: "Your password" }),
	      react.createElement( ListInput, {
	        label: "E-mail", name: "email", type: "email", clearButton: true, placeholder: "Your e-mail" }),
	      react.createElement( ListInput, {
	        label: "URL", name: "url", type: "url", clearButton: true, placeholder: "URL" }),
	      react.createElement( ListInput, {
	        label: "Phone", name: "phone", type: "tel", clearButton: true, placeholder: "Your phone number" }),
	      react.createElement( ListInput, {
	        label: "Gender", type: "select", name: "gender", placeholder: "Please choose..." },
	        react.createElement( 'option', { value: "Male" }, "Male"),
	        react.createElement( 'option', { value: "Female" }, "Female")
	      ),
	      react.createElement( ListInput, {
	        label: "Birthday", name: "birthday", type: "date", defaultValue: "2014-04-30", placeholder: "Please choose..." }),
	      react.createElement( ListInput, {
	        label: "Date time", name: "date", type: "datetime-local", placeholder: "Please choose..." }),
	      react.createElement( ListInput, {
	        label: "Range", input: false },
	        react.createElement( Range$2, { name: "range", slot: "input", value: 50, min: 0, max: 100, step: 1 })
	      ),

	      react.createElement( ListInput, {
	        label: "About you", type: "textarea", name: "bio", resizable: true, placeholder: "Bio" })
	    )
	  )
	); }

	var defaultExport$a = /*@__PURE__*/(function (superclass) {
	  function defaultExport() {
	    superclass.call(this);

	    this.state = {
	      gaugeValue: 0.5,
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;

	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Gauge", backLink: "Back" }),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Framework7 comes with Gauge component. It produces nice looking fully responsive SVG gauges." )
	        ),
	        react.createElement( Block, { strong: true, className: "text-align-center" },
	          react.createElement( Gauge$2, {
	            type: "circle", value: this.state.gaugeValue, size: 250, borderColor: "#2196f3", borderWidth: 10, valueText: ((this.state.gaugeValue * 100) + "%"), valueFontSize: 41, valueTextColor: "#2196f3", labelText: "amount of something" }),
	          react.createElement( Segmented, { tag: "p", raised: true },
	            react.createElement( Button, { active: this.state.gaugeValue === 0, onClick: function () { return this$1.setState({ gaugeValue: 0 }); } }, "0%"),
	            react.createElement( Button, { active: this.state.gaugeValue === 0.25, onClick: function () { return this$1.setState({ gaugeValue: 0.25 }); } }, "25%"),
	            react.createElement( Button, { active: this.state.gaugeValue === 0.5, onClick: function () { return this$1.setState({ gaugeValue: 0.5 }); } }, "50%"),
	            react.createElement( Button, { active: this.state.gaugeValue === 0.75, onClick: function () { return this$1.setState({ gaugeValue: 0.75 }); } }, "75%"),
	            react.createElement( Button, { active: this.state.gaugeValue === 1, onClick: function () { return this$1.setState({ gaugeValue: 1 }); } }, "100%")
	          )
	        ),

	        react.createElement( BlockTitle, null, "Circle Gauges" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( Row, null,
	            react.createElement( Col, { className: "text-align-center" },
	              react.createElement( Gauge$2, {
	                type: "circle", value: 0.44, valueText: "44%", valueTextColor: "#ff9800", borderColor: "#ff9800" })
	            ),
	            react.createElement( Col, { className: "text-align-center" },
	              react.createElement( Gauge$2, {
	                type: "circle", value: 0.12, valueText: "$120", valueTextColor: "#4caf50", borderColor: "#4caf50", labelText: "of $1000 budget", labelTextColor: "#f44336", labelFontWeight: 700 })
	            )
	          )
	        ),
	        react.createElement( BlockTitle, null, "Semicircle Gauges" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( Row, null,
	            react.createElement( Col, { className: "text-align-center" },
	              react.createElement( Gauge$2, {
	                type: "semicircle", value: 0.3, valueText: "30%", valueTextColor: "#f44336", borderColor: "#f44336" })
	            ),
	            react.createElement( Col, { className: "text-align-center" },
	              react.createElement( Gauge$2, {
	                type: "semicircle", value: 0.5, valueText: "30kg", valueTextColor: "#e91e63", borderColor: "#e91e63", labelText: "of 60kg total", labelTextColor: "#333" })
	            )
	          )
	        ),
	        react.createElement( BlockTitle, null, "Customization" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( Row, null,
	            react.createElement( Col, { className: "text-align-center" },
	              react.createElement( Gauge$2, {
	                type: "circle", value: 0.35, valueText: "35%", valueTextColor: "#4caf50", valueFontSize: 51, valueFontWeight: 700, borderWidth: 20, borderColor: "#4caf50", borderBgColor: "#ffeb3b", bgColor: "#ffeb3b" })
	            ),
	            react.createElement( Col, { className: "text-align-center" },
	              react.createElement( Gauge$2, {
	                type: "circle", value: 0.67, valueText: "$670", valueTextColor: "#000", borderColor: "#ff9800", labelText: "of $1000 spent", labelTextColor: "#4caf50", labelFontWeight: 800, labelFontSize: 12, borderWidth: 30 })
	            )
	          ),
	          react.createElement( 'br', null ),
	          react.createElement( Row, null,
	            react.createElement( Col, { className: "text-align-center" },
	              react.createElement( Gauge$2, {
	                type: "semicircle", value: 0.5, valueText: "50%", valueTextColor: "#ffeb3b", valueFontSize: 41, valueFontWeight: 700, borderWidth: 10, borderColor: "#ffeb3b", borderBgColor: "transparent" })
	            ),
	            react.createElement( Col, { className: "text-align-center" },
	              react.createElement( Gauge$2, {
	                type: "semicircle", value: 0.77, borderColor: "#ff9800", labelText: "$770 spent so far", labelTextColor: "#ff9800", labelFontWeight: 800, labelFontSize: 12, borderWidth: 10 })
	            )
	          )
	        )
	      )
	    )
	  };

	  return defaultExport;
	}(react.Component));

	function Grid$1 () { return (
	  react.createElement( Page, { className: "grid-demo" },
	    react.createElement( Navbar$2, { title: "Grid / Layout", backLink: "Back" }),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Columns within a row are automatically set to have equal width. Otherwise you can define your column with pourcentage of screen you want." )
	    ),
	    react.createElement( BlockTitle, null, "Columns with gap" ),
	    react.createElement( Block, null,
	      react.createElement( Row, null,
	        react.createElement( Col, null, "50% (.col)" ),
	        react.createElement( Col, null, "50% (.col)" )
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, null, "25% (.col)" ),
	        react.createElement( Col, null, "25% (.col)" ),
	        react.createElement( Col, null, "25% (.col)" ),
	        react.createElement( Col, null, "25% (.col)" )
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, null, "33% (.col)" ),
	        react.createElement( Col, null, "33% (.col)" ),
	        react.createElement( Col, null, "33% (.col)" )
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, null, "20% (.col)" ),
	        react.createElement( Col, null, "20% (.col)" ),
	        react.createElement( Col, null, "20% (.col)" ),
	        react.createElement( Col, null, "20% (.col)" ),
	        react.createElement( Col, null, "20% (.col)" )
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, { width: "33" }, "33% (.col-33)"),
	        react.createElement( Col, { width: "66" }, "66% (.col-66)")
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, { width: "25" }, "25% (.col-25)"),
	        react.createElement( Col, { width: "25" }, "25% (.col-25)"),
	        react.createElement( Col, { width: "50" }, "50% (.col-50)")
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, { width: "75" }, "75% (.col-75)"),
	        react.createElement( Col, { width: "25" }, "25% (.col-25)")
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, { width: "80" }, "80% (.col-80)"),
	        react.createElement( Col, { width: "20" }, "20% (.col-20)")
	      )
	    ),
	    react.createElement( BlockTitle, null, "No gap between columns" ),
	    react.createElement( Block, null,
	      react.createElement( Row, { noGap: true },
	        react.createElement( Col, null, "50% (.col)" ),
	        react.createElement( Col, null, "50% (.col)" )
	      ),
	      react.createElement( Row, { noGap: true },
	        react.createElement( Col, null, "25% (.col)" ),
	        react.createElement( Col, null, "25% (.col)" ),
	        react.createElement( Col, null, "25% (.col)" ),
	        react.createElement( Col, null, "25% (.col)" )
	      ),
	      react.createElement( Row, { noGap: true },
	        react.createElement( Col, null, "33% (.col)" ),
	        react.createElement( Col, null, "33% (.col)" ),
	        react.createElement( Col, null, "33% (.col)" )
	      ),
	      react.createElement( Row, { noGap: true },
	        react.createElement( Col, null, "20% (.col)" ),
	        react.createElement( Col, null, "20% (.col)" ),
	        react.createElement( Col, null, "20% (.col)" ),
	        react.createElement( Col, null, "20% (.col)" ),
	        react.createElement( Col, null, "20% (.col)" )
	      ),
	      react.createElement( Row, { noGap: true },
	        react.createElement( Col, { width: "33" }, "33% (.col-33)"),
	        react.createElement( Col, { width: "66" }, "66% (.col-66)")
	      ),
	      react.createElement( Row, { noGap: true },
	        react.createElement( Col, { width: "25" }, "25% (.col-25)"),
	        react.createElement( Col, { width: "25" }, "25% (.col-25)"),
	        react.createElement( Col, { width: "50" }, "50% (.col-50)")
	      ),
	      react.createElement( Row, { noGap: true },
	        react.createElement( Col, { width: "75" }, "75% (.col-75)"),
	        react.createElement( Col, { width: "25" }, "25% (.col-25)")
	      ),
	      react.createElement( Row, { noGap: true },
	        react.createElement( Col, { width: "80" }, "80% (.col-80)"),
	        react.createElement( Col, { width: "20" }, "20% (.col-20)")
	      )
	    ),

	    react.createElement( BlockTitle, null, "Nested" ),
	    react.createElement( Block, null,
	      react.createElement( Row, null,
	        react.createElement( Col, null, "50% (.col) ", react.createElement( Row, null,
	            react.createElement( Col, null, "50% (.col)" ),
	            react.createElement( Col, null, "50% (.col)" )
	          )
	        ),
	        react.createElement( Col, null, "50% (.col) ", react.createElement( Row, null,
	            react.createElement( Col, { width: "33" }, "33% (.col-33)"),
	            react.createElement( Col, { width: "66" }, "66% (.col-66)")
	          )
	        )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Responsive Grid" ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Grid cells have different size on Phone/Tablet" ),
	      react.createElement( Row, null,
	        react.createElement( Col, { width: "100", tabletWidth: "50" }, ".col-100.tablet-50"),
	        react.createElement( Col, { width: "100", tabletWidth: "50" }, ".col-100.tablet-50")
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, { width: "50", tabletWidth: "25" }, ".col-50.tablet-25"),
	        react.createElement( Col, { width: "50", tabletWidth: "25" }, ".col-50.tablet-25"),
	        react.createElement( Col, { width: "50", tabletWidth: "25" }, ".col-50.tablet-25"),
	        react.createElement( Col, { width: "50", tabletWidth: "25" }, ".col-50.tablet-25")
	      ),
	      react.createElement( Row, null,
	        react.createElement( Col, { width: "100", tabletWidth: "40" }, ".col-100.tablet-40"),
	        react.createElement( Col, { width: "50", tabletWidth: "60" }, ".col-50.tablet-60"),
	        react.createElement( Col, { width: "50", tabletWidth: "66" }, ".col-50.tablet-66"),
	        react.createElement( Col, { width: "100", tabletWidth: "33" }, ".col-100.tablet-33")
	      )
	    )
	  )
	); }

	var f7Icons = 'abc abc_square abc_square_fill add add_round add_round_fill alarm alarm_fill albums albums_fill alert alert_fill arrow_down arrow_down_round_fill arrow_left arrow_left_round_fill arrow_right arrow_right_round_fill arrow_up arrow_up_round_fill at at_round at_round_fill attachment bag bag_fill barcode barcode_fill bars bars_chart bars_chart_round bars_chart_round_fill bars_chart_square bars_chart_square_fill bell bell_fill bell_off bitcoin bitcoin_round bitcoin_round_fill bolt bolt_fill bolt_round bolt_round_fill book book_fill bookmark bookmark_fill box box_fill briefcase briefcase_fill bulb bulb_fill business business_fill calendar calendar_fill calendar_today calendar_today_fill camera camera_fill camera_round camera_round_fill card card_fill cat chat chat_bubble chat_bubble_fill chat_fill check check_round check_round_fill chevron_down chevron_down_round chevron_down_round_fill chevron_left chevron_left_round chevron_left_round_fill chevron_right chevron_right_round chevron_right_round_fill chevron_up chevron_up_round chevron_up_round_fill circle circle_fill circle_half close close_round close_round_fill cloud cloud_download cloud_download_fill cloud_fill cloud_upload cloud_upload_fill collection collection_fill color_filter color_filter_fill compass compass_fill compose compose_fill data data_fill delete delete_round delete_round_fill desktop document document_chart document_chart_fill document_check document_check_fill document_fill document_person document_person_fill document_text document_text_fill dog download download_fill download_round download_round_fill drawer drawer_fill drawers drawers_fill edit email email_fill enter enter_fill enter_round enter_round_fill exit exit_fill exit_round exit_round_fill expand eye eye_fill eye_off fastforward fastforward_fill fastforward_round fastforward_round_fill favorites favorites_alt favorites_alt_fill favorites_fill film film_fill filter fire fire_fill flag flag_fill folder folder_fill forward forward_fill gamepad gear gear_fill gift gift_fill graph_round graph_round_fill graph_square graph_square_fill hand hand_alt heart heart_fill help help_round help_round_fill home home_fill images images_fill infinite info info_round info_round_fill keyboard keyboard_fill laptop layers layers_alt layers_alt_fill layers_fill library library_fill link list list_fill lock lock_fill logo_android logo_android_text logo_apple logo_facebook logo_github logo_google logo_google_text logo_googleplus logo_instagram logo_ios logo_linkedin logo_macos logo_microsoft logo_rss logo_twitter logo_windows map menu message message_fill mic mic_fill mic_off mic_round mic_round_fill money_dollar money_dollar_round money_dollar_round_fill money_euro money_euro_round money_euro_round_fill money_pound money_pound_round money_pound_round_fill money_rubl money_rubl_round money_rubl_round_fill money_yen money_yen_round money_yen_round_fill more more_fill more_round more_round_fill more_vertical more_vertical_fill more_vertical_round more_vertical_round_fill move navigation navigation_fill navigation_round navigation_round_fill numbers numbers_square numbers_square_fill paper_plane paper_plane_fill pause pause_fill pause_round pause_round_fill paw person person_round person_round_fill persons persons_round persons_round_fill phone phone_fill phone_landscape phone_portrait phone_round phone_round_fill photos photos_fill piano pie_chart pie_chart_fill placemark placemark_fill play play_fill play_round play_round_fill poultry_leg print qrcode radio redo refresh refresh_round refresh_round_fill reload reload_round reload_round_fill reply reply_fill resize resize_h resize_v rewind rewind_fill rewind_round rewind_round_fill rocket rocket_fill save scissors search settings settings_fill share share_fill shopping_cart sort sort_down sort_down_round sort_down_round_fill sort_round sort_round_fill sort_up sort_up_round sort_up_round_fill star star_fill star_half star_round_fill stopwatch stopwatch_fill tablet_landscape tablet_portrait tabs tabs_fill tag tag_fill tags tags_fill tape tape_fill thumbs_down thumbs_up ticket ticket_fill tickets tickets_fill time time_fill timer timer_fill today today_fill trash trash_fill tree tune tune_fill undo unlock unlock_fill upload_round upload_round_fill videocam videocam_fill videocam_round videocam_round_fill volume volume_fill volume_low volume_low_fill volume_mute volume_mute_fill volume_off waterdrop waterdrop_fill world world_fill zoom_in zoom_out'.split(' ');

	var mdIcons = '3d_rotation ac_unit access_alarm access_alarms access_time accessibility accessible account_balance account_balance_wallet account_box account_circle adb add add_a_photo add_alarm add_alert add_box add_circle add_circle_outline add_location add_shopping_cart add_to_photos add_to_queue adjust airline_seat_flat airline_seat_flat_angled airline_seat_individual_suite airline_seat_legroom_extra airline_seat_legroom_normal airline_seat_legroom_reduced airline_seat_recline_extra airline_seat_recline_normal airplanemode_active airplanemode_inactive airplay airport_shuttle alarm alarm_add alarm_off alarm_on album all_inclusive all_out android announcement apps archive arrow_back arrow_downward arrow_drop_down arrow_drop_down_circle arrow_drop_up arrow_forward arrow_upward art_track aspect_ratio assessment assignment assignment_ind assignment_late assignment_return assignment_returned assignment_turned_in assistant assistant_photo attach_file attach_money attachment audiotrack autorenew av_timer backspace backup battery_alert battery_charging_full battery_full battery_std battery_unknown beach_access beenhere block bluetooth bluetooth_audio bluetooth_connected bluetooth_disabled bluetooth_searching blur_circular blur_linear blur_off blur_on book bookmark bookmark_border border_all border_bottom border_clear border_color border_horizontal border_inner border_left border_outer border_right border_style border_top border_vertical branding_watermark brightness_1 brightness_2 brightness_3 brightness_4 brightness_5 brightness_6 brightness_7 brightness_auto brightness_high brightness_low brightness_medium broken_image brush bubble_chart bug_report build burst_mode business business_center cached cake call call_end call_made call_merge call_missed call_missed_outgoing call_received call_split call_to_action camera camera_alt camera_enhance camera_front camera_rear camera_roll cancel card_giftcard card_membership card_travel casino cast cast_connected center_focus_strong center_focus_weak change_history chat chat_bubble chat_bubble_outline check check_box check_box_outline_blank check_circle chevron_left chevron_right child_care child_friendly chrome_reader_mode class clear clear_all close closed_caption cloud cloud_circle cloud_done cloud_download cloud_off cloud_queue cloud_upload code collections collections_bookmark color_lens colorize comment compare compare_arrows computer confirmation_number contact_mail contact_phone contacts content_copy content_cut content_paste control_point control_point_duplicate copyright create create_new_folder credit_card crop crop_16_9 crop_3_2 crop_5_4 crop_7_5 crop_din crop_free crop_landscape crop_original crop_portrait crop_rotate crop_square dashboard data_usage date_range dehaze delete delete_forever delete_sweep description desktop_mac desktop_windows details developer_board developer_mode device_hub devices devices_other dialer_sip dialpad directions directions_bike directions_boat directions_bus directions_car directions_railway directions_run directions_subway directions_transit directions_walk disc_full dns do_not_disturb do_not_disturb_alt do_not_disturb_off do_not_disturb_on dock domain done done_all donut_large donut_small drafts drag_handle drive_eta dvr edit edit_location eject email enhanced_encryption equalizer error error_outline euro_symbol ev_station event event_available event_busy event_note event_seat exit_to_app expand_less expand_more explicit explore exposure exposure_neg_1 exposure_neg_2 exposure_plus_1 exposure_plus_2 exposure_zero extension face fast_forward fast_rewind favorite favorite_border featured_play_list featured_video feedback fiber_dvr fiber_manual_record fiber_new fiber_pin fiber_smart_record file_download file_upload filter filter_1 filter_2 filter_3 filter_4 filter_5 filter_6 filter_7 filter_8 filter_9 filter_9_plus filter_b_and_w filter_center_focus filter_drama filter_frames filter_hdr filter_list filter_none filter_tilt_shift filter_vintage find_in_page find_replace fingerprint first_page fitness_center flag flare flash_auto flash_off flash_on flight flight_land flight_takeoff flip flip_to_back flip_to_front folder folder_open folder_shared folder_special font_download format_align_center format_align_justify format_align_left format_align_right format_bold format_clear format_color_fill format_color_reset format_color_text format_indent_decrease format_indent_increase format_italic format_line_spacing format_list_bulleted format_list_numbered format_paint format_quote format_shapes format_size format_strikethrough format_textdirection_l_to_r format_textdirection_r_to_l format_underlined forum forward forward_10 forward_30 forward_5 free_breakfast fullscreen fullscreen_exit functions g_translate gamepad games gavel gesture get_app gif golf_course gps_fixed gps_not_fixed gps_off grade gradient grain graphic_eq grid_off grid_on group group_add group_work hd hdr_off hdr_on hdr_strong hdr_weak headset headset_mic healing hearing help help_outline high_quality highlight highlight_off history home hot_tub hotel hourglass_empty hourglass_full http https image image_aspect_ratio import_contacts import_export important_devices inbox indeterminate_check_box info info_outline input insert_chart insert_comment insert_drive_file insert_emoticon insert_invitation insert_link insert_photo invert_colors invert_colors_off iso keyboard keyboard_arrow_down keyboard_arrow_left keyboard_arrow_right keyboard_arrow_up keyboard_backspace keyboard_capslock keyboard_hide keyboard_return keyboard_tab keyboard_voice kitchen label label_outline landscape language laptop laptop_chromebook laptop_mac laptop_windows last_page launch layers layers_clear leak_add leak_remove lens library_add library_books library_music lightbulb_outline line_style line_weight linear_scale link linked_camera list live_help live_tv local_activity local_airport local_atm local_bar local_cafe local_car_wash local_convenience_store local_dining local_drink local_florist local_gas_station local_grocery_store local_hospital local_hotel local_laundry_service local_library local_mall local_movies local_offer local_parking local_pharmacy local_phone local_pizza local_play local_post_office local_printshop local_see local_shipping local_taxi location_city location_disabled location_off location_on location_searching lock lock_open lock_outline looks looks_3 looks_4 looks_5 looks_6 looks_one looks_two loop loupe low_priority loyalty mail mail_outline map markunread markunread_mailbox memory menu merge_type message mic mic_none mic_off mms mode_comment mode_edit monetization_on money_off monochrome_photos mood mood_bad more more_horiz more_vert motorcycle mouse move_to_inbox movie movie_creation movie_filter multiline_chart music_note music_video my_location nature nature_people navigate_before navigate_next navigation near_me network_cell network_check network_locked network_wifi new_releases next_week nfc no_encryption no_sim not_interested note note_add notifications notifications_active notifications_none notifications_off notifications_paused offline_pin ondemand_video opacity open_in_browser open_in_new open_with pages pageview palette pan_tool panorama panorama_fish_eye panorama_horizontal panorama_vertical panorama_wide_angle party_mode pause pause_circle_filled pause_circle_outline payment people people_outline perm_camera_mic perm_contact_calendar perm_data_setting perm_device_information perm_identity perm_media perm_phone_msg perm_scan_wifi person person_add person_outline person_pin person_pin_circle personal_video pets phone phone_android phone_bluetooth_speaker phone_forwarded phone_in_talk phone_iphone phone_locked phone_missed phone_paused phonelink phonelink_erase phonelink_lock phonelink_off phonelink_ring phonelink_setup photo photo_album photo_camera photo_filter photo_library photo_size_select_actual photo_size_select_large photo_size_select_small picture_as_pdf picture_in_picture picture_in_picture_alt pie_chart pie_chart_outlined pin_drop place play_arrow play_circle_filled play_circle_outline play_for_work playlist_add playlist_add_check playlist_play plus_one poll polymer pool portable_wifi_off portrait power power_input power_settings_new pregnant_woman present_to_all print priority_high public publish query_builder question_answer queue queue_music queue_play_next radio radio_button_checked radio_button_unchecked rate_review receipt recent_actors record_voice_over redeem redo refresh remove remove_circle remove_circle_outline remove_from_queue remove_red_eye remove_shopping_cart reorder repeat repeat_one replay replay_10 replay_30 replay_5 reply reply_all report report_problem restaurant restaurant_menu restore restore_page ring_volume room room_service rotate_90_degrees_ccw rotate_left rotate_right rounded_corner router rowing rss_feed rv_hookup satellite save scanner schedule school screen_lock_landscape screen_lock_portrait screen_lock_rotation screen_rotation screen_share sd_card sd_storage search security select_all send sentiment_dissatisfied sentiment_neutral sentiment_satisfied sentiment_very_dissatisfied sentiment_very_satisfied settings settings_applications settings_backup_restore settings_bluetooth settings_brightness settings_cell settings_ethernet settings_input_antenna settings_input_component settings_input_composite settings_input_hdmi settings_input_svideo settings_overscan settings_phone settings_power settings_remote settings_system_daydream settings_voice share shop shop_two shopping_basket shopping_cart short_text show_chart shuffle signal_cellular_4_bar signal_cellular_connected_no_internet_4_bar signal_cellular_no_sim signal_cellular_null signal_cellular_off signal_wifi_4_bar signal_wifi_4_bar_lock signal_wifi_off sim_card sim_card_alert skip_next skip_previous slideshow slow_motion_video smartphone smoke_free smoking_rooms sms sms_failed snooze sort sort_by_alpha spa space_bar speaker speaker_group speaker_notes speaker_notes_off speaker_phone spellcheck star star_border star_half stars stay_current_landscape stay_current_portrait stay_primary_landscape stay_primary_portrait stop stop_screen_share storage store store_mall_directory straighten streetview strikethrough_s style subdirectory_arrow_left subdirectory_arrow_right subject subscriptions subtitles subway supervisor_account surround_sound swap_calls swap_horiz swap_vert swap_vertical_circle switch_camera switch_video sync sync_disabled sync_problem system_update system_update_alt tab tab_unselected tablet tablet_android tablet_mac tag_faces tap_and_play terrain text_fields text_format textsms texture theaters thumb_down thumb_up thumbs_up_down time_to_leave timelapse timeline timer timer_10 timer_3 timer_off title toc today toll tonality touch_app toys track_changes traffic train tram transfer_within_a_station transform translate trending_down trending_flat trending_up tune turned_in turned_in_not tv unarchive undo unfold_less unfold_more update usb verified_user vertical_align_bottom vertical_align_center vertical_align_top vibration video_call video_label video_library videocam videocam_off videogame_asset view_agenda view_array view_carousel view_column view_comfy view_compact view_day view_headline view_list view_module view_quilt view_stream view_week vignette visibility visibility_off voice_chat voicemail volume_down volume_mute volume_off volume_up vpn_key vpn_lock wallpaper warning watch watch_later wb_auto wb_cloudy wb_incandescent wb_iridescent wb_sunny wc web web_asset weekend whatshot widgets wifi wifi_lock wifi_tethering work wrap_text youtube_searched_for zoom_in zoom_out zoom_out_map'.split(' ');

	function Icons () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Icons", backLink: "Back" }),
	    react.createElement( BlockTitle, null, "Scroll bottom" ),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "Framework7 comes with the premium and free ", react.createElement( 'a', { href: "https://github.com/framework7io/framework7-icons", className: "external", target: "_blank" }, "Framework7 Icons"), " iOS-icons font developed specially to be used with iOS theme of Framework7. As for Material theme we recommend to use great-designed ", react.createElement( 'a', { href: "https://material.io/icons/", className: "external", target: "_blank" }, "Material Icons"), " font. Both of these fonts use a typographic feature called ", react.createElement( 'a', { href: "http://alistapart.com/article/the-era-of-symbol-fonts", className: "external", target: "_blank" }, "ligatures"), ". It’s easy to incorporate icons into your app. Here’s a small example:" ),
	      react.createElement( 'p', null, react.createElement( 'code', null, "<i class=\"f7-icons\">home</i>" ), " - ", react.createElement( 'i', { className: "f7-icons" }, "home") ),
	      react.createElement( 'p', null, react.createElement( 'code', null, "<i class=\"material-icons\">home</i>" ), " - ", react.createElement( 'i', { className: "material-icons" }, "home") ),
	      react.createElement( 'p', null, react.createElement( 'a', { href: "http://alistapart.com/article/the-era-of-symbol-fonts", className: "external", target: "_blank" }, "Ligatures"), " allow rendering of an icon glyph simply by using its textual name. The replacement is done automatically by the web browser and provides more readable code than the equivalent numeric character reference." )
	    ),
	    react.createElement( BlockHeader, null,
	      react.createElement( Segmented, null,
	        react.createElement( Button, { outline: true, tabLink: "#tab-f7", tabLinkActive: true }, "F7 Icons"),
	        react.createElement( Button, { outline: true, tabLink: "#tab-md" }, "Material Icons")
	      )
	    ),
	    react.createElement( Block, { strong: true, className: "tabs" },
	      react.createElement( Tab$1, { id: "tab-f7", tabActive: true },
	        react.createElement( Row, null,
	          f7Icons.map(function (icon, index) { return (
	            react.createElement( Col, { key: index, width: "33", tabletWidth: "15", className: "demo-icon" },
	              react.createElement( 'div', { className: "demo-icon-icon" },
	                react.createElement( Icon, { f7: icon })
	              ),
	              react.createElement( 'div', { className: "demo-icon-name" }, icon)
	            )
	          ); })
	        )
	      ),
	      react.createElement( Tab$1, { id: "tab-md" },
	        react.createElement( Row, null,
	          mdIcons.map(function (icon, index) { return (
	            react.createElement( Col, { key: index, width: "33", tabletWidth: "15", className: "demo-icon" },
	              react.createElement( 'div', { className: "demo-icon-icon" },
	                react.createElement( Icon, { material: icon })
	              ),
	              react.createElement( 'div', { className: "demo-icon-name" }, icon)
	            )
	          ); })
	        )
	      )
	    )
	  )
	); }

	var defaultExport$b = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);

	    this.state = {
	      items: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
	      allowInfinite: true,
	      showPreloader: true,
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, {
	        infinite: true, infiniteDistance: 50, infinitePreloader: this.state.showPreloader, onInfinite: this.loadMore.bind(this) },
	        react.createElement( Navbar$2, { title: "Infinite Scroll", backLink: "Back" }),
	        react.createElement( BlockTitle, null, "Scroll bottom" ),
	        react.createElement( List, null,
	          this.state.items.map(function (item, index) { return (
	            react.createElement( ListItem, { title: ("Item " + item), key: index })
	          ); })
	        )
	      )
	    )
	  };
	  defaultExport.prototype.loadMore = function loadMore () {
	    var self = this;
	    if (!self.state.allowInfinite) { return; }
	    self.setState({ allowInfinite: false });

	    setTimeout(function () {
	      var items = self.state.items;
	      if (items.length >= 200) {
	        self.setState({ showPreloader: false });
	        return;
	      }

	      var itemsLength = items.length;

	      for (var i = 1; i <= 20; i += 1) {
	        items.push(itemsLength + i);
	      }

	      self.setState({
	        items: items,
	        allowInfinite: true,
	      });
	    }, 1000);
	  };

	  return defaultExport;
	}(react.Component));

	function Inputs () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Form Inputs", backLink: "Back" }),
	    react.createElement( BlockTitle, null, "Full Layout / Inline Labels" ),
	    react.createElement( List, { inlineLabels: true, noHairlinesMd: true },
	      react.createElement( ListInput, {
	        label: "Name", type: "text", placeholder: "Your name", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Password", type: "password", placeholder: "Your password", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "E-mail", type: "email", placeholder: "Your e-mail", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "URL", type: "url", placeholder: "URL", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Phone", type: "tel", placeholder: "Your phone number", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Gender", type: "select", defaultValue: "Male", placeholder: "Please choose..." },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" }),
	        react.createElement( 'option', { value: "Male" }, "Male"),
	        react.createElement( 'option', { value: "Female" }, "Female")
	      ),

	      react.createElement( ListInput, {
	        label: "Birthday", type: "date", defaultValue: "2014-04-30", placeholder: "Please choose..." },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Date time", type: "datetime-local", placeholder: "Please choose..." },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Range", input: false },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" }),
	        react.createElement( Range$2, { slot: "input", value: 50, min: 0, max: 100, step: 1 })
	      ),

	      react.createElement( ListInput, {
	        label: "Textarea", type: "textarea", placeholder: "Bio" },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Resizable", type: "textarea", resizable: true, placeholder: "Bio" },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      )

	    ),

	    react.createElement( BlockTitle, null, "Full Layout / Stacked Labels" ),
	    react.createElement( List, { noHairlinesMd: true },
	      react.createElement( ListInput, {
	        label: "Name", type: "text", placeholder: "Your name", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Password", type: "password", placeholder: "Your password", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "E-mail", type: "email", placeholder: "Your e-mail", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "URL", type: "url", placeholder: "URL", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Phone", type: "tel", placeholder: "Your phone number", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Gender", type: "select", defaultValue: "Male", placeholder: "Please choose..." },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" }),
	        react.createElement( 'option', { value: "Male" }, "Male"),
	        react.createElement( 'option', { value: "Female" }, "Female")
	      ),

	      react.createElement( ListInput, {
	        label: "Birthday", type: "date", defaultValue: "2014-04-30", placeholder: "Please choose..." },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Date time", type: "datetime-local", placeholder: "Please choose..." },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Range", input: false },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" }),
	        react.createElement( Range$2, { slot: "input", value: 50, min: 0, max: 100, step: 1 })
	      ),

	      react.createElement( ListInput, {
	        label: "Textarea", type: "textarea", placeholder: "Bio" },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Resizable", type: "textarea", resizable: true, placeholder: "Bio" },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      )
	    ),

	    react.createElement( BlockTitle, null, "Floating Labels" ),
	    react.createElement( List, { noHairlinesMd: true },
	      react.createElement( ListInput, {
	        label: "Name", floatingLabel: true, type: "text", placeholder: "Your name", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Password", floatingLabel: true, type: "password", placeholder: "Your password", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "E-mail", floatingLabel: true, type: "email", placeholder: "Your e-mail", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "URL", floatingLabel: true, type: "url", placeholder: "URL", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Phone", floatingLabel: true, type: "tel", placeholder: "Your phone number", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Resizable", floatingLabel: true, type: "textarea", resizable: true, placeholder: "Bio" },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      )
	    ),

	    react.createElement( BlockTitle, null, "Floating Labels + Outline Inputs" ),
	    react.createElement( List, { noHairlinesMd: true },
	      react.createElement( ListInput, {
	        outline: true, label: "Name", floatingLabel: true, type: "text", placeholder: "Your name", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),
	      react.createElement( ListInput, {
	        outline: true, label: "Password", floatingLabel: true, type: "password", placeholder: "Your password", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),
	      react.createElement( ListInput, {
	        outline: true, label: "E-mail", floatingLabel: true, type: "email", placeholder: "Your e-mail", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),
	      react.createElement( ListInput, {
	        outline: true, label: "URL", floatingLabel: true, type: "url", placeholder: "URL", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),
	      react.createElement( ListInput, {
	        outline: true, label: "Phone", floatingLabel: true, type: "tel", placeholder: "Your phone number", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),
	      react.createElement( ListInput, {
	        outline: true, label: "Bio", floatingLabel: true, type: "textarea", resizable: true, placeholder: "Bio", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      )
	    ),

	    react.createElement( BlockTitle, null, "Validation + Additional Info" ),
	    react.createElement( List, { noHairlinesMd: true },
	      react.createElement( ListInput, {
	        label: "Name", type: "text", placeholder: "Your name", info: "Default validation", required: true, validate: true, clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Fruit", type: "text", placeholder: "Type 'apple' or 'banana'", required: true, validate: true, pattern: "apple|banana", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" }),
	        react.createElement( 'span', { slot: "info" }, "Pattern validation (", react.createElement( 'b', null, "apple|banana" ), ")")
	      ),

	      react.createElement( ListInput, {
	        label: "E-mail", type: "email", placeholder: "Your e-mail", info: "Default e-mail validation", required: true, validate: true, clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "URL", type: "url", placeholder: "Your URL", info: "Default URL validation", required: true, validate: true, clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        label: "Number", type: "text", placeholder: "Enter number", info: "With custom error message", errorMessage: "Only numbers please!", required: true, validate: true, pattern: "[0-9]*", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      )

	    ),

	    react.createElement( BlockTitle, null, "Icon + Input" ),
	    react.createElement( List, { noHairlinesMd: true },
	      react.createElement( ListInput, {
	        type: "text", placeholder: "Your name", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        type: "password", placeholder: "Your password", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        type: "email", placeholder: "Your e-mail", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      ),

	      react.createElement( ListInput, {
	        type: "url", placeholder: "URL", clearButton: true },
	        react.createElement( Icon, { icon: "demo-list-icon", slot: "media" })
	      )

	    ),

	    react.createElement( BlockTitle, null, "Label + Input" ),
	    react.createElement( List, { noHairlinesMd: true },
	      react.createElement( ListInput, {
	        label: "Name", type: "text", placeholder: "Your name", clearButton: true }),

	      react.createElement( ListInput, {
	        label: "Password", type: "password", placeholder: "Your password", clearButton: true }),

	      react.createElement( ListInput, {
	        label: "E-mail", type: "email", placeholder: "Your e-mail", clearButton: true }),

	      react.createElement( ListInput, {
	        label: "URL", type: "url", placeholder: "URL", clearButton: true })
	    ),

	    react.createElement( BlockTitle, null, "Only Inputs" ),
	    react.createElement( List, { noHairlinesMd: true },
	      react.createElement( ListInput, {
	        type: "text", placeholder: "Your name", clearButton: true }),

	      react.createElement( ListInput, {
	        type: "password", placeholder: "Your password", clearButton: true }),

	      react.createElement( ListInput, {
	        type: "email", placeholder: "Your e-mail", clearButton: true }),

	      react.createElement( ListInput, {
	        type: "url", placeholder: "URL", clearButton: true })
	    ),

	    react.createElement( BlockTitle, null, "Inputs + Additional Info" ),
	    react.createElement( List, { noHairlinesMd: true },
	      react.createElement( ListInput, {
	        type: "text", placeholder: "Your name", info: "Full name please", clearButton: true }),

	      react.createElement( ListInput, {
	        type: "password", placeholder: "Your password", info: "8 characters minimum", clearButton: true }),

	      react.createElement( ListInput, {
	        type: "email", placeholder: "Your e-mail", info: "Your work e-mail address", clearButton: true }),

	      react.createElement( ListInput, {
	        type: "url", placeholder: "URL", info: "Your website URL", clearButton: true })
	    ),

	    react.createElement( BlockTitle, null, "Only Inputs Inset" ),
	    react.createElement( List, { inset: true },
	      react.createElement( ListInput, {
	        type: "text", placeholder: "Your name", clearButton: true }),

	      react.createElement( ListInput, {
	        type: "password", placeholder: "Your password", clearButton: true }),

	      react.createElement( ListInput, {
	        type: "email", placeholder: "Your e-mail", clearButton: true }),

	      react.createElement( ListInput, {
	        type: "url", placeholder: "URL", clearButton: true })
	    )
	  )
	); }

	function LazyLoad () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Lazy Load Images", backLink: "Back" }),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "Lazy Load delays loading of images on page while they are outside of viewport until user scrolls to them." ),
	      react.createElement( 'p', null, "It will make the page load faster, improve scrolling performance and also save traffic." )
	    ),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, " ", react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-500x500-1.jpg", width: "1500", height: "1500", className: "lazy lazy-fadeIn demo-lazy" }) ),
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi tempus viverra lectus sit amet lobortis. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Quisque faucibus consectetur mauris eget lobortis. Maecenas efficitur efficitur mauris ac vehicula. Sed ut lectus laoreet, semper nisi vel, maximus massa. Duis at lorem vitae sem auctor condimentum a at neque. Phasellus vel scelerisque dui. Morbi varius nibh eu finibus rutrum." ),
	      react.createElement( 'p', null, " ", react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-500x500-2.jpg", width: "1500", height: "1500", className: "lazy lazy-fadeIn demo-lazy" }) ),
	      react.createElement( 'p', null, "Aenean id congue orci. Aliquam gravida nulla nec sollicitudin consectetur. Donec iaculis ipsum in purus tincidunt sagittis quis vehicula sapien. Vestibulum quis consectetur nibh. Pellentesque vehicula ligula sit amet commodo malesuada. Proin eget dolor sodales, egestas sapien sed, consectetur ante. Vivamus imperdiet porttitor condimentum. Aliquam sit amet tellus quis mauris dapibus convallis eu in nulla. Aliquam erat volutpat." ),
	      react.createElement( 'p', null, " ", react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-500x500-3.jpg", width: "1500", height: "1500", className: "lazy lazy-fadeIn demo-lazy" }) ),
	      react.createElement( 'p', null, "Pellentesque aliquam maximus libero a tincidunt. Nunc rhoncus tellus ac congue commodo. Aenean malesuada ante sit amet erat efficitur vehicula ac id ipsum. Suspendisse sed purus vel nisl rhoncus feugiat et ut ante. Mauris vehicula ligula sed nisl vulputate, nec ullamcorper quam vehicula. Etiam eu turpis eget sem luctus rutrum at porta nulla. Ut posuere lorem et nisi faucibus molestie." ),
	      react.createElement( 'p', null, " ", react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-500x500-4.jpg", width: "1500", height: "1500", className: "lazy lazy-fadeIn demo-lazy" }) ),
	      react.createElement( 'p', null, "Duis ullamcorper velit id enim rutrum, vel venenatis lacus laoreet. Sed id bibendum ligula, sed congue erat. Maecenas rhoncus posuere lorem ac consectetur. Duis accumsan, urna id pharetra tincidunt, libero nibh tincidunt enim, vestibulum suscipit turpis neque nec ante." ),
	      react.createElement( 'p', null, " ", react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-500x500-5.jpg", width: "1500", height: "1500", className: "lazy lazy-fadeIn demo-lazy" }) ),
	      react.createElement( 'p', null, "Suspendisse potenti. Curabitur et neque ac ante dapibus mollis tempor eget ex. Vivamus porttitor faucibus dui. Nulla eleifend hendrerit cursus. Sed elit nulla, pulvinar vitae diam eget, consectetur efficitur orci. Vivamus vel pharetra sapien. Suspendisse tortor tortor, iaculis at ullamcorper sit amet, vestibulum vel arcu. Aenean sed eleifend sapien. Praesent at varius metus." ),
	      react.createElement( 'p', null, " ", react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-500x500-6.jpg", width: "1500", height: "1500", className: "lazy lazy-fadeIn demo-lazy" }) ),
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent laoreet nisl eget neque blandit lobortis. Sed sagittis risus id vestibulum finibus. Cras vestibulum sem et massa hendrerit maximus. Vestibulum suscipit tristique iaculis. Nam vitae risus non eros auctor tincidunt quis vel nulla. Sed volutpat, libero ac blandit vehicula, est sem gravida lectus, sed imperdiet sapien risus ut neque." ),
	      react.createElement( 'p', null, " ", react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-500x500-7.jpg", width: "1500", height: "1500", className: "lazy lazy-fadeIn demo-lazy" }) ),
	      react.createElement( 'p', null, "Aenean id congue orci. Aliquam gravida nulla nec sollicitudin consectetur. Donec iaculis ipsum in purus tincidunt sagittis quis vehicula sapien. Vestibulum quis consectetur nibh. Pellentesque vehicula ligula sit amet commodo malesuada. Proin eget dolor sodales, egestas sapien sed, consectetur ante. Vivamus imperdiet porttitor condimentum. Aliquam sit amet tellus quis mauris dapibus convallis eu in nulla. Aliquam erat volutpat." ),
	      react.createElement( 'p', null, " ", react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-500x500-8.jpg", width: "1500", height: "1500", className: "lazy lazy-fadeIn demo-lazy" }) ),
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi tempus viverra lectus sit amet lobortis. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Quisque faucibus consectetur mauris eget lobortis. Maecenas efficitur efficitur mauris ac vehicula. Sed ut lectus laoreet, semper nisi vel, maximus massa. Duis at lorem vitae sem auctor condimentum a at neque. Phasellus vel scelerisque dui. Morbi varius nibh eu finibus rutrum." ),
	      react.createElement( 'p', null, " ", react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/people-500x500-1.jpg", width: "1500", height: "1500", className: "lazy lazy-fadeIn demo-lazy" }) ),
	      react.createElement( 'p', null, "Pellentesque aliquam maximus libero a tincidunt. Nunc rhoncus tellus ac congue commodo. Aenean malesuada ante sit amet erat efficitur vehicula ac id ipsum. Suspendisse sed purus vel nisl rhoncus feugiat et ut ante. Mauris vehicula ligula sed nisl vulputate, nec ullamcorper quam vehicula. Etiam eu turpis eget sem luctus rutrum at porta nulla. Ut posuere lorem et nisi faucibus molestie." ),
	      react.createElement( 'p', null, " ", react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-500x500-10.jpg", width: "1500", height: "1500", className: "lazy lazy-fadeIn demo-lazy" }) ),
	      react.createElement( 'p', null, "Duis ullamcorper velit id enim rutrum, vel venenatis lacus laoreet. Sed id bibendum ligula, sed congue erat. Maecenas rhoncus posuere lorem ac consectetur. Duis accumsan, urna id pharetra tincidunt, libero nibh tincidunt enim, vestibulum suscipit turpis neque nec ante." ),
	      react.createElement( 'p', null, react.createElement( 'b', null, "Using as background image:" ) ),
	      react.createElement( 'div', { 'data-background': "https://cdn.framework7.io/placeholder/people-500x500-10.jpg", className: "lazy lazy-fadeIn demo-lazy" }),
	      react.createElement( 'p', null, "Suspendisse potenti. Curabitur et neque ac ante dapibus mollis tempor eget ex. Vivamus porttitor faucibus dui. Nulla eleifend hendrerit cursus. Sed elit nulla, pulvinar vitae diam eget, consectetur efficitur orci. Vivamus vel pharetra sapien. Suspendisse tortor tortor, iaculis at ullamcorper sit amet, vestibulum vel arcu. Aenean sed eleifend sapien. Praesent at varius metus." )
	    )
	  )
	); }

	function List$1 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "List View", backLink: "Back" }),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Framework7 allows you to be flexible with list views (table views). You can make them as navigation menus, you can use there icons, inputs, and any elements inside of the list, and even make them nested:" )
	    ),
	    react.createElement( BlockTitle, null, "Simple List" ),
	    react.createElement( List, { simpleList: true },
	      react.createElement( ListItem, { title: "Item 1" }),
	      react.createElement( ListItem, { title: "Item 2" }),
	      react.createElement( ListItem, { title: "Item 3" })
	    ),
	    react.createElement( BlockTitle, null, "Simple Links List" ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { title: "Link 1", link: "#" }),
	      react.createElement( ListItem, { title: "Link 2", link: "#" }),
	      react.createElement( ListItem, { title: "Link 3", link: "#" })
	    ),
	    react.createElement( BlockTitle, null, "Data list, with icons" ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { title: "Ivan Petrov", after: "CEO" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { title: "John Doe", badge: "5" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { title: "Jenna Smith" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      )
	    ),
	    react.createElement( BlockTitle, null, "Links" ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { link: "#", title: "Ivan Petrov", after: "CEO" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { link: "#", title: "John Doe", after: "Cleaner" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { link: "#", title: "Jenna Smith" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      )
	    ),
	    react.createElement( BlockTitle, null, "Links, Header, Footer" ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { link: "#", header: "Name", title: "John Doe", after: "Edit" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { link: "#", header: "Phone", title: "+7 90 111-22-3344", after: "Edit" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { link: "#", header: "Email", title: "john@doe", footer: "Home", after: "Edit" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { link: "#", header: "Email", title: "john@framework7", footer: "Work", after: "Edit" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      )
	    ),
	    react.createElement( BlockTitle, null, "Links, no icons" ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { link: "#", title: "Ivan Petrov" }),
	      react.createElement( ListItem, { link: "#", title: "John Doe" }),
	      react.createElement( ListItem, { divider: true, title: "Divider Here" }),
	      react.createElement( ListItem, { link: "#", title: "Ivan Petrov" }),
	      react.createElement( ListItem, { link: "#", title: "Jenna Smith" })
	    ),
	    react.createElement( BlockTitle, null, "Grouped with sticky titles" ),
	    react.createElement( List, null,
	      react.createElement( ListGroup, null,
	        react.createElement( ListItem, { title: "A", groupTitle: true }),
	        react.createElement( ListItem, { title: "Aaron " }),
	        react.createElement( ListItem, { title: "Abbie" }),
	        react.createElement( ListItem, { title: "Adam" })
	      ),
	      react.createElement( ListGroup, null,
	        react.createElement( ListItem, { title: "B", groupTitle: true }),
	        react.createElement( ListItem, { title: "Bailey" }),
	        react.createElement( ListItem, { title: "Barclay" }),
	        react.createElement( ListItem, { title: "Bartolo" })
	      ),
	      react.createElement( ListGroup, null,
	        react.createElement( ListItem, { title: "C", groupTitle: true }),
	        react.createElement( ListItem, { title: "Caiden" }),
	        react.createElement( ListItem, { title: "Calvin" }),
	        react.createElement( ListItem, { title: "Candy" })
	      )
	    ),
	    react.createElement( BlockTitle, null, "Mixed and nested" ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { link: "#", title: "Ivan Petrov", after: "CEO" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { link: "#", title: "Two icons here" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { title: "No icons here" }),
	      react.createElement( 'li', null,
	        react.createElement( 'ul', null,
	          react.createElement( ListItem, { link: "#", title: "Ivan Petrov", after: "CEO" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { link: "#", title: "Two icons here" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { title: "No icons here" }),
	          react.createElement( ListItem, { link: "#", title: "Ultra long text goes here, no, it is really really long" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          ),
	          react.createElement( ListItem, { title: "With toggle" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	            react.createElement( Toggle$2, { slot: "after" })
	          )
	        )
	      ),
	      react.createElement( ListItem, { link: "#", title: "Ultra long text goes here, no, it is really really long" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { title: "With toggle" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	        react.createElement( Toggle$2, { slot: "after" })
	      )
	    ),
	    react.createElement( BlockTitle, null, "Mixed, inset" ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { link: "#", title: "Ivan Petrov", after: "CEO" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { link: "#", title: "Two icons here" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { link: "#", title: "Ultra long text goes here, no, it is really really long" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { title: "With toggle" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	        react.createElement( Toggle$2, { slot: "after" })
	      ),
	      react.createElement( BlockFooter, null,
	        react.createElement( 'p', null, "Here comes some useful information about list above" )
	      )
	    ),
	    react.createElement( BlockTitle, null, "Tablet inset" ),
	    react.createElement( List, { tabletInset: true },
	      react.createElement( ListItem, { link: "#", title: "Ivan Petrov", after: "CEO" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { link: "#", title: "Two icons here" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( ListItem, { link: "#", title: "Ultra long text goes here, no, it is really really long" },
	        react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	      ),
	      react.createElement( BlockFooter, null,
	        react.createElement( 'p', null, "This list block will look like \"inset\" only on tablets (iPad)" )
	      )
	    ),

	    react.createElement( BlockTitle, null, "Media Lists" ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Media Lists are almost the same as Data Lists, but with a more flexible layout for visualization of more complex data, like products, services, userc, etc." )
	    ),
	    react.createElement( BlockTitle, null, "Songs" ),
	    react.createElement( List, { mediaList: true },
	      react.createElement( ListItem, {
	        link: "#", title: "Yellow Submarine", after: "$15", subtitle: "Beatles", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." },
	        react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/people-160x160-1.jpg", width: "80" })
	      ),
	      react.createElement( ListItem, {
	        link: "#", title: "Don't Stop Me Now", after: "$22", subtitle: "Queen", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." },
	        react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/people-160x160-2.jpg", width: "80" })
	      ),
	      react.createElement( ListItem, {
	        link: "#", title: "Billie Jean", after: "$16", subtitle: "Michael Jackson", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." },
	        react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/people-160x160-3.jpg", width: "80" })
	      )
	    ),
	    react.createElement( BlockTitle, null, "Mail App" ),
	    react.createElement( List, { mediaList: true },
	      react.createElement( ListItem, {
	        link: "#", title: "Facebook", after: "17:14", subtitle: "New messages from John Doe", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." }),
	      react.createElement( ListItem, {
	        link: "#", title: "John Doe (via Twitter)", after: "17:11", subtitle: "John Doe (@_johndoe) mentioned you on Twitter!", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." }),
	      react.createElement( ListItem, {
	        link: "#", title: "Facebook", after: "16:48", subtitle: "New messages from John Doe", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." }),
	      react.createElement( ListItem, {
	        link: "#", title: "John Doe (via Twitter)", after: "15:32", subtitle: "John Doe (@_johndoe) mentioned you on Twitter!", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." })
	    ),
	    react.createElement( BlockTitle, null, "Something more simple" ),
	    react.createElement( List, { mediaList: true },
	      react.createElement( ListItem, {
	        title: "Yellow Submarine", subtitle: "Beatles" },
	        react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/fashion-88x88-1.jpg", width: "44" })
	      ),
	      react.createElement( ListItem, {
	        link: "#", title: "Don't Stop Me Now", subtitle: "Queen" },
	        react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/fashion-88x88-2.jpg", width: "44" })
	      ),
	      react.createElement( ListItem, {
	        title: "Billie Jean", subtitle: "Michael Jackson" },
	        react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/fashion-88x88-3.jpg", width: "44" })
	      )
	    ),
	    react.createElement( BlockTitle, null, "Inset" ),
	    react.createElement( List, { mediaList: true, inset: true },
	      react.createElement( ListItem, {
	        link: "#", title: "Yellow Submarine", subtitle: "Beatles" },
	        react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/fashion-88x88-4.jpg", width: "44" })
	      ),
	      react.createElement( ListItem, {
	        link: "#", title: "Don't Stop Me Now", subtitle: "Queen" },
	        react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/fashion-88x88-5.jpg", width: "44" })
	      ),
	      react.createElement( ListItem, {
	        link: "#", title: "Billie Jean", subtitle: "Michael Jackson" },
	        react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/fashion-88x88-6.jpg", width: "44" })
	      )
	    ),
	    react.createElement( BlockTitle, null, "Custom Table-like Layout" ),
	    react.createElement( List, null,
	      react.createElement( 'li', null,
	        react.createElement( 'a', { href: "#", className: "item-link item-content" },
	          react.createElement( 'div', { className: "item-inner item-cell" },
	            react.createElement( ListItemRow, null,
	              react.createElement( ListItemCell, null, "Cell 1-1" ),
	              react.createElement( ListItemCell, null, "Cell 1-2" ),
	              react.createElement( ListItemCell, null, "Cell 1-3" )
	            ),
	            react.createElement( ListItemRow, null,
	              react.createElement( ListItemCell, null, "Cell 2-1" ),
	              react.createElement( ListItemCell, null, "Cell 2-2" )
	              ),
	            react.createElement( ListItemRow, null,
	              react.createElement( ListItemCell, null, "Cell 3-1" ),
	              react.createElement( ListItemCell, null,
	                react.createElement( ListItemRow, null, "Cell 3-2" ),
	                react.createElement( ListItemRow, null, "Cell 3-3" )
	              )
	            )
	          )
	        )
	      ),
	      react.createElement( 'li', null,
	        react.createElement( 'a', { href: "#", className: "item-link item-content" },
	          react.createElement( 'div', { className: "item-inner item-cell" },
	            react.createElement( ListItemRow, null,
	              react.createElement( ListItemCell, null, "Cell 1-1" ),
	              react.createElement( ListItemCell, null, "Cell 1-2" ),
	              react.createElement( ListItemCell, null, "Cell 1-3" )
	            ),
	            react.createElement( ListItemRow, null,
	              react.createElement( ListItemCell, null, "Cell 2-1" ),
	              react.createElement( ListItemCell, null, "Cell 2-2" )
	              ),
	            react.createElement( ListItemRow, null,
	              react.createElement( ListItemCell, null, "Cell 3-1" ),
	              react.createElement( ListItemCell, null,
	                react.createElement( ListItemRow, null, "Cell 3-2" ),
	                react.createElement( ListItemRow, null, "Cell 3-3" )
	              )
	            )
	          )
	        )
	      )
	    )
	  )
	); }

	var defaultExport$c = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "List Index", backLink: "Back" }),
	        react.createElement( ListIndex$2, {
	          indexes: "auto", listEl: ".list.contacts-list", scrollList: true, label: true, onListIndexSelect: this.onIndexSelect.bind(this) }),
	        react.createElement( List, { contactsList: true },
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "A", groupTitle: true }),
	            react.createElement( ListItem, { title: "Aaron" }),
	            react.createElement( ListItem, { title: "Adam" }),
	            react.createElement( ListItem, { title: "Aiden" }),
	            react.createElement( ListItem, { title: "Albert" }),
	            react.createElement( ListItem, { title: "Alex" }),
	            react.createElement( ListItem, { title: "Alexander" }),
	            react.createElement( ListItem, { title: "Alfie" }),
	            react.createElement( ListItem, { title: "Archie" }),
	            react.createElement( ListItem, { title: "Arthur" }),
	            react.createElement( ListItem, { title: "Austin" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "B", groupTitle: true }),
	            react.createElement( ListItem, { title: "Benjamin" }),
	            react.createElement( ListItem, { title: "Blake" }),
	            react.createElement( ListItem, { title: "Bobby" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "C", groupTitle: true }),
	            react.createElement( ListItem, { title: "Caleb" }),
	            react.createElement( ListItem, { title: "Callum" }),
	            react.createElement( ListItem, { title: "Cameron" }),
	            react.createElement( ListItem, { title: "Charles" }),
	            react.createElement( ListItem, { title: "Charlie" }),
	            react.createElement( ListItem, { title: "Connor" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "D", groupTitle: true }),
	            react.createElement( ListItem, { title: "Daniel" }),
	            react.createElement( ListItem, { title: "David" }),
	            react.createElement( ListItem, { title: "Dexter" }),
	            react.createElement( ListItem, { title: "Dylan" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "E", groupTitle: true }),
	            react.createElement( ListItem, { title: "Edward" }),
	            react.createElement( ListItem, { title: "Elijah" }),
	            react.createElement( ListItem, { title: "Elliot" }),
	            react.createElement( ListItem, { title: "Elliott" }),
	            react.createElement( ListItem, { title: "Ethan" }),
	            react.createElement( ListItem, { title: "Evan" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "F", groupTitle: true }),
	            react.createElement( ListItem, { title: "Felix" }),
	            react.createElement( ListItem, { title: "Finlay" }),
	            react.createElement( ListItem, { title: "Finley" }),
	            react.createElement( ListItem, { title: "Frankie" }),
	            react.createElement( ListItem, { title: "Freddie" }),
	            react.createElement( ListItem, { title: "Frederick" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "G", groupTitle: true }),
	            react.createElement( ListItem, { title: "Gabriel" }),
	            react.createElement( ListItem, { title: "George" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "H", groupTitle: true }),
	            react.createElement( ListItem, { title: "Harley" }),
	            react.createElement( ListItem, { title: "Harrison" }),
	            react.createElement( ListItem, { title: "Harry" }),
	            react.createElement( ListItem, { title: "Harvey" }),
	            react.createElement( ListItem, { title: "Henry" }),
	            react.createElement( ListItem, { title: "Hugo" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "I", groupTitle: true }),
	            react.createElement( ListItem, { title: "Ibrahim" }),
	            react.createElement( ListItem, { title: "Isaac" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "J", groupTitle: true }),
	            react.createElement( ListItem, { title: "Jack" }),
	            react.createElement( ListItem, { title: "Jacob" }),
	            react.createElement( ListItem, { title: "Jake" }),
	            react.createElement( ListItem, { title: "James" }),
	            react.createElement( ListItem, { title: "Jamie" }),
	            react.createElement( ListItem, { title: "Jayden" }),
	            react.createElement( ListItem, { title: "Jenson" }),
	            react.createElement( ListItem, { title: "Joseph" }),
	            react.createElement( ListItem, { title: "Joshua" }),
	            react.createElement( ListItem, { title: "Jude" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "K", groupTitle: true }),
	            react.createElement( ListItem, { title: "Kai" }),
	            react.createElement( ListItem, { title: "Kian" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "L", groupTitle: true }),
	            react.createElement( ListItem, { title: "Leo" }),
	            react.createElement( ListItem, { title: "Leon" }),
	            react.createElement( ListItem, { title: "Lewis" }),
	            react.createElement( ListItem, { title: "Liam" }),
	            react.createElement( ListItem, { title: "Logan" }),
	            react.createElement( ListItem, { title: "Louie" }),
	            react.createElement( ListItem, { title: "Louis" }),
	            react.createElement( ListItem, { title: "Luca" }),
	            react.createElement( ListItem, { title: "Lucas" }),
	            react.createElement( ListItem, { title: "Luke" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "M", groupTitle: true }),
	            react.createElement( ListItem, { title: "Mason" }),
	            react.createElement( ListItem, { title: "Matthew" }),
	            react.createElement( ListItem, { title: "Max" }),
	            react.createElement( ListItem, { title: "Michael" }),
	            react.createElement( ListItem, { title: "Mohammad" }),
	            react.createElement( ListItem, { title: "Mohammed" }),
	            react.createElement( ListItem, { title: "Muhammad" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "N", groupTitle: true }),
	            react.createElement( ListItem, { title: "Nathan" }),
	            react.createElement( ListItem, { title: "Noah" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "O", groupTitle: true }),
	            react.createElement( ListItem, { title: "Oliver" }),
	            react.createElement( ListItem, { title: "Ollie" }),
	            react.createElement( ListItem, { title: "Oscar" }),
	            react.createElement( ListItem, { title: "Owen" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "R", groupTitle: true }),
	            react.createElement( ListItem, { title: "Reuben" }),
	            react.createElement( ListItem, { title: "Riley" }),
	            react.createElement( ListItem, { title: "Robert" }),
	            react.createElement( ListItem, { title: "Ronnie" }),
	            react.createElement( ListItem, { title: "Rory" }),
	            react.createElement( ListItem, { title: "Ryan" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "S", groupTitle: true }),
	            react.createElement( ListItem, { title: "Samuel" }),
	            react.createElement( ListItem, { title: "Sebastian" }),
	            react.createElement( ListItem, { title: "Seth" }),
	            react.createElement( ListItem, { title: "Sonny" }),
	            react.createElement( ListItem, { title: "Stanley" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "T", groupTitle: true }),
	            react.createElement( ListItem, { title: "Teddy" }),
	            react.createElement( ListItem, { title: "Theo" }),
	            react.createElement( ListItem, { title: "Theodore" }),
	            react.createElement( ListItem, { title: "Thomas" }),
	            react.createElement( ListItem, { title: "Toby" }),
	            react.createElement( ListItem, { title: "Tommy" }),
	            react.createElement( ListItem, { title: "Tyler" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "W", groupTitle: true }),
	            react.createElement( ListItem, { title: "William" })
	          ),
	          react.createElement( ListGroup, null,
	            react.createElement( ListItem, { title: "Z", groupTitle: true }),
	            react.createElement( ListItem, { title: "Zachary" })
	          )
	        )
	      )
	    )
	  };
	  defaultExport.prototype.onIndexSelect = function onIndexSelect (itemContent) {
	    console.log(itemContent);
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$d = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);

	    this.state = {
	      loginScreenOpened: false,
	      username: '',
	      password: '',
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Login Screen", backLink: "Back" }),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Framework7 comes with ready to use Login Screen layout. It could be used inside of page or inside of popup (Embedded) or as a standalone overlay:" )
	        ),

	        react.createElement( List, null,
	          react.createElement( ListItem, { link: "/login-screen-page/", title: "As Separate Page" })
	        ),

	        react.createElement( Block, null,
	          react.createElement( Button, { raised: true, large: true, fill: true, loginScreenOpen: ".demo-login-screen" }, "As Overlay")
	        ),

	        react.createElement( Block, null,
	          react.createElement( Button, { raised: true, large: true, fill: true, onClick: function () {this$1.setState({loginScreenOpened : true});} }, "Open Via Prop Change")
	        ),

	        react.createElement( LoginScreen$2, { className: "demo-login-screen", opened: this.state.loginScreenOpened, onLoginScreenClosed: function () {this$1.setState({loginScreenOpened : false});} },
	          react.createElement( Page, { loginScreen: true },
	            react.createElement( LoginScreenTitle, null, "Framework7" ),
	            react.createElement( List, { form: true },
	              react.createElement( ListInput, {
	                label: "Username", type: "text", placeholder: "Your username", value: this.state.username, onInput: function (e) {
	                  this$1.setState({ username: e.target.value});
	                } }),
	              react.createElement( ListInput, {
	                label: "Password", type: "password", placeholder: "Your password", value: this.state.password, onInput: function (e) {
	                  this$1.setState({ password: e.target.value});
	                } })
	            ),
	            react.createElement( List, null,
	              react.createElement( ListButton, { onClick: this.signIn.bind(this) }, "Sign In"),
	              react.createElement( BlockFooter, null, "Some text about login information.", react.createElement( 'br', null ), "Lorem ipsum dolor sit amet, consectetur adipiscing elit." )
	            )
	          )
	        )
	      )
	    )
	  };
	  defaultExport.prototype.signIn = function signIn () {
	    var self = this;
	    var app = self.$f7;

	    app.dialog.alert(("Username: " + (self.state.username) + "<br>Password: " + (self.state.password)), function () {
	      app.loginScreen.close();
	    });
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$e = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);

	    this.state = {
	      username: '',
	      password: '',
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;

	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, { noToolbar: true, noNavbar: true, noSwipeback: true, loginScreen: true },
	        react.createElement( LoginScreenTitle, null, "Framework7" ),
	        react.createElement( List, { form: true },
	          react.createElement( ListInput, {
	            label: "Username", type: "text", placeholder: "Your username", value: this.state.username, onInput: function (e) {
	              this$1.setState({ username: e.target.value});
	            } }),
	          react.createElement( ListInput, {
	            label: "Password", type: "password", placeholder: "Your password", value: this.state.password, onInput: function (e) {
	              this$1.setState({ password: e.target.value});
	            } })
	        ),
	        react.createElement( List, null,
	          react.createElement( ListButton, { onClick: this.signIn.bind(this) }, "Sign In"),
	          react.createElement( BlockFooter, null, "Some text about login information.", react.createElement( 'br', null ), "Lorem ipsum dolor sit amet, consectetur adipiscing elit." )
	        )
	      )
	    )
	  };
	  defaultExport.prototype.signIn = function signIn () {
	    var self = this;
	    var app = self.$f7;
	    var router = self.$f7router;
	    app.dialog.alert(("Username: " + (self.state.username) + "<br>Password: " + (self.state.password)), function () {
	      router.back();
	    });
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$f = /*@__PURE__*/(function (superclass) {
	  function defaultExport() {
	    superclass.call(this);
	    this.state = {
	      mapStyleLoaded: false,
	      mapScriptLoaded: false,
	      mapInitialized: false,
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.onPageAfterIn = function onPageAfterIn () {
	    var self = this;
	    if (self.state.mapInitialized) { return; }
	    if (!window.L) {
	      self.loadMapAssets();
	      return;
	    }
	    self.initMap();
	  };
	  defaultExport.prototype.loadMapAssets = function loadMapAssets () {
	    var self = this;
	    var style = document.createElement('link');
	    style.rel = 'stylesheet';
	    style.href = 'https://unpkg.com/leaflet@1.4.0/dist/leaflet.css';
	    style.integrity='sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA==';
	    style.setAttribute('crossorigin', '');
	    style.onload = function () {
	      self.setState({ mapStyleLoaded: true });
	      if (self.state.mapScriptLoaded) { self.initMap(); }
	    };
	    document.head.appendChild(style);

	    var script = document.createElement('script');
	    script.src = 'https://unpkg.com/leaflet@1.4.0/dist/leaflet.js';
	    script.integrity='sha512-QVftwZFqvtRNi0ZyCtsznlKSWOStnDORoefr1enyq5mVL4tmKB3S/EnC3rRJcxCPavG10IcrVGSmPh6Qw5lwrg==';
	    script.setAttribute('crossorigin', '');
	    script.onload = function () {
	      self.setState({ mapScriptLoaded: true });
	      if (self.state.mapStyleLoaded) { self.initMap(); }
	    };
	    document.head.appendChild(script);
	  };
	  defaultExport.prototype.initMap = function initMap () {
	    var self = this;
	    var mymap = L.map(self.mapEl, { zoomControl: false }).setView([51.505, -0.09], 10);
	    L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1Ijoibm9saW1pdHM0d2ViIiwiYSI6ImNqcXA4NTdmczBocm8zeG13Zm1zNTdyeDAifQ.HoJgmqQ_uH4zLyNJmiY98A', {
	      maxZoom: 18,
	      attribution: "Map data &copy; <a class=\"external\" target=\"_blank\" href=\"https://www.openstreetmap.org/\">OpenStreetMap</a> contributors,\n        <a class=\"external\" target=\"_blank\" href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>,\n        Imagery © <a class=\"external\" target=\"_blank\" href=\"https://www.mapbox.com/\">Mapbox</a>",
	      id: 'mapbox.streets'
	    }).addTo(mymap);
	    self.setState({ mapInitialized: true });
	  };
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, { onPageAfterIn: function () { return this$1.onPageAfterIn(); } },
	        react.createElement( Navbar$2, { title: "Menu", backLink: "Back" }),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Menu component is designed to be used as overlay control. It can be very helpful when you need controls on top of the map, images, some text/code editor, etc." )
	        ),
	        react.createElement( BlockTitle, null, "Links" ),
	        react.createElement( Block, { strong: true, className: "no-padding-horizontal" },
	          react.createElement( Menu$2, null,
	            react.createElement( MenuItem, { href: "#", text: "Item 1" }),
	            react.createElement( MenuItem, { href: "#", text: "Item 2" }),
	            react.createElement( MenuItem, { href: "#", iconF7: "edit" }),
	            react.createElement( MenuItem, { href: "#", iconF7: "share" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Dropdowns" ),
	        react.createElement( Block, { strong: true, className: "no-padding-horizontal", style: {zIndex: 2000} },
	          react.createElement( 'p', { className: "padding-horizontal" }, "Dropdown can be position on left, center or right of the menu item. It also can be scrollable."),
	          react.createElement( Menu$2, null,
	            react.createElement( MenuItem, { text: "Left", dropdown: true },
	              react.createElement( MenuDropdown, { left: true },
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 1" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 2" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 3" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 4" }),
	                react.createElement( MenuDropdownItem, { divider: true }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 5" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 6" })
	              )
	            ),

	            react.createElement( MenuItem, { text: "Center", dropdown: true },
	              react.createElement( MenuDropdown, { center: true, contentHeight: "200px" },
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 1" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 2" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 3" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 4" }),
	                react.createElement( MenuDropdownItem, { divider: true }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 5" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 6" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 7" }),
	                react.createElement( MenuDropdownItem, { divider: true }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 8" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 9" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 10" })
	              )
	            ),

	            react.createElement( MenuItem, { text: "Right", dropdown: true },
	              react.createElement( MenuDropdown, { right: true },
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 1" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 2" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 3" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 4" }),
	                react.createElement( MenuDropdownItem, { divider: true }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 5" }),
	                react.createElement( MenuDropdownItem, { href: "#", text: "Menu Item 6" })
	              )
	            ),

	            react.createElement( MenuItem, { style: {marginLeft: 'auto'}, iconF7: "share", dropdown: true },
	              react.createElement( MenuDropdown, { right: true },
	                react.createElement( MenuDropdownItem, { href: "#" },
	                  react.createElement( 'span', null, "Share on Facebook" ),
	                  react.createElement( Icon, { className: "margin-left", f7: "logo_facebook" })
	                ),
	                react.createElement( MenuDropdownItem, { href: "#" },
	                  react.createElement( 'span', null, "Share on Twitter" ),
	                  react.createElement( Icon, { className: "margin-left", f7: "logo_twitter" })
	                )
	              )
	            ),

	            react.createElement( MenuItem, { href: "#", iconF7: "edit" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "On Top Of Map" ),
	        react.createElement( Card$1, null,
	          react.createElement( CardContent, { padding: false },
	            react.createElement( 'div', { ref: function (el) { return this$1.mapEl = el; }, style: {height: '240px'} }),
	            react.createElement( Menu$2, { style: {position: 'absolute', left: '0px', top: '6px'} },
	              react.createElement( MenuItem, { href: "#", iconF7: "zoom_in" }),
	              react.createElement( MenuItem, { href: "#", iconF7: "zoom_out" }),
	              react.createElement( MenuItem, { iconF7: "layers_fill", dropdown: true },
	                react.createElement( MenuDropdown, { left: true },
	                  react.createElement( MenuDropdownItem, { href: "#", text: "Terrain" }),
	                  react.createElement( MenuDropdownItem, { href: "#", text: "Satellite" })
	                )
	              )
	            )
	          )
	        )
	      )
	    );
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$g = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);

	    this.state = {
	      attachments: [],
	      sheetVisible: false,
	      typingMessage: null,
	      messageText: '',
	      messagesData: [
	        {
	          type: 'sent',
	          text: 'Hi, Kate',
	        },
	        {
	          type: 'sent',
	          text: 'How are you?',
	        },
	        {
	          name: 'Kate',
	          type: 'received',
	          text: 'Hi, I am good!',
	          avatar: 'https://cdn.framework7.io/placeholder/people-100x100-9.jpg',
	        },
	        {
	          name: 'Blue Ninja',
	          type: 'received',
	          text: 'Hi there, I am also fine, thanks! And how are you?',
	          avatar: 'https://cdn.framework7.io/placeholder/people-100x100-7.jpg',
	        },
	        {
	          type: 'sent',
	          text: 'Hey, Blue Ninja! Glad to see you ;)',
	        },
	        {
	          type: 'sent',
	          text: 'Hey, look, cutest kitten ever!',
	        },
	        {
	          type: 'sent',
	          image: 'https://cdn.framework7.io/placeholder/cats-200x260-4.jpg',

	        },
	        {
	          name: 'Kate',
	          type: 'received',
	          text: 'Nice!',
	          avatar: 'https://cdn.framework7.io/placeholder/people-100x100-9.jpg',
	        },
	        {
	          name: 'Kate',
	          type: 'received',
	          text: 'Like it very much!',
	          avatar: 'https://cdn.framework7.io/placeholder/people-100x100-9.jpg',
	        },
	        {
	          name: 'Blue Ninja',
	          type: 'received',
	          text: 'Awesome!',
	          avatar: 'https://cdn.framework7.io/placeholder/people-100x100-7.jpg',
	        } ],
	      images: [
	        'https://cdn.framework7.io/placeholder/cats-300x300-1.jpg',
	        'https://cdn.framework7.io/placeholder/cats-200x300-2.jpg',
	        'https://cdn.framework7.io/placeholder/cats-400x300-3.jpg',
	        'https://cdn.framework7.io/placeholder/cats-300x150-4.jpg',
	        'https://cdn.framework7.io/placeholder/cats-150x300-5.jpg',
	        'https://cdn.framework7.io/placeholder/cats-300x300-6.jpg',
	        'https://cdn.framework7.io/placeholder/cats-300x300-7.jpg',
	        'https://cdn.framework7.io/placeholder/cats-200x300-8.jpg',
	        'https://cdn.framework7.io/placeholder/cats-400x300-9.jpg',
	        'https://cdn.framework7.io/placeholder/cats-300x150-10.jpg' ],
	      people: [
	        {
	          name: 'Kate Johnson',
	          avatar: 'https://cdn.framework7.io/placeholder/people-100x100-9.jpg',
	        },
	        {
	          name: 'Blue Ninja',
	          avatar: 'https://cdn.framework7.io/placeholder/people-100x100-7.jpg',
	        } ],
	      answers: [
	        'Yes!',
	        'No',
	        'Hm...',
	        'I am not sure',
	        'And what about you?',
	        'May be ;)',
	        'Lorem ipsum dolor sit amet, consectetur',
	        'What?',
	        'Are you sure?',
	        'Of course',
	        'Need to think about it',
	        'Amazing!!!' ],
	      responseInProgress: false,
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;

	  var prototypeAccessors = { attachmentsVisible: { configurable: true },placeholder: { configurable: true } };
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Messsages", backLink: "Back" }),

	        react.createElement( Messagebar$2, {
	          placeholder: this.placeholder, ref: function (el) {this$1.messagebarComponent = el;}, attachmentsVisible: this.attachmentsVisible, sheetVisible: this.state.sheetVisible, value: this.state.messageText, onInput: function (e) { return this$1.setState({messageText: e.target.value}); } },
	          react.createElement( Link, {
	            iconIos: "f7:camera_fill", iconAurora: "f7:camera_fill", iconMd: "material:camera_alt", slot: "inner-start", onClick: function () {this$1.setState({sheetVisible: !this$1.state.sheetVisible});} }),
	          react.createElement( Link, {
	            iconIos: "f7:arrow_up_round_fill", iconAurora: "f7:arrow_up_round_fill", iconMd: "material:send", slot: "inner-end", onClick: this.sendMessage.bind(this) }),
	          react.createElement( MessagebarAttachments, null,
	            this.state.attachments.map(function (image, index) { return (
	              react.createElement( MessagebarAttachment, {
	                key: index, image: image, onAttachmentDelete: function () { return this$1.deleteAttachment(image); } })
	            ); })
	          ),
	          react.createElement( MessagebarSheet, null,
	            this.state.images.map(function (image, index) { return (
	              react.createElement( MessagebarSheetImage, {
	                key: index, image: image, checked: this$1.state.attachments.indexOf(image) >= 0, onChange: this$1.handleAttachment.bind(this$1) })
	            ); })
	          )
	        ),

	        react.createElement( Messages$2, { ref: function (el) {this$1.messagesComponent = el;} },
	          react.createElement( MessagesTitle, null, react.createElement( 'b', null, "Sunday, Feb 9," ), " 12:58" ),

	          this.state.messagesData.map(function (message, index) { return (
	            react.createElement( Message, {
	              key: index, type: message.type, image: message.image, name: message.name, avatar: message.avatar, first: this$1.isFirstMessage(message, index), last: this$1.isLastMessage(message, index), tail: this$1.isTailMessage(message, index) },
	              message.text && (
	                react.createElement( 'span', { slot: "text", dangerouslySetInnerHTML: {__html: message.text} })
	              )
	            )
	          ); }),
	          this.state.typingMessage && (
	            react.createElement( Message, {
	              type: "received", typing: true, first: true, last: true, tail: true, header: ((this.state.typingMessage.name) + " is typing"), avatar: this.state.typingMessage.avatar })
	          )
	        )
	      )
	    )
	  };

	  prototypeAccessors.attachmentsVisible.get = function () {
	    var self = this;
	    return self.state.attachments.length > 0;
	  };
	  prototypeAccessors.placeholder.get = function () {
	    var self = this;
	    return self.state.attachments.length > 0 ? 'Add comment or Send' : 'Message';
	  };
	  defaultExport.prototype.componentDidMount = function componentDidMount () {
	    var self = this;
	    self.$f7ready(function () {
	      self.messagebar = self.messagebarComponent.f7Messagebar;
	      self.messages = self.messagesComponent.f7Messages;
	    });
	  };
	  defaultExport.prototype.isFirstMessage = function isFirstMessage (message, index) {
	    var self = this;
	    var previousMessage = self.state.messagesData[index - 1];
	    if (message.isTitle) { return false; }
	    if (!previousMessage || previousMessage.type !== message.type || previousMessage.name !== message.name) { return true; }
	    return false;
	  };
	  defaultExport.prototype.isLastMessage = function isLastMessage (message, index) {
	    var self = this;
	    var nextMessage = self.state.messagesData[index + 1];
	    if (message.isTitle) { return false; }
	    if (!nextMessage || nextMessage.type !== message.type || nextMessage.name !== message.name) { return true; }
	    return false;
	  };
	  defaultExport.prototype.isTailMessage = function isTailMessage (message, index) {
	    var self = this;
	    var nextMessage = self.state.messagesData[index + 1];
	    if (message.isTitle) { return false; }
	    if (!nextMessage || nextMessage.type !== message.type || nextMessage.name !== message.name) { return true; }
	    return false;
	  };
	  defaultExport.prototype.deleteAttachment = function deleteAttachment (image) {
	    var self = this;
	    var attachments = self.state.attachments;
	    var index = attachments.indexOf(image);
	    attachments.splice(index, 1);
	    self.setState({ attachments: attachments });
	  };
	  defaultExport.prototype.handleAttachment = function handleAttachment (e) {
	    var self = this;
	    var attachments = self.state.attachments;
	    var index = self.$$(e.target).parents('label.checkbox').index();
	    var image = self.state.images[index];
	    if (e.target.checked) {
	      // Add to attachments
	      attachments.unshift(image);
	    } else {
	      // Remove from attachments
	      attachments.splice(attachments.indexOf(image), 1);
	    }
	    self.setState({ attachments: attachments });
	  };
	  defaultExport.prototype.sendMessage = function sendMessage () {
	    var self = this;
	    var text = self.state.messageText.replace(/\n/g, '<br>').trim();
	    var messagesToSend = [];
	    self.state.attachments.forEach(function (attachment) {
	      messagesToSend.push({
	        image: attachment,
	      });
	    });
	    if (text.length) {
	      messagesToSend.push({
	        text: text,
	      });
	    }
	    if (messagesToSend.length === 0) {
	      return;
	    }

	    self.setState({
	      // Reset attachments
	      attachments: [],
	      // Hide sheet
	      sheetVisible: false,
	      // Send message
	      messagesData: self.state.messagesData.concat( messagesToSend),
	      // Clear
	      messageText: '',
	    });

	    // Focus area
	    if (text.length) { self.messagebar.focus(); }

	    // Mock response
	    if (self.state.responseInProgress) { return; }
	    self.setState({
	      responseInProgress: true,
	    });
	    setTimeout(function () {
	      var answer = self.state.answers[Math.floor(Math.random() * self.state.answers.length)];
	      var person = self.state.people[Math.floor(Math.random() * self.state.people.length)];
	      self.setState({
	        typingMessage: {
	          name: person.name,
	          avatar: person.avatar,
	        },
	      });
	      setTimeout(function () {
	        self.setState({
	          messagesData: self.state.messagesData.concat( [{
	            text: answer,
	            type: 'received',
	            name: person.name,
	            avatar: person.avatar,
	          }]),
	          typingMessage: null,
	          responseInProgress: false,
	        });
	      }, 4000);
	    }, 1000);
	  };

	  Object.defineProperties( defaultExport.prototype, prototypeAccessors );

	  return defaultExport;
	}(react.Component));

	function Navbar$3 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Navbar", subtitle: "Subtitle", backLink: "Back" },
	      react.createElement( NavRight, null,
	        react.createElement( Link, null, "Right" )
	      )
	    ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Navbar is a fixed (with Fixed and Through layout types) area at the top of a screen that contains Page title and navigation elements." ),
	      react.createElement( 'p', null, "Navbar has 3 main parts: Left, Title and Right. Each part may contain any HTML content." )
	    ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { link: "/navbar-hide-scroll/", title: "Hide Navbar On Scroll" })
	    )
	  )
	); }

	function NavbarHideScroll () { return (
	  react.createElement( Page, { hideNavbarOnScroll: true },
	    react.createElement( Navbar$2, { title: "Hide Navbar On Scroll", backLink: "Back" }),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "Navbar will be hidden if you scroll bottom" )
	    ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quos maxime incidunt id ab culpa ipsa omnis eos, vel excepturi officiis neque illum perferendis dolorum magnam rerum natus dolore nulla ex." ),
	      react.createElement( 'p', null, "Eum dolore, amet enim quaerat omnis. Modi minus voluptatum quam veritatis assumenda, eligendi minima dolore in autem delectus sequi accusantium? Cupiditate praesentium autem eius, esse ratione consequuntur dolor minus error." ),
	      react.createElement( 'p', null, "Repellendus ipsa sint quisquam delectus dolore quidem odio, praesentium, sequi temporibus amet architecto? Commodi molestiae, in repellat fugit! Laudantium, fuga quia officiis error. Provident inventore iusto quas iure, expedita optio." ),
	      react.createElement( 'p', null, "Eligendi recusandae eos sed alias delectus reprehenderit quaerat modi dolor commodi beatae temporibus nisi ullam ut, quae, animi esse in officia nesciunt sequi amet repellendus? Maiores quos provident nisi expedita." ),
	      react.createElement( 'p', null, "Dolorem aspernatur repudiandae aperiam autem excepturi inventore explicabo molestiae atque, architecto consequatur ab quia quaerat deleniti quis ipsum alias itaque veritatis maiores consectetur minima facilis amet. Maiores impedit ipsum sint." ),
	      react.createElement( 'p', null, "Consequuntur minus fugit vitae magnam illo quibusdam. Minima rerum, magnam nostrum id error temporibus odio molestias tempore vero, voluptas quam iusto. In laboriosam blanditiis, ratione consequuntur similique, quos repellendus ex!" ),
	      react.createElement( 'p', null, "Error suscipit odio modi blanditiis voluptatibus tempore minima ipsam accusantium id! Minus, ea totam veniam dolorem aspernatur repudiandae quae similique odio dolor, voluptate quis aut tenetur porro culpa odit aliquid." ),
	      react.createElement( 'p', null, "Aperiam velit sed sit quaerat, expedita tempore aspernatur iusto nobis ipsam error ut sapiente delectus in minima recusandae dolore alias, cumque labore. Doloribus veritatis magni nisi odio voluptatum perferendis placeat!" ),
	      react.createElement( 'p', null, "Eaque laboriosam iusto corporis iure nemo ab deleniti ut facere laborum, blanditiis neque nihil dignissimos fuga praesentium illo facilis eos beatae accusamus cumque molestiae asperiores cupiditate? Provident laborum officiis suscipit!" ),
	      react.createElement( 'p', null, "Exercitationem odio nulla rerum soluta aspernatur fugit, illo iusto ullam similique. Recusandae consectetur rem, odio autem voluptate similique atque, alias possimus quis vitae in, officiis labore deserunt aspernatur rerum sunt?" ),
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quos maxime incidunt id ab culpa ipsa omnis eos, vel excepturi officiis neque illum perferendis dolorum magnam rerum natus dolore nulla ex." ),
	      react.createElement( 'p', null, "Eum dolore, amet enim quaerat omnis. Modi minus voluptatum quam veritatis assumenda, eligendi minima dolore in autem delectus sequi accusantium? Cupiditate praesentium autem eius, esse ratione consequuntur dolor minus error." ),
	      react.createElement( 'p', null, "Repellendus ipsa sint quisquam delectus dolore quidem odio, praesentium, sequi temporibus amet architecto? Commodi molestiae, in repellat fugit! Laudantium, fuga quia officiis error. Provident inventore iusto quas iure, expedita optio." ),
	      react.createElement( 'p', null, "Eligendi recusandae eos sed alias delectus reprehenderit quaerat modi dolor commodi beatae temporibus nisi ullam ut, quae, animi esse in officia nesciunt sequi amet repellendus? Maiores quos provident nisi expedita." ),
	      react.createElement( 'p', null, "Dolorem aspernatur repudiandae aperiam autem excepturi inventore explicabo molestiae atque, architecto consequatur ab quia quaerat deleniti quis ipsum alias itaque veritatis maiores consectetur minima facilis amet. Maiores impedit ipsum sint." ),
	      react.createElement( 'p', null, "Consequuntur minus fugit vitae magnam illo quibusdam. Minima rerum, magnam nostrum id error temporibus odio molestias tempore vero, voluptas quam iusto. In laboriosam blanditiis, ratione consequuntur similique, quos repellendus ex!" ),
	      react.createElement( 'p', null, "Error suscipit odio modi blanditiis voluptatibus tempore minima ipsam accusantium id! Minus, ea totam veniam dolorem aspernatur repudiandae quae similique odio dolor, voluptate quis aut tenetur porro culpa odit aliquid." ),
	      react.createElement( 'p', null, "Aperiam velit sed sit quaerat, expedita tempore aspernatur iusto nobis ipsam error ut sapiente delectus in minima recusandae dolore alias, cumque labore. Doloribus veritatis magni nisi odio voluptatum perferendis placeat!" ),
	      react.createElement( 'p', null, "Eaque laboriosam iusto corporis iure nemo ab deleniti ut facere laborum, blanditiis neque nihil dignissimos fuga praesentium illo facilis eos beatae accusamus cumque molestiae asperiores cupiditate? Provident laborum officiis suscipit!" ),
	      react.createElement( 'p', null, "Exercitationem odio nulla rerum soluta aspernatur fugit, illo iusto ullam similique. Recusandae consectetur rem, odio autem voluptate similique atque, alias possimus quis vitae in, officiis labore deserunt aspernatur rerum sunt?" ),
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quos maxime incidunt id ab culpa ipsa omnis eos, vel excepturi officiis neque illum perferendis dolorum magnam rerum natus dolore nulla ex." ),
	      react.createElement( 'p', null, "Eum dolore, amet enim quaerat omnis. Modi minus voluptatum quam veritatis assumenda, eligendi minima dolore in autem delectus sequi accusantium? Cupiditate praesentium autem eius, esse ratione consequuntur dolor minus error." ),
	      react.createElement( 'p', null, "Repellendus ipsa sint quisquam delectus dolore quidem odio, praesentium, sequi temporibus amet architecto? Commodi molestiae, in repellat fugit! Laudantium, fuga quia officiis error. Provident inventore iusto quas iure, expedita optio." ),
	      react.createElement( 'p', null, "Eligendi recusandae eos sed alias delectus reprehenderit quaerat modi dolor commodi beatae temporibus nisi ullam ut, quae, animi esse in officia nesciunt sequi amet repellendus? Maiores quos provident nisi expedita." ),
	      react.createElement( 'p', null, "Dolorem aspernatur repudiandae aperiam autem excepturi inventore explicabo molestiae atque, architecto consequatur ab quia quaerat deleniti quis ipsum alias itaque veritatis maiores consectetur minima facilis amet. Maiores impedit ipsum sint." ),
	      react.createElement( 'p', null, "Consequuntur minus fugit vitae magnam illo quibusdam. Minima rerum, magnam nostrum id error temporibus odio molestias tempore vero, voluptas quam iusto. In laboriosam blanditiis, ratione consequuntur similique, quos repellendus ex!" ),
	      react.createElement( 'p', null, "Error suscipit odio modi blanditiis voluptatibus tempore minima ipsam accusantium id! Minus, ea totam veniam dolorem aspernatur repudiandae quae similique odio dolor, voluptate quis aut tenetur porro culpa odit aliquid." ),
	      react.createElement( 'p', null, "Aperiam velit sed sit quaerat, expedita tempore aspernatur iusto nobis ipsam error ut sapiente delectus in minima recusandae dolore alias, cumque labore. Doloribus veritatis magni nisi odio voluptatum perferendis placeat!" ),
	      react.createElement( 'p', null, "Eaque laboriosam iusto corporis iure nemo ab deleniti ut facere laborum, blanditiis neque nihil dignissimos fuga praesentium illo facilis eos beatae accusamus cumque molestiae asperiores cupiditate? Provident laborum officiis suscipit!" ),
	      react.createElement( 'p', null, "Exercitationem odio nulla rerum soluta aspernatur fugit, illo iusto ullam similique. Recusandae consectetur rem, odio autem voluptate similique atque, alias possimus quis vitae in, officiis labore deserunt aspernatur rerum sunt?" )
	    )
	  )
	); }

	var defaultExport$h = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, { onPageBeforeOut: this.onPageBeforeOut.bind(this), onPageBeforeRemove: this.onPageBeforeRemove.bind(this) },
	        react.createElement( Navbar$2, { title: "Notifications", backLink: "Back" }),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Framework7 comes with simple Notifications component that allows you to show some useful messages to user and request basic actions." ),
	          react.createElement( 'p', null, react.createElement( Button, { fill: true, onClick: this.showNotificationFull.bind(this) }, "Full layout notification") ),
	          react.createElement( 'p', null, react.createElement( Button, { fill: true, onClick: this.showNotificationWithButton.bind(this) }, "With close button") ),
	          react.createElement( 'p', null, react.createElement( Button, { fill: true, onClick: this.showNotificationCloseOnClick.bind(this) }, "Click to close") ),
	          react.createElement( 'p', null, react.createElement( Button, { fill: true, onClick: this.showNotificationCallbackOnClose.bind(this) }, "Callback on close") )
	        )
	      )
	    )
	  };
	  defaultExport.prototype.showNotificationFull = function showNotificationFull () {
	    var self = this;
	    // Create toast
	    if (!self.notificationFull) {
	      self.notificationFull = self.$f7.notification.create({
	        icon: '<i class="icon icon-f7"></i>',
	        title: 'Framework7',
	        titleRightText: 'now',
	        subtitle: 'This is a subtitle',
	        text: 'This is a simple notification message',
	        closeTimeout: 3000,
	      });
	    }
	    // Open it
	    self.notificationFull.open();
	  };
	  defaultExport.prototype.showNotificationWithButton = function showNotificationWithButton () {
	    var self = this;
	    // Create toast
	    if (!self.notificationWithButton) {
	      self.notificationWithButton = self.$f7.notification.create({
	        icon: '<i class="icon icon-f7"></i>',
	        title: 'Framework7',
	        subtitle: 'Notification with close button',
	        text: 'Click (x) button to close me',
	        closeButton: true,
	      });
	    }
	    // Open it
	    self.notificationWithButton.open();
	  };
	  defaultExport.prototype.showNotificationCloseOnClick = function showNotificationCloseOnClick () {
	    var self = this;
	    // Create toast
	    if (!self.notificationCloseOnClick) {
	      self.notificationCloseOnClick = self.$f7.notification.create({
	        icon: '<i class="icon icon-f7"></i>',
	        title: 'Framework7',
	        titleRightText: 'now',
	        subtitle: 'Notification with close on click',
	        text: 'Click me to close',
	        closeOnClick: true,
	      });
	    }
	    // Open it
	    self.notificationCloseOnClick.open();
	  };
	  defaultExport.prototype.showNotificationCallbackOnClose = function showNotificationCallbackOnClose () {
	    var self = this;
	    // Create toast
	    if (!self.notificationCallbackOnClose) {
	      self.notificationCallbackOnClose = self.$f7.notification.create({
	        icon: '<i class="icon icon-f7"></i>',
	        title: 'Framework7',
	        titleRightText: 'now',
	        subtitle: 'Notification with close on click',
	        text: 'Click me to close',
	        closeOnClick: true,
	        on: {
	          close: function close() {
	            self.$f7.dialog.alert('Notification closed');
	          },
	        },
	      });
	    }
	    // Open it
	    self.notificationCallbackOnClose.open();
	  };
	  defaultExport.prototype.onPageBeforeOut = function onPageBeforeOut () {
	    var self = this;
	    self.$f7.notification.close();
	  };
	  defaultExport.prototype.onPageBeforeRemove = function onPageBeforeRemove () {
	    var self = this;
	    // Destroy toasts when page removed
	    if (self.notificationFull) { self.notificationFull.destroy(); }
	    if (self.notificationWithButton) { self.notificationWithButton.destroy(); }
	    if (self.notificationCloseOnClick) { self.notificationCloseOnClick.destroy(); }
	    if (self.notificationCallbackOnClose) { self.notificationCallbackOnClose.destroy(); }
	  };

	  return defaultExport;
	}(react.Component));

	function Panel$3 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Panel / Side panels", backLink: "Back" }),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Framework7 comes with 2 panels (on left and on right), both are optional. They have two different layouts/effects - ", react.createElement( 'b', null, "cover" ), " above the content (like left panel here) and ", react.createElement( 'b', null, "reveal" ), " (like right panel). You can put absolutely anything inside: data lists, forms, custom content, and even other isolated app view (like in right panel now) with its own dynamic navbar. Checkout panels:" )
	    ),
	    react.createElement( Block, { className: "row" },
	      react.createElement( Col, null,
	        react.createElement( Button, { raised: true, fill: true, panelOpen: "left" }, "Open left panel")
	      ),
	      react.createElement( Col, null,
	        react.createElement( Button, { raised: true, fill: true, panelOpen: "right" }, "Open right panel")
	      )
	    )
	  )
	); }

	var defaultExport$i = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	    this.state = {
	      photos: [
	        {
	          url: 'img/beach.jpg',
	          caption: 'Amazing beach in Goa, India',
	        },
	        'http://placekitten.com/1024/1024',
	        'img/lock.jpg',
	        {
	          url: 'img/monkey.jpg',
	          caption: 'I met this monkey in Chinese mountains',
	        },
	        {
	          url: 'img/mountains.jpg',
	          caption: 'Beautiful mountains in Zhangjiajie, China',
	        } ],
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Photo Browser", backLink: "Back" }),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Photo Browser is a standalone and highly configurable component that allows to open window with photo viewer and navigation elements with the following features:" ),
	          react.createElement( 'ul', null,
	            react.createElement( 'li', null, "Swiper between photos" ),
	            react.createElement( 'li', null, "Multi-gestures support for zooming" ),
	            react.createElement( 'li', null, "Toggle zoom by double tap on photo" ),
	            react.createElement( 'li', null, "Single click on photo to toggle Exposition mode" )
	          )
	        ),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Photo Browser could be opened in a three ways - as a Standalone component (Popup modification), in Popup, and as separate Page:" ),
	          react.createElement( Row, null,
	            react.createElement( Col, null,
	              react.createElement( PhotoBrowser$2, { photos: this.state.photos, ref: function (el) {this$1.standalone = el;} }),
	              react.createElement( Button, { fill: true, onClick: function () { return this$1.standalone.open(); } }, "Standalone")
	            ),
	            react.createElement( Col, null,
	              react.createElement( PhotoBrowser$2, { photos: this.state.photos, type: "popup", ref: function (el) {this$1.popup = el;} }),
	              react.createElement( Button, { fill: true, onClick: function () { return this$1.popup.open(); } }, "Popup")
	            ),
	            react.createElement( Col, null,
	              react.createElement( PhotoBrowser$2, { photos: this.state.photos, type: "page", backLinkText: "Back", ref: function (el) {this$1.page = el;} }),
	              react.createElement( Button, { fill: true, onClick: function () { return this$1.page.open(); } }, "Page")
	            )
	          )
	        ),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Photo Browser suppots 2 default themes - default Light (like in previous examples) and Dark theme. Here is a Dark theme examples:" ),
	          react.createElement( Row, null,
	            react.createElement( Col, null,
	              react.createElement( PhotoBrowser$2, { photos: this.state.photos, theme: "dark", ref: function (el) {this$1.standaloneDark = el;} }),
	              react.createElement( Button, { fill: true, onClick: function () { return this$1.standaloneDark.open(); } }, "Standalone")
	            ),
	            react.createElement( Col, null,
	              react.createElement( PhotoBrowser$2, { photos: this.state.photos, theme: "dark", type: "popup", ref: function (el) {this$1.popupDark = el;} }),
	              react.createElement( Button, { fill: true, onClick: function () { return this$1.popupDark.open(); } }, "Popup")
	            ),
	            react.createElement( Col, null,
	              react.createElement( PhotoBrowser$2, { photos: this.state.photos, theme: "dark", type: "page", backLinkText: "Back", ref: function (el) {this$1.pageDark = el;} }),
	              react.createElement( Button, { fill: true, onClick: function () { return this$1.pageDark.open(); } }, "Page")
	            )
	          )
	        )
	      )
	    );
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$j = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, { onPageInit: this.onPageInit.bind(this), onPageBeforeRemove: this.onPageBeforeRemove.bind(this) },
	        react.createElement( Navbar$2, { title: "Picker", backLink: "Back" }),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Picker is a powerful component that allows you to create custom overlay pickers which looks like native picker." ),
	          react.createElement( 'p', null, "Picker could be used as inline component or as overlay. Overlay Picker will be automatically converted to Popover on tablets (iPad)." )
	        ),
	        react.createElement( BlockTitle, null, "Picker with single value" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, { type: "text", placeholder: "Your iOS device", readonly: true, inputId: "demo-picker-device" })
	        ),
	        react.createElement( BlockTitle, null, "2 values and 3d-rotate effect" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, { type: "text", placeholder: "Describe yourself", readonly: true, inputId: "demo-picker-describe" })
	        ),
	        react.createElement( BlockTitle, null, "Dependent values" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, { type: "text", placeholder: "Your car", readonly: true, inputId: "demo-picker-dependent" })
	        ),

	        react.createElement( BlockTitle, null, "Custom toolbar" ),
	        react.createElement( List, { noHairlinesMd: true },
	          react.createElement( ListInput, { type: "text", placeholder: "Describe yourself", readonly: true, inputId: "demo-picker-custom-toolbar" })
	        ),
	        react.createElement( BlockTitle, null, "Inline Picker / Date-time" ),
	        react.createElement( List, { className: "no-margin" },
	          react.createElement( ListInput, { type: "text", placeholder: "Date Time", readonly: true, inputId: "demo-picker-date" })
	        ),
	        react.createElement( Block, { strong: true, className: "no-padding no-margin margin-bottom" },
	          react.createElement( 'div', { id: "demo-picker-date-container" })
	        )
	      )
	    )
	  };
	  defaultExport.prototype.onPageInit = function onPageInit (e) {
	    var self = this;
	    var today = new Date();
	    var app = self.$f7;
	    // iOS Device picker
	    self.pickerDevice = app.picker.create({
	      inputEl: '#demo-picker-device',
	      cols: [
	        {
	          textAlign: 'center',
	          values: ['iPhone 4', 'iPhone 4S', 'iPhone 5', 'iPhone 5S', 'iPhone 6', 'iPhone 6 Plus', 'iPad 2', 'iPad Retina', 'iPad Air', 'iPad mini', 'iPad mini 2', 'iPad mini 3'],
	        } ],
	    });

	    // Describe yourself picker
	    self.pickerDescribe = app.picker.create({
	      inputEl: '#demo-picker-describe',
	      rotateEffect: true,
	      cols: [
	        {
	          textAlign: 'left',
	          values: ('Super Amazing Bat Iron Rocket Lex Beautiful Wonderful Raining Happy Funny Cool Hot').split(' '),
	        },
	        {
	          values: ('Man Luthor Woman Boy Girl Person Cutie Babe Raccoon').split(' '),
	        } ],
	    });

	    // Dependent values
	    var carVendors = {
	      Japanese: ['Honda', 'Lexus', 'Mazda', 'Nissan', 'Toyota'],
	      German: ['Audi', 'BMW', 'Mercedes', 'Volkswagen', 'Volvo'],
	      American: ['Cadillac', 'Chrysler', 'Dodge', 'Ford'],
	    };
	    self.pickerDependent = app.picker.create({
	      inputEl: '#demo-picker-dependent',
	      rotateEffect: true,
	      formatValue: function formatValue(values) {
	        return values[1];
	      },
	      cols: [
	        {
	          textAlign: 'left',
	          values: ['Japanese', 'German', 'American'],
	          onChange: function onChange(picker, country) {
	            if (picker.cols[1].replaceValues) {
	              picker.cols[1].replaceValues(carVendors[country]);
	            }
	          },
	        },
	        {
	          values: carVendors.Japanese,
	          width: 160,
	        } ],
	    });

	    // Custom Toolbar
	    self.pickerCustomToolbar = app.picker.create({
	      inputEl: '#demo-picker-custom-toolbar',
	      rotateEffect: true,
	      renderToolbar: function renderToolbar() {
	        return '<div class="toolbar">' +
	        '<div class="toolbar-inner">' +
	          '<div class="left">' +
	            '<a href="#" class="link toolbar-randomize-link">Randomize</a>' +
	          '</div>' +
	          '<div class="right">' +
	            '<a href="#" class="link sheet-close popover-close">That\'s me</a>' +
	          '</div>' +
	        '</div>' +
	      '</div>';
	      },
	      cols: [
	        {
	          values: ['Mr', 'Ms'],
	        },
	        {
	          textAlign: 'left',
	          values: ('Super Amazing Bat Iron Rocket Lex Beautiful Wonderful Raining Happy Funny Cool Hot').split(' '),
	        },
	        {
	          values: ('Man Luthor Woman Boy Girl Person Cutie Babe Raccoon').split(' '),
	        } ],
	      on: {
	        open: function open(picker) {
	          picker.$el.find('.toolbar-randomize-link').on('click', function () {
	            var col0Values = picker.cols[0].values;
	            var col0Random = col0Values[Math.floor(Math.random() * col0Values.length)];

	            var col1Values = picker.cols[1].values;
	            var col1Random = col1Values[Math.floor(Math.random() * col1Values.length)];

	            var col2Values = picker.cols[2].values;
	            var col2Random = col2Values[Math.floor(Math.random() * col2Values.length)];

	            picker.setValue([col0Random, col1Random, col2Random]);
	          });
	        },
	      },
	    });
	    // Inline date-time
	    self.pickerInline = app.picker.create({
	      containerEl: '#demo-picker-date-container',
	      inputEl: '#demo-picker-date',
	      toolbar: false,
	      rotateEffect: true,
	      value: [
	        today.getMonth(),
	        today.getDate(),
	        today.getFullYear(),
	        today.getHours(),
	        today.getMinutes() < 10 ? ("0" + (today.getMinutes())) : today.getMinutes() ],
	      formatValue: function formatValue(values, displayValues) {
	        return ((displayValues[0]) + " " + (values[1]) + ", " + (values[2]) + " " + (values[3]) + ":" + (values[4]));
	      },
	      cols: [
	      // Months
	        {
	          values: ('0 1 2 3 4 5 6 7 8 9 10 11').split(' '),
	          displayValues: ('January February March April May June July August September October November December').split(' '),
	          textAlign: 'left',
	        },
	        // Days
	        {
	          values: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31],
	        },
	        // Years
	        {
	          values: (function createValues() {
	            var arr = [];
	            for (var i = 1950; i <= 2030; i += 1) { arr.push(i); }
	            return arr;
	          }()),
	        },
	        // Space divider
	        {
	          divider: true,
	          content: '&nbsp;&nbsp;',
	        },
	        // Hours
	        {
	          values: (function createValues() {
	            var arr = [];
	            for (var i = 0; i <= 23; i += 1) { arr.push(i); }
	            return arr;
	          }()),
	        },
	        // Divider
	        {
	          divider: true,
	          content: ':',
	        },
	        // Minutes
	        {
	          values: (function createValues() {
	            var arr = [];
	            for (var i = 0; i <= 59; i += 1) { arr.push(i < 10 ? ("0" + i) : i); }
	            return arr;
	          }()),
	        } ],
	      on: {
	        change: function change(picker, values, displayValues) {
	          var daysInMonth = new Date(picker.value[2], picker.value[0] * 1 + 1, 0).getDate();
	          if (values[1] > daysInMonth) {
	            picker.cols[1].setValue(daysInMonth);
	          }
	        },
	      },
	    });
	  };
	  defaultExport.prototype.onPageBeforeRemove = function onPageBeforeRemove () {
	    var self = this;
	    self.pickerDevice.destroy();
	    self.pickerDescribe.destroy();
	    self.pickerDependent.destroy();
	    self.pickerCustomToolbar.destroy();
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$k = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);

	    this.state = {
	      popupOpened: false,
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, { onPageBeforeRemove: this.onPageBeforeRemove.bind(this) },
	        react.createElement( Navbar$2, { title: "Popup", backLink: "Back" }),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Popup is a modal window with any HTML content that pops up over App's main content. Popup as all other overlays is part of so called \"Temporary Views\"." ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, popupOpen: ".demo-popup" }, "Open Popup")
	          ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, onClick: function () { return this$1.setState({ popupOpened : true }); } }, "Open Via Prop Change")
	          ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, onClick: this.createPopup.bind(this) }, "Create Dynamic Popup")
	          )
	        ),
	        react.createElement( BlockTitle, null, "Swipe To Close" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Popup can be closed with swipe to top or bottom:" ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, popupOpen: ".demo-popup-swipe" }, "Swipe To Close")
	          ),
	          react.createElement( 'p', null, "Or it can be closed with swipe on special swipe handler and, for example, only to bottom:" ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, popupOpen: ".demo-popup-swipe-handler" }, "With Swipe Handler")
	          )
	        ),
	        react.createElement( Popup$2, { className: "demo-popup", opened: this.state.popupOpened, onPopupClosed: function () { return this$1.setState({popupOpened : false}); } },
	          react.createElement( Page, null,
	            react.createElement( Navbar$2, { title: "Popup Title" },
	              react.createElement( NavRight, null,
	                react.createElement( Link, { popupClose: true }, "Close")
	              )
	            ),
	            react.createElement( Block, null,
	              react.createElement( 'p', null, "Here comes popup. You can put here anything, even independent view with its own navigation. Also not, that by default popup looks a bit different on iPhone/iPod and iPad, on iPhone it is fullscreen." ),
	              react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse faucibus mauris leo, eu bibendum neque congue non. Ut leo mauris, eleifend eu commodo a, egestas ac urna. Maecenas in lacus faucibus, viverra ipsum pulvinar, molestie arcu. Etiam lacinia venenatis dignissim. Suspendisse non nisl semper tellus malesuada suscipit eu et eros. Nulla eu enim quis quam elementum vulputate. Mauris ornare consequat nunc viverra pellentesque. Aenean semper eu massa sit amet aliquam. Integer et neque sed libero mollis elementum at vitae ligula. Vestibulum pharetra sed libero sed porttitor. Suspendisse a faucibus lectus." ),
	              react.createElement( 'p', null, "Duis ut mauris sollicitudin, venenatis nisi sed, luctus ligula. Phasellus blandit nisl ut lorem semper pharetra. Nullam tortor nibh, suscipit in consequat vel, feugiat sed quam. Nam risus libero, auctor vel tristique ac, malesuada ut ante. Sed molestie, est in eleifend sagittis, leo tortor ullamcorper erat, at vulputate eros sapien nec libero. Mauris dapibus laoreet nibh quis bibendum. Fusce dolor sem, suscipit in iaculis id, pharetra at urna. Pellentesque tempor congue massa quis faucibus. Vestibulum nunc eros, convallis blandit dui sit amet, gravida adipiscing libero." )
	            )
	          )
	        ),

	        react.createElement( Popup$2, { className: "demo-popup-swipe", swipeToClose: true },
	          react.createElement( Page, null,
	            react.createElement( Navbar$2, { title: "Swipe To Close" },
	              react.createElement( NavRight, null,
	                react.createElement( Link, { popupClose: true }, "Close")
	              )
	            ),

	            react.createElement( 'div', { style: {height: '100%'}, className: "display-flex justify-content-center align-items-center" },
	              react.createElement( 'p', null, "Swipe me up or down" )
	            )
	          )
	        ),

	        react.createElement( Popup$2, { className: "demo-popup-swipe-handler", swipeToClose: "to-bottom", swipeHandler: ".swipe-handler" },
	          react.createElement( Page, null,
	            react.createElement( 'div', { slot: "fixed", className: "swipe-handler" }),
	            react.createElement( BlockTitle, { large: true }, "Hello!"),
	            react.createElement( Block, { strong: true },
	              react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse faucibus mauris leo, eu bibendum neque congue non. Ut leo mauris, eleifend eu commodo a, egestas ac urna. Maecenas in lacus faucibus, viverra ipsum pulvinar, molestie arcu. Etiam lacinia venenatis dignissim. Suspendisse non nisl semper tellus malesuada suscipit eu et eros. Nulla eu enim quis quam elementum vulputate. Mauris ornare consequat nunc viverra pellentesque. Aenean semper eu massa sit amet aliquam. Integer et neque sed libero mollis elementum at vitae ligula. Vestibulum pharetra sed libero sed porttitor. Suspendisse a faucibus lectus." ),
	              react.createElement( 'p', null, "Duis ut mauris sollicitudin, venenatis nisi sed, luctus ligula. Phasellus blandit nisl ut lorem semper pharetra. Nullam tortor nibh, suscipit in consequat vel, feugiat sed quam. Nam risus libero, auctor vel tristique ac, malesuada ut ante. Sed molestie, est in eleifend sagittis, leo tortor ullamcorper erat, at vulputate eros sapien nec libero. Mauris dapibus laoreet nibh quis bibendum. Fusce dolor sem, suscipit in iaculis id, pharetra at urna. Pellentesque tempor congue massa quis faucibus. Vestibulum nunc eros, convallis blandit dui sit amet, gravida adipiscing libero." ),
	              react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse faucibus mauris leo, eu bibendum neque congue non. Ut leo mauris, eleifend eu commodo a, egestas ac urna. Maecenas in lacus faucibus, viverra ipsum pulvinar, molestie arcu. Etiam lacinia venenatis dignissim. Suspendisse non nisl semper tellus malesuada suscipit eu et eros. Nulla eu enim quis quam elementum vulputate. Mauris ornare consequat nunc viverra pellentesque. Aenean semper eu massa sit amet aliquam. Integer et neque sed libero mollis elementum at vitae ligula. Vestibulum pharetra sed libero sed porttitor. Suspendisse a faucibus lectus." ),
	              react.createElement( 'p', null, "Duis ut mauris sollicitudin, venenatis nisi sed, luctus ligula. Phasellus blandit nisl ut lorem semper pharetra. Nullam tortor nibh, suscipit in consequat vel, feugiat sed quam. Nam risus libero, auctor vel tristique ac, malesuada ut ante. Sed molestie, est in eleifend sagittis, leo tortor ullamcorper erat, at vulputate eros sapien nec libero. Mauris dapibus laoreet nibh quis bibendum. Fusce dolor sem, suscipit in iaculis id, pharetra at urna. Pellentesque tempor congue massa quis faucibus. Vestibulum nunc eros, convallis blandit dui sit amet, gravida adipiscing libero." )
	            )
	          )
	        )
	      )
	    )
	  };
	  defaultExport.prototype.createPopup = function createPopup () {
	    var self = this;
	    // Create popup
	    if (!self.popup) {
	      self.popup = self.$f7.popup.create({
	        content: "\n          <div className=\"popup\">\n            <div className=\"page\">\n              <div className=\"navbar\">\n                <div className=\"navbar-inner\">\n                  <div className=\"title\">Dynamic Popup</div>\n                  <div className=\"right\"><a href=\"#\" className=\"link popup-close\">Close</a></div>\n                </div>\n              </div>\n              <div className=\"page-content\">\n                <div className=\"block\">\n                  <p>This popup was created dynamically</p>\n                  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse faucibus mauris leo, eu bibendum neque congue non. Ut leo mauris, eleifend eu commodo a, egestas ac urna. Maecenas in lacus faucibus, viverra ipsum pulvinar, molestie arcu. Etiam lacinia venenatis dignissim. Suspendisse non nisl semper tellus malesuada suscipit eu et eros. Nulla eu enim quis quam elementum vulputate. Mauris ornare consequat nunc viverra pellentesque. Aenean semper eu massa sit amet aliquam. Integer et neque sed libero mollis elementum at vitae ligula. Vestibulum pharetra sed libero sed porttitor. Suspendisse a faucibus lectus.</p>\n                </div>\n              </div>\n            </div>\n          </div>\n        ".trim(),
	      });
	    }
	    // Open it
	    self.popup.open();
	  };
	  defaultExport.prototype.onPageBeforeRemove = function onPageBeforeRemove () {
	    var self = this;
	    // Destroy popup when page removed
	    if (self.popup) { self.popup.destroy(); }
	  };

	  return defaultExport;
	}(react.Component));

	function Popover$3 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Popover", backLink: "Back" }),
	    react.createElement( Toolbar$2, { bottom: true },
	      react.createElement( Link, null, "Dummy Link" ),
	      react.createElement( Link, { popoverOpen: ".popover-menu" }, "Open Popover")
	    ),

	    react.createElement( Block, null,
	      react.createElement( 'p', null, react.createElement( Button, { fill: true, popoverOpen: ".popover-menu" }, "Open popover on me") ),
	      react.createElement( 'p', null, "Mauris fermentum neque et luctus venenatis. Vivamus a sem rhoncus, ornare tellus eu, euismod mauris. In porta turpis at semper convallis. Duis adipiscing leo eu nulla lacinia, quis rhoncus metus condimentum. Etiam nec malesuada nibh. Maecenas quis lacinia nisl, vel posuere dolor. Vestibulum condimentum, nisl ac vulputate egestas, neque enim dignissim elit, rhoncus volutpat magna enim a est. Aenean sit amet ligula neque. Cras suscipit rutrum enim. Nam a odio facilisis, elementum tellus non, ", react.createElement( Link, { popoverOpen: ".popover-menu" }, "popover"), " tortor. Pellentesque felis eros, dictum vitae lacinia quis, lobortis vitae ipsum. Cras vehicula bibendum lorem quis imperdiet." ),
	      react.createElement( 'p', null, "In hac habitasse platea dictumst. Etiam varius, ante vel ornare facilisis, velit massa rutrum dolor, ac porta magna magna lacinia nunc. Curabitur ", react.createElement( Link, { popoverOpen: ".popover-menu" }, "popover!"), " cursus laoreet. Aenean vel tempus augue. Pellentesque in imperdiet nibh. Mauris rhoncus nulla id sem suscipit volutpat. Pellentesque ac arcu in nisi viverra pulvinar. Nullam nulla orci, bibendum sed ligula non, ullamcorper iaculis mi. In hac habitasse platea dictumst. Praesent varius at nisl eu luctus. Cras aliquet porta est. Quisque elementum quis dui et consectetur. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Sed sed laoreet purus. Pellentesque eget ante ante." ),
	      react.createElement( 'p', null, "Duis et ultricies nibh. Sed facilisis turpis urna, ac imperdiet erat venenatis eu. Proin sit amet faucibus tortor, et varius sem. Etiam vitae lacinia neque. Aliquam nisi purus, interdum in arcu sed, ultrices rutrum arcu. Nulla mi turpis, consectetur vel enim quis, facilisis viverra dui. Aliquam quis convallis tortor, quis semper ligula. Morbi ullamcorper ", react.createElement( Link, { popoverOpen: ".popover-menu" }, "one more popover"), " massa at accumsan. Etiam purus odio, posuere in ligula vitae, viverra ultricies justo. Vestibulum nec interdum nisi. Aenean ac consectetur velit, non malesuada magna. Sed pharetra vehicula augue, vel venenatis lectus gravida eget. Curabitur lacus tellus, venenatis eu arcu in, interdum auctor nunc. Nunc non metus neque. Suspendisse viverra lectus sed risus aliquet, vel accumsan dolor feugiat." )
	    ),
	    react.createElement( Popover$2, { className: "popover-menu" },
	      react.createElement( List, null,
	        react.createElement( ListItem, { link: "/dialog/", popoverClose: true, title: "Dialog" }),
	        react.createElement( ListItem, { link: "/tabs/", popoverClose: true, title: "Tabs" }),
	        react.createElement( ListItem, { link: "/panel/", popoverClose: true, title: "Side Panels" }),
	        react.createElement( ListItem, { link: "/list/", popoverClose: true, title: "List View" }),
	        react.createElement( ListItem, { link: "/inputs/", popoverClose: true, title: "Form Inputs" })
	      )
	    )
	  )
	); }

	var defaultExport$l = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Preloader", backLink: "Back" }),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "How about an activity indicator? Framework 7 has a nice one. The F7 Preloader is made with SVG and animated with CSS so it can be easily resized." )
	        ),

	        react.createElement( BlockTitle, null, "Default" ),
	        react.createElement( Block, { className: "row demo-preloaders align-items-stretch text-align-center" },
	          react.createElement( Col, null,
	            react.createElement( Preloader$2, null )
	          ),
	          react.createElement( Col, { style: {background: '#000'} },
	            react.createElement( Preloader$2, { color: "white" })
	          ),
	          react.createElement( Col, null,
	            react.createElement( Preloader$2, { size: 42 })
	          ),
	          react.createElement( Col, { style: {background: '#000'} },
	            react.createElement( Preloader$2, { size: 42, color: "white" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Color Preloaders" ),
	        react.createElement( Block, { className: "row text-align-center" },
	          react.createElement( Col, null,
	            react.createElement( Preloader$2, { color: "red" })
	          ),
	          react.createElement( Col, null,
	            react.createElement( Preloader$2, { color: "green" })
	          ),
	          react.createElement( Col, null,
	            react.createElement( Preloader$2, { color: "orange" })
	          ),
	          react.createElement( Col, null,
	            react.createElement( Preloader$2, { color: "blue" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Multi-color (MD-theme only)" ),
	        react.createElement( Block, { className: "text-align-center" },
	          react.createElement( Preloader$2, { color: "multi" })
	        ),

	        react.createElement( BlockTitle, null, "Preloader Modals" ),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "With ", react.createElement( 'b', null, "app.preloader.show()" ), " you can show small overlay with preloader indicator." ),
	          react.createElement( 'p', null,
	            react.createElement( 'a', { className: "button button-fill", onClick: this.openIndicator.bind(this) }, "Open Small Indicator")
	          ),
	          react.createElement( 'p', null, "With ", react.createElement( 'b', null, "app.dialog.preloader()" ), " you can show dialog modal with preloader indicator." ),
	          react.createElement( 'p', null,
	            react.createElement( 'a', { className: "button button-fill", onClick: this.openDialog.bind(this) }, "Open Dialog Preloader")
	          ),
	          react.createElement( 'p', null, "With ", react.createElement( 'b', null, "app.dialog.preloader('My text...')" ), " you can show dialog preloader modal with custom title." ),
	          react.createElement( 'p', null,
	            react.createElement( 'a', { className: "button button-fill", onClick: this.openCustomDialog.bind(this) }, "Open Dialog Preloader")
	          )
	        )
	      )
	    );
	  };

	  defaultExport.prototype.openIndicator = function openIndicator () {
	    var self = this;
	    self.$f7.preloader.show();
	    setTimeout(function () {
	      self.$f7.preloader.hide();
	    }, 2000);
	  };
	  defaultExport.prototype.openDialog = function openDialog () {
	    var self = this;
	    self.$f7.dialog.preloader();
	    setTimeout(function () {
	      self.$f7.dialog.close();
	    }, 2000);
	  };
	  defaultExport.prototype.openCustomDialog = function openCustomDialog () {
	    var self = this;
	    self.$f7.dialog.preloader('My text...');
	    setTimeout(function () {
	      self.$f7.dialog.close();
	    }, 2000);
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$m = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);

	    this.setInlineProgress = this.setInlineProgress.bind(this);
	    this.showInfinite = this.showInfinite.bind(this);
	    this.showDeterminate = this.showDeterminate.bind(this);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Progress Bar", backLink: "Back" }),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "In addition to ", react.createElement( 'a', { href: "/preloader/" }, "Preloader"), ", Framework7 also comes with fancy animated determinate and infinite/indeterminate progress bars to indicate some activity." )
	        ),
	        react.createElement( BlockTitle, null, "Determinate Progress Bar" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "When progress bar is determinate it indicates how long an operation will take when the percentage complete is detectable." ),
	          react.createElement( 'p', null, "Inline determinate progress bar:" ),
	          react.createElement( 'div', null,
	            react.createElement( 'p', null, react.createElement( Progressbar$2, { progress: 10, id: "demo-inline-progressbar" }) ),
	            react.createElement( Segmented, { raised: true },
	              react.createElement( Button, { onClick: function (){this$1.setInlineProgress(10);} }, "10%"),
	              react.createElement( Button, { onClick: function (){this$1.setInlineProgress(30);} }, "30%"),
	              react.createElement( Button, { onClick: function (){this$1.setInlineProgress(50);} }, "50%"),
	              react.createElement( Button, { onClick: function (){this$1.setInlineProgress(100);} }, "100%")
	            )
	          ),
	          react.createElement( 'div', null,
	            react.createElement( 'p', null, "Inline determinate load & hide:" ),
	            react.createElement( 'p', { id: "demo-determinate-container" }),
	            react.createElement( 'p', null,
	              react.createElement( Button, { fill: true, onClick: function (){this$1.showDeterminate(true);} }, "Start Loading")
	            )
	          ),
	          react.createElement( 'div', null,
	            react.createElement( 'p', null, "Overlay with determinate progress bar on top of the app:" ),
	            react.createElement( 'p', null,
	              react.createElement( Button, { fill: true, onClick: function (){this$1.showDeterminate(false);} }, "Start Loading")
	            )
	          )
	        ),
	        react.createElement( BlockTitle, null, "Infinite Progress Bar" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "When progress bar is infinite/indeterminate it requests that the user wait while something finishes when it’s not necessary to indicate how long it will take." ),
	          react.createElement( 'p', null, "Inline infinite progress bar" ),
	          react.createElement( 'p', null,
	            react.createElement( Progressbar$2, { infinite: true })
	          ),
	          react.createElement( 'p', null, "Multi-color infinite progress bar" ),
	          react.createElement( 'p', null,
	            react.createElement( Progressbar$2, { infinite: true, color: "multi" })
	          ),
	          react.createElement( 'div', null,
	            react.createElement( 'p', null, "Overlay with infinite progress bar on top of the app" ),
	            react.createElement( 'p', { id: "demo-infinite-container" }),
	            react.createElement( 'p', null,
	              react.createElement( Button, { fill: true, onClick: function (){this$1.showInfinite(false);} }, "Start Loading")
	            )
	          ),
	          react.createElement( 'div', null,
	            react.createElement( 'p', null, "Overlay with infinite multi-color progress bar on top of the app" ),
	            react.createElement( 'p', null,
	              react.createElement( Button, { fill: true, onClick: function (){this$1.showInfinite(true);} }, "Start Loading")
	            )
	          )
	        ),
	        react.createElement( BlockTitle, null, "Colors" ),
	        react.createElement( List, { simpleList: true },
	          react.createElement( ListItem, null,
	            react.createElement( Progressbar$2, { color: "blue", progress: 10 })
	          ),
	          react.createElement( ListItem, null,
	            react.createElement( Progressbar$2, { color: "red", progress: 20 })
	          ),
	          react.createElement( ListItem, null,
	            react.createElement( Progressbar$2, { color: "pink", progress: 30 })
	          ),
	          react.createElement( ListItem, null,
	            react.createElement( Progressbar$2, { color: "green", progress: 80 })
	          ),
	          react.createElement( ListItem, null,
	            react.createElement( Progressbar$2, { color: "yellow", progress: 90 })
	          ),
	          react.createElement( ListItem, null,
	            react.createElement( Progressbar$2, { color: "orange", progress: 100 })
	          )
	        )
	      )
	    );
	  };
	  defaultExport.prototype.setInlineProgress = function setInlineProgress (value) {
	    var self = this;
	    var app = self.$f7;
	    app.progressbar.set('#demo-inline-progressbar', value);
	  };
	  defaultExport.prototype.showDeterminate = function showDeterminate (inline) {
	    var self = this;
	    var app = self.$f7;
	    if (self.determinateLoading) { return; }
	    self.determinateLoading = true;
	    var progressBarEl;
	    if (inline) {
	      progressBarEl = app.progressbar.show('#demo-determinate-container', 0);
	    } else {
	      progressBarEl = app.progressbar.show(0, app.theme === 'md' ? 'yellow' : 'blue');
	    }
	    var progress = 0;
	    function simulateLoading() {
	      setTimeout(function () {
	        var progressBefore = progress;
	        progress += Math.random() * 20;
	        app.progressbar.set(progressBarEl, progress);
	        if (progressBefore < 100) {
	          simulateLoading(); // keep "loading"
	        } else {
	          self.determinateLoading = false;
	          app.progressbar.hide(progressBarEl); // hide
	        }
	      }, Math.random() * 200 + 200);
	    }
	    simulateLoading();
	  };
	  defaultExport.prototype.showInfinite = function showInfinite (multiColor) {
	    var self = this;
	    var app = self.$f7;
	    if (self.infiniteLoading) { return; }
	    self.infiniteLoading = true;
	    if (multiColor) {
	      app.progressbar.show('multi');
	    } else {
	      app.progressbar.show(app.theme === 'md' ? 'yellow' : 'blue');
	    }
	    setTimeout(function () {
	      self.infiniteLoading = false;
	      app.progressbar.hide();
	    }, 3000);
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$n = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);

	    this.state = {
	      items: [
	        {
	          title: 'Yellow Submarine',
	          author: 'Beatles',
	          cover: 'https://cdn.framework7.io/placeholder/abstract-88x88-1.jpg',
	        },
	        {
	          title: 'Don\'t Stop Me Now',
	          author: 'Queen',
	          cover: 'https://cdn.framework7.io/placeholder/abstract-88x88-2.jpg',
	        },
	        {
	          title: 'Billie Jean',
	          author: 'Michael Jackson',
	          cover: 'https://cdn.framework7.io/placeholder/abstract-88x88-3.jpg',
	        } ],
	      songs: ['Yellow Submarine', 'Don\'t Stop Me Now', 'Billie Jean', 'Californication'],
	      authors: ['Beatles', 'Queen', 'Michael Jackson', 'Red Hot Chili Peppers'],
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, { ptr: true, ptrMousewheel: true, onPtrRefresh: this.loadMore.bind(this) },
	        react.createElement( Navbar$2, { title: "Pull To Refresh", backLink: "Back" }),
	        react.createElement( List, { mediaList: true },
	          this.state.items.map(function (item, index) { return (
	            react.createElement( ListItem, {
	              key: index, title: item.title, subtitle: item.author },
	              react.createElement( 'img', { slot: "media", src: item.cover, width: "44" })
	            )
	          ); }),
	          react.createElement( BlockFooter, null,
	            react.createElement( 'p', null, "Just pull page down to let the magic happen.", react.createElement( 'br', null ), "Note that pull-to-refresh feature is optimised for touch and native scrolling so it may not work on desktop browser." )
	          )
	        )
	      )
	    );
	  };
	  defaultExport.prototype.loadMore = function loadMore (event, done) {
	    var self = this;
	    setTimeout(function () {
	      var ref = self.state;
	      var items = ref.items;
	      var songs = ref.songs;
	      var authors = ref.authors;
	      var picURL = "https://cdn.framework7.io/placeholder/abstract-88x88-" + (Math.round(Math.random() * 10)) + ".jpg";
	      var song = songs[Math.floor(Math.random() * songs.length)];
	      var author = authors[Math.floor(Math.random() * authors.length)];
	      items.push({
	        title: song,
	        author: author,
	        img: picURL,
	      });
	      self.setState({ items: items });

	      done();
	    }, 1000);
	  };

	  return defaultExport;
	}(react.Component));

	function Radio$2 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Radio", backLink: "Back" }),

	    react.createElement( BlockTitle, null, "Inline" ),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "Lorem ", react.createElement( Radio$1, { name: "demo-radio-inline", value: "inline-1" }), " ipsum dolor sit amet, consectetur adipisicing elit. Alias beatae illo nihil aut eius commodi sint eveniet aliquid eligendi ", react.createElement( Radio$1, { name: "demo-radio-inline", value: "inline-2", defaultChecked: true }), " ad delectus impedit tempore nemo, enim vel praesentium consequatur nulla mollitia!" )
	    ),

	    react.createElement( BlockTitle, null, "Radio Group" ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { radio: true, title: "Books", name: "demo-radio", value: "Books", defaultChecked: true }),
	      react.createElement( ListItem, { radio: true, title: "Movies", value: "Movies", name: "demo-radio" }),
	      react.createElement( ListItem, { radio: true, title: "Food", value: "Food", name: "demo-radio" }),
	      react.createElement( ListItem, { radio: true, title: "Drinks", value: "Drinks", name: "demo-radio" })
	    ),


	    react.createElement( BlockTitle, null, "With Media Lists" ),
	    react.createElement( List, { mediaList: true },
	      react.createElement( ListItem, {
	        radio: true, defaultChecked: true, name: "demo-media-radio", value: "1", title: "Facebook", after: "17:14", subtitle: "New messages from John Doe", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." }),
	      react.createElement( ListItem, {
	        radio: true, name: "demo-media-radio", value: "2", title: "John Doe (via Twitter)", after: "17:11", subtitle: "John Doe (@_johndoe) mentioned you on Twitter!", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." }),
	      react.createElement( ListItem, {
	        radio: true, name: "demo-media-radio", value: "3", title: "Facebook", after: "16:48", subtitle: "New messages from John Doe", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." }),
	      react.createElement( ListItem, {
	        radio: true, name: "demo-media-radio", value: "4", title: "John Doe (via Twitter)", after: "15:32", subtitle: "John Doe (@_johndoe) mentioned you on Twitter!", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." })
	    )
	  )
	); }

	var defaultExport$o = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);

	    this.state = {
	      priceMin: 200,
	      priceMax: 400,
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Range Slider", backLink: "Back" }),

	        react.createElement( BlockTitle, null, "Volume" ),
	        react.createElement( List, { simpleList: true },
	          react.createElement( ListItem, null,
	            react.createElement( ListItemCell, { className: "width-auto flex-shrink-0" },
	              react.createElement( Icon, { ios: "f7:volume_mute_fill", aurora: "f7:volume_mute_fill", md: "material:volume_mute" })
	            ),
	            react.createElement( ListItemCell, { className: "flex-shrink-3" },
	              react.createElement( Range$2, {
	                min: 0, max: 100, step: 1, value: 10 })
	            ),
	            react.createElement( ListItemCell, { className: "width-auto flex-shrink-0" },
	              react.createElement( Icon, { ios: "f7:volume_fill", aurora: "f7:volume_fill", md: "material:volume_up" })
	            )
	          )
	        ),

	        react.createElement( BlockTitle, null, "Brightness" ),
	        react.createElement( List, { simpleList: true },
	          react.createElement( ListItem, null,
	            react.createElement( ListItemCell, { className: "width-auto flex-shrink-0" },
	              react.createElement( Icon, { ios: "f7:circle", aurora: "f7:circle", md: "material:brightness_low" })
	            ),
	            react.createElement( ListItemCell, { className: "flex-shrink-3" },
	              react.createElement( Range$2, {
	                min: 0, max: 100, step: 1, value: 50, label: true, color: "orange" })
	            ),
	            react.createElement( ListItemCell, { className: "width-auto flex-shrink-0" },
	              react.createElement( Icon, { ios: "f7:circle_half", aurora: "f7:circle_half", md: "material:brightness_high" })
	            )
	          )
	        ),

	        react.createElement( BlockTitle, { className: "display-flex justify-content-space-between" }, "Price Filter ", react.createElement( 'span', null, "$", this.state.priceMin, " - $", this.state.priceMax )),
	        react.createElement( List, { simpleList: true },
	          react.createElement( ListItem, null,
	            react.createElement( ListItemCell, { className: "width-auto flex-shrink-0" },
	              react.createElement( Icon, { ios: "f7:money_dollar_round", aurora: "f7:money_dollar_round", md: "material:attach_money" })
	            ),
	            react.createElement( ListItemCell, { className: "flex-shrink-3" },
	              react.createElement( Range$2, {
	                min: 0, max: 500, step: 1, value: [this.state.priceMin, this.state.priceMax], label: true, dual: true, color: "green", onRangeChange: this.onPriceChange.bind(this) })
	            ),
	            react.createElement( ListItemCell, { className: "width-auto flex-shrink-0" },
	              react.createElement( Icon, { ios: "f7:money_dollar_round_fill", aurora: "f7:money_dollar_round_fill", md: "material:monetization_on" })
	            )
	          )
	        ),

	        react.createElement( BlockTitle, null, "With Scale" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( Range$2, {
	            min: 0, max: 100, label: true, step: 5, value: 25, scale: true, scaleSteps: 5, scaleSubSteps: 4 })
	        ),

	        react.createElement( BlockTitle, null, "Vertical" ),
	        react.createElement( Block, { strong: true, className: "display-flex justify-content-center" },
	          react.createElement( Range$2, {
	            className: "margin-right", style: {height: '160px'}, vertical: true, min: 0, max: 100, label: true, step: 1, value: 25 }),
	          react.createElement( Range$2, {
	            className: "margin-horizontal", style: {height: '160px'}, vertical: true, min: 0, max: 100, label: true, step: 1, value: 50 }),
	          react.createElement( Range$2, {
	            className: "margin-horizontal", style: {height: '160px'}, vertical: true, min: 0, max: 100, label: true, step: 1, value: 75 }),
	          react.createElement( Range$2, {
	            className: "margin-left", style: {height: '160px'}, dual: true, vertical: true, min: 0, max: 100, label: true, step: 1, value: [25, 75] })
	        ),

	        react.createElement( BlockTitle, null, "Vertical Reversed" ),
	        react.createElement( Block, { strong: true, className: "display-flex justify-content-center" },
	          react.createElement( Range$2, {
	            className: "margin-right", color: "red", style: {height: '160px'}, vertical: true, verticalReversed: true, min: 0, max: 100, label: true, step: 1, value: 25 }),
	          react.createElement( Range$2, {
	            className: "margin-horizontal", color: "red", style: {height: '160px'}, vertical: true, verticalReversed: true, min: 0, max: 100, label: true, step: 1, value: 50 }),
	          react.createElement( Range$2, {
	            className: "margin-horizontal", color: "red", style: {height: '160px'}, vertical: true, verticalReversed: true, min: 0, max: 100, label: true, step: 1, value: 75 }),
	          react.createElement( Range$2, {
	            className: "margin-left", color: "red", style: {height: '160px'}, dual: true, vertical: true, verticalReversed: true, min: 0, max: 100, label: true, step: 1, value: [25, 75] })
	        )

	      )
	    )
	  };
	  defaultExport.prototype.onPriceChange = function onPriceChange (values) {
	    this.setState({
	      priceMin: values[0],
	      priceMax: values[1],
	    });
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$p = /*@__PURE__*/(function (superclass) {
	  function defaultExport() {
	    superclass.call(this);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { backLink: "Back", title: "Searchbar" },
	          react.createElement( Subnavbar$1, { inner: false },
	            react.createElement( Searchbar$2, {
	              searchContainer: ".search-list", searchIn: ".item-title", disableButton: !this.$theme.aurora })
	          )
	        ),
	        react.createElement( List, { className: "searchbar-not-found" },
	          react.createElement( ListItem, { title: "Nothing found" })
	        ),
	        react.createElement( List, { className: "search-list searchbar-found" },
	          react.createElement( ListItem, { title: "Acura" }),
	          react.createElement( ListItem, { title: "Audi" }),
	          react.createElement( ListItem, { title: "BMW" }),
	          react.createElement( ListItem, { title: "Cadillac " }),
	          react.createElement( ListItem, { title: "Chevrolet " }),
	          react.createElement( ListItem, { title: "Chrysler " }),
	          react.createElement( ListItem, { title: "Dodge " }),
	          react.createElement( ListItem, { title: "Ferrari " }),
	          react.createElement( ListItem, { title: "Ford " }),
	          react.createElement( ListItem, { title: "GMC " }),
	          react.createElement( ListItem, { title: "Honda" }),
	          react.createElement( ListItem, { title: "Hummer" }),
	          react.createElement( ListItem, { title: "Hyundai" }),
	          react.createElement( ListItem, { title: "Infiniti " }),
	          react.createElement( ListItem, { title: "Isuzu " }),
	          react.createElement( ListItem, { title: "Jaguar " }),
	          react.createElement( ListItem, { title: "Jeep " }),
	          react.createElement( ListItem, { title: "Kia" }),
	          react.createElement( ListItem, { title: "Lamborghini " }),
	          react.createElement( ListItem, { title: "Land Rover" }),
	          react.createElement( ListItem, { title: "Lexus " }),
	          react.createElement( ListItem, { title: "Lincoln " }),
	          react.createElement( ListItem, { title: "Lotus " }),
	          react.createElement( ListItem, { title: "Mazda" }),
	          react.createElement( ListItem, { title: "Mercedes-Benz" }),
	          react.createElement( ListItem, { title: "Mercury " }),
	          react.createElement( ListItem, { title: "Mitsubishi" }),
	          react.createElement( ListItem, { title: "Nissan " }),
	          react.createElement( ListItem, { title: "Oldsmobile " }),
	          react.createElement( ListItem, { title: "Peugeot " }),
	          react.createElement( ListItem, { title: "Pontiac " }),
	          react.createElement( ListItem, { title: "Porsche" }),
	          react.createElement( ListItem, { title: "Regal" }),
	          react.createElement( ListItem, { title: "Saab " }),
	          react.createElement( ListItem, { title: "Saturn " }),
	          react.createElement( ListItem, { title: "Subaru " }),
	          react.createElement( ListItem, { title: "Suzuki " }),
	          react.createElement( ListItem, { title: "Toyota" }),
	          react.createElement( ListItem, { title: "Volkswagen" }),
	          react.createElement( ListItem, { title: "Volvo" })
	        )
	      )
	    );
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$q = /*@__PURE__*/(function (superclass) {
	  function defaultExport() {
	    superclass.call(this);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { backLink: "Back", title: "Searchbar" },
	          react.createElement( NavRight, null,
	            react.createElement( Link, { searchbarEnable: ".searchbar-demo", iconIos: "f7:search", iconMd: "material:search", iconAurora: "f7:search" })
	          ),
	          react.createElement( Searchbar$2, {
	            className: "searchbar-demo", expandable: true, searchContainer: ".search-list", searchIn: ".item-title", disableButton: !this.$theme.aurora })
	        ),
	        react.createElement( List, { className: "searchbar-not-found" },
	          react.createElement( ListItem, { title: "Nothing found" })
	        ),
	        react.createElement( List, { className: "search-list searchbar-found" },
	          react.createElement( ListItem, { title: "Acura" }),
	          react.createElement( ListItem, { title: "Audi" }),
	          react.createElement( ListItem, { title: "BMW" }),
	          react.createElement( ListItem, { title: "Cadillac " }),
	          react.createElement( ListItem, { title: "Chevrolet " }),
	          react.createElement( ListItem, { title: "Chrysler " }),
	          react.createElement( ListItem, { title: "Dodge " }),
	          react.createElement( ListItem, { title: "Ferrari " }),
	          react.createElement( ListItem, { title: "Ford " }),
	          react.createElement( ListItem, { title: "GMC " }),
	          react.createElement( ListItem, { title: "Honda" }),
	          react.createElement( ListItem, { title: "Hummer" }),
	          react.createElement( ListItem, { title: "Hyundai" }),
	          react.createElement( ListItem, { title: "Infiniti " }),
	          react.createElement( ListItem, { title: "Isuzu " }),
	          react.createElement( ListItem, { title: "Jaguar " }),
	          react.createElement( ListItem, { title: "Jeep " }),
	          react.createElement( ListItem, { title: "Kia" }),
	          react.createElement( ListItem, { title: "Lamborghini " }),
	          react.createElement( ListItem, { title: "Land Rover" }),
	          react.createElement( ListItem, { title: "Lexus " }),
	          react.createElement( ListItem, { title: "Lincoln " }),
	          react.createElement( ListItem, { title: "Lotus " }),
	          react.createElement( ListItem, { title: "Mazda" }),
	          react.createElement( ListItem, { title: "Mercedes-Benz" }),
	          react.createElement( ListItem, { title: "Mercury " }),
	          react.createElement( ListItem, { title: "Mitsubishi" }),
	          react.createElement( ListItem, { title: "Nissan " }),
	          react.createElement( ListItem, { title: "Oldsmobile " }),
	          react.createElement( ListItem, { title: "Peugeot " }),
	          react.createElement( ListItem, { title: "Pontiac " }),
	          react.createElement( ListItem, { title: "Porsche" }),
	          react.createElement( ListItem, { title: "Regal" }),
	          react.createElement( ListItem, { title: "Saab " }),
	          react.createElement( ListItem, { title: "Saturn " }),
	          react.createElement( ListItem, { title: "Subaru " }),
	          react.createElement( ListItem, { title: "Suzuki " }),
	          react.createElement( ListItem, { title: "Toyota" }),
	          react.createElement( ListItem, { title: "Volkswagen" }),
	          react.createElement( ListItem, { title: "Volvo" })
	        )
	      )
	    );
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$r = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);

	    this.state = {
	      sheetOpened: false,
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, { onPageBeforeOut: this.onPageBeforeOut.bind(this), onPageBeforeRemove: this.onPageBeforeRemove.bind(this) },
	        react.createElement( Navbar$2, { title: "Sheet Modal", backLink: "Back" }),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Sheet Modals slide up from the bottom of the screen to reveal more content. Such modals allow to create custom overlays with custom content." ),
	          react.createElement( Row, { tag: "p" },
	            react.createElement( Button, { className: "col", fill: true, sheetOpen: ".demo-sheet" }, "Open Sheet"),
	            react.createElement( Button, { className: "col", fill: true, onClick: this.createSheet.bind(this) }, "Create Dynamic Sheet")
	          ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { className: "col", fill: true, sheetOpen: ".demo-sheet-top" }, "Top Sheet")
	          ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { className: "col", fill: true, onClick: function () {this$1.setState({sheetOpened: true});} }, "Open Via Prop Change")
	          )
	        ),

	        react.createElement( BlockTitle, null, "Swipeable Sheet" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Sheet modal can be closed with swipe to top (for top Sheet) or bottom (for default Bottom sheet):" ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, sheetOpen: ".demo-sheet-swipe-to-close" }, "Swipe To Close")
	          ),
	          react.createElement( 'p', null, "Also there is swipe-step that can be set on Sheet modal to expand it with swipe:" ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, sheetOpen: ".demo-sheet-swipe-to-step" }, "Swipe To Step")
	          )
	        ),

	        react.createElement( Sheet$2, { className: "demo-sheet", opened: this.state.sheetOpened, onSheetClosed: function () {this$1.setState({sheetOpened: false});} },
	          react.createElement( Toolbar$2, null,
	            react.createElement( 'div', { className: "left" }),
	            react.createElement( 'div', { className: "right" },
	              react.createElement( Link, { sheetClose: true }, "Close")
	            )
	          )
	          /*  Scrollable sheet content */,
	          react.createElement( PageContent, null,
	            react.createElement( Block, null,
	              react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quae ducimus dolorum ipsa aliquid accusamus perferendis laboriosam delectus numquam minima animi, libero illo in tempora harum sequi corporis alias ex adipisci." ),
	              react.createElement( 'p', null, "Sunt magni enim saepe quasi aspernatur delectus consectetur fugiat necessitatibus qui sed, similique quis facere tempora, laudantium quae expedita ea, aperiam dolores. Aut deserunt soluta alias magnam. Consequatur, nisi, enim." ),
	              react.createElement( 'p', null, "Eaque maiores ducimus, impedit unde culpa qui, explicabo accusamus, non vero corporis voluptatibus similique odit ab. Quaerat quasi consectetur quidem libero? Repudiandae adipisci vel voluptatum, autem libero minus dignissimos repellat." ),
	              react.createElement( 'p', null, "Iusto, est corrupti! Totam minus voluptas natus esse possimus nobis, delectus veniam expedita sapiente ut cum reprehenderit aliquid odio amet praesentium vero temporibus obcaecati beatae aspernatur incidunt, perferendis voluptates doloribus?" ),
	              react.createElement( 'p', null, "Illum id laborum tempore, doloribus culpa labore ex iusto odit. Quibusdam consequuntur totam nam obcaecati, enim cumque nobis, accusamus, quos voluptates, voluptatibus sapiente repellendus nesciunt praesentium velit ipsa illo iusto." )
	            )
	          )
	        ),

	        react.createElement( Sheet$2, { top: true, className: "demo-sheet-top" },
	          react.createElement( Toolbar$2, { bottom: true },
	            react.createElement( 'div', { className: "left" }),
	            react.createElement( 'div', { className: "right" },
	              react.createElement( Link, { sheetClose: true }, "Close")
	            )
	          )
	          /*  Scrollable sheet content */,
	          react.createElement( PageContent, null,
	            react.createElement( Block, null,
	              react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quae ducimus dolorum ipsa aliquid accusamus perferendis laboriosam delectus numquam minima animi, libero illo in tempora harum sequi corporis alias ex adipisci." ),
	              react.createElement( 'p', null, "Sunt magni enim saepe quasi aspernatur delectus consectetur fugiat necessitatibus qui sed, similique quis facere tempora, laudantium quae expedita ea, aperiam dolores. Aut deserunt soluta alias magnam. Consequatur, nisi, enim." ),
	              react.createElement( 'p', null, "Eaque maiores ducimus, impedit unde culpa qui, explicabo accusamus, non vero corporis voluptatibus similique odit ab. Quaerat quasi consectetur quidem libero? Repudiandae adipisci vel voluptatum, autem libero minus dignissimos repellat." ),
	              react.createElement( 'p', null, "Iusto, est corrupti! Totam minus voluptas natus esse possimus nobis, delectus veniam expedita sapiente ut cum reprehenderit aliquid odio amet praesentium vero temporibus obcaecati beatae aspernatur incidunt, perferendis voluptates doloribus?" ),
	              react.createElement( 'p', null, "Illum id laborum tempore, doloribus culpa labore ex iusto odit. Quibusdam consequuntur totam nam obcaecati, enim cumque nobis, accusamus, quos voluptates, voluptatibus sapiente repellendus nesciunt praesentium velit ipsa illo iusto." )
	            )
	          )
	        ),

	        react.createElement( Sheet$2, {
	          className: "demo-sheet-swipe-to-close", style: {height: 'auto'}, swipeToClose: true, backdrop: true },
	          react.createElement( 'div', { className: "swipe-handler" }),

	          react.createElement( PageContent, null,
	            react.createElement( BlockTitle, { large: true }, "Hello!"),
	            react.createElement( Block, null,
	              react.createElement( 'p', null, "Eaque maiores ducimus, impedit unde culpa qui, explicabo accusamus, non vero corporis voluptatibus similique odit ab. Quaerat quasi consectetur quidem libero? Repudiandae adipisci vel voluptatum, autem libero minus dignissimos repellat." ),
	              react.createElement( 'p', null, "Iusto, est corrupti! Totam minus voluptas natus esse possimus nobis, delectus veniam expedita sapiente ut cum reprehenderit aliquid odio amet praesentium vero temporibus obcaecati beatae aspernatur incidunt, perferendis voluptates doloribus?" )
	            )
	          )
	        ),

	        react.createElement( Sheet$2, {
	          className: "demo-sheet-swipe-to-step", style: {height: 'auto'}, swipeToClose: true, swipeToStep: true, backdrop: true },
	          react.createElement( 'div', { className: "swipe-handler", onClick: function () { return this$1.toggleSwipeStep(); } }),
	          react.createElement( 'div', { className: "sheet-modal-swipe-step" },
	            react.createElement( 'div', { className: "display-flex padding justify-content-space-between align-items-center" },
	              react.createElement( 'div', { style: {fontSize: '18px'} }, react.createElement( 'b', null, "Total:" )),
	              react.createElement( 'div', { style: {fontSize: '22px'} }, react.createElement( 'b', null, "$500" ))
	            ),
	            react.createElement( 'div', { className: "padding-horizontal padding-bottom" },
	              react.createElement( Button, { large: true, fill: true }, "Make Payment"),
	              react.createElement( 'div', { className: "margin-top text-align-center" }, "Swipe up for more details")
	            )
	          ),
	          react.createElement( BlockTitle, { medium: true, className: "margin-top" }, "Your order:"),
	          react.createElement( List, { noHairlines: true },
	            react.createElement( ListItem, { title: "Item 1" },
	              react.createElement( 'b', { slot: "after", className: "text-color-black" }, "$200")
	            ),
	            react.createElement( ListItem, { title: "Item 2" },
	              react.createElement( 'b', { slot: "after", className: "text-color-black" }, "$180")
	            ),
	            react.createElement( ListItem, { title: "Delivery" },
	              react.createElement( 'b', { slot: "after", className: "text-color-black" }, "$120")
	            )
	          )
	        )
	      )
	    );
	  };
	  defaultExport.prototype.toggleSwipeStep = function toggleSwipeStep () {
	    var self = this;
	    self.$f7.sheet.stepToggle('.demo-sheet-swipe-to-step');
	  };
	  defaultExport.prototype.createSheet = function createSheet () {
	    var self = this;
	    var $ = self.$$;
	    // Create sheet modal
	    if (!self.sheet) {
	      self.sheet = self.$f7.sheet.create({
	        content: "\n          <div className=\"sheet-modal\">\n            <div className=\"toolbar\">\n              <div className=\"toolbar-inner justify-content-flex-end\">\n                <a href=\"#\" className=\"link sheet-close\">Close</a>\n              </div>\n            </div>\n            <div className=\"sheet-modal-inner\">\n              <div className=\"page-content\">\n                <div className=\"block\">\n                  <p>This sheet modal was created dynamically</p>\n                  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse faucibus mauris leo, eu bibendum neque congue non. Ut leo mauris, eleifend eu commodo a, egestas ac urna. Maecenas in lacus faucibus, viverra ipsum pulvinar, molestie arcu. Etiam lacinia venenatis dignissim. Suspendisse non nisl semper tellus malesuada suscipit eu et eros. Nulla eu enim quis quam elementum vulputate. Mauris ornare consequat nunc viverra pellentesque. Aenean semper eu massa sit amet aliquam. Integer et neque sed libero mollis elementum at vitae ligula. Vestibulum pharetra sed libero sed porttitor. Suspendisse a faucibus lectus.</p>\n                </div>\n              </div>\n            </div>\n          </div>\n        ".trim(),
	      });
	    }
	    // Close inline sheet
	    if ($('.demo-sheet.modal-in').length > 0) { self.$f7.sheet.close('.demo-sheet'); }
	    // Open it
	    self.sheet.open();
	  };
	  defaultExport.prototype.onPageBeforeOut = function onPageBeforeOut () {
	    var self = this;
	    // Close opened sheets on page out
	    self.$f7.sheet.close();
	  };
	  defaultExport.prototype.onPageBeforeRemove = function onPageBeforeRemove () {
	    var self = this;
	    // Destroy sheet modal when page removed
	    if (self.sheet) { self.sheet.destroy(); }
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$s = /*@__PURE__*/(function (superclass) {
	  function defaultExport() {
	    superclass.call(this);
	    this.state = {
	      loading: false,
	      effect: null,
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Skeleton Layouts", backLink: "Back" }),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Skeleton (or Ghost) elements designed to improve perceived performance and make app feels faster." ),
	          react.createElement( 'p', null, "Framework7 comes with two types of such elements: Skeleton Block and Skeleton Text. Skeleton block is a gray box that can be used as placeholder for any element. Skeleton text uses special built-in skeleton font to render each character of such text as gray rectangle. Skeleton text allows to make such elements responsive and feel more natural." ),
	          react.createElement( 'p', null, "It can be used in any places and with any elements." )
	        ),

	        react.createElement( BlockTitle, null, "Skeleton List" ),
	        react.createElement( List, { mediaList: true, className: "skeleton-text" },
	          react.createElement( ListItem, {
	            title: "Title", subtitle: "Subtitle", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi lobortis et massa ac interdum." },
	            react.createElement( SkeletonBlock, { style: { width: '40px', height: '40px', 'border-radius': '50%' }, slot: "media" })
	          ),
	          react.createElement( ListItem, {
	            title: "Title", subtitle: "Subtitle", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi lobortis et massa ac interdum." },
	            react.createElement( SkeletonBlock, { style: { width: '40px', height: '40px', 'border-radius': '50%' }, slot: "media" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Skeleton Card" ),
	        react.createElement( Card$1, {
	          className: "skeleton-text", title: "Card Header", content: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi lobortis et massa ac interdum. Cras consequat felis at consequat hendrerit.", footer: "Card Footer" }),

	        react.createElement( BlockTitle, null, "Loading Effects" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "It supports few loading effects:" ),
	          react.createElement( Row, { tag: "p" },
	            react.createElement( Button, { fill: true, small: true, round: true, className: "col", onClick: function () { return this$1.load('fade'); } }, "Fade"),
	            react.createElement( Button, { fill: true, small: true, round: true, className: "col", onClick: function () { return this$1.load('blink'); } }, "Blink"),
	            react.createElement( Button, { fill: true, small: true, round: true, className: "col", onClick: function () { return this$1.load('pulse'); } }, "Pulse")
	          )
	        ),
	        this.state.loading
	          ? (
	            react.createElement( List, { mediaList: true, 'v-if': "loading" },
	              [1,2,3].map(function (n) { return (
	                react.createElement( ListItem, {
	                  key: n, className: ("skeleton-text skeleton-effect-" + (this$1.state.effect)), title: "Full Name", subtitle: "Position", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi lobortis et massa ac interdum. Cras consequat felis at consequat hendrerit. Aliquam vestibulum vitae lorem ac iaculis. Praesent nec pharetra massa, at blandit lectus. Sed tincidunt, lectus eu convallis elementum, nibh nisi aliquet urna, nec imperdiet felis sapien at enim." },
	                  react.createElement( SkeletonBlock, { style: { width: '40px', height: '40px', 'border-radius': '50%' }, slot: "media" })
	                )
	              ); })
	            )
	          )
	          : (
	            react.createElement( List, { mediaList: true },
	              react.createElement( ListItem, {
	                title: "John Doe", subtitle: "CEO", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi lobortis et massa ac interdum. Cras consequat felis at consequat hendrerit. Aliquam vestibulum vitae lorem ac iaculis. Praesent nec pharetra massa, at blandit lectus. Sed tincidunt, lectus eu convallis elementum, nibh nisi aliquet urna, nec imperdiet felis sapien at enim." },
	                react.createElement( 'img', { src: "https://placeimg.com/80/80/people/1", style: { width: '40px', height: '40px', 'border-radius': '50%' }, slot: "media" })
	              ),
	              react.createElement( ListItem, {
	                title: "Jane Doe", subtitle: "Marketing", text: "Cras consequat felis at consequat hendrerit. Aliquam vestibulum vitae lorem ac iaculis. Praesent nec pharetra massa, at blandit lectus. Sed tincidunt, lectus eu convallis elementum, nibh nisi aliquet urna, nec imperdiet felis sapien at enim." },
	                react.createElement( 'img', { src: "https://placeimg.com/80/80/people/2", style: { width: '40px', height: '40px', 'border-radius': '50%' }, slot: "media" })
	              ),
	              react.createElement( ListItem, {
	                title: "Kate Johnson", subtitle: "Admin", text: "Sed tincidunt, lectus eu convallis elementum, nibh nisi aliquet urna, nec imperdiet felis sapien at enim." },
	                react.createElement( 'img', { src: "https://placeimg.com/80/80/people/3", style: { width: '40px', height: '40px', 'border-radius': '50%' }, slot: "media" })
	              )
	            )
	          )
	      )
	    );
	  };
	  defaultExport.prototype.load = function load (effect) {
	    var self = this;
	    if (self.state.loading) { return; }
	    self.setState({
	      effect: effect,
	      loading: true,
	    });
	    setTimeout(function () {
	      self.setState({ loading: false });
	    }, 3000);
	  };

	  return defaultExport;
	}(react.Component));

	function SmartSelect$2 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Smart Select", backLink: "Back" }),
	    react.createElement( Block, null, "Framework7 allows you to easily convert your usual form selects to dynamic pages with radios:" ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { title: "Fruit", smartSelect: true },
	        react.createElement( 'select', { name: "fruits", defaultValue: "apple" },
	          react.createElement( 'option', { value: "apple" }, "Apple"),
	          react.createElement( 'option', { value: "pineapple" }, "Pineapple"),
	          react.createElement( 'option', { value: "pear" }, "Pear"),
	          react.createElement( 'option', { value: "orange" }, "Orange"),
	          react.createElement( 'option', { value: "melon" }, "Melon"),
	          react.createElement( 'option', { value: "peach" }, "Peach"),
	          react.createElement( 'option', { value: "banana" }, "Banana")
	        )
	      ),
	      react.createElement( ListItem, { title: "Car", smartSelect: true, smartSelectParams: {openIn: 'popup', searchbar: true, searchbarPlaceholder: 'Search car'} },
	        react.createElement( 'select', { name: "car", multiple: true, defaultValue: ['honda', 'audi', 'ford'] },
	          react.createElement( 'optgroup', { label: "Japanese" },
	            react.createElement( 'option', { value: "honda" }, "Honda"),
	            react.createElement( 'option', { value: "lexus" }, "Lexus"),
	            react.createElement( 'option', { value: "mazda" }, "Mazda"),
	            react.createElement( 'option', { value: "nissan" }, "Nissan"),
	            react.createElement( 'option', { value: "toyota" }, "Toyota")
	          ),
	          react.createElement( 'optgroup', { label: "German" },
	            react.createElement( 'option', { value: "audi" }, "Audi"),
	            react.createElement( 'option', { value: "bmw" }, "BMW"),
	            react.createElement( 'option', { value: "mercedes" }, "Mercedes"),
	            react.createElement( 'option', { value: "vw" }, "Volkswagen"),
	            react.createElement( 'option', { value: "volvo" }, "Volvo")
	          ),
	          react.createElement( 'optgroup', { label: "American" },
	            react.createElement( 'option', { value: "cadillac" }, "Cadillac"),
	            react.createElement( 'option', { value: "chrysler" }, "Chrysler"),
	            react.createElement( 'option', { value: "dodge" }, "Dodge"),
	            react.createElement( 'option', { value: "ford" }, "Ford")
	          )
	        )
	      ),
	      react.createElement( ListItem, { title: "Mac or Windows", smartSelect: true, smartSelectParams: {openIn: 'sheet'} },
	        react.createElement( 'select', { name: "mac-windows", defaultValue: "mac" },
	          react.createElement( 'option', { value: "mac" }, "Mac"),
	          react.createElement( 'option', { value: "windows" }, "Windows")
	        )
	      ),
	      react.createElement( ListItem, { title: "Super Hero", smartSelect: true, smartSelectParams: {openIn: 'popover'} },
	        react.createElement( 'select', { name: "superhero", multiple: true, defaultValue: ['Batman'] },
	          react.createElement( 'option', { value: "Batman" }, "Batman"),
	          react.createElement( 'option', { value: "Superman" }, "Superman"),
	          react.createElement( 'option', { value: "Hulk" }, "Hulk"),
	          react.createElement( 'option', { value: "Spiderman" }, "Spiderman"),
	          react.createElement( 'option', { value: "Ironman" }, "Ironman"),
	          react.createElement( 'option', { value: "Thor" }, "Thor"),
	          react.createElement( 'option', { value: "Wonder Woman" }, "Wonder Woman")
	        )
	      )
	    )
	  )
	); }

	function Sortable$2 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Sortable List", backLink: "Back" },
	      react.createElement( NavRight, null,
	        react.createElement( Link, { sortableToggle: ".sortable" }, "Toggle")
	      )
	    ),

	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Just click \"Toggle\" button on navigation bar to enable/disable sorting" )
	    ),
	    react.createElement( List, { sortable: true },
	      react.createElement( ListItem, {
	        title: "1 Jenna Smith", after: "CEO" },
	        react.createElement( Icon, { icon: "icon-f7", slot: "media" })
	      ),
	      react.createElement( ListItem, {
	        title: "2 John Doe", after: "Director" },
	        react.createElement( Icon, { icon: "icon-f7", slot: "media" })
	      ),
	      react.createElement( ListItem, {
	        title: "3 John Doe", after: "Developer" },
	        react.createElement( Icon, { icon: "icon-f7", slot: "media" })
	      ),
	      react.createElement( ListItem, {
	        title: "4 Aaron Darling", after: "Manager" },
	        react.createElement( Icon, { icon: "icon-f7", slot: "media" })
	      ),
	      react.createElement( ListItem, {
	        title: "5 Calvin Johnson", after: "Accounter" },
	        react.createElement( Icon, { icon: "icon-f7", slot: "media" })
	      ),
	      react.createElement( ListItem, {
	        title: "6 John Smith", after: "SEO" },
	        react.createElement( Icon, { icon: "icon-f7", slot: "media" })
	      ),
	      react.createElement( ListItem, {
	        title: "7 Chloe", after: "Manager" },
	        react.createElement( Icon, { icon: "icon-f7", slot: "media" })
	      )
	    ),
	    react.createElement( List, { mediaList: true, sortable: true },
	      react.createElement( ListItem, {
	        title: "Yellow Submarine", after: "$15", subtitle: "Beatles", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." },
	        react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/people-160x160-1.jpg", width: "80" })
	      ),
	      react.createElement( ListItem, {
	        title: "Don't Stop Me Now", after: "$22", subtitle: "Queen", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." },
	        react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/people-160x160-2.jpg", width: "80" })
	      ),
	      react.createElement( ListItem, {
	        title: "Billie Jean", after: "$16", subtitle: "Michael Jackson", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." },
	        react.createElement( 'img', { slot: "media", src: "https://cdn.framework7.io/placeholder/people-160x160-3.jpg", width: "80" })
	      )
	    )
	  )
	); }

	var defaultExport$t = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Statusbar Overlay", backLink: "Back" }),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Framework7 automatically detects if your app in full screen mode, and automatically shows statusbar overlay if app is in full screen mode (or hides statusbar if app is not in full screen mode). Its visibility can be forced using app parameters or using API:" ),
	          react.createElement( Row, { tag: "p" },
	            react.createElement( Button, { fill: true, className: "col", onClick: this.showStatusbar.bind(this) }, "Show Statusbar"),
	            react.createElement( Button, { fill: true, className: "col", onClick: this.hideStatusbar.bind(this) }, "Hide Statusbar")
	          )
	        )
	      )
	    );
	  };
	  defaultExport.prototype.showStatusbar = function showStatusbar () {
	    this.$f7.statusbar.show();
	  };
	  defaultExport.prototype.hideStatusbar = function hideStatusbar () {
	    this.$f7.statusbar.hide();
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$u = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);

	    this.state = {
	      applesCount: 0,
	      orangesCount: 0,
	      meetingTime: 15,
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;

	  var prototypeAccessors = { meetingTimeComputed: { configurable: true } };
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Stepper", backLink: "Back" }),
	        react.createElement( BlockTitle, null, "Shape and size" ),
	        react.createElement( Block, { strong: true, className: "text-align-center" },
	          react.createElement( Row, null,
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Default"),
	              react.createElement( Stepper$2, null )
	            ),
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Round"),
	              react.createElement( Stepper$2, { round: true })
	            )
	          ),

	          react.createElement( Row, { className: "margin-top" },
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Fill"),
	              react.createElement( Stepper$2, { fill: true })
	            ),
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Round Fill"),
	              react.createElement( Stepper$2, { fill: true, round: true })
	            )
	          ),

	          react.createElement( Row, { className: "margin-top" },
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Small"),
	              react.createElement( Stepper$2, { small: true })
	            ),
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Small Round"),
	              react.createElement( Stepper$2, { small: true, round: true })
	            )
	          ),

	          react.createElement( Row, { className: "margin-top" },
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Small Fill"),
	              react.createElement( Stepper$2, { small: true, fill: true })
	            ),
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Small Round Fill"),
	              react.createElement( Stepper$2, { small: true, round: true, fill: true })
	            )
	          ),

	          react.createElement( Row, { className: "margin-top" },
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Large"),
	              react.createElement( Stepper$2, { large: true })
	            ),
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Large Round"),
	              react.createElement( Stepper$2, { large: true, round: true })
	            )
	          ),

	          react.createElement( Row, { className: "margin-top" },
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Large Fill"),
	              react.createElement( Stepper$2, { large: true, fill: true })
	            ),
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Large Round Fill"),
	              react.createElement( Stepper$2, { large: true, round: true, fill: true })
	            )
	          )
	        ),

	        react.createElement( BlockTitle, null, "Raised" ),
	        react.createElement( Block, { strong: true, className: "text-align-center" },
	          react.createElement( Row, null,
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Default"),
	              react.createElement( Stepper$2, { raised: true })
	            ),
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Round"),
	              react.createElement( Stepper$2, { raised: true, round: true })
	            )
	          ),

	          react.createElement( Row, { className: "margin-top" },
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Fill"),
	              react.createElement( Stepper$2, { raised: true, fill: true })
	            ),
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Round Fill"),
	              react.createElement( Stepper$2, { raised: true, fill: true, round: true })
	            )
	          ),

	          react.createElement( Row, { className: "margin-top" },
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Small"),
	              react.createElement( Stepper$2, { raised: true, small: true })
	            ),
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Small Round"),
	              react.createElement( Stepper$2, { raised: true, small: true, round: true })
	            )
	          ),

	          react.createElement( Row, { className: "margin-top" },
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Small Fill"),
	              react.createElement( Stepper$2, { raised: true, small: true, fill: true })
	            ),
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Small Round Fill"),
	              react.createElement( Stepper$2, { raised: true, small: true, round: true, fill: true })
	            )
	          ),

	          react.createElement( Row, { className: "margin-top" },
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Large"),
	              react.createElement( Stepper$2, { raised: true, large: true })
	            ),
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Large Round"),
	              react.createElement( Stepper$2, { raised: true, large: true, round: true })
	            )
	          ),

	          react.createElement( Row, { className: "margin-top" },
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Large Fill"),
	              react.createElement( Stepper$2, { raised: true, large: true, fill: true })
	            ),
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Large Round Fill"),
	              react.createElement( Stepper$2, { raised: true, large: true, round: true, fill: true })
	            )
	          )
	        ),
	        react.createElement( BlockTitle, null, "Colors" ),
	        react.createElement( Block, { strong: true, className: "text-align-center" },
	          react.createElement( Row, null,
	            react.createElement( Col, null,
	              react.createElement( Stepper$2, { fill: true, color: "red" })
	            ),
	            react.createElement( Col, null,
	              react.createElement( Stepper$2, { fill: true, round: true, color: "green" })
	            )
	          ),

	          react.createElement( Row, { className: "margin-top" },
	            react.createElement( Col, null,
	              react.createElement( Stepper$2, { fill: true, color: "blue" })
	            ),
	            react.createElement( Col, null,
	              react.createElement( Stepper$2, { fill: true, round: true, color: "pink" })
	            )
	          ),

	          react.createElement( Row, { className: "margin-top" },
	            react.createElement( Col, null,
	              react.createElement( Stepper$2, { fill: true, small: true, color: "yellow" })
	            ),
	            react.createElement( Col, null,
	              react.createElement( Stepper$2, { fill: true, small: true, round: true, color: "orange" })
	            )
	          ),

	          react.createElement( Row, { className: "margin-top" },
	            react.createElement( Col, null,
	              react.createElement( Stepper$2, { fill: true, small: true, color: "gray" })
	            ),
	            react.createElement( Col, null,
	              react.createElement( Stepper$2, { fill: true, small: true, round: true, color: "black" })
	            )
	          )
	        ),
	        react.createElement( BlockTitle, null, "Without input element" ),
	        react.createElement( Block, { strong: true, className: "text-align-center" },
	          react.createElement( Row, null,
	            react.createElement( Col, null,
	              react.createElement( Stepper$2, { input: false })
	            ),
	            react.createElement( Col, null,
	              react.createElement( Stepper$2, { input: false, round: true })
	            )
	          )
	        ),
	        react.createElement( BlockTitle, null, "Min, max, step" ),
	        react.createElement( Block, { strong: true, className: "text-align-center" },
	          react.createElement( Row, null,
	            react.createElement( Col, null,
	              react.createElement( Stepper$2, { fill: true, value: 100, min: 0, max: 1000, step: 100 })
	            ),
	            react.createElement( Col, null,
	              react.createElement( Stepper$2, { fill: true, input: false, value: 5, min: 0, max: 10, step: 0.5 })
	            )
	          )
	        ),

	        react.createElement( BlockTitle, null, "Autorepeat (Tap & hold)" ),
	        react.createElement( BlockHeader, null, "Pressing and holding one of its buttons increments or decrements the stepper’s value repeatedly. With dynamic autorepeat, the rate of change depends on how long the user continues pressing the control." ),
	        react.createElement( Block, { strong: true, className: "text-align-center" },
	          react.createElement( Row, null,
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Default"),
	              react.createElement( Stepper$2, { fill: true, value: 0, min: 0, max: 100, step: 1, autorepeat: true })
	            ),
	            react.createElement( Col, null,
	              react.createElement( 'small', { className: "display-block" }, "Dynamic"),
	              react.createElement( Stepper$2, { fill: true, value: 0, min: 0, max: 100, step: 1, autorepeat: true, autorepeatDynamic: true })
	            )
	          )
	        ),

	        react.createElement( BlockTitle, null, "Wraps" ),
	        react.createElement( BlockHeader, null, "In wraps mode incrementing beyond maximum value sets value to minimum value, likewise, decrementing below minimum value sets value to maximum value" ),
	        react.createElement( Block, { strong: true, className: "text-align-center" },
	          react.createElement( Row, null,
	            react.createElement( Col, null,
	              react.createElement( Stepper$2, { fill: true, value: 0, min: 0, max: 10, step: 1, autorepeat: true, wraps: true })
	            )
	          )
	        ),

	        react.createElement( BlockTitle, null, "Custom value element" ),
	        react.createElement( List, null,
	          react.createElement( ListItem, { title: ("Apples " + (this.state.applesCount)) },
	            react.createElement( Stepper$2, { buttonsOnly: true, small: true, raised: true, slot: "after", onStepperChange: this.setApples.bind(this) })
	          ),
	          react.createElement( ListItem, { title: ("Oranges " + (this.state.orangesCount)) },
	            react.createElement( Stepper$2, { buttonsOnly: true, small: true, raised: true, slot: "after", onStepperChange: this.setOranges.bind(this) })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Custom value format" ),
	        react.createElement( List, null,
	          react.createElement( ListItem, { header: "Meeting starts in", title: this.meetingTimeComputed },
	            react.createElement( Stepper$2, {
	              min: 15, max: 240, step: 15, value: this.state.meetingTime, buttonsOnly: true, small: true, fill: true, raised: true, slot: "after", onStepperChange: this.setMeetingTime.bind(this) })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Manual input" ),
	        react.createElement( BlockHeader, null, "It is possible to enter value manually from keyboard or mobile keypad. When click on input field, stepper enter into manual input mode, which allow type value from keyboar and check fractional part with defined accurancy. Click outside or enter Return key, ending manual mode." ),
	        react.createElement( Block, { strong: true, className: "text-align-center" },
	          react.createElement( Row, null,
	            react.createElement( Col, null,
	              react.createElement( Stepper$2, { fill: true, value: 0, min: 0, max: 1000, step: 1, autorepeat: true, wraps: true, manualInputMode: true, decimalPoint: 2 })
	            )
	          )
	        )
	      )
	    );
	  };
	  prototypeAccessors.meetingTimeComputed.get = function () {
	    var self = this;
	    var value = self.state.meetingTime;

	    var hours = Math.floor(value / 60);
	    var minutes = value - (hours * 60);
	    var formatted = [];
	    if (hours > 0) {
	      formatted.push(hours + ' ' + (hours > 1 ? 'hours' : 'hour'));
	    }
	    if (minutes > 0) {
	      formatted.push(minutes + ' minutes');
	    }
	    return formatted.join(' ');
	  };
	  defaultExport.prototype.setApples = function setApples (value) {
	    this.setState({ applesCount: value });
	  };
	  defaultExport.prototype.setOranges = function setOranges (value) {
	    this.setState({ orangesCount: value });
	  };
	  defaultExport.prototype.setMeetingTime = function setMeetingTime (value) {
	    this.setState({ meetingTime: value });
	  };

	  Object.defineProperties( defaultExport.prototype, prototypeAccessors );

	  return defaultExport;
	}(react.Component));

	function Subnavbar$2 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Subnavbar", backLink: "Back" },
	      react.createElement( Subnavbar$1, null,
	        react.createElement( Segmented, null,
	          react.createElement( Button, { outline: true, active: true }, "Link 1"),
	          react.createElement( Button, { outline: true }, "Link 2"),
	          react.createElement( Button, { outline: true }, "Link 3")
	        )
	      )
	    ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Subnavbar is useful when you need to put any additional elements into Navbar, like Tab Links or Search Bar. It also remains visible when Navbar hidden." )
	    ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { link: "/subnavbar-title/", title: "Subnavbar Title" })
	    )
	  )
	); }

	function SubnavbarTitle () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { backLink: "Back" },
	      react.createElement( Subnavbar$1, { title: "Page Title" })
	    ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "It also possible to use Subnavbar to display page title and keep navbar only for actions." )
	    ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Unde, consequatur quia amet voluptate vero quasi, veniam, quisquam dolorum magni sint enim, harum expedita excepturi quas iure magnam minus voluptatem quaerat!" ),
	      react.createElement( 'p', null, "Dolore laboriosam error magnam velit expedita recusandae, dolor asperiores unde, sint, veritatis illum ipsum? Nulla ratione nobis, ullam debitis. Inventore sapiente rem dolore eum ipsa totam perspiciatis cupiditate, amet maiores!" ),
	      react.createElement( 'p', null, "Ratione quod minus ipsum maxime cum voluptate molestiae adipisci placeat ut illo, alias nobis perferendis magni odio sunt, porro, totam praesentium possimus! Autem inventore ut provident animi quae, impedit id!" ),
	      react.createElement( 'p', null, "Aperiam ea ab harum. Quis dolorem cupiditate, incidunt mollitia ducimus voluptatem commodi! Odio quasi amet hic nesciunt, quibusdam, est vero repellat sapiente perferendis, optio laboriosam in culpa veniam alias ad." ),
	      react.createElement( 'p', null, "A fuga corporis harum velit maiores, quaerat accusantium cum aspernatur consequuntur dolor vel fugit omnis est dolorum delectus debitis aperiam distinctio eveniet vero nihil voluptatum culpa. Accusamus aliquid facere tenetur?" )
	    )
	  )
	); }

	function Swiper$3 () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Swiper Slider", backLink: "Back" }),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Framework7 comes with powerful and most modern touch slider ever - ", react.createElement( 'a', { href: "http://idangero.us/swiper", className: "external", target: "_blank" }, "Swiper Slider"), "with super flexible configuration and lot, lot of features. Just check the following demos:" )
	    ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { link: "swiper-horizontal/", title: "Swiper Horizontal" }),
	      react.createElement( ListItem, { link: "swiper-vertical/", title: "Swiper Vertical" }),
	      react.createElement( ListItem, { link: "swiper-space-between/", title: "Space Between Slides" }),
	      react.createElement( ListItem, { link: "swiper-multiple/", title: "Multiple Per Page" }),
	      react.createElement( ListItem, { link: "swiper-nested/", title: "Nested Swipers" }),
	      react.createElement( ListItem, { link: "swiper-loop/", title: "Infinite Loop Mode" }),
	      react.createElement( ListItem, { link: "swiper-3d-cube/", title: "3D Cube Effect" }),
	      react.createElement( ListItem, { link: "swiper-3d-coverflow/", title: "3D Coverflow Effect" }),
	      react.createElement( ListItem, { link: "swiper-3d-flip/", title: "3D Flip Effect" }),
	      react.createElement( ListItem, { link: "swiper-fade/", title: "Fade Effect" }),
	      react.createElement( ListItem, { link: "swiper-scrollbar/", title: "With Scrollbar" }),
	      react.createElement( ListItem, { link: "swiper-gallery/", title: "Thumbs Gallery" }),
	      react.createElement( ListItem, { link: "swiper-custom-controls/", title: "Custom Controls" }),
	      react.createElement( ListItem, { link: "swiper-parallax/", title: "Parallax" }),
	      react.createElement( ListItem, { link: "swiper-lazy/", title: "Lazy Loading" }),
	      react.createElement( ListItem, { link: "swiper-pagination-progress/", title: "Progress Pagination" }),
	      react.createElement( ListItem, { link: "swiper-pagination-fraction/", title: "Fraction Pagination" }),
	      react.createElement( ListItem, { link: "swiper-zoom/", title: "Zoom" })
	    )
	  )

	); }

	function SwiperHorizontal () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Swiper Horizontal", backLink: "Back" }),
	    react.createElement( Swiper$2, { className: "demo-swiper", pagination: true, params: {
	      pagination: {
	        hideOnClick: true,
	      }
	    } },
	      react.createElement( SwiperSlide, null, "Slide 1" ),
	      react.createElement( SwiperSlide, null, "Slide 2" ),
	      react.createElement( SwiperSlide, null, "Slide 3" ),
	      react.createElement( SwiperSlide, null, "Slide 4" ),
	      react.createElement( SwiperSlide, null, "Slide 5" ),
	      react.createElement( SwiperSlide, null, "Slide 6" ),
	      react.createElement( SwiperSlide, null, "Slide 7" ),
	      react.createElement( SwiperSlide, null, "Slide 8" ),
	      react.createElement( SwiperSlide, null, "Slide 9" ),
	      react.createElement( SwiperSlide, null, "Slide 10" )
	    )
	  )
	); }

	function SwiperVertical () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Swiper Horizontal", backLink: "Back" }),
	    react.createElement( Swiper$2, { className: "demo-swiper", pagination: true, params: {
	      direction: 'vertical',
	      pagination: {
	        hideOnClick: true,
	      }
	    } },
	      react.createElement( SwiperSlide, null, "Slide 1" ),
	      react.createElement( SwiperSlide, null, "Slide 2" ),
	      react.createElement( SwiperSlide, null, "Slide 3" ),
	      react.createElement( SwiperSlide, null, "Slide 4" ),
	      react.createElement( SwiperSlide, null, "Slide 5" ),
	      react.createElement( SwiperSlide, null, "Slide 6" ),
	      react.createElement( SwiperSlide, null, "Slide 7" ),
	      react.createElement( SwiperSlide, null, "Slide 8" ),
	      react.createElement( SwiperSlide, null, "Slide 9" ),
	      react.createElement( SwiperSlide, null, "Slide 10" )
	    )
	  )
	); }

	function SwiperSpaceBetween () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Space Between Slides", backLink: "Back" }),
	    react.createElement( Swiper$2, { className: "demo-swiper", pagination: true, params: {
	      spaceBetween: 50,
	      pagination: {
	        hideOnClick: true,
	      }
	    } },
	      react.createElement( SwiperSlide, null, "Slide 1" ),
	      react.createElement( SwiperSlide, null, "Slide 2" ),
	      react.createElement( SwiperSlide, null, "Slide 3" ),
	      react.createElement( SwiperSlide, null, "Slide 4" ),
	      react.createElement( SwiperSlide, null, "Slide 5" ),
	      react.createElement( SwiperSlide, null, "Slide 6" ),
	      react.createElement( SwiperSlide, null, "Slide 7" ),
	      react.createElement( SwiperSlide, null, "Slide 8" ),
	      react.createElement( SwiperSlide, null, "Slide 9" ),
	      react.createElement( SwiperSlide, null, "Slide 10" )
	    )
	  )
	); }

	function SwiperMultiple () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Multiple Swipers", backLink: "Back" }),
	    react.createElement( BlockTitle, null, "1 Slide Per View, 50px Between" ),
	    react.createElement( Swiper$2, { className: "demo-swiper-multiple", pagination: true, params: {
	      spaceBetween: 50,
	    } },
	      react.createElement( SwiperSlide, null, "Slide 1" ),
	      react.createElement( SwiperSlide, null, "Slide 2" ),
	      react.createElement( SwiperSlide, null, "Slide 3" ),
	      react.createElement( SwiperSlide, null, "Slide 4" ),
	      react.createElement( SwiperSlide, null, "Slide 5" ),
	      react.createElement( SwiperSlide, null, "Slide 6" ),
	      react.createElement( SwiperSlide, null, "Slide 7" ),
	      react.createElement( SwiperSlide, null, "Slide 8" ),
	      react.createElement( SwiperSlide, null, "Slide 9" ),
	      react.createElement( SwiperSlide, null, "Slide 10" )
	    ),

	    react.createElement( BlockTitle, null, "2 Slides Per View, 20px Between" ),
	    react.createElement( Swiper$2, { className: "demo-swiper-multiple", pagination: true, params: {
	      spaceBetween: 20,
	      slidesPerView: 2,
	    } },
	      react.createElement( SwiperSlide, null, "Slide 1" ),
	      react.createElement( SwiperSlide, null, "Slide 2" ),
	      react.createElement( SwiperSlide, null, "Slide 3" ),
	      react.createElement( SwiperSlide, null, "Slide 4" ),
	      react.createElement( SwiperSlide, null, "Slide 5" ),
	      react.createElement( SwiperSlide, null, "Slide 6" ),
	      react.createElement( SwiperSlide, null, "Slide 7" ),
	      react.createElement( SwiperSlide, null, "Slide 8" ),
	      react.createElement( SwiperSlide, null, "Slide 9" ),
	      react.createElement( SwiperSlide, null, "Slide 10" )
	    ),

	    react.createElement( BlockTitle, null, "3 Slides Per View, 10px Between" ),
	    react.createElement( Swiper$2, { className: "demo-swiper-multiple", pagination: true, params: {
	      spaceBetween: 10,
	      slidesPerView: 3,
	    } },
	      react.createElement( SwiperSlide, null, "Slide 1" ),
	      react.createElement( SwiperSlide, null, "Slide 2" ),
	      react.createElement( SwiperSlide, null, "Slide 3" ),
	      react.createElement( SwiperSlide, null, "Slide 4" ),
	      react.createElement( SwiperSlide, null, "Slide 5" ),
	      react.createElement( SwiperSlide, null, "Slide 6" ),
	      react.createElement( SwiperSlide, null, "Slide 7" ),
	      react.createElement( SwiperSlide, null, "Slide 8" ),
	      react.createElement( SwiperSlide, null, "Slide 9" ),
	      react.createElement( SwiperSlide, null, "Slide 10" )
	    ),

	    react.createElement( BlockTitle, null, "Auto Slides Per View + Centered" ),
	    react.createElement( Swiper$2, { className: "demo-swiper-multiple demo-swiper-multiple-auto", pagination: true, params: {
	      spaceBetween: 10,
	      centeredSlides: true,
	      slidesPerView: 'auto',
	    } },
	      react.createElement( SwiperSlide, null, "Slide 1" ),
	      react.createElement( SwiperSlide, null, "Slide 2" ),
	      react.createElement( SwiperSlide, null, "Slide 3" ),
	      react.createElement( SwiperSlide, null, "Slide 4" ),
	      react.createElement( SwiperSlide, null, "Slide 5" ),
	      react.createElement( SwiperSlide, null, "Slide 6" ),
	      react.createElement( SwiperSlide, null, "Slide 7" ),
	      react.createElement( SwiperSlide, null, "Slide 8" ),
	      react.createElement( SwiperSlide, null, "Slide 9" ),
	      react.createElement( SwiperSlide, null, "Slide 10" )
	    ),

	    react.createElement( BlockTitle, null, "Vertical, 10px Between" ),
	    react.createElement( Swiper$2, { className: "demo-swiper-multiple", pagination: true, params: {
	      direction: 'vertical',
	      spaceBetween: 10,
	    } },
	      react.createElement( SwiperSlide, null, "Slide 1" ),
	      react.createElement( SwiperSlide, null, "Slide 2" ),
	      react.createElement( SwiperSlide, null, "Slide 3" ),
	      react.createElement( SwiperSlide, null, "Slide 4" ),
	      react.createElement( SwiperSlide, null, "Slide 5" ),
	      react.createElement( SwiperSlide, null, "Slide 6" ),
	      react.createElement( SwiperSlide, null, "Slide 7" ),
	      react.createElement( SwiperSlide, null, "Slide 8" ),
	      react.createElement( SwiperSlide, null, "Slide 9" ),
	      react.createElement( SwiperSlide, null, "Slide 10" )
	    ),

	    react.createElement( BlockTitle, null, "Slow speed" ),
	    react.createElement( Swiper$2, { className: "demo-swiper-multiple", pagination: true, params: {
	      speed: 900,
	      spaceBetween: 50,
	    } },
	      react.createElement( SwiperSlide, null, "Slide 1" ),
	      react.createElement( SwiperSlide, null, "Slide 2" ),
	      react.createElement( SwiperSlide, null, "Slide 3" ),
	      react.createElement( SwiperSlide, null, "Slide 4" ),
	      react.createElement( SwiperSlide, null, "Slide 5" ),
	      react.createElement( SwiperSlide, null, "Slide 6" ),
	      react.createElement( SwiperSlide, null, "Slide 7" ),
	      react.createElement( SwiperSlide, null, "Slide 8" ),
	      react.createElement( SwiperSlide, null, "Slide 9" ),
	      react.createElement( SwiperSlide, null, "Slide 10" )
	    )
	  )
	); }

	function SwiperNested () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Nested Swipers", backLink: "Back" }),
	    react.createElement( Swiper$2, { className: "demo-swiper", pagination: true },
	      react.createElement( SwiperSlide, null, "Horizontal Slide 1" ),
	      react.createElement( SwiperSlide, null,
	        react.createElement( Swiper$2, { className: "demo-swiper", pagination: true, params: { direction: 'vertical' } },
	          react.createElement( SwiperSlide, null, "Vertical Slide 1" ),
	          react.createElement( SwiperSlide, null, "Vertical Slide 2" ),
	          react.createElement( SwiperSlide, null, "Vertical Slide 3" )
	        )
	      ),
	      react.createElement( SwiperSlide, null, "Horizontal Slide 3" ),
	      react.createElement( SwiperSlide, null, "Horizontal Slide 3" )
	    )
	  )
	); }

	function SwiperLoop () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Infinite Loop Mode", backLink: "Back" }),
	    react.createElement( Swiper$2, { className: "demo-swiper", pagination: true, params: {
	      loop: true,
	    } },
	      react.createElement( SwiperSlide, null, "Slide 1" ),
	      react.createElement( SwiperSlide, null, "Slide 2" ),
	      react.createElement( SwiperSlide, null, "Slide 3" ),
	      react.createElement( SwiperSlide, null, "Slide 4" ),
	      react.createElement( SwiperSlide, null, "Slide 5" ),
	      react.createElement( SwiperSlide, null, "Slide 6" ),
	      react.createElement( SwiperSlide, null, "Slide 7" ),
	      react.createElement( SwiperSlide, null, "Slide 8" ),
	      react.createElement( SwiperSlide, null, "Slide 9" ),
	      react.createElement( SwiperSlide, null, "Slide 10" )
	    )
	  )
	); }

	function Swiper3dCube () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "3D Cube", backLink: "Back" }),
	    react.createElement( Swiper$2, { className: "demo-swiper demo-swiper-cube", params: {
	      effect: 'cube',
	    } },
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-1.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-2.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-3.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-4.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-5.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-6.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-7.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-8.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-9.jpg)'} })
	    )
	  )
	); }

	function Swiper3dCoverflow () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "3D Coverflow Effect", backLink: "Back" }),
	    react.createElement( Swiper$2, { className: "demo-swiper demo-swiper-coverflow", pagination: true, params: {
	      effect: 'coverflow',
	      centeredSlides: true,
	      slidesPerView: 'auto',
	    } },
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-1.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-2.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-3.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-4.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-5.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-6.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-7.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-8.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-9.jpg)'} })
	    )
	  )
	); }

	function Swiper3dFlip () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "3D Flip Effect", backLink: "Back" }),
	    react.createElement( Swiper$2, { className: "demo-swiper demo-swiper-cube", params: {
	      effect: 'flip',
	    } },
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-1.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-2.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-3.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-4.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-5.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-6.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-7.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-8.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-800x800-9.jpg)'} })
	    )
	  )
	); }

	function SwiperFade () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Fade Effect", backLink: "Back" }),
	    react.createElement( Swiper$2, { className: "demo-swiper demo-swiper-fade", pagination: true, params: {
	      effect: 'fade',
	    } },
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-1024x1024-1.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-1024x1024-2.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-1024x1024-3.jpg)'} }),
	      react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/people-1024x1024-4.jpg)'} })
	    )
	  )

	); }

	function SwiperScrollbar () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Scrollbar", backLink: "Back" }),
	    react.createElement( Swiper$2, { className: "demo-swiper", scrollbar: true },
	      react.createElement( SwiperSlide, null, "Slide 1" ),
	      react.createElement( SwiperSlide, null, "Slide 2" ),
	      react.createElement( SwiperSlide, null, "Slide 3" ),
	      react.createElement( SwiperSlide, null, "Slide 4" ),
	      react.createElement( SwiperSlide, null, "Slide 5" ),
	      react.createElement( SwiperSlide, null, "Slide 6" ),
	      react.createElement( SwiperSlide, null, "Slide 7" ),
	      react.createElement( SwiperSlide, null, "Slide 8" ),
	      react.createElement( SwiperSlide, null, "Slide 9" ),
	      react.createElement( SwiperSlide, null, "Slide 10" )
	    )
	  )

	); }

	var defaultExport$v = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, { style: {background: '#000'}, onPageInit: this.onPageInit.bind(this), onPageBeforeRemove: this.onPageBeforeRemove.bind(this) },
	        react.createElement( Navbar$2, { title: "Two Way Control Gallery", backLink: "Back" }),
	        react.createElement( Swiper$2, {
	          className: "demo-swiper-gallery-top", navigation: true, colorTheme: "white", init: false },
	          react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-1.jpg)'} }),
	          react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-2.jpg)'} }),
	          react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-3.jpg)'} }),
	          react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-4.jpg)'} }),
	          react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-5.jpg)'} }),
	          react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-6.jpg)'} })
	        ),
	        react.createElement( Swiper$2, {
	          className: "demo-swiper-gallery-thumbs", init: false },
	          react.createElement( SwiperSlide, null,
	            react.createElement( 'div', { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-1.jpg)'}, className: "swiper-slide-pic" })
	          ),
	          react.createElement( SwiperSlide, null,
	            react.createElement( 'div', { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-2.jpg)'}, className: "swiper-slide-pic" })
	          ),
	          react.createElement( SwiperSlide, null,
	            react.createElement( 'div', { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-3.jpg)'}, className: "swiper-slide-pic" })
	          ),
	          react.createElement( SwiperSlide, null,
	            react.createElement( 'div', { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-4.jpg)'}, className: "swiper-slide-pic" })
	          ),
	          react.createElement( SwiperSlide, null,
	            react.createElement( 'div', { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-5.jpg)'}, className: "swiper-slide-pic" })
	          ),
	          react.createElement( SwiperSlide, null,
	            react.createElement( 'div', { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nature-800x800-6.jpg)'}, className: "swiper-slide-pic" })
	          )
	        )
	      )
	    );
	  };
	  defaultExport.prototype.onPageBeforeRemove = function onPageBeforeRemove () {
	    var self = this;
	    self.swiperTop.destroy();
	    self.swiperThumbs.destroy();
	  };
	  defaultExport.prototype.onPageInit = function onPageInit () {
	    var self = this;

	    var swiperThumbs = self.$f7.swiper.create('.demo-swiper-gallery-thumbs', {
	      slidesPerView: 4,
	      spaceBetween: 10,
	      freeMode: true,
	      watchSlidesProgress: true,
	      watchSlidesVisibility: true,
	    });
	    var swiperTop = self.$f7.swiper.create('.demo-swiper-gallery-top', {
	      spaceBetween: 10,
	      navigation: {
	        nextEl: '.swiper-button-next',
	        prevEl: '.swiper-button-prev',
	      },
	      thumbs: {
	        swiper: swiperThumbs,
	      },
	    });

	    self.swiperTop = swiperTop;
	    self.swiperThumbs = swiperThumbs;
	  };

	  return defaultExport;
	}(react.Component));

	function SwiperCustomControls () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Custom Controls", backLink: "Back" }),
	    react.createElement( 'div', { className: "demo-swiper-custom" },
	      react.createElement( Swiper$2, {
	        pagination: true, navigation: true, params: {
	          pagination: {
	            clickable: true,
	          }
	        } },
	        react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nightlife-1024x1024-1.jpg)'} }),
	        react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nightlife-1024x1024-2.jpg)'} }),
	        react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nightlife-1024x1024-3.jpg)'} }),
	        react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nightlife-1024x1024-4.jpg)'} }),
	        react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nightlife-1024x1024-5.jpg)'} }),
	        react.createElement( SwiperSlide, { style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nightlife-1024x1024-6.jpg)'} })
	      )
	    )
	  )

	); }

	function SwiperParallax () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Parallax", backLink: "Back" }),
	    react.createElement( Swiper$2, {
	      className: "demo-swiper-parallax", pagination: true, navigation: true, colorTheme: "white", params: {
	        parallax: true,
	        speed: 600,
	      } },
	      react.createElement( 'div', {
	        slot: "before-wrapper", 'data-swiper-parallax': "-23%", style: {backgroundImage: 'url(https://cdn.framework7.io/placeholder/nightlife-1024x1024-2.jpg)'}, className: "swiper-parallax-bg" }),
	      react.createElement( SwiperSlide, null,
	        react.createElement( 'div', { 'data-swiper-parallax': "-300", className: "swiper-slide-title" }, "Slide 1"),
	        react.createElement( 'div', { 'data-swiper-parallax': "-200", className: "swiper-slide-subtitle" }, "Subtitle"),
	        react.createElement( 'div', { 'data-swiper-parallax': "-100", className: "swiper-slide-text" },
	          react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam dictum mattis velit, sit amet faucibus felis iaculis nec. Nulla laoreet justo vitae porttitor porttitor. Suspendisse in sem justo. Integer laoreet magna nec elit suscipit, ac laoreet nibh euismod. Aliquam hendrerit lorem at elit facilisis rutrum. Ut at ullamcorper velit. Nulla ligula nisi, imperdiet ut lacinia nec, tincidunt ut libero. Aenean feugiat non eros quis feugiat." )
	        )
	      ),
	      react.createElement( SwiperSlide, null,
	        react.createElement( 'div', { 'data-swiper-parallax': "-300", className: "swiper-slide-title" }, "Slide 2"),
	        react.createElement( 'div', { 'data-swiper-parallax': "-200", className: "swiper-slide-subtitle" }, "Subtitle"),
	        react.createElement( 'div', { 'data-swiper-parallax': "-100", className: "swiper-slide-text" },
	          react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam dictum mattis velit, sit amet faucibus felis iaculis nec. Nulla laoreet justo vitae porttitor porttitor. Suspendisse in sem justo. Integer laoreet magna nec elit suscipit, ac laoreet nibh euismod. Aliquam hendrerit lorem at elit facilisis rutrum. Ut at ullamcorper velit. Nulla ligula nisi, imperdiet ut lacinia nec, tincidunt ut libero. Aenean feugiat non eros quis feugiat." )
	        )
	      ),
	      react.createElement( SwiperSlide, null,
	        react.createElement( 'div', { 'data-swiper-parallax': "-300", className: "swiper-slide-title" }, "Slide 3"),
	        react.createElement( 'div', { 'data-swiper-parallax': "-200", className: "swiper-slide-subtitle" }, "Subtitle"),
	        react.createElement( 'div', { 'data-swiper-parallax': "-100", className: "swiper-slide-text" },
	          react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam dictum mattis velit, sit amet faucibus felis iaculis nec. Nulla laoreet justo vitae porttitor porttitor. Suspendisse in sem justo. Integer laoreet magna nec elit suscipit, ac laoreet nibh euismod. Aliquam hendrerit lorem at elit facilisis rutrum. Ut at ullamcorper velit. Nulla ligula nisi, imperdiet ut lacinia nec, tincidunt ut libero. Aenean feugiat non eros quis feugiat." )
	        )
	      )
	    )
	  )

	); }

	function SwiperLazy () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Slider Lazy Loading", backLink: "Back" }),
	    react.createElement( Swiper$2, {
	      className: "demo-swiper-lazy", pagination: true, navigation: true, params: {
	        lazy: true,
	      } },
	      react.createElement( SwiperSlide, null,
	        react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-1024x1024-1.jpg", className: "swiper-lazy" }),
	        react.createElement( 'div', { className: "preloader swiper-lazy-preloader" })
	      ),
	      react.createElement( SwiperSlide, null,
	        react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-1024x1024-2.jpg", className: "swiper-lazy" }),
	        react.createElement( 'div', { className: "preloader swiper-lazy-preloader" })
	      ),
	      react.createElement( SwiperSlide, null,
	        react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-1024x1024-3.jpg", className: "swiper-lazy" }),
	        react.createElement( 'div', { className: "preloader swiper-lazy-preloader" })
	      ),
	      react.createElement( SwiperSlide, null,
	        react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-1024x1024-4.jpg", className: "swiper-lazy" }),
	        react.createElement( 'div', { className: "preloader swiper-lazy-preloader" })
	      ),
	      react.createElement( SwiperSlide, null,
	        react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-1024x1024-5.jpg", className: "swiper-lazy" }),
	        react.createElement( 'div', { className: "preloader swiper-lazy-preloader" })
	      ),
	      react.createElement( SwiperSlide, null,
	        react.createElement( 'img', { 'data-src': "https://cdn.framework7.io/placeholder/nature-1024x1024-6.jpg", className: "swiper-lazy" }),
	        react.createElement( 'div', { className: "preloader swiper-lazy-preloader" })
	      )
	    )
	  )

	); }

	function SwiperPaginationProgress () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Progress Pagination", backLink: "Back" }),
	    react.createElement( Swiper$2, {
	      className: "demo-swiper", pagination: true, params: {
	        pagination: {
	          type: 'progressbar',
	        }
	      } },
	      react.createElement( SwiperSlide, null, "Slide 1" ),
	      react.createElement( SwiperSlide, null, "Slide 2" ),
	      react.createElement( SwiperSlide, null, "Slide 3" ),
	      react.createElement( SwiperSlide, null, "Slide 4" ),
	      react.createElement( SwiperSlide, null, "Slide 5" ),
	      react.createElement( SwiperSlide, null, "Slide 6" ),
	      react.createElement( SwiperSlide, null, "Slide 7" ),
	      react.createElement( SwiperSlide, null, "Slide 8" ),
	      react.createElement( SwiperSlide, null, "Slide 9" ),
	      react.createElement( SwiperSlide, null, "Slide 10" )
	    )
	  )

	); }

	function SwiperPaginationFraction () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Pagination Fraction", backLink: "Back" }),
	    react.createElement( Swiper$2, {
	      className: "demo-swiper", pagination: true, params: {
	        pagination: {
	          type: 'fraction',
	        }
	      } },
	      react.createElement( SwiperSlide, null, "Slide 1" ),
	      react.createElement( SwiperSlide, null, "Slide 2" ),
	      react.createElement( SwiperSlide, null, "Slide 3" ),
	      react.createElement( SwiperSlide, null, "Slide 4" ),
	      react.createElement( SwiperSlide, null, "Slide 5" ),
	      react.createElement( SwiperSlide, null, "Slide 6" ),
	      react.createElement( SwiperSlide, null, "Slide 7" ),
	      react.createElement( SwiperSlide, null, "Slide 8" ),
	      react.createElement( SwiperSlide, null, "Slide 9" ),
	      react.createElement( SwiperSlide, null, "Slide 10" )
	    )
	  )

	); }

	function SwiperZoom () { return (

	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Zoom", backLink: "Back" }),
	    react.createElement( Swiper$2, {
	      className: "demo-swiper", pagination: true, navigation: true, params: {
	        zoom: {
	          enabled: true,
	        }
	      } },
	      react.createElement( SwiperSlide, { zoom: true },
	        react.createElement( 'img', { src: "https://cdn.framework7.io/placeholder/nature-800x800-1.jpg" })
	      ),
	      react.createElement( SwiperSlide, { zoom: true },
	        react.createElement( 'img', { src: "https://cdn.framework7.io/placeholder/nature-800x800-2.jpg" })
	      ),
	      react.createElement( SwiperSlide, { zoom: true },
	        react.createElement( 'img', { src: "https://cdn.framework7.io/placeholder/nature-800x800-3.jpg" })
	      ),
	      react.createElement( SwiperSlide, { zoom: true },
	        react.createElement( 'img', { src: "https://cdn.framework7.io/placeholder/nature-800x800-4.jpg" })
	      ),
	      react.createElement( SwiperSlide, { zoom: true },
	        react.createElement( 'img', { src: "https://cdn.framework7.io/placeholder/nature-800x800-5.jpg" })
	      ),
	      react.createElement( SwiperSlide, { zoom: true },
	        react.createElement( 'img', { src: "https://cdn.framework7.io/placeholder/nature-800x800-6.jpg" })
	      )
	    )
	  )

	); }

	var defaultExport$w = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, { onPageBeforeRemove: this.onPageBeforeRemove.bind(this), onPageInit: this.onPageInit.bind(this) },
	        react.createElement( Navbar$2, { title: "Swipeout", backLink: "Back" }),

	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Swipe out actions on list elements is one of the most awesome F7 features. It allows you to call hidden menu for each list element where you can put default ready-to use delete button or any other buttons for some required actions." )
	        ),

	        react.createElement( BlockTitle, null, "Swipe to delete with confirm modal" ),
	        react.createElement( List, null,
	          react.createElement( ListItem, {
	            swipeout: true, title: "Swipe left on me please" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	            react.createElement( SwipeoutActions, { right: true },
	              react.createElement( SwipeoutButton, { delete: true, confirmText: "Are you sure you want to delete this item?" }, "Delete")
	            )
	          ),
	          react.createElement( ListItem, {
	            swipeout: true, title: "Swipe left on me too" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	            react.createElement( SwipeoutActions, { right: true },
	              react.createElement( SwipeoutButton, { delete: true, confirmText: "Are you sure you want to delete this item?" }, "Delete")
	            )
	          ),
	          react.createElement( ListItem, {
	            title: "I am not removable" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Swipe to delete without confirm" ),
	        react.createElement( List, null,
	          react.createElement( ListItem, {
	            swipeout: true, title: "Swipe left on me please" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	            react.createElement( SwipeoutActions, { right: true },
	              react.createElement( SwipeoutButton, { delete: true }, "Delete")
	            )
	          ),
	          react.createElement( ListItem, {
	            swipeout: true, title: "Swipe left on me too" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	            react.createElement( SwipeoutActions, { right: true },
	              react.createElement( SwipeoutButton, { delete: true }, "Delete")
	            )
	          ),
	          react.createElement( ListItem, {
	            title: "I am not removable" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Swipe for actions" ),
	        react.createElement( List, null,
	          react.createElement( ListItem, {
	            swipeout: true, title: "Swipe left on me please" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	            react.createElement( SwipeoutActions, { right: true },
	              react.createElement( SwipeoutButton, { onClick: this.more.bind(this) }, "More"),
	              react.createElement( SwipeoutButton, { delete: true }, "Delete")
	            )
	          ),
	          react.createElement( ListItem, {
	            swipeout: true, title: "Swipe left on me too" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	            react.createElement( SwipeoutActions, { right: true },
	              react.createElement( SwipeoutButton, { onClick: this.more.bind(this) }, "More"),
	              react.createElement( SwipeoutButton, { delete: true }, "Delete")
	            )
	          ),
	          react.createElement( ListItem, {
	            swipeout: true, title: "You can't delete me" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	            react.createElement( SwipeoutActions, { right: true },
	              react.createElement( SwipeoutButton, { onClick: this.more.bind(this) }, "More")
	            )
	          )
	        ),

	        react.createElement( BlockTitle, null, "With callback on remove" ),
	        react.createElement( List, null,
	          react.createElement( ListItem, {
	            swipeout: true, onSwipeoutDeleted: this.onDeleted.bind(this), title: "Swipe left on me please" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	            react.createElement( SwipeoutActions, { right: true },
	              react.createElement( SwipeoutButton, { delete: true }, "Delete")
	            )
	          ),
	          react.createElement( ListItem, {
	            swipeout: true, onSwipeoutDeleted: this.onDeleted.bind(this), title: "Swipe left on me too" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	            react.createElement( SwipeoutActions, { right: true },
	              react.createElement( SwipeoutButton, { delete: true }, "Delete")
	            )
	          ),
	          react.createElement( ListItem, {
	            title: "I am not removable" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "With actions on left side (swipe to right)" ),
	        react.createElement( List, null,
	          react.createElement( ListItem, {
	            swipeout: true, title: "Swipe right on me please" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	            react.createElement( SwipeoutActions, { left: true },
	              react.createElement( SwipeoutButton, { color: "green", onClick: this.reply.bind(this) }, "Reply"),
	              react.createElement( SwipeoutButton, { color: "blue", onClick: this.forward.bind(this) }, "Forward")
	            )
	          ),
	          react.createElement( ListItem, {
	            swipeout: true, title: "Swipe right on me too" },
	            react.createElement( Icon, { slot: "media", icon: "icon-f7" }),
	            react.createElement( SwipeoutActions, { left: true },
	              react.createElement( SwipeoutButton, { color: "green", onClick: this.reply.bind(this) }, "Reply"),
	              react.createElement( SwipeoutButton, { color: "blue", onClick: this.forward.bind(this) }, "Forward")
	            )
	          )
	        ),

	        react.createElement( BlockTitle, null, "On both sides with overswipes" ),
	        react.createElement( List, { mediaList: true },
	          react.createElement( ListItem, {
	            swipeout: true, title: "Facebook", after: "17:14", subtitle: "New messages from John Doe", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." },
	            react.createElement( SwipeoutActions, { left: true },
	              react.createElement( SwipeoutButton, { overswipe: true, color: "green", onClick: this.reply.bind(this) }, "Reply"),
	              react.createElement( SwipeoutButton, { color: "blue", onClick: this.forward.bind(this) }, "Forward")
	            ),
	            react.createElement( SwipeoutActions, { right: true },
	              react.createElement( SwipeoutButton, { onClick: this.more.bind(this) }, "More"),
	              react.createElement( SwipeoutButton, { color: "orange", onClick: this.mark.bind(this) }, "Mark"),
	              react.createElement( SwipeoutButton, { delete: true, overswipe: true, confirmText: "Are you sure you want to delete this item?" }, "Delete")
	            )
	          ),
	          react.createElement( ListItem, {
	            swipeout: true, title: "John Doe (via Twitter)", after: "17:11", subtitle: "John Doe (@_johndoe) mentioned you on Twitter!", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." },
	            react.createElement( SwipeoutActions, { left: true },
	              react.createElement( SwipeoutButton, { overswipe: true, color: "green", onClick: this.reply.bind(this) }, "Reply"),
	              react.createElement( SwipeoutButton, { color: "blue", onClick: this.forward.bind(this) }, "Forward")
	            ),
	            react.createElement( SwipeoutActions, { right: true },
	              react.createElement( SwipeoutButton, { onClick: this.more.bind(this) }, "More"),
	              react.createElement( SwipeoutButton, { color: "orange", onClick: this.mark.bind(this) }, "Mark"),
	              react.createElement( SwipeoutButton, { delete: true, overswipe: true, confirmText: "Are you sure you want to delete this item?" }, "Delete")
	            )
	          ),
	          react.createElement( ListItem, {
	            swipeout: true, title: "Facebook", after: "16:48", subtitle: "New messages from John Doe", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." },
	            react.createElement( SwipeoutActions, { left: true },
	              react.createElement( SwipeoutButton, { overswipe: true, color: "green", onClick: this.reply.bind(this) }, "Reply"),
	              react.createElement( SwipeoutButton, { color: "blue", onClick: this.forward.bind(this) }, "Forward")
	            ),
	            react.createElement( SwipeoutActions, { right: true },
	              react.createElement( SwipeoutButton, { onClick: this.more.bind(this) }, "More"),
	              react.createElement( SwipeoutButton, { color: "orange", onClick: this.mark.bind(this) }, "Mark"),
	              react.createElement( SwipeoutButton, { delete: true, overswipe: true, confirmText: "Are you sure you want to delete this item?" }, "Delete")
	            )
	          ),
	          react.createElement( ListItem, {
	            swipeout: true, title: "John Doe (via Twitter)", after: "15:32", subtitle: "John Doe (@_johndoe) mentioned you on Twitter!", text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla sagittis tellus ut turpis condimentum, ut dignissim lacus tincidunt. Cras dolor metus, ultrices condimentum sodales sit amet, pharetra sodales eros. Phasellus vel felis tellus. Mauris rutrum ligula nec dapibus feugiat. In vel dui laoreet, commodo augue id, pulvinar lacus." },
	            react.createElement( SwipeoutActions, { left: true },
	              react.createElement( SwipeoutButton, { overswipe: true, color: "green", onClick: this.reply.bind(this) }, "Reply"),
	              react.createElement( SwipeoutButton, { color: "blue", onClick: this.forward.bind(this) }, "Forward")
	            ),
	            react.createElement( SwipeoutActions, { right: true },
	              react.createElement( SwipeoutButton, { onClick: this.more.bind(this) }, "More"),
	              react.createElement( SwipeoutButton, { color: "orange", onClick: this.mark.bind(this) }, "Mark"),
	              react.createElement( SwipeoutButton, { delete: true, overswipe: true, confirmText: "Are you sure you want to delete this item?" }, "Delete")
	            )
	          )
	        )
	      )
	    );
	  };
	  defaultExport.prototype.more = function more () {
	    var self = this;
	    self.actions.open();
	  };
	  defaultExport.prototype.mark = function mark () {
	    var app = this.$f7;
	    app.dialog.alert('Mark');
	  };
	  defaultExport.prototype.reply = function reply () {
	    var app = this.$f7;
	    app.dialog.alert('Reply');
	  };
	  defaultExport.prototype.forward = function forward () {
	    var app = this.$f7;
	    app.dialog.alert('Forward');
	  };
	  defaultExport.prototype.onDeleted = function onDeleted () {
	    var app = this.$f7;
	    app.dialog.alert('Thanks, item removed!');
	  };
	  defaultExport.prototype.onPageBeforeRemove = function onPageBeforeRemove () {
	    var self = this;
	    self.actions.destroy();
	  };
	  defaultExport.prototype.onPageInit = function onPageInit () {
	    var self = this;
	    var app = self.$f7;
	    self.actions = app.actions.create({
	      buttons: [
	        [
	          {
	            text: 'Here comes some optional description or warning for actions below',
	            label: true,
	          },
	          {
	            text: 'Action 1',
	          },
	          {
	            text: 'Action 2',
	          } ],
	        [
	          {
	            text: 'Cancel',
	            bold: true,
	          } ] ],
	    });
	  };

	  return defaultExport;
	}(react.Component));

	function Tabs$2 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Tabs", backLink: "Back" }),
	    react.createElement( List, null,
	      react.createElement( ListItem, { link: "/tabs-static/", title: "Static Tabs" }),
	      react.createElement( ListItem, { link: "/tabs-animated/", title: "Animated Tabs" }),
	      react.createElement( ListItem, { link: "/tabs-swipeable/", title: "Swipeable Tabs" }),
	      react.createElement( ListItem, { link: "/tabs-routable/", title: "Routable Tabs" })
	    )
	  )
	); }

	function TabsStatic () { return (
	  react.createElement( Page, { pageContent: false },
	    react.createElement( Navbar$2, { title: "Static Tabs", backLink: "Back" }),
	    react.createElement( Toolbar$2, { bottom: true, tabbar: true },
	      react.createElement( Link, { tabLink: "#tab-1", tabLinkActive: true }, "Tab 1"),
	      react.createElement( Link, { tabLink: "#tab-2" }, "Tab 2"),
	      react.createElement( Link, { tabLink: "#tab-3" }, "Tab 3")
	    ),
	    react.createElement( Tabs$1, null,
	      react.createElement( Tab$1, { id: "tab-1", className: "page-content", tabActive: true },
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Tab 1 content" ),
	          react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	          react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	          react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	          react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	          react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	          react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	          react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	        )
	      ),
	      react.createElement( Tab$1, { id: "tab-2", className: "page-content" },
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Tab 2 content" ),
	          react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	          react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	          react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	          react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	          react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	          react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	          react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	        )
	      ),
	      react.createElement( Tab$1, { id: "tab-3", className: "page-content" },
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Tab 3 content" ),
	          react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	          react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	          react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	          react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	          react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	          react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	          react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	        )
	      )
	    )
	  )
	); }

	function TabsAnimated () { return (
	  react.createElement( Page, { pageContent: false },
	    react.createElement( Navbar$2, { title: "Animated Tabs", backLink: "Back" }),
	    react.createElement( Toolbar$2, { bottom: true, tabbar: true },
	      react.createElement( Link, { tabLink: "#tab-1", tabLinkActive: true }, "Tab 1"),
	      react.createElement( Link, { tabLink: "#tab-2" }, "Tab 2"),
	      react.createElement( Link, { tabLink: "#tab-3" }, "Tab 3")
	    ),
	    react.createElement( Tabs$1, { animated: true },
	      react.createElement( Tab$1, { id: "tab-1", className: "page-content", tabActive: true },
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Tab 1 content" ),
	          react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	          react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	          react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	          react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	          react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	          react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	          react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	        )
	      ),
	      react.createElement( Tab$1, { id: "tab-2", className: "page-content" },
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Tab 2 content" ),
	          react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	          react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	          react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	          react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	          react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	          react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	          react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	        )
	      ),
	      react.createElement( Tab$1, { id: "tab-3", className: "page-content" },
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Tab 3 content" ),
	          react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	          react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	          react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	          react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	          react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	          react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	          react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	        )
	      )
	    )
	  )
	); }

	function TabsSwipeable () { return (
	  react.createElement( Page, { pageContent: false },
	    react.createElement( Navbar$2, { title: "Swipeable Tabs", backLink: "Back" }),
	    react.createElement( Toolbar$2, { bottom: true, tabbar: true },
	      react.createElement( Link, { tabLink: "#tab-1", tabLinkActive: true }, "Tab 1"),
	      react.createElement( Link, { tabLink: "#tab-2" }, "Tab 2"),
	      react.createElement( Link, { tabLink: "#tab-3" }, "Tab 3")
	    ),
	    react.createElement( Tabs$1, { swipeable: true },
	      react.createElement( Tab$1, { id: "tab-1", className: "page-content", tabActive: true },
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Tab 1 content" ),
	          react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	          react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	          react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	          react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	          react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	          react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	          react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	        )
	      ),
	      react.createElement( Tab$1, { id: "tab-2", className: "page-content" },
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Tab 2 content" ),
	          react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	          react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	          react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	          react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	          react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	          react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	          react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	        )
	      ),
	      react.createElement( Tab$1, { id: "tab-3", className: "page-content" },
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Tab 3 content" ),
	          react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	          react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	          react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	          react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	          react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	          react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	          react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	        )
	      )
	    )
	  )
	); }

	function TabsRoutable () { return (
	  react.createElement( Page, { pageContent: false },
	    react.createElement( Navbar$2, { title: "Tabs Routable", backLink: "Back" }),
	    react.createElement( Toolbar$2, { bottom: true, tabbar: true },
	      react.createElement( Link, { tabLink: true, href: "./", routeTabId: "tab1" }, "Tab 1"),
	      react.createElement( Link, { tabLink: true, href: "tab2/", routeTabId: "tab2" }, "Tab 2"),
	      react.createElement( Link, { tabLink: true, href: "tab3/", routeTabId: "tab3" }, "Tab 3")
	    ),
	    react.createElement( Tabs$1, { routable: true },
	      react.createElement( Tab$1, { className: "page-content", id: "tab1" }),
	      react.createElement( Tab$1, { className: "page-content", id: "tab2" }),
	      react.createElement( Tab$1, { className: "page-content", id: "tab3" })
	    )
	  )
	); }

	var defaultExport$x = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, { onPageBeforeRemove: this.onPageBeforeRemove.bind(this), onPageBeforeOut: this.onPageBeforeOut.bind(this) },
	        react.createElement( Navbar$2, { title: "Toast", backLink: "Back" }),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Toasts provide brief feedback about an operation through a message on the screen." ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, onClick: this.showToastBottom.bind(this) }, "Toast on Bottom")
	          ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, onClick: this.showToastTop.bind(this) }, "Toast on Top")
	          ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, onClick: this.showToastCenter.bind(this) }, "Toast on Center")
	          ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, onClick: this.showToastIcon.bind(this) }, "Toast with icon")
	          ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, onClick: this.showToastLargeMessage.bind(this) }, "Toast with large message")
	          ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, onClick: this.showToastWithButton.bind(this) }, "Toast with close button")
	          ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, onClick: this.showToastWithCustomButton.bind(this) }, "Toast with custom button")
	          ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, onClick: this.showToastWithCallback.bind(this) }, "Toast with callback on close")
	          )
	        )
	      )
	    );
	  };
	  defaultExport.prototype.showToastBottom = function showToastBottom () {
	    var self = this;
	    // Create toast
	    if (!self.toastBottom) {
	      self.toastBottom = self.$f7.toast.create({
	        text: 'This is default bottom positioned toast',
	        closeTimeout: 2000,
	      });
	    }
	    // Open it
	    self.toastBottom.open();
	  };
	  defaultExport.prototype.showToastTop = function showToastTop () {
	    var self = this;
	    // Create toast
	    if (!self.toastTop) {
	      self.toastTop = self.$f7.toast.create({
	        text: 'Top positioned toast',
	        position: 'top',
	        closeTimeout: 2000,
	      });
	    }
	    // Open it
	    self.toastTop.open();
	  };
	  defaultExport.prototype.showToastCenter = function showToastCenter () {
	    var self = this;
	    // Create toast
	    if (!self.toastCenter) {
	      self.toastCenter = self.$f7.toast.create({
	        text: 'I\'m on center',
	        position: 'center',
	        closeTimeout: 2000,
	      });
	    }
	    // Open it
	    self.toastCenter.open();
	  };
	  defaultExport.prototype.showToastIcon = function showToastIcon () {
	    var self = this;
	    // Create toast
	    if (!self.toastIcon) {
	      self.toastIcon = self.$f7.toast.create({
	        icon: self.$theme.ios || self.$theme.aurora ? '<i class="f7-icons">star_fill</i>' : '<i class="material-icons">star</i>',
	        text: 'I\'m on center',
	        position: 'center',
	        closeTimeout: 2000,
	      });
	    }
	    // Open it
	    self.toastIcon.open();
	  };
	  defaultExport.prototype.showToastLargeMessage = function showToastLargeMessage () {
	    var self = this;
	    // Create toast
	    if (!self.toastLargeMessage) {
	      self.toastLargeMessage = self.$f7.toast.create({
	        text: 'This toast contains a lot of text. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nihil, quae, ab. Delectus amet optio facere autem sapiente quisquam beatae culpa dolore.',
	        closeTimeout: 2000,
	      });
	    }
	    // Open it
	    self.toastLargeMessage.open();
	  };
	  defaultExport.prototype.showToastWithButton = function showToastWithButton () {
	    var self = this;
	    // Create toast
	    if (!self.toastWithButton) {
	      self.toastWithButton = self.$f7.toast.create({
	        text: 'Toast with additional close button',
	        closeButton: true,
	      });
	    }
	    // Open it
	    self.toastWithButton.open();
	  };
	  defaultExport.prototype.showToastWithCustomButton = function showToastWithCustomButton () {
	    var self = this;
	    // Create toast
	    if (!self.toastWithCustomButton) {
	      self.toastWithCustomButton = self.$f7.toast.create({
	        text: 'Custom close button',
	        closeButton: true,
	        closeButtonText: 'Close Me',
	        closeButtonColor: 'red',
	      });
	    }
	    // Open it
	    self.toastWithCustomButton.open();
	  };
	  defaultExport.prototype.showToastWithCallback = function showToastWithCallback () {
	    var self = this;
	    // Create toast
	    if (!self.toastWithCallback) {
	      self.toastWithCallback = self.$f7.toast.create({
	        text: 'Callback on close',
	        closeButton: true,
	        on: {
	          close: function close() {
	            self.$f7.dialog.alert('Toast closed');
	          },
	        },
	      });
	    }
	    // Open it
	    self.toastWithCallback.open();
	  };
	  defaultExport.prototype.onPageBeforeOut = function onPageBeforeOut () {
	    var self = this;
	    self.$f7.toast.close();
	  };
	  defaultExport.prototype.onPageBeforeRemove = function onPageBeforeRemove () {
	    var self = this;
	    // Destroy toasts when page removed
	    if (self.toastBottom) { self.toastBottom.destroy(); }
	    if (self.toastTop) { self.toastTop.destroy(); }
	    if (self.toastCenter) { self.toastCenter.destroy(); }
	    if (self.toastIcon) { self.toastIcon.destroy(); }
	    if (self.toastLargeMessage) { self.toastLargeMessage.destroy(); }
	    if (self.toastWithButton) { self.toastWithButton.destroy(); }
	    if (self.toastWithCustomButton) { self.toastWithCustomButton.destroy(); }
	    if (self.toastWithCallback) { self.toastWithCallback.destroy(); }
	  };

	  return defaultExport;
	}(react.Component));

	function Toggle$3 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Toggle", backLink: "Back" }),
	    react.createElement( BlockTitle, null, "Super Heroes" ),
	    react.createElement( List, { simpleList: true },
	      react.createElement( ListItem, null,
	        react.createElement( 'span', null, "Batman" ),
	        react.createElement( Toggle$2, { defaultChecked: true })
	      ),
	      react.createElement( ListItem, null,
	        react.createElement( 'span', null, "Aquaman" ),
	        react.createElement( Toggle$2, { defaultChecked: true, color: "blue" })
	      ),
	      react.createElement( ListItem, null,
	        react.createElement( 'span', null, "Superman" ),
	        react.createElement( Toggle$2, { defaultChecked: true, color: "red" })
	      ),
	      react.createElement( ListItem, null,
	        react.createElement( 'span', null, "Hulk" ),
	        react.createElement( Toggle$2, { color: "green" })
	      ),
	      react.createElement( ListItem, null,
	        react.createElement( 'span', null, "Spiderman (Disabled)" ),
	        react.createElement( Toggle$2, { disabled: true })
	      ),
	      react.createElement( ListItem, null,
	        react.createElement( 'span', null, "Ironman (Disabled)" ),
	        react.createElement( Toggle$2, { defaultChecked: true, disabled: true })
	      ),
	      react.createElement( ListItem, null,
	        react.createElement( 'span', null, "Thor" ),
	        react.createElement( Toggle$2, { defaultChecked: true, color: "orange" })
	      ),
	      react.createElement( ListItem, null,
	        react.createElement( 'span', null, "Wonder Woman" ),
	        react.createElement( Toggle$2, { color: "pink" })
	      )
	    )
	  )
	); }

	var defaultExport$y = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	    this.state = {
	      toolbarPosition: 'bottom',
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.toggleToolbarPosition = function toggleToolbarPosition () {
	    this.setState({
	      toolbarPosition: this.state.toolbarPosition === 'top' ? 'bottom' : 'top',
	    });
	  };
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, { ref: "el" },
	        react.createElement( Navbar$2, { title: "Toolbar & Tabbar", backLink: "Back" }),
	        react.createElement( Toolbar$2, { position: this.state.toolbarPosition },
	          react.createElement( Link, null, "Left Link" ),
	          react.createElement( Link, null, "Right Link" )
	        ),
	        react.createElement( List, null,
	          react.createElement( ListItem, { link: "./tabbar/", title: "Tabbar" }),
	          react.createElement( ListItem, { link: "./tabbar-labels/", title: "Tabbar With Labels" }),
	          react.createElement( ListItem, { link: "./tabbar-scrollable/", title: "Tabbar Scrollable" }),
	          react.createElement( ListItem, { link: "./toolbar-hide-scroll/", title: "Hide Toolbar On Scroll" })
	        ),
	        react.createElement( BlockTitle, null, "Toolbar Position" ),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Toolbar supports both top and bottom positions. Click the following button to change its position." ),
	          react.createElement( 'p', null,
	            react.createElement( Button, { fill: true, onClick: function () {this$1.toggleToolbarPosition();} }, "Toggle Toolbar Position")
	          )
	        )
	      )
	    )
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$z = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	    this.state = {
	      toolbarPosition: 'bottom',
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.toggleToolbarPosition = function toggleToolbarPosition () {
	    this.setState({
	      toolbarPosition: this.state.toolbarPosition === 'top' ? 'bottom' : 'top',
	    });
	  };
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, { pageContent: false, ref: "el" },
	        react.createElement( Navbar$2, { title: "Tabbar", backLink: "Back" },
	          react.createElement( NavRight, null,
	            react.createElement( Link, { iconMd: "material:compare_arrows", iconIos: "f7:reload", iconAurora: "f7:reload", onClick: function () {this$1.toggleToolbarPosition();} })
	          )
	        ),
	        react.createElement( Toolbar$2, { tabbar: true, position: this.state.toolbarPosition },
	          react.createElement( Link, { tabLink: "#tab-1", tabLinkActive: true }, "Tab 1"),
	          react.createElement( Link, { tabLink: "#tab-2" }, "Tab 2"),
	          react.createElement( Link, { tabLink: "#tab-3" }, "Tab 3")
	        ),

	        react.createElement( Tabs$1, null,
	          react.createElement( Tab$1, { id: "tab-1", className: "page-content", tabActive: true },
	            react.createElement( Block, null,
	              react.createElement( 'p', null, "Tab 1 content" ),
	              react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	              react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	              react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	              react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	              react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	              react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	              react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	            )
	          ),
	          react.createElement( Tab$1, { id: "tab-2", className: "page-content" },
	            react.createElement( Block, null,
	              react.createElement( 'p', null, "Tab 2 content" ),
	              react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	              react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	              react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	              react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	              react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	              react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	              react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	            )
	          ),
	          react.createElement( Tab$1, { id: "tab-3", className: "page-content" },
	            react.createElement( Block, null,
	              react.createElement( 'p', null, "Tab 3 content" ),
	              react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	              react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	              react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	              react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	              react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	              react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	              react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	            )
	          )
	        )
	      )
	    );
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$A = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	    this.state = {
	      toolbarPosition: 'bottom',
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.toggleToolbarPosition = function toggleToolbarPosition () {
	    this.setState({
	      toolbarPosition: this.state.toolbarPosition === 'top' ? 'bottom' : 'top',
	    });
	  };
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, { pageContent: false },
	        react.createElement( Navbar$2, { title: "Tabbar Labels", backLink: "Back" },
	          react.createElement( NavRight, null,
	            react.createElement( Link, { iconMd: "material:compare_arrows", iconIos: "f7:reload", iconAurora: "f7:reload", onClick: function () {this$1.toggleToolbarPosition();} })
	          )
	        ),
	        react.createElement( Toolbar$2, { tabbar: true, labels: true, position: this.state.toolbarPosition },
	          react.createElement( Link, { tabLink: "#tab-1", tabLinkActive: true, text: "Tab 1", iconIos: "f7:email_fill", iconAurora: "f7:email_fill", iconMd: "material:email" }),
	          react.createElement( Link, { tabLink: "#tab-2", text: "Tab 2", iconIos: "f7:calendar_fill", iconAurora: "f7:calendar_fill", iconMd: "material:today" }),
	          react.createElement( Link, { tabLink: "#tab-3", text: "Tab 3", iconIos: "f7:cloud_upload_fill", iconAurora: "f7:cloud_upload_fill", iconMd: "material:file_upload" })
	        ),

	        react.createElement( Tabs$1, null,
	          react.createElement( Tab$1, { id: "tab-1", className: "page-content", tabActive: true },
	            react.createElement( Block, null,
	              react.createElement( 'p', null, "Tab 1 content" ),
	              react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	              react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	              react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	              react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	              react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	              react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	              react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	            )
	          ),
	          react.createElement( Tab$1, { id: "tab-2", className: "page-content" },
	            react.createElement( Block, null,
	              react.createElement( 'p', null, "Tab 2 content" ),
	              react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	              react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	              react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	              react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	              react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	              react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	              react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	            )
	          ),
	          react.createElement( Tab$1, { id: "tab-3", className: "page-content" },
	            react.createElement( Block, null,
	              react.createElement( 'p', null, "Tab 3 content" ),
	              react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?" ),
	              react.createElement( 'p', null, "Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti." ),
	              react.createElement( 'p', null, "Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis." ),
	              react.createElement( 'p', null, "Atque quis totam repellendus omnis alias magnam corrupti, possimus aspernatur perspiciatis quae provident consequatur minima doloremque blanditiis nihil maxime ducimus earum autem. Magni animi blanditiis similique iusto, repellat sed quisquam!" ),
	              react.createElement( 'p', null, "Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!" ),
	              react.createElement( 'p', null, "Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit." ),
	              react.createElement( 'p', null, "Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere." )
	            )
	          )
	        )
	      )
	    );
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$B = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	    this.state = {
	      toolbarPosition: 'bottom',
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.toggleToolbarPosition = function toggleToolbarPosition () {
	    this.setState({
	      toolbarPosition: this.state.toolbarPosition === 'top' ? 'bottom' : 'top',
	    });
	  };
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    var tabs = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
	    return (
	      react.createElement( Page, { pageContent: false },
	        react.createElement( Navbar$2, { title: "Tabbar Scrollable", backLink: "Back" },
	          react.createElement( NavRight, null,
	            react.createElement( Link, { iconMd: "material:compare_arrows", iconIos: "f7:reload", iconAurora: "f7:reload", onClick: function () {this$1.toggleToolbarPosition();} })
	          )
	        ),
	        react.createElement( Toolbar$2, { tabbar: true, scrollable: true, position: this.state.toolbarPosition },
	          tabs.map(function (tab, index) { return (
	            react.createElement( Link, {
	              key: tab, tabLink: ("#tab-" + tab), tabLinkActive: index === 0 }, "Tab ", tab)
	          ); })
	        ),
	        react.createElement( Tabs$1, null,
	          tabs.map(function (tab, index) { return (
	            react.createElement( Tab$1, {
	              key: tab, id: ("tab-" + tab), className: "page-content", tabActive: index === 0 },
	              react.createElement( Block, null,
	                react.createElement( 'p', null, react.createElement( 'b', null, "Tab ", tab, " content" ) ),
	                react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Itaque corrupti, quos asperiores unde aspernatur illum odio, eveniet. Fugiat magnam perspiciatis ex dignissimos, rerum modi ea nesciunt praesentium iusto optio rem?" ),
	                react.createElement( 'p', null, "Illo debitis et recusandae, ipsum nisi nostrum vero delectus quasi. Quasi, consequatur! Corrupti, explicabo maxime incidunt fugit sint dicta saepe officiis sed expedita, minima porro! Ipsa dolores quia, delectus labore!" ),
	                react.createElement( 'p', null, "At similique minima placeat magni molestias sunt deleniti repudiandae voluptatibus magnam quam esse reprehenderit dolor enim qui sed alias, laboriosam quaerat laborum iure repellat praesentium pariatur dolorum possimus veniam! Consectetur." ),
	                react.createElement( 'p', null, "Sunt, sed, magnam! Qui, suscipit. Beatae cum ullam necessitatibus eligendi, culpa rem excepturi consequatur quidem totam eum voluptates nihil, enim pariatur incidunt corporis sed facere magni earum tenetur rerum ea." ),
	                react.createElement( 'p', null, "Veniam nulla quis molestias voluptatem inventore consectetur iusto voluptatibus perferendis quisquam, cupiditate voluptates, tenetur vero magnam nisi animi praesentium atque adipisci optio quod aliquid vel delectus ad? Dicta deleniti, recusandae." )
	              )
	            )
	          ); })
	        )
	      )
	    );
	  };

	  return defaultExport;
	}(react.Component));

	function ToolbarHideScroll () { return (
	  react.createElement( Page, { hideToolbarOnScroll: true },
	    react.createElement( Navbar$2, { title: "Hide Toolbar On Scroll", backLink: "Back" }),
	    react.createElement( Toolbar$2, { bottom: true },
	      react.createElement( Link, null, "Left Link" ),
	      react.createElement( Link, null, "Right Link" )
	    ),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "Toolbar will be hidden if you scroll bottom" )
	    ),
	    react.createElement( Block, null,
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quos maxime incidunt id ab culpa ipsa omnis eos, vel excepturi officiis neque illum perferendis dolorum magnam rerum natus dolore nulla ex." ),
	      react.createElement( 'p', null, "Eum dolore, amet enim quaerat omnis. Modi minus voluptatum quam veritatis assumenda, eligendi minima dolore in autem delectus sequi accusantium? Cupiditate praesentium autem eius, esse ratione consequuntur dolor minus error." ),
	      react.createElement( 'p', null, "Repellendus ipsa sint quisquam delectus dolore quidem odio, praesentium, sequi temporibus amet architecto? Commodi molestiae, in repellat fugit! Laudantium, fuga quia officiis error. Provident inventore iusto quas iure, expedita optio." ),
	      react.createElement( 'p', null, "Eligendi recusandae eos sed alias delectus reprehenderit quaerat modi dolor commodi beatae temporibus nisi ullam ut, quae, animi esse in officia nesciunt sequi amet repellendus? Maiores quos provident nisi expedita." ),
	      react.createElement( 'p', null, "Dolorem aspernatur repudiandae aperiam autem excepturi inventore explicabo molestiae atque, architecto consequatur ab quia quaerat deleniti quis ipsum alias itaque veritatis maiores consectetur minima facilis amet. Maiores impedit ipsum sint." ),
	      react.createElement( 'p', null, "Consequuntur minus fugit vitae magnam illo quibusdam. Minima rerum, magnam nostrum id error temporibus odio molestias tempore vero, voluptas quam iusto. In laboriosam blanditiis, ratione consequuntur similique, quos repellendus ex!" ),
	      react.createElement( 'p', null, "Error suscipit odio modi blanditiis voluptatibus tempore minima ipsam accusantium id! Minus, ea totam veniam dolorem aspernatur repudiandae quae similique odio dolor, voluptate quis aut tenetur porro culpa odit aliquid." ),
	      react.createElement( 'p', null, "Aperiam velit sed sit quaerat, expedita tempore aspernatur iusto nobis ipsam error ut sapiente delectus in minima recusandae dolore alias, cumque labore. Doloribus veritatis magni nisi odio voluptatum perferendis placeat!" ),
	      react.createElement( 'p', null, "Eaque laboriosam iusto corporis iure nemo ab deleniti ut facere laborum, blanditiis neque nihil dignissimos fuga praesentium illo facilis eos beatae accusamus cumque molestiae asperiores cupiditate? Provident laborum officiis suscipit!" ),
	      react.createElement( 'p', null, "Exercitationem odio nulla rerum soluta aspernatur fugit, illo iusto ullam similique. Recusandae consectetur rem, odio autem voluptate similique atque, alias possimus quis vitae in, officiis labore deserunt aspernatur rerum sunt?" ),
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quos maxime incidunt id ab culpa ipsa omnis eos, vel excepturi officiis neque illum perferendis dolorum magnam rerum natus dolore nulla ex." ),
	      react.createElement( 'p', null, "Eum dolore, amet enim quaerat omnis. Modi minus voluptatum quam veritatis assumenda, eligendi minima dolore in autem delectus sequi accusantium? Cupiditate praesentium autem eius, esse ratione consequuntur dolor minus error." ),
	      react.createElement( 'p', null, "Repellendus ipsa sint quisquam delectus dolore quidem odio, praesentium, sequi temporibus amet architecto? Commodi molestiae, in repellat fugit! Laudantium, fuga quia officiis error. Provident inventore iusto quas iure, expedita optio." ),
	      react.createElement( 'p', null, "Eligendi recusandae eos sed alias delectus reprehenderit quaerat modi dolor commodi beatae temporibus nisi ullam ut, quae, animi esse in officia nesciunt sequi amet repellendus? Maiores quos provident nisi expedita." ),
	      react.createElement( 'p', null, "Dolorem aspernatur repudiandae aperiam autem excepturi inventore explicabo molestiae atque, architecto consequatur ab quia quaerat deleniti quis ipsum alias itaque veritatis maiores consectetur minima facilis amet. Maiores impedit ipsum sint." ),
	      react.createElement( 'p', null, "Consequuntur minus fugit vitae magnam illo quibusdam. Minima rerum, magnam nostrum id error temporibus odio molestias tempore vero, voluptas quam iusto. In laboriosam blanditiis, ratione consequuntur similique, quos repellendus ex!" ),
	      react.createElement( 'p', null, "Error suscipit odio modi blanditiis voluptatibus tempore minima ipsam accusantium id! Minus, ea totam veniam dolorem aspernatur repudiandae quae similique odio dolor, voluptate quis aut tenetur porro culpa odit aliquid." ),
	      react.createElement( 'p', null, "Aperiam velit sed sit quaerat, expedita tempore aspernatur iusto nobis ipsam error ut sapiente delectus in minima recusandae dolore alias, cumque labore. Doloribus veritatis magni nisi odio voluptatum perferendis placeat!" ),
	      react.createElement( 'p', null, "Eaque laboriosam iusto corporis iure nemo ab deleniti ut facere laborum, blanditiis neque nihil dignissimos fuga praesentium illo facilis eos beatae accusamus cumque molestiae asperiores cupiditate? Provident laborum officiis suscipit!" ),
	      react.createElement( 'p', null, "Exercitationem odio nulla rerum soluta aspernatur fugit, illo iusto ullam similique. Recusandae consectetur rem, odio autem voluptate similique atque, alias possimus quis vitae in, officiis labore deserunt aspernatur rerum sunt?" ),
	      react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quos maxime incidunt id ab culpa ipsa omnis eos, vel excepturi officiis neque illum perferendis dolorum magnam rerum natus dolore nulla ex." ),
	      react.createElement( 'p', null, "Eum dolore, amet enim quaerat omnis. Modi minus voluptatum quam veritatis assumenda, eligendi minima dolore in autem delectus sequi accusantium? Cupiditate praesentium autem eius, esse ratione consequuntur dolor minus error." ),
	      react.createElement( 'p', null, "Repellendus ipsa sint quisquam delectus dolore quidem odio, praesentium, sequi temporibus amet architecto? Commodi molestiae, in repellat fugit! Laudantium, fuga quia officiis error. Provident inventore iusto quas iure, expedita optio." ),
	      react.createElement( 'p', null, "Eligendi recusandae eos sed alias delectus reprehenderit quaerat modi dolor commodi beatae temporibus nisi ullam ut, quae, animi esse in officia nesciunt sequi amet repellendus? Maiores quos provident nisi expedita." ),
	      react.createElement( 'p', null, "Dolorem aspernatur repudiandae aperiam autem excepturi inventore explicabo molestiae atque, architecto consequatur ab quia quaerat deleniti quis ipsum alias itaque veritatis maiores consectetur minima facilis amet. Maiores impedit ipsum sint." ),
	      react.createElement( 'p', null, "Consequuntur minus fugit vitae magnam illo quibusdam. Minima rerum, magnam nostrum id error temporibus odio molestias tempore vero, voluptas quam iusto. In laboriosam blanditiis, ratione consequuntur similique, quos repellendus ex!" ),
	      react.createElement( 'p', null, "Error suscipit odio modi blanditiis voluptatibus tempore minima ipsam accusantium id! Minus, ea totam veniam dolorem aspernatur repudiandae quae similique odio dolor, voluptate quis aut tenetur porro culpa odit aliquid." ),
	      react.createElement( 'p', null, "Aperiam velit sed sit quaerat, expedita tempore aspernatur iusto nobis ipsam error ut sapiente delectus in minima recusandae dolore alias, cumque labore. Doloribus veritatis magni nisi odio voluptatum perferendis placeat!" ),
	      react.createElement( 'p', null, "Eaque laboriosam iusto corporis iure nemo ab deleniti ut facere laborum, blanditiis neque nihil dignissimos fuga praesentium illo facilis eos beatae accusamus cumque molestiae asperiores cupiditate? Provident laborum officiis suscipit!" ),
	      react.createElement( 'p', null, "Exercitationem odio nulla rerum soluta aspernatur fugit, illo iusto ullam similique. Recusandae consectetur rem, odio autem voluptate similique atque, alias possimus quis vitae in, officiis labore deserunt aspernatur rerum sunt?" )
	    )
	  )
	); }

	var defaultExport$C = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, { onPageInit: this.onPageInit.bind(this), onPageBeforeRemove: this.onPageBeforeRemove.bind(this) },
	        react.createElement( Navbar$2, { title: "Action Sheet", backLink: "Back" },
	          react.createElement( NavRight, null,
	            react.createElement( Link, { className: "navbar-tooltip" },
	              react.createElement( Icon, { ios: "f7:info_round_fill", aurora: "f7:info_round_fill", md: "material:info_outline" })
	            )
	          )
	        ),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Tooltips display informative text when users hover over, or tap an target element.." ),
	          react.createElement( 'p', null, "Tooltip can be positioned around any element with any HTML content inside." )
	        ),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec lacinia augue urna, in tincidunt augue hendrerit ut. In nulla massa, facilisis non consectetur a, tempus semper ex. Proin eget volutpat nisl. Integer lacinia maximus nunc molestie viverra. ", react.createElement( Icon, { className: "icon-tooltip", ios: "f7:info_round_fill", aurora: "f7:info_round_fill", md: "material:info", size: 20 }), " Etiam ullamcorper ultricies ipsum, ut congue tortor rutrum at. Vestibulum rutrum risus a orci dictum, in placerat leo finibus. Sed a congue enim, ut dictum felis. Aliquam erat volutpat. Etiam id nisi in magna egestas malesuada. Sed vitae orci sollicitudin, accumsan nisi a, bibendum felis. Maecenas risus libero, gravida ut tincidunt auctor, ", react.createElement( Icon, { className: "icon-tooltip", ios: "f7:info_round_fill", aurora: "f7:info_round_fill", md: "material:info", size: 20 }), " aliquam non lectus. Nam laoreet turpis erat, eget bibendum leo suscipit nec." ),
	          react.createElement( 'p', null, "Vestibulum ", react.createElement( Icon, { className: "icon-tooltip", ios: "f7:info_round_fill", aurora: "f7:info_round_fill", md: "material:info", size: 20 }), " gravida dui magna, eget pulvinar ligula molestie hendrerit. Mauris vitae facilisis justo. Nam velit mi, pharetra sit amet luctus quis, consectetur a tellus. Maecenas ac magna sit amet eros aliquam rhoncus. Ut dapibus vehicula lectus, ac blandit felis ultricies at. In sollicitudin, lorem eget volutpat viverra, magna ", react.createElement( Icon, { className: "icon-tooltip", ios: "f7:info_round_fill", aurora: "f7:info_round_fill", md: "material:info", size: 20 }), " felis tempus nisl, porta consectetur nunc neque eget risus. Phasellus vestibulum leo at ante ornare, vel congue justo tincidunt." ),
	          react.createElement( 'p', null, "Praesent tempus enim id lectus porta, at rutrum purus imperdiet. Donec eget sem vulputate, scelerisque diam nec, consequat turpis. Ut vel convallis felis. Integer ", react.createElement( Icon, { className: "icon-tooltip", ios: "f7:info_round_fill", aurora: "f7:info_round_fill", md: "material:info", size: 20 }), " neque ex, sollicitudin vitae magna eget, ultrices volutpat dui. Sed placerat odio hendrerit consequat lobortis. Fusce pulvinar facilisis rhoncus. Sed erat ipsum, consequat molestie suscipit vitae, malesuada a ", react.createElement( Icon, { className: "icon-tooltip", ios: "f7:info_round_fill", aurora: "f7:info_round_fill", md: "material:info", size: 20 }), " massa." )
	        ),

	        react.createElement( BlockTitle, null, "Auto Initialization" ),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "For simple cases when you don't need a lot of control over the Tooltip, it can be set on buttons and links automatically with ", react.createElement( 'code', null, "tooltip" ), " prop: ", react.createElement( Button, { round: true, outline: true, small: true, style: {display: 'inline-block'}, tooltip: "Button tooltip text" }, "Button with Tooltip") )
	        )
	      )
	    )
	  };
	  defaultExport.prototype.onPageInit = function onPageInit () {
	    var self = this;
	    var app = self.$f7;
	    self.iconTooltip = app.tooltip.create({
	      targetEl: '.icon-tooltip',
	      text: 'Tooltip text',
	    });
	    self.navbarTooltip = app.tooltip.create({
	      targetEl: '.navbar-tooltip',
	      text: 'One more tooltip<br>with more text<br><em>and custom formatting</em>'
	    });
	  };
	  defaultExport.prototype.onPageBeforeRemove = function onPageBeforeRemove () {
	    var self = this;
	    if (self.iconTooltip) { self.iconTooltip.destroy(); }
	    if (self.navbarTooltip) { self.navbarTooltip.destroy(); }
	  };

	  return defaultExport;
	}(react.Component));

	function Timeline$1 () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Timeline", backLink: "Back" }),
	    react.createElement( List, null,
	      react.createElement( ListItem, { link: "/timeline-vertical/", title: "Vertical Timeline" }),
	      react.createElement( ListItem, { link: "/timeline-horizontal/", title: "Horizontal Timeline" }),
	      react.createElement( ListItem, { link: "/timeline-horizontal-calendar/", title: "Calendar Timeline" })
	    )
	  )
	); }

	function TimelineVertical () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Vertical Timeline", backLink: "Back" }),
	    react.createElement( BlockTitle, null, "Default" ),
	    react.createElement( 'div', { className: "timeline" },
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "21 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "Some text goes here")
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "22 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "Another text goes here")
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "23 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor fugiat ipsam hic porro enim, accusamus perferendis, quas commodi alias quaerat eius nemo deleniti. Odio quasi quos quis iure, aperiam pariatur?")
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "24 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "One more text here")
	        )
	      )
	    ),
	    react.createElement( BlockTitle, null, "Side By Side" ),
	    react.createElement( 'div', { className: "timeline timeline-sides" },
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "21 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "Some text goes here")
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "22 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "Another text goes here")
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "23 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "Just plain text")
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "24 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "One more text here")
	        )
	      )
	    ),
	    react.createElement( BlockTitle, null, "Only Tablet Side By Side" ),
	    react.createElement( 'div', { className: "timeline tablet-sides" },
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "21 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "Some text goes here")
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "22 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "Another text goes here")
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "23 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "Just plain text")
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "24 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "One more text here")
	        )
	      )
	    ),
	    react.createElement( BlockTitle, null, "Forced Sides" ),
	    react.createElement( 'div', { className: "timeline timeline-sides" },
	      react.createElement( 'div', { className: "timeline-item timeline-item-right" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "21 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "Some text goes here")
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item timeline-item-right" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "22 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "Another text goes here")
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item timeline-item-left" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "23 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "Just plain text")
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item timeline-item-left" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "24 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" }, "One more text here")
	        )
	      )
	    ),
	    react.createElement( BlockTitle, null, "Rich Content" ),
	    react.createElement( 'div', { className: "timeline" },
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "21 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" },
	            react.createElement( 'div', { className: "timeline-item-time" }, "12:56"),
	            react.createElement( 'div', { className: "timeline-item-title" }, "Item Title"),
	            react.createElement( 'div', { className: "timeline-item-subtitle" }, "Item Subtitle"),
	            react.createElement( 'div', { className: "timeline-item-text" }, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor fugiat ipsam hic porro enim, accusamus perferendis, quas commodi alias quaerat eius nemo deleniti. Odio quasi quos quis iure, aperiam pariatur?"),
	            react.createElement( 'div', { className: "timeline-item-time" }, "15:07"),
	            react.createElement( 'div', { className: "timeline-item-title" }, "Item Title"),
	            react.createElement( 'div', { className: "timeline-item-subtitle" }, "Item Subtitle"),
	            react.createElement( 'div', { className: "timeline-item-text" }, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor fugiat ipsam hic porro enim, accusamus perferendis, quas commodi alias quaerat eius nemo deleniti. Odio quasi quos quis iure, aperiam pariatur?")
	          )
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "22 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" },
	            react.createElement( 'div', { className: "timeline-item-time" }, "12:56"),
	            react.createElement( 'div', { className: "timeline-item-title" }, "Item Title"),
	            react.createElement( 'div', { className: "timeline-item-subtitle" }, "Item Subtitle"),
	            react.createElement( 'div', { className: "timeline-item-text" }, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor fugiat ipsam hic porro enim, accusamus perferendis, quas commodi alias quaerat eius nemo deleniti. Odio quasi quos quis iure, aperiam pariatur?")
	          ),
	          react.createElement( 'div', { className: "timeline-item-inner" },
	            react.createElement( 'div', { className: "timeline-item-time" }, "15:07"),
	            react.createElement( 'div', { className: "timeline-item-title" }, "Item Title"),
	            react.createElement( 'div', { className: "timeline-item-subtitle" }, "Item Subtitle"),
	            react.createElement( 'div', { className: "timeline-item-text" }, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor fugiat ipsam hic porro enim, accusamus perferendis, quas commodi alias quaerat eius nemo deleniti. Odio quasi quos quis iure, aperiam pariatur?")
	          )
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "23 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content card no-safe-areas" },
	          react.createElement( 'div', { className: "card-header" }, "Card Header"),
	          react.createElement( 'div', { className: "card-content card-content-padding" }, "Card Content"),
	          react.createElement( 'div', { className: "card-footer" }, "Card Footer")
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "24 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content list links-list inset no-safe-areas" },
	          react.createElement( 'ul', null,
	            react.createElement( 'li', null, react.createElement( 'a', { href: "#" }, "Item 1") ),
	            react.createElement( 'li', null, react.createElement( 'a', { href: "#" }, "Item 2") ),
	            react.createElement( 'li', null, react.createElement( 'a', { href: "#" }, "Item 3") )
	          )
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "25 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-divider" }),
	        react.createElement( 'div', { className: "timeline-item-content" }, "Plain text")
	      )
	    ),
	    react.createElement( BlockTitle, null, "Inside Content Block" ),
	    react.createElement( 'div', { className: "block block-strong" },
	      react.createElement( 'div', { className: "timeline" },
	        react.createElement( 'div', { className: "timeline-item" },
	          react.createElement( 'div', { className: "timeline-item-date" }, "21 ", react.createElement( 'small', null, "DEC" )),
	          react.createElement( 'div', { className: "timeline-item-divider" }),
	          react.createElement( 'div', { className: "timeline-item-content" },
	            react.createElement( 'div', { className: "timeline-item-inner" }, "Some text goes here")
	          )
	        ),
	        react.createElement( 'div', { className: "timeline-item" },
	          react.createElement( 'div', { className: "timeline-item-date" }, "22 ", react.createElement( 'small', null, "DEC" )),
	          react.createElement( 'div', { className: "timeline-item-divider" }),
	          react.createElement( 'div', { className: "timeline-item-content" },
	            react.createElement( 'div', { className: "timeline-item-inner" }, "Another text goes here")
	          )
	        ),
	        react.createElement( 'div', { className: "timeline-item" },
	          react.createElement( 'div', { className: "timeline-item-date" }, "23 ", react.createElement( 'small', null, "DEC" )),
	          react.createElement( 'div', { className: "timeline-item-divider" }),
	          react.createElement( 'div', { className: "timeline-item-content" },
	            react.createElement( 'div', { className: "timeline-item-inner" }, "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor fugiat ipsam hic porro enim, accusamus perferendis, quas commodi alias quaerat eius nemo deleniti. Odio quasi quos quis iure, aperiam pariatur?")
	          )
	        ),
	        react.createElement( 'div', { className: "timeline-item" },
	          react.createElement( 'div', { className: "timeline-item-date" }, "24 ", react.createElement( 'small', null, "DEC" )),
	          react.createElement( 'div', { className: "timeline-item-divider" }),
	          react.createElement( 'div', { className: "timeline-item-content" },
	            react.createElement( 'div', { className: "timeline-item-inner" }, "One more text here")
	          )
	        )
	      )
	    )
	  )
	); }

	function TimelineHorizontal () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { noShadow: true, title: "Horizontal Timeline", backLink: "Back" }),
	    react.createElement( 'div', { className: "timeline timeline-horizontal col-33 tablet-20" },
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "21 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" },
	            react.createElement( 'div', { className: "timeline-item-time" }, "12:56"),
	            react.createElement( 'div', { className: "timeline-item-title" }, "Title 1"),
	            react.createElement( 'div', { className: "timeline-item-subtitle" }, "Subtitle 1"),
	            react.createElement( 'div', { className: "timeline-item-text" }, "Lorem ipsum dolor sit amet, consectetur adipisicing elit")
	          ),
	          react.createElement( 'div', { className: "timeline-item-inner" },
	            react.createElement( 'div', { className: "timeline-item-time" }, "13:15"),
	            react.createElement( 'div', { className: "timeline-item-title" }, "Title 2"),
	            react.createElement( 'div', { className: "timeline-item-subtitle" }, "Subtitle 2"),
	            react.createElement( 'div', { className: "timeline-item-text" }, "Lorem ipsum dolor sit amet, consectetur adipisicing elit")
	          ),
	          react.createElement( 'div', { className: "timeline-item-inner" },
	            react.createElement( 'div', { className: "timeline-item-time" }, "14:45"),
	            react.createElement( 'div', { className: "timeline-item-text" }, "Do something")
	          ),
	          react.createElement( 'div', { className: "timeline-item-inner" },
	            react.createElement( 'div', { className: "timeline-item-time" }, "16:11"),
	            react.createElement( 'div', { className: "timeline-item-text" }, "Do something else")
	          )
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "22 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-content" }, "Plain text goes here")
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "23 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "card no-safe-areas" },
	            react.createElement( 'div', { className: "card-header" }, "Card"),
	            react.createElement( 'div', { className: "card-content card-content-padding" }, "Card Content"),
	            react.createElement( 'div', { className: "card-footer" }, "Card Footer")
	          ),
	          react.createElement( 'div', { className: "card no-safe-areas" },
	            react.createElement( 'div', { className: "card-content card-content-padding" }, "Another Card Content")
	          )
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "24 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "list links-list inset no-safe-areas" },
	            react.createElement( 'ul', null,
	              react.createElement( 'li', null, react.createElement( 'a', { href: "#" }, "Item 1") ),
	              react.createElement( 'li', null, react.createElement( 'a', { href: "#" }, "Item 2") ),
	              react.createElement( 'li', null, react.createElement( 'a', { href: "#" }, "Item 3") )
	            )
	          )
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "25 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-time" }, "11:11"),
	          react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	          react.createElement( 'div', { className: "timeline-item-time" }, "12:33"),
	          react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	          react.createElement( 'div', { className: "timeline-item-time" }, "13:24"),
	          react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	          react.createElement( 'div', { className: "timeline-item-time" }, "14:55"),
	          react.createElement( 'div', { className: "timeline-item-text" }, "Task 4"),
	          react.createElement( 'div', { className: "timeline-item-time" }, "15:15"),
	          react.createElement( 'div', { className: "timeline-item-text" }, "Task 5"),
	          react.createElement( 'div', { className: "timeline-item-time" }, "16:54"),
	          react.createElement( 'div', { className: "timeline-item-text" }, "Task 6")
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-item" },
	        react.createElement( 'div', { className: "timeline-item-date" }, "26 ", react.createElement( 'small', null, "DEC" )),
	        react.createElement( 'div', { className: "timeline-item-content" },
	          react.createElement( 'div', { className: "timeline-item-inner" },
	            react.createElement( 'div', { className: "timeline-item-time" }, "11:11"),
	            react.createElement( 'div', { className: "timeline-item-text" }, "Task 1")
	          ),
	          react.createElement( 'div', { className: "timeline-item-inner" },
	            react.createElement( 'div', { className: "timeline-item-time" }, "12:33"),
	            react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	          ),
	          react.createElement( 'div', { className: "timeline-item-inner" },
	            react.createElement( 'div', { className: "timeline-item-time" }, "13:24"),
	            react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	          ),
	          react.createElement( 'div', { className: "timeline-item-inner" },
	            react.createElement( 'div', { className: "timeline-item-time" }, "14:55"),
	            react.createElement( 'div', { className: "timeline-item-text" }, "Task 4")
	          ),
	          react.createElement( 'div', { className: "timeline-item-inner" },
	            react.createElement( 'div', { className: "timeline-item-time" }, "15:15"),
	            react.createElement( 'div', { className: "timeline-item-text" }, "Task 5")
	          ),
	          react.createElement( 'div', { className: "timeline-item-inner" },
	            react.createElement( 'div', { className: "timeline-item-time" }, "16:54"),
	            react.createElement( 'div', { className: "timeline-item-text" }, "Task 6")
	          )
	        )
	      )
	    )
	  )
	); }

	function TimelineHorizontalCalendar () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { noShadow: true, title: "Horizontal Timeline Calendar", backLink: "Back" }),
	    react.createElement( 'div', { className: "timeline timeline-horizontal col-33 tablet-15" },
	      react.createElement( 'div', { className: "timeline-year" },
	        react.createElement( 'div', { className: "timeline-year-title" }, react.createElement( 'span', null, "2016" )),
	        react.createElement( 'div', { className: "timeline-month" },
	          react.createElement( 'div', { className: "timeline-month-title" }, react.createElement( 'span', null, "December" )),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "20"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "10:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "13:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "8:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "2:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "21"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "1:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "1:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "7:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "22"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "23:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "15:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "0:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "23"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "12:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "11:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "24"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "18:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "14:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "25"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "11:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "20:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "26"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "10:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "8:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "27"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "17:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "0:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "3:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "28"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "9:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "21:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "29"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "1:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "19:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "12:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "8:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "30"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "21:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "7:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "31"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "1:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "19:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          )
	        )
	      ),
	      react.createElement( 'div', { className: "timeline-year" },
	        react.createElement( 'div', { className: "timeline-year-title" }, react.createElement( 'span', null, "2017" )),
	        react.createElement( 'div', { className: "timeline-month" },
	          react.createElement( 'div', { className: "timeline-month-title" }, react.createElement( 'span', null, "January" )),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "1"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "19:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "20:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "15:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "2"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "4:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "20:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "10:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "10:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "3"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "3:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "16:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "9:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "4"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "19:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "8:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "19:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "18:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "5"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "20:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "6"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "2:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "5:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "1:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "7"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "10:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "8"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "7:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "9"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "20:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "21:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "10"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "20:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "11"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "3:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "14:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "14:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "16:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "12"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "3:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "13"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "11:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "4:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "7:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "15:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "14"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "5:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "3:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "18:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "15"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "2:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "0:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "16"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "16:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "7:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "17"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "0:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "18"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "16:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "0:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "19"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "13:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "14:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "20"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "10:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "21"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "8:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "14:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "22"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "9:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "5:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "11:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "23"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "2:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "16:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "19:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "15:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "24"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "15:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "20:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "25"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "7:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "0:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "26"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "22:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "17:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "21:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "27"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "17:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "28"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "14:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "20:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "29"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "13:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "5:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "30"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "4:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "16:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "31"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "3:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1")
	            )
	          )
	        ),
	        react.createElement( 'div', { className: "timeline-month" },
	          react.createElement( 'div', { className: "timeline-month-title" }, react.createElement( 'span', null, "February" )),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "1"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "2"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "5:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "3"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "10:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "9:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "4"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "9:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "4:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "11:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "17:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "23:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 5")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "5"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "9:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "7:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "6"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "11:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "12:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "2:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "7"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "5:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "8"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "2:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "9"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "5:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "22:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "14:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "3:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "10"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "8:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "8:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "11"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "1:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "3:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "4:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "18:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "13:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 5")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "12"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "17:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "15:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "23:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "13"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "13:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "19:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "18:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "14"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "17:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "15"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "1:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "14:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "16"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "7:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "4:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "22:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "17"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "14:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "10:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "23:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "13:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "12:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 5")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "18"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "13:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "12:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "19"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "2:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "16:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "12:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "1:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "9:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 5")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "20"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "19:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "14:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "17:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "21"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "4:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "11:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "13:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "22"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "22:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "0:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "6:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 4")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "23"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "0:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "24"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "7:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "15:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "5:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "25"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "5:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "20:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "2:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "26"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "13:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "18:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "27"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "2:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "20:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 2"),
	              react.createElement( 'div', { className: "timeline-item-time" }, "3:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 3")
	            )
	          ),
	          react.createElement( 'div', { className: "timeline-item" },
	            react.createElement( 'div', { className: "timeline-item-date" }, "28"),
	            react.createElement( 'div', { className: "timeline-item-content" },
	              react.createElement( 'div', { className: "timeline-item-time" }, "15:00"),
	              react.createElement( 'div', { className: "timeline-item-text" }, "Task 1")
	            )
	          )
	        )
	      )
	    )
	  )
	); }

	var defaultExport$D = /*@__PURE__*/(function (superclass) {
	  function defaultExport() {
	    superclass.call(this);
	    this.state = {
	      checkboxes: {
	        images: {
	          'avatar.png': false,
	          'background.jpg': false,
	        },
	        documents: {
	          'cv.docx': false,
	          'info.docx': false,
	        },
	        '.gitignore': false,
	        '.index.html': false,
	      },
	      selectedItem: null,
	      loadedChildren: [],
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;

	  defaultExport.prototype.toggleSelectable = function toggleSelectable (e, item) {
	    var self = this;
	    var $ = self.$$;
	    if ($(e.target).is('.treeview-toggle')) { return; }
	    self.setState({selectedItem: item});
	  };

	  defaultExport.prototype.loadChildren = function loadChildren (done) {
	    var self = this;
	    setTimeout(function () {
	      // call done() to hide preloader
	      done();
	      self.setState({
	        loadedChildren: [
	          {
	            name: 'John Doe',
	          },
	          {
	            name: 'Jane Doe',
	          },
	          {
	            name: 'Calvin Johnson',
	          } ],
	      });
	    }, 2000);
	  };

	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Treeview", backLink: "Back" }),

	        react.createElement( BlockTitle, null, "Basic tree view" ),
	        react.createElement( Block, { strong: true, className: "no-padding-horizontal" },
	          react.createElement( Treeview$2, null,
	            react.createElement( TreeviewItem, { label: "Item 1" },
	              react.createElement( TreeviewItem, { label: "Sub Item 1" },
	                react.createElement( TreeviewItem, { label: "Sub Sub Item 1" }),
	                react.createElement( TreeviewItem, { label: "Sub Sub Item 2" })
	              ),
	              react.createElement( TreeviewItem, { label: "Sub Item 2" },
	                react.createElement( TreeviewItem, { label: "Sub Sub Item 1" }),
	                react.createElement( TreeviewItem, { label: "Sub Sub Item 2" })
	              )
	            ),
	            react.createElement( TreeviewItem, { label: "Item 2" },
	              react.createElement( TreeviewItem, { label: "Sub Item 1" },
	                react.createElement( TreeviewItem, { label: "Sub Sub Item 1" }),
	                react.createElement( TreeviewItem, { label: "Sub Sub Item 2" })
	              ),
	              react.createElement( TreeviewItem, { label: "Sub Item 2" },
	                react.createElement( TreeviewItem, { label: "Sub Sub Item 1" }),
	                react.createElement( TreeviewItem, { label: "Sub Sub Item 2" })
	              )
	            ),
	            react.createElement( TreeviewItem, { label: "Item 3" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "With icons" ),
	        react.createElement( Block, { strong: true, className: "no-padding-horizontal" },
	          react.createElement( Treeview$2, null,
	            react.createElement( TreeviewItem, { label: "images", iconF7: "folder_fill" },
	              react.createElement( TreeviewItem, { label: "avatar.png", iconF7: "images_fill" }),
	              react.createElement( TreeviewItem, { label: "background.jpg", iconF7: "images_fill" })
	            ),
	            react.createElement( TreeviewItem, { label: "documents", iconF7: "folder_fill" },
	              react.createElement( TreeviewItem, { label: "cv.docx", iconF7: "document_text_fill" }),
	              react.createElement( TreeviewItem, { label: "info.docx", iconF7: "document_text_fill" })
	            ),
	            react.createElement( TreeviewItem, { label: ".gitignore", iconF7: "logo_github" }),
	            react.createElement( TreeviewItem, { label: "index.html", iconF7: "document_text_fill" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "With checkboxes" ),
	        react.createElement( Block, { strong: true, className: "no-padding-horizontal" },
	          react.createElement( Treeview$2, null,
	            react.createElement( TreeviewItem, { label: "images", iconF7: "folder_fill" },
	              react.createElement( Checkbox$1, { slot: "content-start", checked: Object.values(this.state.checkboxes.images).indexOf(false) < 0, indeterminate: Object.values(this.state.checkboxes.images).indexOf(false) >= 0 && Object.values(this.state.checkboxes.images).indexOf(true) >= 0, onChange: function (e) {
	                  Object.keys(this$1.state.checkboxes.images).forEach(function (k) { return this$1.state.checkboxes.images[k] = e.target.checked; });
	                  this$1.setState(Object.assign({}, this$1.state));
	                } }),
	              react.createElement( TreeviewItem, { label: "avatar.png", iconF7: "images_fill" },
	                react.createElement( Checkbox$1, { slot: "content-start", checked: this.state.checkboxes.images['avatar.png'], onChange: function (e) {
	                    this$1.state.checkboxes.images['avatar.png'] = e.target.checked;
	                    this$1.setState(Object.assign({}, this$1.state));
	                  } })
	              ),
	              react.createElement( TreeviewItem, { label: "background.jpg", iconF7: "images_fill" },
	                react.createElement( Checkbox$1, { slot: "content-start", checked: this.state.checkboxes.images['background.jpg'], onChange: function (e) {
	                    this$1.state.checkboxes.images['background.jpg'] = e.target.checked;
	                    this$1.setState(Object.assign({}, this$1.state));
	                  } })
	              )
	            ),
	            react.createElement( TreeviewItem, { label: "documents", iconF7: "folder_fill" },
	              react.createElement( Checkbox$1, { slot: "content-start", checked: Object.values(this.state.checkboxes.documents).indexOf(false) < 0, indeterminate: Object.values(this.state.checkboxes.documents).indexOf(false) >= 0 && Object.values(this.state.checkboxes.documents).indexOf(true) >= 0, onChange: function (e) {
	                  Object.keys(this$1.state.checkboxes.documents).forEach(function (k) { return this$1.state.checkboxes.documents[k] = e.target.checked; });
	                  this$1.setState(Object.assign({}, this$1.state));
	                } }),
	              react.createElement( TreeviewItem, { label: "cv.docx", iconF7: "document_text_fill" },
	                react.createElement( Checkbox$1, { slot: "content-start", checked: this.state.checkboxes.documents['cv.docx'], onChange: function (e) {
	                    this$1.state.checkboxes.documents['cv.docx'] = e.target.checked;
	                    this$1.setState(Object.assign({}, this$1.state));
	                  } })
	              ),
	              react.createElement( TreeviewItem, { label: "info.docx", iconF7: "document_text_fill" },
	                react.createElement( Checkbox$1, { slot: "content-start", checked: this.state.checkboxes.documents['info.docx'], onChange: function (e) {
	                    this$1.state.checkboxes.documents['info.docx'] = e.target.checked;
	                    this$1.setState(Object.assign({}, this$1.state));
	                  } })
	              )
	            ),
	            react.createElement( TreeviewItem, { label: ".gitignore", iconF7: "logo_github" },
	              react.createElement( Checkbox$1, { slot: "content-start", checked: this.state.checkboxes['.gitignore'], onChange: function (e) {
	                this$1.state.checkboxes['.gitignore'] = e.target.checked;
	                this$1.setState(Object.assign({}, this$1.state));
	              } })
	            ),
	            react.createElement( TreeviewItem, { label: "index.html", iconF7: "document_text_fill" },
	              react.createElement( Checkbox$1, { slot: "content-start", checked: this.state.checkboxes['index.html'], onChange: function (e) {
	                this$1.state.checkboxes['index.html'] = e.target.checked;
	                this$1.setState(Object.assign({}, this$1.state));
	              } })
	            )
	          )
	        ),

	        react.createElement( BlockTitle, null, "Whole item as toggle" ),
	        react.createElement( Block, { strong: true, className: "no-padding-horizontal" },
	          react.createElement( Treeview$2, null,
	            react.createElement( TreeviewItem, { itemToggle: true, label: "images", iconF7: "folder_fill" },
	              react.createElement( TreeviewItem, { label: "avatar.png", iconF7: "images_fill" }),
	              react.createElement( TreeviewItem, { label: "background.jpg", iconF7: "images_fill" })
	            ),
	            react.createElement( TreeviewItem, { itemToggle: true, label: "documents", iconF7: "folder_fill" },
	              react.createElement( TreeviewItem, { label: "cv.docx", iconF7: "document_text_fill" }),
	              react.createElement( TreeviewItem, { label: "info.docx", iconF7: "document_text_fill" })
	            ),
	            react.createElement( TreeviewItem, { label: ".gitignore", iconF7: "logo_github" }),
	            react.createElement( TreeviewItem, { label: "index.html", iconF7: "document_text_fill" })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Selectable" ),
	        react.createElement( Block, { strong: true, className: "no-padding-horizontal" },
	          react.createElement( Treeview$2, null,
	            react.createElement( TreeviewItem, {
	              selectable: true, selected: this.state.selectedItem === 'images', label: "images", iconF7: "folder_fill", onClick: function (e) { return this$1.toggleSelectable(e, 'images'); } },
	              react.createElement( TreeviewItem, {
	                selectable: true, selected: this.state.selectedItem === 'avatar.png', label: "avatar.png", iconF7: "images_fill", onClick: function (e) { return this$1.toggleSelectable(e, 'avatar.png'); } }),
	              react.createElement( TreeviewItem, {
	                selectable: true, selected: this.state.selectedItem === 'background.jpg', label: "background.jpg", iconF7: "images_fill", onClick: function (e) { return this$1.toggleSelectable(e, 'background.jpg'); } })
	            ),
	            react.createElement( TreeviewItem, {
	              selectable: true, selected: this.state.selectedItem === 'documents', label: "documents", iconF7: "folder_fill", onClick: function (e) { return this$1.toggleSelectable(e, 'documents'); } },
	              react.createElement( TreeviewItem, {
	                selectable: true, selected: this.state.selectedItem === 'cv.docx', label: "cv.docx", iconF7: "document_text_fill", onClick: function (e) { return this$1.toggleSelectable(e, 'cv.docx'); } }),
	              react.createElement( TreeviewItem, {
	                selectable: true, selected: this.state.selectedItem === 'info.docx', label: "info.docx", iconF7: "document_text_fill", onClick: function (e) { return this$1.toggleSelectable(e, 'info.docx'); } })
	            ),
	            react.createElement( TreeviewItem, {
	              selectable: true, selected: this.state.selectedItem === '.gitignore', label: ".gitignore", iconF7: "logo_github", onClick: function (e) { return this$1.toggleSelectable(e, '.gitignore'); } }),
	            react.createElement( TreeviewItem, {
	              selectable: true, selected: this.state.selectedItem === 'index.html', label: "index.html", iconF7: "document_text_fill", onClick: function (e) { return this$1.toggleSelectable(e, 'index.html'); } })
	          )
	        ),

	        react.createElement( BlockTitle, null, "Preload children" ),
	        react.createElement( Block, { strong: true, className: "no-padding-horizontal" },
	          react.createElement( Treeview$2, null,
	            react.createElement( TreeviewItem, {
	              toggle: true, loadChildren: true, iconF7: "persons", label: "Users", onTreeviewLoadChildren: function (e, done) { return this$1.loadChildren(done); } },
	              this.state.loadedChildren.map(function (item, index) { return (
	                react.createElement( TreeviewItem, {
	                  key: index, iconF7: "person", label: item.name })
	              ); })
	            )
	          )
	        ),

	        react.createElement( BlockTitle, null, "With links" ),
	        react.createElement( Block, { strong: true, className: "no-padding-horizontal" },
	          react.createElement( Treeview$2, null,
	            react.createElement( TreeviewItem, { iconF7: "data_fill", itemToggle: true, label: "Modals" },
	              react.createElement( TreeviewItem, { link: "/popup/", iconF7: "link", label: "Popup" }),
	              react.createElement( TreeviewItem, { link: "/dialog/", iconF7: "link", label: "Dialog" }),
	              react.createElement( TreeviewItem, { link: "/action-sheet/", iconF7: "link", label: "Action Sheet" })
	            ),
	            react.createElement( TreeviewItem, { iconF7: "data_fill", itemToggle: true, label: "Navigation Bars" },
	              react.createElement( TreeviewItem, { link: "/navbar/", iconF7: "link", label: "Navbar" }),
	              react.createElement( TreeviewItem, { link: "/toolbar-tabbar/", iconF7: "link", label: "Toolbar & Tabbar" })
	            )
	          )
	        )
	      )
	    );
	  };

	  return defaultExport;
	}(react.Component));

	var defaultExport$E = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);

	    var items = [];
	    for (var i = 1; i <= 10000; i += 1) {
	      items.push({
	        title: ("Item " + i),
	        subtitle: ("Subtitle " + i),
	      });
	    }
	    this.state = {
	      items: items,
	      vlData: {
	        items: [],
	      },
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: "Virtual List", backLink: "Back" },
	          react.createElement( Subnavbar$1, { inner: false },
	            react.createElement( Searchbar$2, {
	              searchContainer: ".virtual-list", searchItem: "li", searchIn: ".item-title", disableButton: !this.$theme.aurora })
	          )
	        ),
	        react.createElement( Block, null,
	          react.createElement( 'p', null, "Virtual List allows to render lists with huge amount of elements without loss of performance. And it is fully compatible with all Framework7 list components such as Search Bar, Infinite Scroll, Pull To Refresh, Swipeouts (swipe-to-delete) and Sortable." ),
	          react.createElement( 'p', null, "Here is the example of virtual list with 10 000 items:" )
	        ),
	        react.createElement( List, { className: "searchbar-not-found" },
	          react.createElement( ListItem, { title: "Nothing found" })
	        ),
	        react.createElement( List, {
	          className: "searchbar-found", medialList: true, virtualList: true, virtualListParams: { items: this.state.items, searchAll: this.searchAll, renderExternal: this.renderExternal.bind(this), height: this.$theme.ios ? 63 : (this.$theme.md ? 73 : 46)} },
	          react.createElement( 'ul', null,
	            this.state.vlData.items.map(function (item, index) { return (
	              react.createElement( ListItem, {
	                key: index, mediaItem: true, link: "#", title: item.title, subtitle: item.subtitle, style: {top: ((this$1.state.vlData.topPosition) + "px")}, virtualListIndex: this$1.state.items.indexOf(item) })
	            ); })
	          )
	        )
	      )
	    )
	  };
	  defaultExport.prototype.searchAll = function searchAll (query, items) {
	    var found = [];
	    for (var i = 0; i < items.length; i += 1) {
	      if (items[i].title.toLowerCase().indexOf(query.toLowerCase()) >= 0 || query.trim() === '') { found.push(i); }
	    }
	    return found; // return array with mathced indexes
	  };
	  defaultExport.prototype.renderExternal = function renderExternal (vl, vlData) {
	    this.setState({ vlData: vlData });
	  };

	  return defaultExport;
	}(react.Component));

	var stylesheet;
	var globalTheme = 'light';
	var globalBarsStyle = 'empty';
	var globalCustomColor = '';
	var globalCustomProperties = '';

	var defaultExport$F = /*@__PURE__*/(function (superclass) {
	  function defaultExport(props) {
	    superclass.call(this, props);

	    var colors = [
	      'red',
	      'green',
	      'blue',
	      'pink',
	      'yellow',
	      'orange',
	      'purple',
	      'deeppurple',
	      'lightblue',
	      'teal',
	      'lime',
	      'deeporange',
	      'gray',
	      'black' ];
	    this.state = {
	      theme: globalTheme,
	      barsStyle: globalBarsStyle,
	      customColor: globalCustomColor,
	      customProperties: globalCustomProperties,
	      colors: colors,
	      themeColor: this.$$('html').css('--f7-theme-color').trim(),
	    };
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    var this$1 = this;

	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { large: true, title: "Color Themes", backLink: "Back" }),
	        react.createElement( BlockTitle, { medium: true }, "Layout Themes"),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Framework7 comes with 2 main layout themes: Light (default) and Dark:" ),
	          react.createElement( Row, null,
	            react.createElement( Col, { width: "50", className: "bg-color-white demo-theme-picker", onClick: function () { return this$1.setLayoutTheme('light'); } },
	              this.state.theme === 'light' && (
	                react.createElement( Checkbox$1, { checked: true, disabled: true })
	              )
	            ),
	            react.createElement( Col, { width: "50", className: "bg-color-black demo-theme-picker", onClick: function () { return this$1.setLayoutTheme('dark'); } },
	              this.state.theme === 'dark' && (
	                react.createElement( Checkbox$1, { checked: true, disabled: true })
	              )
	            )
	          )
	        ),
	        react.createElement( BlockTitle, { medium: true }, "Navigation Bars Style"),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Switch navigation bars to filled style:" ),
	          react.createElement( Row, null,
	            react.createElement( Col, { width: "50", className: "demo-bars-picker demo-bars-picker-empty", onClick: function () { return this$1.setBarsStyle('empty'); } },
	              react.createElement( 'div', { className: "demo-navbar" }),
	              this.state.barsStyle === 'empty' && (
	                react.createElement( Checkbox$1, { checked: true, disabled: true })
	              )
	            ),
	            react.createElement( Col, { width: "50", className: "demo-bars-picker demo-bars-picker-fill", onClick: function () { return this$1.setBarsStyle('fill'); } },
	              react.createElement( 'div', { className: "demo-navbar" }),
	              this.state.barsStyle === 'fill' && (
	                react.createElement( Checkbox$1, { checked: true, disabled: true })
	              )
	            )
	          )
	        ),
	        react.createElement( BlockTitle, { medium: true }, "Default Color Themes"),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, "Framework7 comes with ", this.state.colors.length, " color themes set." ),
	          react.createElement( Row, null,
	            this.state.colors.map(function (color, index) { return (
	              react.createElement( Col, { width: "33", tabletWidth: "25", desktopWidth: "20", key: index },
	                react.createElement( Button, { fill: true, round: true, small: true, className: "demo-color-picker-button", color: color, onClick: function () { return this$1.setColorTheme(color); } }, color)
	              )
	            ); }),

	            react.createElement( Col, { width: "33", tabletWidth: "25", desktopWidth: "20" }),
	            react.createElement( Col, { width: "33", tabletWidth: "25", desktopWidth: "20" }),
	            react.createElement( Col, { width: "33", tabletWidth: "25", desktopWidth: "20" })
	          )
	        ),
	        react.createElement( BlockTitle, { medium: true }, "Custom Color Theme"),
	        react.createElement( List, null,
	          react.createElement( ListInput, {
	            type: "colorpicker", label: "HEX Color", placeholder: "e.g. #ff0000", readonly: true, value: {hex: this.state.customColor || this.state.themeColor}, onColorPickerChange: function (value) { return this$1.setCustomColor(value.hex); }, colorPickerParams: {
	              targetEl: '#color-theme-picker-color',
	            } },
	            react.createElement( 'div', {
	              slot: "media", id: "color-theme-picker-color", style: {width: '28px', height: '28px', borderRadius: '4px', background: 'var(--f7-theme-color)'} })
	          )
	        ),

	        react.createElement( BlockTitle, { medium: true }, "Generated CSS Variables"),
	        react.createElement( Block, { strong: true },
	          this.state.customProperties && (
	            react.createElement( 'p', null, "Add this code block to your custom stylesheet:" )
	          ),
	          this.state.customProperties && (
	            react.createElement( 'pre', { style: {overflow: 'auto', WebkitOverflowScrolling: 'touch', margin: 0, fontSize: '12px'} }, this.state.customProperties)
	          ),
	          !this.state.customProperties && (
	            react.createElement( 'p', null, "Change navigation bars styles or specify custom color to see custom CSS variables here" )
	          )
	        )
	      )
	    );
	  };

	  defaultExport.prototype.generateStylesheet = function generateStylesheet () {
	    var self = this;
	    var styles = '';
	    if (self.state.customColor) {
	      var colorThemeProperties = self.$f7.utils.colorThemeCSSProperties(self.state.customColor);
	      if (Object.keys(colorThemeProperties).length) {
	        styles += "\n/* Custom color theme */\n:root {\n  " + (Object.keys(colorThemeProperties)
	  .map(function (key) { return (key + ": " + (colorThemeProperties[key]) + ";"); })
	  .join('\n  ')) + "\n}";
	      }
	    }
	    if (self.state.barsStyle === 'fill') {
	      styles += "\n/* Invert navigation bars to fill style */\n:root,\n:root.theme-dark,\n:root .theme-dark {\n  --f7-bars-bg-color: var(--f7-theme-color);\n  --f7-bars-text-color: #fff;\n  --f7-bars-link-color: #fff;\n  --f7-navbar-subtitle-text-color: rgba(255,255,255,0.85);\n  --f7-bars-border-color: transparent;\n  --f7-tabbar-link-active-color: #fff;\n  --f7-tabbar-link-inactive-color: rgba(255,255,255,0.54);\n  --f7-searchbar-bg-color: var(--f7-bars-bg-color);\n  --f7-searchbar-input-bg-color: #fff;\n  --f7-searchbar-input-text-color: #000;\n  --f7-sheet-border-color: transparent;\n  --f7-tabbar-link-active-border-color: #fff;\n}\n.appbar,\n.navbar,\n.toolbar,\n.subnavbar,\n.calendar-header,\n.calendar-footer {\n  --f7-touch-ripple-color: var(--f7-touch-ripple-white);\n  --f7-link-highlight-color: var(--f7-link-highlight-white);\n  --f7-button-text-color: #fff;\n  --f7-button-pressed-bg-color: rgba(255,255,255,0.1);\n}\n      ";
	    }
	    return styles.trim();
	  };

	  defaultExport.prototype.componentDidMount = function componentDidMount () {
	    if (!stylesheet) {
	      stylesheet = document.createElement('style');
	      document.head.appendChild(stylesheet);
	    }
	  };

	  defaultExport.prototype.setLayoutTheme = function setLayoutTheme (theme) {
	    var self = this;
	    var $html = self.$$('html');
	    globalTheme = theme;
	    $html.removeClass('theme-dark theme-light').addClass('theme-' + globalTheme);
	    self.setState({ theme: globalTheme });
	  };

	  defaultExport.prototype.setColorTheme = function setColorTheme (color) {
	    var self = this;
	    var $html = self.$$('html');
	    var currentColorClass = $html[0].className.match(/color-theme-([a-z]*)/);
	    if (currentColorClass) { $html.removeClass(currentColorClass[0]); }
	    $html.addClass('color-theme-' + color);
	    self.unsetCustomColor();
	    self.setState({
	      themeColor: $html.css('--f7-color-' + color).trim(),
	    });
	  };

	  defaultExport.prototype.setBarsStyle = function setBarsStyle (barsStyle) {
	    var self = this;
	    globalBarsStyle = barsStyle;
	    self.setState({barsStyle: globalBarsStyle});
	    globalCustomProperties = self.generateStylesheet();
	    stylesheet.innerHTML = globalCustomProperties;
	    self.setState({customProperties: globalCustomProperties});
	  };

	  defaultExport.prototype.unsetCustomColor = function unsetCustomColor () {
	    var self = this;
	    globalCustomColor = '';
	    self.setState({customColor: ''});
	    globalCustomProperties = self.generateStylesheet();
	    stylesheet.innerHTML = globalCustomProperties;
	    self.setState({customProperties: globalCustomProperties});
	  };

	  defaultExport.prototype.setCustomColor = function setCustomColor (color) {
	    var self = this;
	    if (self.state.themeColor === color) { return; }
	    clearTimeout(self.timeout);
	    self.timeout = setTimeout(function () {
	      globalCustomColor = color;
	      self.setState({customColor: globalCustomColor}, function () {
	        globalCustomProperties = self.generateStylesheet();
	        stylesheet.innerHTML = globalCustomProperties;
	        self.setState({customProperties: globalCustomProperties});
	      });
	    }, 300);
	  };

	  return defaultExport;
	}(react.Component));

	function RoutableModals () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Routable Modals", backLink: "Back" }),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "In addition to pages, Framework7 router allows to load modal components:" )
	    ),
	    react.createElement( List, null,
	      react.createElement( ListItem, { title: "Popup", link: "popup/" }),
	      react.createElement( ListItem, { title: "Action Sheet", link: "actions/" })
	    )
	  )
	); }

	function RoutablePopup () { return (
	  react.createElement( Popup$2, null,
	    react.createElement( Page, null,
	      react.createElement( Navbar$2, { title: "Routable Popup" },
	        react.createElement( NavRight, null,
	          react.createElement( Link, { popupClose: true }, "Close")
	        )
	      ),
	      react.createElement( Block, { strong: true },
	        react.createElement( 'p', null, "This Popup was loaded using route link as standalone component" ),
	        react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse faucibus mauris leo, eu bibendum neque congue non. Ut leo mauris, eleifend eu commodo a, egestas ac urna. Maecenas in lacus faucibus, viverra ipsum pulvinar, molestie arcu. Etiam lacinia venenatis dignissim. Suspendisse non nisl semper tellus malesuada suscipit eu et eros. Nulla eu enim quis quam elementum vulputate. Mauris ornare consequat nunc viverra pellentesque. Aenean semper eu massa sit amet aliquam. Integer et neque sed libero mollis elementum at vitae ligula. Vestibulum pharetra sed libero sed porttitor. Suspendisse a faucibus lectus." ),
	        react.createElement( 'p', null, "Duis ut mauris sollicitudin, venenatis nisi sed, luctus ligula. Phasellus blandit nisl ut lorem semper pharetra. Nullam tortor nibh, suscipit in consequat vel, feugiat sed quam. Nam risus libero, auctor vel tristique ac, malesuada ut ante. Sed molestie, est in eleifend sagittis, leo tortor ullamcorper erat, at vulputate eros sapien nec libero. Mauris dapibus laoreet nibh quis bibendum. Fusce dolor sem, suscipit in iaculis id, pharetra at urna. Pellentesque tempor congue massa quis faucibus. Vestibulum nunc eros, convallis blandit dui sit amet, gravida adipiscing libero." )
	      )
	    )
	  )
	); }

	function RoutableActions () { return (
	  react.createElement( Actions$2, null,
	    react.createElement( ActionsGroup, null,
	      react.createElement( ActionsLabel, null, "This Action Sheet was loaded as standalone component" ),
	      react.createElement( ActionsButton, null, "Action 1" ),
	      react.createElement( ActionsButton, null, "Action 2" )
	    ),
	    react.createElement( ActionsGroup, null,
	      react.createElement( ActionsButton, { color: "red" }, "Cancel")
	    )
	  )
	); }

	function MasterDetailMaster () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Master Detail", backLink: "Back" }),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "Master-Detail pattern oftenly used on wide enough screens and tablets, and consists of two views. Master - is an area in the UI where you have a list of something. Detail - is the area that shows the relevant information of a selection in the master." ),
	      react.createElement( 'p', null, "To see Master Detail view make sure the window width is larger than 800px." ),
	      react.createElement( 'p', null, "When collapsed (on narrow screen) navigation between such pages will behave as usual routing." ),
	      react.createElement( 'p', null, "Navigation to/from Master-Detail view happens without transition." )
	    ),

	    react.createElement( List, null,
	      react.createElement( ListItem, { reloadDetail: true, link: "/master-detail/1/" }, "Detail Page 1"),
	      react.createElement( ListItem, { reloadDetail: true, link: "/master-detail/2/" }, "Detail Page 2"),
	      react.createElement( ListItem, { reloadDetail: true, link: "/master-detail/3/" }, "Detail Page 3")
	    )
	  )
	); }

	var defaultExport$G = /*@__PURE__*/(function (superclass) {
	  function defaultExport() {
	    superclass.call(this);
	  }

	  if ( superclass ) defaultExport.__proto__ = superclass;
	  defaultExport.prototype = Object.create( superclass && superclass.prototype );
	  defaultExport.prototype.constructor = defaultExport;
	  defaultExport.prototype.render = function render () {
	    return (
	      react.createElement( Page, null,
	        react.createElement( Navbar$2, { title: ("Detail Page " + (this.$f7route.params.id)), backLink: "Back" }),
	        react.createElement( Block, { strong: true },
	          react.createElement( 'p', null, react.createElement( 'b', null, "Detail Page ", this.$f7route.params.id ) ),
	          react.createElement( 'p', null, "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque congue turpis et risus fringilla condimentum. Aliquam vestibulum est tempor, sagittis massa nec, dictum massa. Phasellus non viverra dui, eget aliquam sem. Donec eleifend dolor id arcu ultrices, vel ultrices dolor fringilla. Phasellus feugiat consectetur libero, eget luctus felis rhoncus at. Duis scelerisque ligula sit amet purus congue pulvinar. Proin a risus id nibh fermentum auctor. Vestibulum at sem a risus mollis iaculis. In vestibulum malesuada arcu id consectetur." )
	        )
	      )
	    );
	  };

	  return defaultExport;
	}(react.Component));

	function NotFound () { return (
	  react.createElement( Page, null,
	    react.createElement( Navbar$2, { title: "Not found", backLink: "Back" }),
	    react.createElement( Block, { strong: true },
	      react.createElement( 'p', null, "Sorry" ),
	      react.createElement( 'p', null, "Requested content not found." )
	    )
	  )
	); }

	// Pages
	var routes = [
	  // Index page
	  {
	    path: '/',
	    component: defaultExport,
	  },
	  // About page
	  {
	    path: '/about/',
	    component: About,
	  },
	  // Left Panel
	  {
	    path: '/panel-left/',
	    component: PanelLeft,
	  },
	  // Right Panel
	  {
	    path: '/panel-right/',
	    component: PanelRight,
	  },
	  // Right Panel pages
	  {
	    path: '/panel-right-1/',
	    content: "\n      <div class=\"page\">\n        <div class=\"navbar\">\n          <div class=\"navbar-inner sliding\">\n            <div class=\"left\">\n              <a href=\"#\" class=\"link back\">\n                <i class=\"icon icon-back\"></i>\n                <span class=\"if-not-md\">Back</span>\n              </a>\n            </div>\n            <div class=\"title\">Panel Page 1</div>\n          </div>\n        </div>\n        <div class=\"page-content\">\n          <div class=\"block\">\n            <p>This is a right panel page 1</p>\n            <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quo saepe aspernatur inventore dolorum voluptates consequatur tempore ipsum! Quia, incidunt, aliquam sit veritatis nisi aliquid porro similique ipsa mollitia eaque ex!</p>\n          </div>\n        </div>\n      </div>\n    ",
	  },
	  {
	    path: '/panel-right-2/',
	    content: "\n      <div class=\"page\">\n        <div class=\"navbar\">\n          <div class=\"navbar-inner sliding\">\n            <div class=\"left\">\n              <a href=\"#\" class=\"link back\">\n                <i class=\"icon icon-back\"></i>\n                <span class=\"if-not-md\">Back</span>\n              </a>\n            </div>\n            <div class=\"title\">Panel Page 2</div>\n          </div>\n        </div>\n        <div class=\"page-content\">\n          <div class=\"block\">\n            <p>This is a right panel page 2</p>\n            <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quo saepe aspernatur inventore dolorum voluptates consequatur tempore ipsum! Quia, incidunt, aliquam sit veritatis nisi aliquid porro similique ipsa mollitia eaque ex!</p>\n          </div>\n        </div>\n      </div>\n    ",
	  },
	  // Components
	  {
	    path: '/accordion/',
	    component: Accordion$2,
	  },
	  {
	    path: '/action-sheet/',
	    component: defaultExport$1,
	  },
	  {
	    path: '/appbar/',
	    component: defaultExport$2,
	  },
	  {
	    path: '/autocomplete/',
	    component: defaultExport$3,
	  },
	  {
	    path: '/badge/',
	    component: Badge$1,
	  },
	  {
	    path: '/buttons/',
	    component: Buttons,
	  },
	  {
	    path: '/calendar/',
	    component: defaultExport$4,
	  },
	  {
	    path: '/calendar-page/',
	    component: defaultExport$5,
	  },
	  {
	    path: '/cards/',
	    component: Cards,
	  },
	  {
	    path: '/cards-expandable/',
	    component: CardsExpandable,
	  },
	  {
	    path: '/checkbox/',
	    component: defaultExport$6,
	  },
	  {
	    path: '/chips/',
	    component: defaultExport$7,
	  },
	  {
	    path: '/color-picker/',
	    component: defaultExport$8,
	  },
	  {
	    path: '/contacts-list/',
	    component: ContactsList$1,
	  },
	  {
	    path: '/content-block/',
	    component: ContentBlock,
	  },
	  {
	    path: '/data-table/',
	    component: DataTable$2,
	  },
	  {
	    path: '/dialog/',
	    component: defaultExport$9,
	  },
	  {
	    path: '/elevation/',
	    component: Elevation$1,
	  },
	  {
	    path: '/fab/',
	    component: Fab$3,
	  },
	  {
	    path: '/fab-morph/',
	    component: FabMorph,
	  },
	  {
	    path: '/form-storage/',
	    component: FormStorage$1,
	  },
	  {
	    path: '/gauge/',
	    component: defaultExport$a,
	  },
	  {
	    path: '/grid/',
	    component: Grid$1,
	  },
	  {
	    path: '/icons/',
	    component: Icons,
	  },
	  {
	    path: '/infinite-scroll/',
	    component: defaultExport$b,
	  },
	  {
	    path: '/inputs/',
	    component: Inputs,
	  },
	  {
	    path: '/lazy-load/',
	    component: LazyLoad,
	  },
	  {
	    path: '/list/',
	    component: List$1,
	  },
	  {
	    path: '/list-index/',
	    component: defaultExport$c,
	  },
	  {
	    path: '/login-screen/',
	    component: defaultExport$d,
	  },
	  {
	    path: '/login-screen-page/',
	    component: defaultExport$e,
	  },
	  {
	    path: '/menu/',
	    component: defaultExport$f,
	  },
	  {
	    path: '/messages/',
	    component: defaultExport$g,
	  },
	  {
	    path: '/navbar/',
	    component: Navbar$3,
	  },
	  {
	    path: '/navbar-hide-scroll/',
	    component: NavbarHideScroll,
	  },
	  {
	    path: '/notifications/',
	    component: defaultExport$h,
	  },
	  {
	    path: '/panel/',
	    component: Panel$3,
	  },
	  {
	    path: '/photo-browser/',
	    component: defaultExport$i,
	  },
	  {
	    path: '/picker/',
	    component: defaultExport$j,
	  },
	  {
	    path: '/popup/',
	    component: defaultExport$k,
	  },
	  {
	    path: '/popover/',
	    component: Popover$3,
	  },
	  {
	    path: '/preloader/',
	    component: defaultExport$l,
	  },
	  {
	    path: '/progressbar/',
	    component: defaultExport$m,
	  },
	  {
	    path: '/pull-to-refresh/',
	    component: defaultExport$n,
	  },
	  {
	    path: '/radio/',
	    component: Radio$2,
	  },
	  {
	    path: '/range/',
	    component: defaultExport$o,
	  },
	  {
	    path: '/searchbar/',
	    component: defaultExport$p,
	  },
	  {
	    path: '/searchbar-expandable/',
	    component: defaultExport$q,
	  },
	  {
	    path: '/sheet-modal/',
	    component: defaultExport$r,
	  },
	  {
	    path: '/skeleton/',
	    component: defaultExport$s,
	  },
	  {
	    path: '/smart-select/',
	    component: SmartSelect$2,
	  },
	  {
	    path: '/sortable/',
	    component: Sortable$2,
	  },
	  {
	    path: '/statusbar/',
	    component: defaultExport$t,
	  },
	  {
	    path: '/stepper/',
	    component: defaultExport$u,
	  },
	  {
	    path: '/subnavbar/',
	    component: Subnavbar$2,
	  },
	  {
	    path: '/subnavbar-title/',
	    component: SubnavbarTitle,
	  },
	  {
	    path: '/swiper/',
	    component: Swiper$3,
	    routes: [
	      {
	        path: 'swiper-horizontal/',
	        component: SwiperHorizontal,
	      },
	      {
	        path: 'swiper-vertical/',
	        component: SwiperVertical,
	      },
	      {
	        path: 'swiper-space-between/',
	        component: SwiperSpaceBetween,
	      },
	      {
	        path: 'swiper-multiple/',
	        component: SwiperMultiple,
	      },
	      {
	        path: 'swiper-nested/',
	        component: SwiperNested,
	      },
	      {
	        path: 'swiper-loop/',
	        component: SwiperLoop,
	      },
	      {
	        path: 'swiper-3d-cube/',
	        component: Swiper3dCube,
	      },
	      {
	        path: 'swiper-3d-coverflow/',
	        component: Swiper3dCoverflow,
	      },
	      {
	        path: 'swiper-3d-flip/',
	        component: Swiper3dFlip,
	      },
	      {
	        path: 'swiper-fade/',
	        component: SwiperFade,
	      },
	      {
	        path: 'swiper-scrollbar/',
	        component: SwiperScrollbar,
	      },
	      {
	        path: 'swiper-gallery/',
	        component: defaultExport$v,
	      },
	      {
	        path: 'swiper-custom-controls/',
	        component: SwiperCustomControls,
	      },
	      {
	        path: 'swiper-parallax/',
	        component: SwiperParallax,
	      },
	      {
	        path: 'swiper-lazy/',
	        component: SwiperLazy,
	      },
	      {
	        path: 'swiper-pagination-progress/',
	        component: SwiperPaginationProgress,
	      },
	      {
	        path: 'swiper-pagination-fraction/',
	        component: SwiperPaginationFraction,
	      },
	      {
	        path: 'swiper-zoom/',
	        component: SwiperZoom,
	      } ],
	  },
	  {
	    path: '/swipeout/',
	    component: defaultExport$w,
	  },
	  {
	    path: '/tabs/',
	    component: Tabs$2,
	  },
	  {
	    path: '/tabs-static/',
	    component: TabsStatic,
	  },
	  {
	    path: '/tabs-animated/',
	    component: TabsAnimated,
	  },
	  {
	    path: '/tabs-swipeable/',
	    component: TabsSwipeable,
	  },
	  {
	    path: '/tabs-routable/',
	    component: TabsRoutable,
	    tabs: [
	      {
	        path: '/',
	        id: 'tab1',
	        content: "\n        <div class=\"block\">\n          <p>Tab 1 content</p>\n          <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?</p>\n          <p>Saepe explicabo voluptas ducimus provident, doloremque quo totam molestias! Suscipit blanditiis eaque exercitationem praesentium reprehenderit, fuga accusamus possimus sed, sint facilis ratione quod, qui dignissimos voluptas! Aliquam rerum consequuntur deleniti.</p>\n          <p>Totam reprehenderit amet commodi ipsum nam provident doloremque possimus odio itaque, est animi culpa modi consequatur reiciendis corporis libero laudantium sed eveniet unde delectus a maiores nihil dolores? Natus, perferendis.</p>\n        </div>\n        ",
	      },
	      {
	        path: '/tab2/',
	        id: 'tab2',
	        content: "\n        <div class=\"block\">\n          <p>Tab 2 content</p>\n          <p>Suscipit, facere quasi atque totam. Repudiandae facilis at optio atque, rem nam, natus ratione cum enim voluptatem suscipit veniam! Repellat, est debitis. Modi nam mollitia explicabo, unde aliquid impedit! Adipisci!</p>\n          <p>Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit.</p>\n          <p>Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere.</p>\n        </div>\n        ",
	      },
	      {
	        path: '/tab3/',
	        id: 'tab3',
	        content: "\n        <div class=\"block\">\n          <p>Tab 3 content</p>\n          <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ullam enim quia molestiae facilis laudantium voluptates obcaecati officia cum, sit libero commodi. Ratione illo suscipit temporibus sequi iure ad laboriosam accusamus?</p>\n          <p>Deserunt adipisci tempora asperiores, quo, nisi ex delectus vitae consectetur iste fugiat iusto dolorem autem. Itaque, ipsa voluptas, a assumenda rem, dolorum porro accusantium, officiis veniam nostrum cum cumque impedit.</p>\n          <p>Laborum illum ipsa voluptatibus possimus nesciunt ex consequatur rem, natus ad praesentium rerum libero consectetur temporibus cupiditate atque aspernatur, eaque provident eligendi quaerat ea soluta doloremque. Iure fugit, minima facere.</p>\n        </div>\n        ",
	      } ],
	  },
	  {
	    path: '/toast/',
	    component: defaultExport$x,
	  },
	  {
	    path: '/toggle/',
	    component: Toggle$3,
	  },
	  {
	    path: '/toolbar-tabbar/',
	    component: defaultExport$y,
	    routes: [
	      {
	        path: 'tabbar/',
	        component: defaultExport$z,
	      },
	      {
	        path: 'tabbar-labels/',
	        component: defaultExport$A,
	      },
	      {
	        path: 'tabbar-scrollable/',
	        component: defaultExport$B,
	      },
	      {
	        path: 'toolbar-hide-scroll/',
	        component: ToolbarHideScroll,
	      } ],
	  },
	  {
	    path: '/tooltip/',
	    component: defaultExport$C,
	  },
	  {
	    path: '/timeline/',
	    component: Timeline$1,
	  },
	  {
	    path: '/timeline-vertical/',
	    component: TimelineVertical,
	  },
	  {
	    path: '/timeline-horizontal/',
	    component: TimelineHorizontal,
	  },
	  {
	    path: '/timeline-horizontal-calendar/',
	    component: TimelineHorizontalCalendar,
	  },
	  {
	    path: '/treeview/',
	    component: defaultExport$D,
	  },
	  {
	    path: '/virtual-list/',
	    component: defaultExport$E,
	  },

	  // Color Themes
	  {
	    path: '/color-themes/',
	    component: defaultExport$F,
	  },

	  // Routable Modals
	  {
	    path: '/routable-modals/',
	    component: RoutableModals,
	    routes: [
	      {
	        path: 'popup/',
	        popup: {
	          component: RoutablePopup,
	        },
	      },
	      {
	        path: 'actions/',
	        popup: {
	          component: RoutableActions,
	        },
	      } ],
	  },
	  {
	    path: '/master-detail/',
	    component: MasterDetailMaster,
	    master: true,
	  },
	  {
	    path: '/master-detail/:id/',
	    component: defaultExport$G,
	  },
	  // Default route (404 page). MUST BE THE LAST
	  {
	    path: '(.*)',
	    component: NotFound,
	  } ];

	function App$1 (props) {
	  var theme = 'auto';
	  if (document.location.search.indexOf('theme=') >= 0) {
	    theme = document.location.search.split('theme=')[1].split('&')[0];
	  }
	  var f7Params = {
	    id: 'io.framework7.testapp',
	    theme: theme,
	    routes: routes,
	    popup: {
	      closeOnEscape: true,
	    },
	    sheet: {
	      closeOnEscape: true,
	    },
	    popover: {
	      closeOnEscape: true,
	    },
	    actions: {
	      closeOnEscape: true,
	    },
	  };
	  return (
	    react.createElement( App, { params: f7Params },
	      react.createElement( Statusbar$2, null ),
	      react.createElement( Panel$2, { left: true, cover: true, resizable: true },
	        react.createElement( View$2, { url: "/panel-left/", linksView: ".view-main" })
	      ),
	      react.createElement( Panel$2, { right: true, reveal: true, resizable: true },
	        react.createElement( View$2, { url: "/panel-right/" })
	      ),
	      react.createElement( View$2, { url: "/", main: true, className: "safe-areas", masterDetailBreakpoint: 800 })
	    )
	  );
	}

	Framework7.use(Plugin);
	// Mount React App
	reactDom.render(
	  react.createElement(App$1),
	  document.getElementById('app')
	);

}));
